<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::scf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1scf.html">scf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::scf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to dictate how loops should be pipelined.  <a href="structmlir_1_1scf_1_1PipeliningOption.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a> = std::vector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td></tr>
<tr class="memdesc:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning vector of values, handy to return from functions.  <a href="#a82927bf8dc031e20dbe7f1437c1fa7da">More...</a><br /></td></tr>
<tr class="separator:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570c5cc67cd9a97e8abf8da08815dae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac570c5cc67cd9a97e8abf8da08815dae">LoopVector</a> = std::vector&lt; scf::ForOp &gt;</td></tr>
<tr class="separator:ac570c5cc67cd9a97e8abf8da08815dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b3ad7311cd509adc44894a88cabd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac08b3ad7311cd509adc44894a88cabd5">LoopMatcherFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ac08b3ad7311cd509adc44894a88cabd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter.  <a href="#ac08b3ad7311cd509adc44894a88cabd5">More...</a><br /></td></tr>
<tr class="separator:ac08b3ad7311cd509adc44894a88cabd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af30aa77e8423a12af795fd7c5fcbc562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#af30aa77e8423a12af795fd7c5fcbc562">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:af30aa77e8423a12af795fd7c5fcbc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601f846f06f5959b1a052e975eae8ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a601f846f06f5959b1a052e975eae8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for IfOp builders. Inserts a yield without arguments.  <a href="#a601f846f06f5959b1a052e975eae8ec1">More...</a><br /></td></tr>
<tr class="separator:a601f846f06f5959b1a052e975eae8ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e692b007039a6d2172e34bb0bc429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a888e692b007039a6d2172e34bb0bc429">ensureLoopTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:a888e692b007039a6d2172e34bb0bc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13caec83d2c9665221580ea507c6e68b"><td class="memItemLeft" align="right" valign="top">ParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">getParallelForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a13caec83d2c9665221580ea507c6e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel loop parent of an induction variable.  <a href="#a13caec83d2c9665221580ea507c6e68b">More...</a><br /></td></tr>
<tr class="separator:a13caec83d2c9665221580ea507c6e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68717bb14a63ffb8d9266322283d253f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a68717bb14a63ffb8d9266322283d253f">insideMutuallyExclusiveBranches</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a68717bb14a63ffb8d9266322283d253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp.  <a href="#a68717bb14a63ffb8d9266322283d253f">More...</a><br /></td></tr>
<tr class="separator:a68717bb14a63ffb8d9266322283d253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a63d89db573aefd9edf2c31fe8e7d5fe1">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of "for" loops, i.e.  <a href="#a63d89db573aefd9edf2c31fe8e7d5fe1">More...</a><br /></td></tr>
<tr class="separator:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a6304a6715d1cc43d3035323cfb4cd78a">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a6304a6715d1cc43d3035323cfb4cd78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version for building loop nests without iteration arguments (like for reductions).  <a href="#a6304a6715d1cc43d3035323cfb4cd78a">More...</a><br /></td></tr>
<tr class="separator:a6304a6715d1cc43d3035323cfb4cd78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">naivelyFuseParallelOps</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations.  <a href="#ac316a00289a9c7b41712aa0a0de2ea0c">More...</a><br /></td></tr>
<tr class="separator:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c1901dd11dac0edafe28fb81a765b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a16c1901dd11dac0edafe28fb81a765b0">peelAndCanonicalizeForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, scf::ForOp &amp;partialIteration)</td></tr>
<tr class="memdesc:a16c1901dd11dac0edafe28fb81a765b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>).  <a href="#a16c1901dd11dac0edafe28fb81a765b0">More...</a><br /></td></tr>
<tr class="separator:a16c1901dd11dac0edafe28fb81a765b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac87521511b3088f00423de46226c32c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ParallelOp, ParallelOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aac87521511b3088f00423de46226c32c">tileParallelLoop</a> (ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSizes, bool noMinMaxBounds)</td></tr>
<tr class="memdesc:aac87521511b3088f00423de46226c32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5)  <a href="#aac87521511b3088f00423de46226c32c">More...</a><br /></td></tr>
<tr class="separator:aac87521511b3088f00423de46226c32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a6b066e35f218deec9bf3b59f25c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a699a6b066e35f218deec9bf3b59f25c2">populateSCFStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a699a6b066e35f218deec9bf3b59f25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <a href="#a699a6b066e35f218deec9bf3b59f25c2">More...</a><br /></td></tr>
<tr class="separator:a699a6b066e35f218deec9bf3b59f25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a331c5d2ebecbdc149e0d0637ce2a65c7">populateSCFLoopPipeliningPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for SCF software pipelining transformation.  <a href="#a331c5d2ebecbdc149e0d0637ce2a65c7">More...</a><br /></td></tr>
<tr class="separator:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd982adcd3c785d3417107be92fee3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acbd982adcd3c785d3417107be92fee3a">populateSCFForLoopCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acbd982adcd3c785d3417107be92fee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for canonicalizing operations inside SCF loop bodies.  <a href="#acbd982adcd3c785d3417107be92fee3a">More...</a><br /></td></tr>
<tr class="separator:acbd982adcd3c785d3417107be92fee3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6282e21b62c3efa8abbb78324718e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a8d6282e21b62c3efa8abbb78324718e8">canonicalizeMinMaxOpInLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, bool isMin, <a class="el" href="namespacemlir_1_1scf.html#ac08b3ad7311cd509adc44894a88cabd5">LoopMatcherFn</a> loopMatcher)</td></tr>
<tr class="memdesc:a8d6282e21b62c3efa8abbb78324718e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to canonicalize an min/max operations in the context of for <code>loops</code> with a known range.  <a href="#a8d6282e21b62c3efa8abbb78324718e8">More...</a><br /></td></tr>
<tr class="separator:a8d6282e21b62c3efa8abbb78324718e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fffdd8c409fd79382ab78c38657b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a29fffdd8c409fd79382ab78c38657b73">rewritePeeledMinMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, bool isMin, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, bool insideLoop)</td></tr>
<tr class="memdesc:a29fffdd8c409fd79382ab78c38657b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify a min/max operation <code>op</code> after loop peeling.  <a href="#a29fffdd8c409fd79382ab78c38657b73">More...</a><br /></td></tr>
<tr class="separator:a29fffdd8c409fd79382ab78c38657b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac08b3ad7311cd509adc44894a88cabd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08b3ad7311cd509adc44894a88cabd5">&#9670;&nbsp;</a></span>LoopMatcherFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ac08b3ad7311cd509adc44894a88cabd5">mlir::scf::LoopMatcherFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter. </p>
<p>The function should return <code>success</code> in that case. If the first parameter is not an iteration variable, return <code>failure</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8h_source.html#l00036">36</a> of file <a class="el" href="AffineCanonicalizationUtils_8h_source.html">AffineCanonicalizationUtils.h</a>.</p>

</div>
</div>
<a id="ac570c5cc67cd9a97e8abf8da08815dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac570c5cc67cd9a97e8abf8da08815dae">&#9670;&nbsp;</a></span>LoopVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#ac570c5cc67cd9a97e8abf8da08815dae">mlir::scf::LoopVector</a> = typedef std::vector&lt;scf::ForOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8h_source.html#l00056">56</a> of file <a class="el" href="Dialect_2SCF_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a id="a82927bf8dc031e20dbe7f1437c1fa7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82927bf8dc031e20dbe7f1437c1fa7da">&#9670;&nbsp;</a></span>ValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> = typedef std::vector&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An owning vector of values, handy to return from functions. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8h_source.html#l00055">55</a> of file <a class="el" href="Dialect_2SCF_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a63d89db573aefd9edf2c31fe8e7d5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d89db573aefd9edf2c31fe8e7d5fe1">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of "for" loops, i.e. </p>
<p>all loops but the innermost contain only another loop and a terminator. The lower, upper bounds and steps are provided as <code>lbs</code>, <code>ubs</code> and <code>steps</code>, which are expected to be of the same size. <code>iterArgs</code> points to the initial values of the loop iteration arguments, which will be forwarded through the nest to the innermost loop. The body of the loop is populated using <code>bodyBuilder</code>, which accepts an ordered list of induction variables of all loops, followed by a list of iteration arguments of the innermost loop, in the same order as provided to <code>iterArgs</code>. This function is expected to return as many values as <code>iterArgs</code>, of the same type and in the same order, that will be treated as yielded from the loop body and forwarded back through the loop nest. If the function is not provided, the loop nest is not expected to have iteration arguments, the body of the innermost loop will be left empty, containing only the zero-operand terminator. Returns the <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> containing the list of perfectly nest scf::ForOp build during the call. If bound arrays are empty, the body builder will be called once to construct the IR outside of the loop with an empty list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00504">504</a> of file <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00367">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00448">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00558">mlir::linalg::generateParallelLoopNest()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00031">insertCopyLoops()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00284">tilePadOp()</a>.</p>

</div>
</div>
<a id="a6304a6715d1cc43d3035323cfb4cd78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304a6715d1cc43d3035323cfb4cd78a">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version for building loop nests without iteration arguments (like for reductions). </p>
<p>Does not take the initial value of reductions or expect the body building functions to return their current value. The built nested scf::For are captured in <code>capturedLoops</code> when non-null. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">577</a> of file <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00504">buildLoopNest()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00489">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8h_source.html#l00312">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00212">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00298">mlir::RewriterBase::mergeBlockBefore()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00277">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00212">mlir::RewriterBase::replaceOpWithIf()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00343">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="PatternMatch_8h_source.html#l00484">mlir::RewriterBase::startRootUpdate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a601f846f06f5959b1a052e975eae8ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f846f06f5959b1a052e975eae8ec1">&#9670;&nbsp;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback for IfOp builders. Inserts a yield without arguments. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00074">74</a> of file <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="a8d6282e21b62c3efa8abbb78324718e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6282e21b62c3efa8abbb78324718e8">&#9670;&nbsp;</a></span>canonicalizeMinMaxOpInLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::canonicalizeMinMaxOpInLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1scf.html#ac08b3ad7311cd509adc44894a88cabd5">LoopMatcherFn</a>&#160;</td>
          <td class="paramname"><em>loopMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to canonicalize an min/max operations in the context of for <code>loops</code> with a known range. </p>
<p>Canonicalize min/max operations in the context of for loops with a known range.</p>
<p><code>map</code> is the body of the min/max operation and <code>operands</code> are the SSA values that the dimensions and symbols are bound to; dimensions are listed first. If <code>isMin</code>, the operation is a min operation; otherwise, a max operation. <code>loopMatcher</code> is used to retrieve loop bounds and the step size for a given iteration variable.</p>
<p>Note: <code>loopMatcher</code> allows this function to be used with any "for loop"-like operation (scf.for, scf.parallel and even ops defined in other dialects).</p>
<p>Call <code>canonicalizeMinMaxOp</code> and add the following constraints to the constraint system (along with the missing dimensions):</p>
<ul>
<li>iv &gt;= lb</li>
<li>iv &lt; lb + step * ((ub - lb - 1) floorDiv step) + 1</li>
</ul>
<p>Note: Due to limitations of IntegerPolyhedron, only constant step sizes are currently supported. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00263">263</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>.</p>

</div>
</div>
<a id="a888e692b007039a6d2172e34bb0bc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e692b007039a6d2172e34bb0bc429">&#9670;&nbsp;</a></span>ensureLoopTerminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::ensureLoopTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00397">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, and <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00369">printInitializationList()</a>.</p>

</div>
</div>
<a id="a13caec83d2c9665221580ea507c6e68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13caec83d2c9665221580ea507c6e68b">&#9670;&nbsp;</a></span>getParallelForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelOp mlir::scf::getParallelForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">2062</a> of file <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00194">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00202">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00633">mlir::OperationState::addTypes()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00345">mlir::InFlightDiagnostic::attachNote()</a>, <a class="el" href="OperationSupport_8h_source.html#l00612">mlir::OperationState::attributes</a>, <a class="el" href="Builders_8cpp_source.html#l00468">mlir::OpBuilder::clone()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00351">mlir::RewriterBase::cloneRegionBefore()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00353">mlir::OpBuilder::createBlock()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00046">diag()</a>, <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="Block_8h_source.html#l00139">mlir::Block::empty()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00489">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, <a class="el" href="Block_8h_source.html#l00120">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="Builders_8cpp_source.html#l00087">mlir::Builder::getBoolAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l01162">mlir::ValueRange::getTypes()</a>, <a class="el" href="OpDefinition_8h_source.html#l00050">mlir::OptionalParseResult::getValue()</a>, <a class="el" href="OpDefinition_8h_source.html#l00047">mlir::OptionalParseResult::hasValue()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00044">mlir::arith::invertPredicate()</a>, <a class="el" href="OperationSupport_8h_source.html#l00607">mlir::OperationState::location</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00059">mlir::BlockAndValueMapping::lookupOrDefault()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00277">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="OperationSupport_8h_source.html#l00609">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00485">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab4382d557de477b5b1b7bbfbbf7ba03f">mlir::AsmParser::parseLParen()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a13e2984db44d0a267a04a3daa6d4f89d">mlir::OpAsmParser::parseOptionalAssignmentList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a6db278b74a263f4222bc92c534bbd0f0">mlir::AsmParser::parseOptionalAttrDictWithKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">mlir::OpAsmParser::parseRegion()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00771">print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00077">mlir::OpAsmPrinter::printFunctionalType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00369">printInitializationList()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a579c48a7df61e02937fa79818e7d1a83">mlir::OpAsmPrinter::printOptionalAttrDictWithKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#aca2979fa160a91a41e9aae802edcb7d1">mlir::OpAsmPrinter::printRegion()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="PatternMatch_8h_source.html#l00484">mlir::RewriterBase::startRootUpdate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Value_8h_source.html#l00203">mlir::Value::use_empty()</a>, <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>, and <a class="el" href="Block_8h_source.html#l00200">mlir::Block::without_terminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>.</p>

</div>
</div>
<a id="a68717bb14a63ffb8d9266322283d253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68717bb14a63ffb8d9266322283d253f">&#9670;&nbsp;</a></span>insideMutuallyExclusiveBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::scf::insideMutuallyExclusiveBranches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">1049</a> of file <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8h_source.html#l00643">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00194">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00202">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00633">mlir::OperationState::addTypes()</a>, <a class="el" href="OperationSupport_8h_source.html#l00612">mlir::OperationState::attributes</a>, <a class="el" href="IR_2Region_8h_source.html#l00064">mlir::Region::back()</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::back()</a>, <a class="el" href="Builders_8h_source.html#l00507">mlir::OpBuilder::cloneWithoutRegions()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00353">mlir::OpBuilder::createBlock()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00518">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00265">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00489">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00050">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getI32VectorAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00048">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8h_source.html#l00373">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00170">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00058">mlir::Builder::getIntegerType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="Block_8h_source.html#l00184">mlir::Block::getOps()</a>, <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00175">mlir::Operation::getParentOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l01162">mlir::ValueRange::getTypes()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, <a class="el" href="OperationSupport_8h_source.html#l00607">mlir::OperationState::location</a>, <a class="el" href="Matchers_8h_source.html#l00321">mlir::m_One()</a>, <a class="el" href="Matchers_8h_source.html#l00333">mlir::matchPattern()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00277">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="OperationSupport_8h_source.html#l00609">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a530427ff32aa6170dd20d2abd94ea880">mlir::OpAsmParser::parseArgumentList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a5f240da7e00c4072d9f268efe1179b1d">mlir::AsmParser::parseEqual()</a>, <a class="el" href="OpImplementation_8h_source.html#l00485">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac8dd551c69e3209e1d5ca180c4778362">mlir::AsmParser::parseOptionalArrowTypeList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">mlir::OpAsmParser::parseRegion()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00771">print()</a>, <a class="el" href="OpImplementation_8h_source.html#l00099">mlir::AsmPrinter::printOptionalArrowTypeList()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#aca2979fa160a91a41e9aae802edcb7d1">mlir::OpAsmPrinter::printRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00616">mlir::OperationState::regions</a>, <a class="el" href="Value_8h_source.html#l00162">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00367">mlir::OpBuilder::setInsertionPointToEnd()</a>, <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>, <a class="el" href="PatternMatch_8h_source.html#l00484">mlir::RewriterBase::startRootUpdate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="OperationSupport_8h_source.html#l00611">mlir::OperationState::types</a>, <a class="el" href="PatternMatch_8h_source.html#l00499">mlir::RewriterBase::updateRootInPlace()</a>, <a class="el" href="Value_8h_source.html#l00203">mlir::Value::use_empty()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

</div>
</div>
<a id="ac316a00289a9c7b41712aa0a0de2ea0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac316a00289a9c7b41712aa0a0de2ea0c">&#9670;&nbsp;</a></span>naivelyFuseParallelOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::naivelyFuseParallelOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations. </p>
<p>Uses a naive aliasing and dependency analysis. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00133">133</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00118">fuseIfLegal()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="a16c1901dd11dac0edafe28fb81a765b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c1901dd11dac0edafe28fb81a765b0">&#9670;&nbsp;</a></span>peelAndCanonicalizeForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::peelAndCanonicalizeForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp &amp;&#160;</td>
          <td class="paramname"><em>partialIteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <code>partialIteration</code>). </p>
<p>This transformation is called "loop peeling".</p>
<p>This transformation is beneficial for a wide range of transformations such as vectorization or loop tiling: It enables additional canonicalizations inside the peeled loop body such as rewriting masked loads into unmaked loads.</p>
<p>E.g., assuming a lower bound of 0 (for illustration purposes): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %ub step %c4 {</div><div class="line">  (loop body)</div><div class="line">}</div></div><!-- fragment --><p> is rewritten into the following pseudo IR: </p><div class="fragment"><div class="line">%newUb = %ub - (%ub <a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> %c4)</div><div class="line">scf.for %iv = %c0 to %newUb step %c4 {</div><div class="line">  (loop body)</div><div class="line">}</div><div class="line">scf.for %iv2 = %newUb to %ub {</div><div class="line">  (loop body)</div><div class="line">}</div></div><!-- fragment --><p>After loop peeling, this function tries to simplify/canonicalize affine.min and affine.max ops in the body of the peeled loop and in the body of the partial iteration loop, taking advantage of the fact that the peeled loop has only "full" iterations. This canonicalization is expected to enable further canonicalization opportunities through other patterns.</p>
<p>The return value indicates whether the loop was rewritten or not. Loops are not rewritten if:</p><ul>
<li>Loop step size is 1 or</li>
<li>Loop bounds and step size are static, and step already divides the iteration space evenly.</li>
</ul>
<p>Note: This function rewrites the given scf.for loop in-place and creates a new scf.for operation for the last iteration. It replaces all uses of the unpeeled loop with the results of the newly generated scf.for. </p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00313">peelLoop()</a>, and <a class="el" href="LoopSpecialization_8cpp_source.html#l00151">rewriteAffineOpAfterPeeling()</a>.</p>

</div>
</div>
<a id="acbd982adcd3c785d3417107be92fee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd982adcd3c785d3417107be92fee3a">&#9670;&nbsp;</a></span>populateSCFForLoopCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFForLoopCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for canonicalizing operations inside SCF loop bodies. </p>
<p>At the moment, only affine.min/max computations with iteration variables, loop bounds and loop steps are canonicalized. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00195">195</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00444">applyExtractSliceOfPadTensorSwapPattern()</a>, and <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>.</p>

</div>
</div>
<a id="a331c5d2ebecbdc149e0d0637ce2a65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c5d2ebecbdc149e0d0637ce2a65c7">&#9670;&nbsp;</a></span>populateSCFLoopPipeliningPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFLoopPipeliningPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for SCF software pipelining transformation. </p>
<p>This transformation generates the pipelined loop and doesn't do any assumptions on the schedule dictated by the option structure. Software pipelining is usually done in two part. The first part of pipelining is to schedule the loop and assign a stage and cycle to each operations. This is highly dependent on the target and is implemented as an heuristic based on operation latencies, and other hardware characteristics. The second part is to take the schedule and generate the pipelined loop as well as the prologue and epilogue. It is independent of the target. This pattern only implement the second part. For example if we break a loop into 3 stages named S0, S1, S2 we would generate the following code with the number in parenthesis the iteration index: S0(0) // Prologue S0(1) S1(0) // Prologue scf.for I = C0 to N - 2 { S0(I+2) S1(I+1) S2(I) // Pipelined kernel } S1(N) S2(N-1) // Epilogue S2(N) // Epilogue </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00477">477</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a699a6b066e35f218deec9bf3b59f25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699a6b066e35f218deec9bf3b59f25c2">&#9670;&nbsp;</a></span>populateSCFStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is scf.if &ndash; the scf.if op and the corresponding scf.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class. ">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00177">177</a> of file <a class="el" href="StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af30aa77e8423a12af795fd7c5fcbc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30aa77e8423a12af795fd7c5fcbc562">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00526">526</a> of file <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00067">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a29fffdd8c409fd79382ab78c38657b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fffdd8c409fd79382ab78c38657b73">&#9670;&nbsp;</a></span>rewritePeeledMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::scf::rewritePeeledMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insideLoop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify a min/max operation <code>op</code> after loop peeling. </p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div><div class="line"><span class="preprocessor">%r = affine.min #affine.min #map(%iv)[%step, %ub]</span></div></div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div></div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div><div class="line"><span class="preprocessor">%r = affine.min #affine.min #map(%iv)[%step, %ub]</span></div></div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div></div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function builds up a set of constraints, capable of proving that:</p><ul>
<li>Inside the peeled loop: min(step, ub - iv) == step</li>
<li>Inside the partial iteration: min(step, ub - iv) == ub - iv</li>
</ul>
<p>Returns <code>success</code> if the given operation was replaced by a new operation; <code>failure</code> otherwise.</p>
<p>Note: <code>ub</code> is the previous upper bound of the loop (before peeling). <code>insideLoop</code> must be true for min/max ops inside the loop and false for affine.min ops inside the partial iteration. For an explanation of the other parameters, see comment of <code>canonicalizeMinMaxOpInLoop</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00317">317</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00191">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00272">mlir::FlatAffineValueConstraints::appendDimId()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::EQ</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00151">rewriteAffineOpAfterPeeling()</a>.</p>

</div>
</div>
<a id="aac87521511b3088f00423de46226c32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac87521511b3088f00423de46226c32c">&#9670;&nbsp;</a></span>tileParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ParallelOp, ParallelOp &gt; mlir::scf::tileParallelLoop </td>
          <td>(</td>
          <td class="paramtype">ParallelOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5) </p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(tileSize[0], arg2-j0) min(tileSize[1], arg3-j1)) step (arg4, arg5) The old loop is replaced with the new one.</p>
<p>The function returns the resulting ParallelOps, i.e. {outer_loop_op, inner_loop_op}.</p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(arg4*tileSize[0], arg2-i0) min(arg5*tileSize[1], arg3-i1)) step (arg4, arg5)</p>
<p>or, when no-min-max-bounds is true, into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (arg4*tileSize[0], arg5*tileSize[1]) step (arg4, arg5) inbound = (j0 * arg4 + i0 &lt; arg2) &amp;&amp; (j1 * arg5 + i1 &lt; arg3) scf.if (inbound) ....</p>
<p>where the uses of i0 and i1 in the loop body are replaced by i0 + j0 and i1 + j1. The old loop is replaced with the new one. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00053">53</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="Block_8cpp_source.html#l00189">mlir::Block::eraseArguments()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">mlir::getAffineDimExpr()</a>, <a class="el" href="Block_8h_source.html#l00120">mlir::Block::getArgument()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00048">mlir::Builder::getIndexType()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00226">mlir::getInnermostParallelLoops()</a>, <a class="el" href="Builders_8cpp_source.html#l00058">mlir::Builder::getIntegerType()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00061">mlir::Value::replaceAllUsesExcept()</a>, <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:06 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
