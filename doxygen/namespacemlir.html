<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Include the generated interface declarations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1acc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1acc.html">acc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arith.html">arith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1arm__neon"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1arm__neon.html">arm_neon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1async"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1async.html">async</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1AttributeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1AttributeTrait.html">AttributeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1AttributeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if an attribute is a dynamic attribute or not; it should only be implemented by dynamic attributes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1cf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1cf.html">cf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1complex"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1complex.html">complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1emitc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1emitc.html">emitc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1func"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html">func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1function__interface__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1function__interface__impl.html">function_interface_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1LLVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1lsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1lsp.html">lsp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1MemoryEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemoryEffects.html">MemoryEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1memref"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html">memref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1MemRefType"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1NVVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl.html">pdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__interp.html">pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__to__pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdll"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdll.html">pdll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1presburger"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1presburger.html">presburger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quant"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1RankedTensorType"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1RankedTensorType.html">RankedTensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ROCDL"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1runtime.html">runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1scf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">scf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1shape"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shape.html">shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1SideEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1SideEffects.html">SideEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1sparse__tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tblgen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tosa"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tosa.html">tosa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1TypeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1TypeTrait.html">TypeTrait</a></td></tr>
<tr class="memdesc:namespacemlir_1_1TypeTrait"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used to determine if a type is a dynamic type or not; it should only be implemented by dynamic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1VectorType"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1VectorType.html">VectorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1x86vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1x86vector.html">x86vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="classmlir_1_1AbstractAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1AbstractType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBound.html">AffineBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineBound.html" title="AffineBound represents a lower or upper bound in the for operation. ">AffineBound</a> represents a lower or upper bound in the for operation.  <a href="classmlir_1_1AffineBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy / DMA generation options for <a class="el" href="namespacemlir.html#aa17a0289ca213cc63e1b5cd46f19308c" title="Performs explicit copying for the contiguous sequence of operations in the block iterator range [`beg...">mlir::affineDataCopyGenerate</a>.  <a href="structmlir_1_1AffineCopyOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  <a href="classmlir_1_1AffineDmaStartOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html">AffineDmaWaitOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> blocks until the completion of a DMA operation associated with the tag element 'tag[index]'.  <a href="classmlir_1_1AffineDmaWaitOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMapAccessInterface.html">AffineMapAccessInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> is an affine map plus its ML value operands and results for analysis purposes.  <a href="classmlir_1_1AffineValueMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineWriteOpInterface.html">AffineWriteOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the main alias analysis interface in MLIR.  <a href="classmlir_1_1AliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of an alias query.  <a href="classmlir_1_1AliasResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AllocLikeOpLLVMLowering.html">AllocLikeOpLLVMLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowering for AllocOp and AllocaOp.  <a href="structmlir_1_1AllocLikeOpLLVMLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ArithBuilder.html">ArithBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple arithmetic quantities with minimal type inference support.  <a href="structmlir_1_1ArithBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm parser hooks, usable across the various derived parsers.  <a href="classmlir_1_1AsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents state from a parsed MLIR textual format string.  <a href="classmlir_1_1AsmParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class exposes generic asm printer hooks, usable across the various derived printers.  <a href="classmlir_1_1AsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeInterface.html">AttributeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an attribute interface.  <a href="classmlir_1_1AttributeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a shared interface for ranked and unranked memref types.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a></code> represents an ordered list of <code><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a></code>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an argument of a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block operand represents an operand that holds a reference to a <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>, e.g.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Blocks.  <a href="classmlir_1_1BlockRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of IntegerAttr to represent boolean integers, i.e., signless i1 integers.  <a href="classmlir_1_1BoolAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html">BufferViewFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straight-forward alias analysis which ensures that all dependencies of all values will be determined.  <a href="classmlir_1_1BufferViewFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexStructBuilder.html">ComplexStructBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeCollapseOfExpandOp.html">ComposeCollapseOfExpandOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to compose <code>collapse_shape(expand_shape(src, reassociation_1), reassociation_2)</code>.  <a href="structmlir_1_1ComposeCollapseOfExpandOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeExpandOfCollapseOp.html">ComposeExpandOfCollapseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComposeReassociativeReshapeOps.html">ComposeReassociativeReshapeOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse producer/consumer reshape ops that are both collapsing dimensions or are both expanding dimensions.  <a href="structmlir_1_1ComposeReassociativeReshapeOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPattern.html">ConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the conversion patterns.  <a href="classmlir_1_1ConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pattern rewriter for use with ConversionPatterns.  <a href="classmlir_1_1ConversionPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a specific conversion target.  <a href="classmlir_1_1ConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpToLLVMPattern.html">ConvertOpToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that match exactly one source operation.  <a href="classmlir_1_1ConvertOpToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPattern.html">ConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1ConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result for calling generateCopyForMemRegion.  <a href="structmlir_1_1CopyGenerateResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataDescriptor.html">DataDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations inserting elements to a Data descriptor.  <a href="classmlir_1_1DataDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main mechanism for performing data layout queries.  <a href="classmlir_1_1DataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data layout objects for each operation that specifies the data layout above and below the given operation.  <a href="classmlir_1_1DataLayoutAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutDialectInterface.html">DataLayoutDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to be implemented by dialects that can have identifiers in the data layout specification entries.  <a href="classmlir_1_1DataLayoutDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutEntryAttr.html">DataLayoutEntryAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data layout entry attribute is a key-value pair where the key is a type or an identifier and the value is another attribute.  <a href="classmlir_1_1DataLayoutEntryAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DataLayoutSpecAttr.html">DataLayoutSpecAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data layout specification is a list of entries that specify (partial) data layout information.  <a href="classmlir_1_1DataLayoutSpecAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DebugAction.html">DebugAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A debug action is a specific action that is to be taken by the compiler, that can be toggled and controlled by an external user.  <a href="classmlir_1_1DebugAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DebugActionManager.html">DebugActionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents manages debug actions, and orchestrates the communication between action queries and action handlers.  <a href="classmlir_1_1DebugActionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DebugCounter.html">DebugCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a debug action handler that attaches a counter value to debug actions and enables/disables execution of these action based on the value of the counter.  <a href="classmlir_1_1DebugCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilities for time measurement and report printing to an output stream.  <a href="classmlir_1_1DefaultTimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two accesses to the same memref access the same element.  <a href="structmlir_1_1DependenceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics. ">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser when parsing attributes and type...">DialectAsmParser</a> has methods for interacting with the asm parser when parsing attributes and types.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectDecodeAttributesInterface.html">DialectDecodeAttributesInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an interface to decode opaque constant tensor.  <a href="classmlir_1_1DialectDecodeAttributesInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtension.html">DialectExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a dialect extension anchored on the given set of dialects.  <a href="classmlir_1_1DialectExtension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectExtensionBase.html">DialectExtensionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an opaque dialect extension.  <a href="classmlir_1_1DialectExtensionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectFoldInterface.html">DialectFoldInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a fold interface to allow for dialects to control specific aspects of the folding behavior for operations they define.  <a href="classmlir_1_1DialectFoldInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInlinerInterface.html">DialectInlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that must be implemented by the dialects of operations to be inlined.  <a href="classmlir_1_1DialectInlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectReductionPatternInterface.html">DialectReductionPatternInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to report the reduction patterns for a <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1DialectReductionPatternInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect. ">DialectRegistry</a> maps a dialect namespace to a constructor for the matching dialect.  <a href="classmlir_1_1DialectRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttr.html">DynamicAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic attribute instance.  <a href="classmlir_1_1DynamicAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicAttrDefinition.html">DynamicAttrDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic attribute.  <a href="classmlir_1_1DynamicAttrDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicOpDefinition.html">DynamicOpDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic op.  <a href="classmlir_1_1DynamicOpDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicType.html">DynamicType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic type instance.  <a href="classmlir_1_1DynamicType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DynamicTypeDefinition.html">DynamicTypeDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a dynamic type.  <a href="classmlir_1_1DynamicTypeDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyPipelineOptions.html">EmptyPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default empty option struct to be used for passes that do not need to take any options.  <a href="structmlir_1_1EmptyPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR modules.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ExecutionEngineOptions.html">ExecutionEngineOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExtensibleDialect.html">ExtensibleDialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect that can be extended with new operations/types/attributes at runtime.  <a href="classmlir_1_1ExtensibleDialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExternalPass.html">ExternalPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass class wraps external passes defined in other languages using the MLIR C-interface.  <a href="classmlir_1_1ExternalPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for representing a failure result, or a valid value of type <code>T</code>.  <a href="classmlir_1_1FailureOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser.html">FieldParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a template class that can be specialized by users to dispatch to parsers.  <a href="structmlir_1_1FieldParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html">FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01AttributeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Afbf44e752e28f353857b0de6053d0e60.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01std_1_1is__member__functi422663489277e3bce914a1d8fcf81d9c.html">FieldParser&lt; ContainerT, std::enable_if_t&lt; std::is_member_function_pointer&lt; decltype(&amp;ContainerT::push_back)&gt;::value, ContainerT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any container that supports back insertion as a list.  <a href="structmlir_1_1FieldParser_3_01ContainerT_00_01std_1_1enable__if__t_3_01std_1_1is__member__functi422663489277e3bce914a1d8fcf81d9c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html">FieldParser&lt; IntT, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, IntT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse any integer.  <a href="structmlir_1_1FieldParser_3_01IntT_00_01std_1_1enable__if__t_3_01std_1_1is__integral_3_01IntT_01_4_1_1value_00_01IntT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html">FieldParser&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string.  <a href="structmlir_1_1FieldParser_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html">FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute.  <a href="structmlir_1_1FieldParser_3_01TypeT_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01Type_0346a91898fcc3a5091d4a6bb97af4903.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FilteredValueUseIterator.html">FilteredValueUseIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain -&gt; range) where &quot;domain&quot; and &quot;range&quot; a...">FlatAffineRelation</a> represents a set of ordered pairs (domain -&gt; range) where "domain" and "range" are tuples of identifiers.  <a href="classmlir_1_1FlatAffineRelation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each identifier can hav...">FlatAffineValueConstraints</a> represents an extension of IntegerPolyhedron where each identifier can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  <a href="classmlir_1_1FlatAffineValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ForwardDataFlowAnalysis.html">ForwardDataFlowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a general forward dataflow analysis driver utilizing the lattice classes defined above, to enable the easy definition of dataflow analysis algorithms.  <a href="classmlir_1_1ForwardDataFlowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a frozen set of patterns that can be processed by a pattern applicator.  <a href="classmlir_1_1FrozenRewritePatternSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusionStrategy.html">FusionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the fusion strategy to be used in the Affine loop fusion utilities.  <a href="classmlir_1_1FusionStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function. ">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLowering.html">GPUFuncOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUIndexIntrinsicOpLowering.html">GPUIndexIntrinsicOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToHIPLowering.html">GPUPrintfOpToHIPLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to HIP hostcalls.  <a href="structmlir_1_1GPUPrintfOpToHIPLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html">GPUPrintfOpToLLVMCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowering of gpu.printf to a call to an external printf() function.  <a href="structmlir_1_1GPUPrintfOpToLLVMCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUReturnOpLowering.html">GPUReturnOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows control over how the GreedyPatternRewriteDriver works.  <a href="classmlir_1_1GreedyRewriteConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1HasDefaultDLTIDataLayout.html">HasDefaultDLTIDataLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to be used by operations willing to use the implementation of the data layout interfaces provided by the Target dialect.  <a href="classmlir_1_1HasDefaultDLTIDataLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html" title="ImplicitLocOpBuilder maintains a &#39;current location&#39;, allowing use of the create&lt;&gt; method without spec...">ImplicitLocOpBuilder</a> maintains a 'current location', allowing use of the create&lt;&gt; method without specifying the location.  <a href="classmlir_1_1ImplicitLocOpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation that implements the given interface.  <a href="classmlir_1_1InterfacePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InvocationBounds.html">InvocationBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents upper and lower bounds on the number of times a region of a <code>RegionBranchOpInterface</code> can be invoked.  <a href="classmlir_1_1InvocationBounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep track of the mutations made to the IR.  <a href="classmlir_1_1IRRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LatticeElement.html">LatticeElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a lattice holding a specific value of type <code>ValueT</code>.  <a href="classmlir_1_1LatticeElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class that automatically populates legalization information for different <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> ops.  <a href="classmlir_1_1LLVMConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dialect interfaces providing translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="classmlir_1_1LLVMTranslationDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTranslationInterface.html">LLVMTranslationInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface collection for translation to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, dispatches to a concrete interface implementation based on the dialect to which the given op belongs.  <a href="classmlir_1_1LLVMTranslationInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocalAliasAnalysis.html">LocalAliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a local form of alias analysis that tries to identify the underlying values addressed by each value and performs a few basic checks to see if they alias.  <a href="classmlir_1_1LocalAliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR. ">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an efficient way to signal success or failure.  <a href="structmlir_1_1LogicalResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1LoopNestStats.html" title="LoopNestStats aggregates various per-loop statistics (eg. ">LoopNestStats</a> aggregates various per-loop statistics (eg.  <a href="structmlir_1_1LoopNestStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a (parallelizable) reduction in an affine loop.  <a href="structmlir_1_1LoopReduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="classmlir_1_1LowerToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="structmlir_1_1LowerVectorToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a memref load or store access information.  <a href="structmlir_1_1MemRefAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptorView.html">MemRefDescriptorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class allowing the user to access a range of Values that correspond to an unpacked memref descriptor using named accessors.  <a href="classmlir_1_1MemRefDescriptorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> is the top-level object for a collection of MLIR operations.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible results of whether a memory access modifies or references a memory location.  <a href="classmlir_1_1ModRefResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a mutable adaptor for a range of operands.  <a href="classmlir_1_1MutableOperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRangeRange.html">MutableOperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of mutable operand ranges, e.g.  <a href="classmlir_1_1MutableOperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttribute.html" title="NamedAttribute represents a combination of a name and an Attribute value. ">NamedAttribute</a> represents a combination of a name and an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> value.  <a href="classmlir_1_1NamedAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> is array of NamedAttributes that tracks whether it is sorted and does some basic work to remain sorted.  <a href="classmlir_1_1NamedAttrList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedMatch.html">NestedMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> captures nested patterns in the IR.  <a href="classmlir_1_1NestedMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPatternContext.html">NestedPatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII structure to transparently manage the bump allocator for <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> and <a class="el" href="classmlir_1_1NestedMatch.html" title="An NestedPattern captures nested patterns in the IR. ">NestedMatch</a> classes.  <a href="classmlir_1_1NestedPatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToOneConvertToLLVMPattern.html">OneToOneConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of one-to-one conversion from "SourceOp" to "TargetOp" where the latter belongs to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect or an equivalent.  <a href="classmlir_1_1OneToOneConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="SPIRVDialect_8cpp.html#a256c9accb1c14859c3de6ba7991cf515">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpConversionPattern.html">OpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpConversionPattern.html" title="OpConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting agai...">OpConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns. ">ConversionPattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="classmlir_1_1OpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRangeRange.html">OperandRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a contiguous range of operand ranges, e.g.  <a href="classmlir_1_1OperandRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> is a basic unit of execution within MLIR.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationEquivalence.html">OperationEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for computing if two operations are equivalent.  <a href="structmlir_1_1OperationEquivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass_3_01void_01_4.html">OperationPass&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation.  <a href="classmlir_1_1OperationPass_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html">OpInterfaceConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpInterfaceConversionPattern.html" title="OpInterfaceConversionPattern is a wrapper around ConversionPattern that allows for matching and rewri...">OpInterfaceConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns. ">ConversionPattern</a> that allows for matching and rewriting against an instance of an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface. ">OpInterface</a> class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="classmlir_1_1OpInterfaceConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html">OpInterfaceRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpInterfaceRewritePattern.html" title="OpInterfaceRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting a...">OpInterfaceRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against an instance of an operation interface instead of a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="structmlir_1_1OpInterfaceRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on a specific operation type.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for parsing-like operations that find it important to chain tog...">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replace SourceOp with a CallOp to <code>f32Func</code> or <code>f64Func</code> depending on the element type that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have. ">Op</a> operates upon.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html">OpTraitRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpTraitRewritePattern.html" title="OpTraitRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting again...">OpTraitRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against instances of an operation that possess a given trait.  <a href="classmlir_1_1OpTraitRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html">OpWithOffsetSizesAndStridesConstantArgumentFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to rewrite a subview op with constant arguments.  <a href="classmlir_1_1OpWithOffsetSizesAndStridesConstantArgumentFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningMemRef.html">OwningMemRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning MemRef type that abstracts over the runtime type for ranked strided memref.  <a href="classmlir_1_1OwningMemRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to an op, and will automatically destroy the held op on destruction if the held op is valid.  <a href="classmlir_1_1OwningOpRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents success/failure for parsing-like operations that find it important to chain together failable operations with <code>||</code>.  <a href="classmlir_1_1ParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassNameCLParser.html">PassNameCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser specifically for MLIR pass names.  <a href="classmlir_1_1PassNameCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineOptions.html">PassPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classmlir_1_1PassPipelineOptions.html" title="Subclasses of PassPipelineOptions provide a set of options that can be used to initialize a pass pipe...">PassPipelineOptions</a> provide a set of options that can be used to initialize a pass pipeline.  <a href="classmlir_1_1PassPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassWrapper.html">PassWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a CRTP wrapper around a base pass class to define several necessary utility methods.  <a href="classmlir_1_1PassWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the data related to a pattern, but does not contain any methods or logic for the actual matching.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternApplicator.html">PatternApplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the application of a group of rewrite patterns, with a user-provided cost model.  <a href="classmlir_1_1PatternApplicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type of <code><a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a></code> that coordinates the application of a rewrite pattern on the current IR being matched, providing a way to keep track of any mutations made.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternModule.html">PDLPatternModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the necessary data for a set of PDL patterns, or pattern rewrites specified in the form of the PDL dialect.  <a href="classmlir_1_1PDLPatternModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents a list of PDL results, returned by a native rewrite method.  <a href="classmlir_1_1PDLResultList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type of byte-code interpreter values.  <a href="classmlir_1_1PDLValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyFileAccumulator.html">PyFileAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates int a python file-like object, either writing text (default) or binary.  <a href="classmlir_1_1PyFileAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PyPrintAccumulator.html">PyPrintAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that accepts an MlirStringCallback.  <a href="structmlir_1_1PyPrintAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PySinglePartStringAccumulator.html">PySinglePartStringAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that is expected to make one (no more, no less) call to the callback (asserts internally on violation).  <a href="structmlir_1_1PySinglePartStringAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples.  <a href="structmlir_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw_ostream subclass that simplifies indention a sequence of code.  <a href="classmlir_1_1raw__indented__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionNode.html">ReductionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReductionTreePass will build a reduction tree during module reduction and the <a class="el" href="classmlir_1_1ReductionNode.html" title="ReductionTreePass will build a reduction tree during module reduction and the ReductionNode represent...">ReductionNode</a> represents the vertex of the tree.  <a href="classmlir_1_1ReductionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a successor of a region.  <a href="classmlir_1_1RegionSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegisteredOperationName.html">RegisteredOperationName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1RegisteredOperationName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  <a href="classmlir_1_1RewriterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContextImpl.html">ScfToSPIRVContextImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SelfOwningTypeID.html">SelfOwningTypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a> for each instance of this class by using a pointer to the instance.  <a href="classmlir_1_1SelfOwningTypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapeAdaptor.html">ShapeAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor class to abstract the differences between whether value is from a ShapedType or <a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType. ">ShapedTypeComponents</a> or DenseIntElementsAttribute.  <a href="classmlir_1_1ShapeAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType. ">ShapedTypeComponents</a> that represents the components of a ShapedType.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Sliceable.html">Sliceable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP base class for pseudo-containers willing to support Python-type slicing access on top of indexed access.  <a href="classmlir_1_1Sliceable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SliceComputationResult.html">SliceComputationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different result statuses of slice computation by <code>computeSliceUnion</code>  <a href="structmlir_1_1SliceComputationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SparseTensorConversion options.  <a href="structmlir_1_1SparseTensorConversionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Sparsification pass.  <a href="structmlir_1_1SparsificationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVConversionTarget.html">SPIRVConversionTarget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVToLLVMConversion.html">SPIRVToLLVMConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion from builtin types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get or create instances of "storage classes".  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructuredGenerator.html">StructuredGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper <a class="el" href="classmlir_1_1StructuredGenerator.html" title="Helper StructuredGenerator class to manipulate and rewrite ops with StructuredOpInterface. ">StructuredGenerator</a> class to manipulate and rewrite ops with <code>StructuredOpInterface</code>.  <a href="classmlir_1_1StructuredGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models how operands are forwarded to block arguments in control flow.  <a href="classmlir_1_1SuccessorOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code>s.  <a href="classmlir_1_1SymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolUserMap.html">SymbolUserMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a map of symbols to users, and provides efficient implementations of symbol queries related to users; such as collecting the users of a symbol, replacing all uses, etc.  <a href="classmlir_1_1SymbolUserMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: <a class="el" href="namespacemlir_1_1RankedTensorType.html">RankedTensorType</a> and UnrankedTensorType.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the testing environment of the tool.  <a href="classmlir_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ThreadLocalCache.html">ThreadLocalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for defining a thread local object with non static storage duration.  <a href="classmlir_1_1ThreadLocalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for a timer in a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time. ">TimingManager</a></code>.  <a href="classmlir_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingIdentifier.html">TimingIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represesents a uniqued string owned by a <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time. ">TimingManager</a></code>.  <a href="classmlir_1_1TimingIdentifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingManager.html">TimingManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents facilities to measure execution time.  <a href="classmlir_1_1TimingManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TimingScope.html">TimingScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII-style wrapper around a timer that ensures the timer is properly started and stopped.  <a href="classmlir_1_1TimingScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as an initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command line parser for translation functions.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  <a href="classmlir_1_1TypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient unique identifier for a specific C++ type.  <a href="classmlir_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeIDAllocator.html">TypeIDAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a way to define new TypeIDs at runtime.  <a href="classmlir_1_1TypeIDAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of a type interface.  <a href="classmlir_1_1TypeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the various different ranges of value types.  <a href="classmlir_1_1TypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRangeRange.html">TypeRangeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction for a range of <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types. ">TypeRange</a>.  <a href="classmlir_1_1TypeRangeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a hook that expands one <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> into multiple <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s, with a TypeConverter-inspired callback registration mechanism.  <a href="classmlir_1_1ValueDecomposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> of values and shapes (corresponding effectively to Shapes dialect's ValueShape type concept).  <a href="classmlir_1_1ValueShapeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class that allows for iterating over the uses of an IR operand type.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the users of an IRObject.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorConvertToLLVMPattern.html">VectorConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lowering implementation to rewrite Ops with just one result to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1VectorConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds parameters to perform n-D vectorization on a single loop nest.  <a href="structmlir_1_1VectorizationStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When lowering an N-d vector transfer op to an (N-1)-d vector transfer op, a temporary buffer is created through which individual (N-1)-d vector are staged.  <a href="structmlir_1_1VectorTransferToSCFOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "14.5.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal how to proceed with an ongoing walk:  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to encode the current walk stage for "generic" walkers.  <a href="classmlir_1_1WalkStage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a611e5b4f126ef025a241fda803748304"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="memdesc:a611e5b4f126ef025a241fda803748304"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs.  <a href="#a611e5b4f126ef025a241fda803748304">More...</a><br /></td></tr>
<tr class="separator:a611e5b4f126ef025a241fda803748304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a> = std::unique_ptr&lt; std::vector&lt; char &gt; &gt;</td></tr>
<tr class="separator:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aaca5fea0016501841c1e98a14e7ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">BlobGenerator</a> = std::function&lt; <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td></tr>
<tr class="separator:af5aaca5fea0016501841c1e98a14e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a45ae9aa1ccffd960f369da94d156"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a> = std::function&lt; std::unique_ptr&lt; llvm::Module &gt;(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td></tr>
<tr class="separator:a594a45ae9aa1ccffd960f369da94d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">VectorizableLoopFun</a> = std::function&lt; bool(AffineForOp)&gt;</td></tr>
<tr class="separator:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">FilterFunctionType</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that:  <a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">More...</a><br /></td></tr>
<tr class="separator:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c23a0a994193842991e0c87709e067"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a>, 2 &gt; &gt;</td></tr>
<tr class="separator:a49c23a0a994193842991e0c87709e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8735b67af7a64e4deff16477a06eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp, 8 &gt;</td></tr>
<tr class="memdesc:ad5c8735b67af7a64e4deff16477a06eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>.  <a href="#ad5c8735b67af7a64e4deff16477a06eb">More...</a><br /></td></tr>
<tr class="separator:ad5c8735b67af7a64e4deff16477a06eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> = std::pair&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> &gt;</td></tr>
<tr class="separator:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab973fb931221b9539fe0ffd408e261ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;</td></tr>
<tr class="separator:ab973fb931221b9539fe0ffd408e261ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed845b40509fa999492a04654211321"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:a7ed845b40509fa999492a04654211321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;</td></tr>
<tr class="separator:ae5cf0e24a954fa30fb469105d4ca5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a> *(size_t)&gt;</td></tr>
<tr class="separator:ac9afb3b6f82b256aea9f20e913e8afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae076c6e0e79ca32d89266007db06f358"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">ElementWiseVisitor</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;)&gt;</td></tr>
<tr class="memdesc:ae076c6e0e79ca32d89266007db06f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient callback to "visit" a memref element by element.  <a href="#ae076c6e0e79ca32d89266007db06f358">More...</a><br /></td></tr>
<tr class="separator:ae076c6e0e79ca32d89266007db06f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33732a3813b186ef51131421fac26f4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">DataLayoutEntryKey</a> = <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr &gt;</td></tr>
<tr class="separator:a33732a3813b186ef51131421fac26f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4f77607d05cf551b24ceb9362c034"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> = <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; DataLayoutEntryInterface, 4 &gt;</td></tr>
<tr class="separator:a72a4f77607d05cf551b24ceb9362c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577834e9b93afb653df29d66a6975ecf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td></tr>
<tr class="separator:a577834e9b93afb653df29d66a6975ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d75e70e7cac31b335126e37dfe49b44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d75e70e7cac31b335126e37dfe49b44">ReifiedRankedShapedTypeDims</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;</td></tr>
<tr class="separator:a9d75e70e7cac31b335126e37dfe49b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bdae349015b16ce375bdd46c1e16c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:a759bdae349015b16ce375bdd46c1e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <a href="#a759bdae349015b16ce375bdd46c1e16c">More...</a><br /></td></tr>
<tr class="separator:a759bdae349015b16ce375bdd46c1e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5011648c4f698028afb8a96b31ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:aad8f5011648c4f698028afb8a96b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">DialectAllocatorFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffd752ab3a9dd88587958c328e34e70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">DialectAllocatorFunctionRef</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a6ffd752ab3a9dd88587958c328e34e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc3d0362a57c5175f05dd95fb59641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> &gt;</td></tr>
<tr class="separator:aedbc3d0362a57c5175f05dd95fb59641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887111bf825d1f766ef9e0911394d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">OpAsmSetValueNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:ab0887111bf825d1f766ef9e0911394d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <a href="#ab0887111bf825d1f766ef9e0911394d5">More...</a><br /></td></tr>
<tr class="separator:ab0887111bf825d1f766ef9e0911394d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d45da2e2b2d5f705d618b778e36d52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">OpAsmSetBlockNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td></tr>
<tr class="memdesc:af2d45da2e2b2d5f705d618b778e36d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of blocks in regions directly nested under an operation.  <a href="#af2d45da2e2b2d5f705d618b778e36d52">More...</a><br /></td></tr>
<tr class="separator:af2d45da2e2b2d5f705d618b778e36d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e9dd2cd47f4932caf7412344a0d902"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8e9dd2cd47f4932caf7412344a0d902">PDLConstraintFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;)&gt;</td></tr>
<tr class="memdesc:ac8e9dd2cd47f4932caf7412344a0d902"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic PDL pattern constraint function.  <a href="#ac8e9dd2cd47f4932caf7412344a0d902">More...</a><br /></td></tr>
<tr class="separator:ac8e9dd2cd47f4932caf7412344a0d902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b3453391c8240336255f36a7aaa9fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab1b3453391c8240336255f36a7aaa9fc">PDLRewriteFunction</a> = std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;)&gt;</td></tr>
<tr class="memdesc:ab1b3453391c8240336255f36a7aaa9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native PDL rewrite function.  <a href="#ab1b3453391c8240336255f36a7aaa9fc">More...</a><br /></td></tr>
<tr class="separator:ab1b3453391c8240336255f36a7aaa9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff85dd5cf397b62e521086d55e2d37"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">TypeRangeRangeIterator</a> = llvm::mapped_iterator&lt; llvm::iota_range&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::iterator, std::function&lt; <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(<a class="el" href="classunsigned.html">unsigned</a>)&gt; &gt;</td></tr>
<tr class="separator:a3bff85dd5cf397b62e521086d55e2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <a href="#a8b36f0e85767ed4e793d86f40bd8fe55">More...</a><br /></td></tr>
<tr class="separator:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9069ef9040ccc727d541c02d49ecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memdesc:a01e9069ef9040ccc727d541c02d49ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived Types.  <a href="#a01e9069ef9040ccc727d541c02d49ecd">More...</a><br /></td></tr>
<tr class="separator:a01e9069ef9040ccc727d541c02d49ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td></tr>
<tr class="memdesc:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">More...</a><br /></td></tr>
<tr class="separator:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;()&gt;</td></tr>
<tr class="separator:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c18458e843e6fbd7837dec1b0be4cd5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = void&gt; </td></tr>
<tr class="memitem:a8c18458e843e6fbd7837dec1b0be4cd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c18458e843e6fbd7837dec1b0be4cd5">DenseMapInfo</a> = <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt; T, Enable &gt;</td></tr>
<tr class="separator:a8c18458e843e6fbd7837dec1b0be4cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;</td></tr>
<tr class="separator:ad7f731697783a754f6f0e3821d1264b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; ValueT, ValueInfoT &gt;</td></tr>
<tr class="separator:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637916a3aeba97d795fa40975fbd7bd6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Vector  = std::vector&lt;T&gt;, typename Set  = DenseSet&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a637916a3aeba97d795fa40975fbd7bd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a> = <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; T, <a class="el" href="structVector.html">Vector</a>, Set &gt;</td></tr>
<tr class="separator:a637916a3aeba97d795fa40975fbd7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt; AllocatorTy &gt;</td></tr>
<tr class="separator:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = T&gt; </td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt; T, R &gt;</td></tr>
<tr class="separator:ac474b9f30a56412e090d9919e4dd8b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ResultT  = void&gt; </td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt; T, ResultT &gt;</td></tr>
<tr class="separator:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; Fn &gt;</td></tr>
<tr class="separator:a0bff6226b7c81b6134b8c1130403a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0c2458571cd80ebb876d979e24346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(std::unique_ptr&lt; llvm::MemoryBuffer &gt; chunkBuffer, raw_ostream &amp;os)&gt;</td></tr>
<tr class="separator:aafb0c2458571cd80ebb876d979e24346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">GenFunction</a> = std::function&lt; bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td></tr>
<tr class="memdesc:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">More...</a><br /></td></tr>
<tr class="separator:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22124ccf5219095aee552486366ccc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">PassPipelineFn</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td></tr>
<tr class="memdesc:aa22124ccf5219095aee552486366ccc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the function type used to setup the pass manager.  <a href="#aa22124ccf5219095aee552486366ccc0">More...</a><br /></td></tr>
<tr class="separator:aa22124ccf5219095aee552486366ccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099014bd868b4d3d9235a0dfd99c18d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a099014bd868b4d3d9235a0dfd99c18d4">TranslateSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a099014bd868b4d3d9235a0dfd99c18d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR.  <a href="#a099014bd868b4d3d9235a0dfd99c18d4">More...</a><br /></td></tr>
<tr class="separator:a099014bd868b4d3d9235a0dfd99c18d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc82af5afce4525743199c60d03df7d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc82af5afce4525743199c60d03df7d5">TranslateStringRefToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:adc82af5afce4525743199c60d03df7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <a href="#adc82af5afce4525743199c60d03df7d5">More...</a><br /></td></tr>
<tr class="separator:adc82af5afce4525743199c60d03df7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">TranslateFromMLIRFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(ModuleOp, llvm::raw_ostream &amp;output)&gt;</td></tr>
<tr class="memdesc:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <a href="#a13b54e61e2491e2bc91c54f8ef429cfa">More...</a><br /></td></tr>
<tr class="separator:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb54b5d484b1a53b08f04871fb0da8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">TranslateFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:addbb54b5d484b1a53b08f04871fb0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <a href="#addbb54b5d484b1a53b08f04871fb0da8">More...</a><br /></td></tr>
<tr class="separator:addbb54b5d484b1a53b08f04871fb0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> { <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b">ChangeResult::NoChange</a>, 
<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9">ChangeResult::Change</a>
 }<tr class="memdesc:a2c02a386e5ba59c4c88f83ac471f999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A result type used to indicate if a change happened.  <a href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2c02a386e5ba59c4c88f83ac471f999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4a641d6831cd23fcfd8e6d413acb0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0e">FusionMode</a> { <a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0eae6bf6be0c81b172c940a529947cbdcbf">Greedy</a>, 
<a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0ea4c84b1b2e881b0df9fbab23123827194">ProducerConsumer</a>, 
<a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0ea9c4a59afa1568bb286a15463cbfca62b">Sibling</a>
 }<tr class="memdesc:a6d4a641d6831cd23fcfd8e6d413acb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusion mode to attempt.  <a href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6d4a641d6831cd23fcfd8e6d413acb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781474aef998ccce168b69ae973cd832"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">SparseParallelizationStrategy::kNone</a>, 
<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7">SparseParallelizationStrategy::kDenseOuterLoop</a>, 
<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af">SparseParallelizationStrategy::kAnyStorageOuterLoop</a>, 
<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8">SparseParallelizationStrategy::kDenseAnyLoop</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7">SparseParallelizationStrategy::kAnyStorageAnyLoop</a>
<br />
 }<tr class="memdesc:a781474aef998ccce168b69ae973cd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parallelization strategy.  <a href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a781474aef998ccce168b69ae973cd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff3aa7fac07fd569937d78a0046fe2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2">SparseVectorizationStrategy</a> { <a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2a35c3ace1970663a16e5c65baa5941b13">SparseVectorizationStrategy::kNone</a>, 
<a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2a580289a4bc04d1b8340b94829df37fbb">SparseVectorizationStrategy::kDenseInnerLoop</a>, 
<a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2a3bd27e991efaf1f1fad03867e363b410">SparseVectorizationStrategy::kAnyStorageInnerLoop</a>
 }<tr class="memdesc:a89ff3aa7fac07fd569937d78a0046fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a vectorization strategy.  <a href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a89ff3aa7fac07fd569937d78a0046fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a> { <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7">SparseToSparseConversionStrategy::kAuto</a>, 
<a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3">SparseToSparseConversionStrategy::kViaCOO</a>, 
<a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e">SparseToSparseConversionStrategy::kDirect</a>
 }<tr class="memdesc:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a strategy for implementing sparse-to-sparse conversion.  <a href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad6dfcab9b0dbfb18cf218eef50ba36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f701680752dfb55505285ab8ce8b55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> { <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131">IteratorType::Parallel</a>, 
<a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a">IteratorType::Reduction</a>
 }<tr class="memdesc:a77f701680752dfb55505285ab8ce8b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed representation for loop type strings.  <a href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a77f701680752dfb55505285ab8ce8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">AffineExprKind::Add</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">AffineExprKind::Mul</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">AffineExprKind::Mod</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">AffineExprKind::FloorDiv</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">AffineExprKind::CeilDiv</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">AffineExprKind::LAST_AFFINE_BINARY_OP</a> = CeilDiv, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">AffineExprKind::Constant</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">AffineExprKind::DimId</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">AffineExprKind::SymbolId</a>
<br />
 }</td></tr>
<tr class="separator:a6d3b7fd763c24274db6c115579084133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11353e6611651b85531ad95629c57d75"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">SliceVerificationResult::Success</a>, 
<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">SliceVerificationResult::RankTooLarge</a>, 
<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SliceVerificationResult::SizeMismatch</a>, 
<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">SliceVerificationResult::ElemTypeMismatch</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">SliceVerificationResult::MemSpaceMismatch</a>, 
<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">SliceVerificationResult::LayoutMismatch</a>
<br />
 }<tr class="memdesc:a11353e6611651b85531ad95629c57d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that captures information related to verifier error conditions on slice insert/extract type of ops.  <a href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a11353e6611651b85531ad95629c57d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">DiagnosticSeverity::Note</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">DiagnosticSeverity::Warning</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">DiagnosticSeverity::Error</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">DiagnosticSeverity::Remark</a>
 }<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">RegionKind</a> { <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b">RegionKind::SSACFG</a>, 
<a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd">RegionKind::Graph</a>
 }<tr class="memdesc:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of regions contained in an operation.  <a href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> { <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">WalkOrder::PreOrder</a>, 
<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">WalkOrder::PostOrder</a>
 }<tr class="memdesc:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal order for region, block and operation walk utilities.  <a href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a59fa9dd53c74f1ca73aa7ef263c94adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">PassDisplayMode::List</a>, 
<a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">PassDisplayMode::Pipeline</a>
 }<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab64460ede39d8480e398fd2e6810d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">TraversalMode</a> { <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96">SinglePath</a>, 
<a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1">Backtrack</a>, 
<a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593">MultiPath</a>
 }<tr class="memdesc:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the traversal method options to be used in the reduction tree traversal.  <a href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8130946445de43cbbe975607457e51c"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af8130946445de43cbbe975607457e51c">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;result)</td></tr>
<tr class="separator:af8130946445de43cbbe975607457e51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0e8ea3e011d372d1f5b3bc1fb34e1286">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;result)</td></tr>
<tr class="separator:a0e8ea3e011d372d1f5b3bc1fb34e1286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a609ab9ceb7a2ad554864c86fc7ece4fd">operator|</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a609ab9ceb7a2ad554864c86fc7ece4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ec055bf293748f02c00aff842dc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a001ec055bf293748f02c00aff842dc38">operator|=</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:a001ec055bf293748f02c00aff842dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45d6414e128b6ce12252cac519bbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab45d6414e128b6ce12252cac519bbac">operator &amp;</a> (<a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> lhs, <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> rhs)</td></tr>
<tr class="separator:aab45d6414e128b6ce12252cac519bbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c969b6eced23c4017b0b2c90574940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72c969b6eced23c4017b0b2c90574940">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *forwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr)</td></tr>
<tr class="memdesc:a72c969b6eced23c4017b0b2c90574940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>forwardSlice</code> with the computed forward slice (i.e.  <a href="#a72c969b6eced23c4017b0b2c90574940">More...</a><br /></td></tr>
<tr class="separator:a72c969b6eced23c4017b0b2c90574940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a934c9a2093cf8857918f57c83852f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6a934c9a2093cf8857918f57c83852f1">getForwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *forwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr)</td></tr>
<tr class="memdesc:a6a934c9a2093cf8857918f57c83852f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getForwardSlice</code>.  <a href="#a6a934c9a2093cf8857918f57c83852f1">More...</a><br /></td></tr>
<tr class="separator:a6a934c9a2093cf8857918f57c83852f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaff1f732caf76ab2f92ea649ed3a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acdaff1f732caf76ab2f92ea649ed3a53">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *backwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr)</td></tr>
<tr class="memdesc:acdaff1f732caf76ab2f92ea649ed3a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>backwardSlice</code> with the computed backward slice (i.e.  <a href="#acdaff1f732caf76ab2f92ea649ed3a53">More...</a><br /></td></tr>
<tr class="separator:acdaff1f732caf76ab2f92ea649ed3a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047e62d0c1056140acf328aeeb91ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7047e62d0c1056140acf328aeeb91ae4">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *backwardSlice, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> filter=nullptr)</td></tr>
<tr class="memdesc:a7047e62d0c1056140acf328aeeb91ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-rooted version of <code>getBackwardSlice</code>.  <a href="#a7047e62d0c1056140acf328aeeb91ae4">More...</a><br /></td></tr>
<tr class="separator:a7047e62d0c1056140acf328aeeb91ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb361921efff7983dd75b7b0f342879d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb361921efff7983dd75b7b0f342879d">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> backwardFilter=nullptr, <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a> forwardFilter=nullptr)</td></tr>
<tr class="memdesc:afb361921efff7983dd75b7b0f342879d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <a href="#afb361921efff7983dd75b7b0f342879d">More...</a><br /></td></tr>
<tr class="separator:afb361921efff7983dd75b7b0f342879d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206ff895887c175c8c4408399856d3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a206ff895887c175c8c4408399856d3e5">topologicalSort</a> (const <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;toSort)</td></tr>
<tr class="memdesc:a206ff895887c175c8c4408399856d3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-root DAG topological sort.  <a href="#a206ff895887c175c8c4408399856d3e5">More...</a><br /></td></tr>
<tr class="separator:a206ff895887c175c8c4408399856d3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0319d523385e6e3a03e2c9ff83a4750a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0319d523385e6e3a03e2c9ff83a4750a">matchReduction</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; iterCarriedArgs, <a class="el" href="classunsigned.html">unsigned</a> redPos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;combinerOps)</td></tr>
<tr class="memdesc:a0319d523385e6e3a03e2c9ff83a4750a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>.  <a href="#a0319d523385e6e3a03e2c9ff83a4750a">More...</a><br /></td></tr>
<tr class="separator:a0319d523385e6e3a03e2c9ff83a4750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7856a3b7ff811204524bbc9959c8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee7856a3b7ff811204524bbc9959c8c9">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aee7856a3b7ff811204524bbc9959c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <a href="#aee7856a3b7ff811204524bbc9959c8c9">More...</a><br /></td></tr>
<tr class="separator:aee7856a3b7ff811204524bbc9959c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6a984b6da6b0bf690f727bd2e20dd31">populateAffineToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect.  <a href="#ad6a984b6da6b0bf690f727bd2e20dd31">More...</a><br /></td></tr>
<tr class="separator:ad6a984b6da6b0bf690f727bd2e20dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdf4bbbb9eb7a9678bd98d122b837cbd">lowerAffineLowerBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">More...</a><br /></td></tr>
<tr class="separator:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d924b9762c352e82e8fe0fb1e222288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d924b9762c352e82e8fe0fb1e222288">lowerAffineUpperBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a2d924b9762c352e82e8fe0fb1e222288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <a href="#a2d924b9762c352e82e8fe0fb1e222288">More...</a><br /></td></tr>
<tr class="separator:a2d924b9762c352e82e8fe0fb1e222288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ce34232ab009ce688d7cdc63695a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">createLowerAffinePass</a> ()</td></tr>
<tr class="memdesc:ae09ce34232ab009ce688d7cdc63695a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives).  <a href="#ae09ce34232ab009ce688d7cdc63695a8">More...</a><br /></td></tr>
<tr class="separator:ae09ce34232ab009ce688d7cdc63695a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f6113274b77800e7c3b22dd83771e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45f6113274b77800e7c3b22dd83771e0">populateConvertArmNeon2dToIntrPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a45f6113274b77800e7c3b22dd83771e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for the lowering of Arm NEON 2D ops to intrinsics.  <a href="#a45f6113274b77800e7c3b22dd83771e0">More...</a><br /></td></tr>
<tr class="separator:a45f6113274b77800e7c3b22dd83771e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4655b459042808cdaf22b54faf67aaf6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4655b459042808cdaf22b54faf67aaf6">createConvertArmNeon2dToIntrPass</a> ()</td></tr>
<tr class="memdesc:a4655b459042808cdaf22b54faf67aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e.  <a href="#a4655b459042808cdaf22b54faf67aaf6">More...</a><br /></td></tr>
<tr class="separator:a4655b459042808cdaf22b54faf67aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4fa49d15d05958ebff1ab8aac3e55cfc">createConvertAsyncToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Async operations to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#a4fa49d15d05958ebff1ab8aac3e55cfc">More...</a><br /></td></tr>
<tr class="separator:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9659670212051d0795efd99cf38772ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9659670212051d0795efd99cf38772ed">populateAsyncStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a9659670212051d0795efd99cf38772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for async structural type conversions.  <a href="#a9659670212051d0795efd99cf38772ed">More...</a><br /></td></tr>
<tr class="separator:a9659670212051d0795efd99cf38772ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acfbd8691a3dda5dad95817bf02cdd3cd">populateBufferizationToMemRefConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the Bufferization dialect to the MemRef dialect.  <a href="#acfbd8691a3dda5dad95817bf02cdd3cd">More...</a><br /></td></tr>
<tr class="separator:acfbd8691a3dda5dad95817bf02cdd3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae01b05ed73bc512e7ae40bc6d37ae1a0">createBufferizationToMemRefPass</a> ()</td></tr>
<tr class="separator:ae01b05ed73bc512e7ae40bc6d37ae1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bf16b29d948811335c75976eb7b876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75bf16b29d948811335c75976eb7b876">populateComplexToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a75bf16b29d948811335c75976eb7b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a75bf16b29d948811335c75976eb7b876">More...</a><br /></td></tr>
<tr class="separator:a75bf16b29d948811335c75976eb7b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a35442d74f5c37a94afbbcce5059e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a38a35442d74f5c37a94afbbcce5059e8">createConvertComplexToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a38a35442d74f5c37a94afbbcce5059e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to the LLVMIR dialect.  <a href="#a38a35442d74f5c37a94afbbcce5059e8">More...</a><br /></td></tr>
<tr class="separator:a38a35442d74f5c37a94afbbcce5059e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a09be0ab6e12c19fefea09a6cb423c54d">populateComplexToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a09be0ab6e12c19fefea09a6cb423c54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Complex to Standard.  <a href="#a09be0ab6e12c19fefea09a6cb423c54d">More...</a><br /></td></tr>
<tr class="separator:a09be0ab6e12c19fefea09a6cb423c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891730d98fe42a400b188049ff923f2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad891730d98fe42a400b188049ff923f2">createConvertComplexToStandardPass</a> ()</td></tr>
<tr class="memdesc:ad891730d98fe42a400b188049ff923f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Complex operations to the Standard dialect.  <a href="#ad891730d98fe42a400b188049ff923f2">More...</a><br /></td></tr>
<tr class="separator:ad891730d98fe42a400b188049ff923f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282b8506125737d8301a4345418bbcec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a282b8506125737d8301a4345418bbcec">createConvertControlFlowToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a282b8506125737d8301a4345418bbcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert ControlFlow ops to SPIR-V ops.  <a href="#a282b8506125737d8301a4345418bbcec">More...</a><br /></td></tr>
<tr class="separator:a282b8506125737d8301a4345418bbcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefa6b16e02f4faa0e2d43ac82fca0185">populateFuncToLLVMFuncOpConversionPattern</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#aefa6b16e02f4faa0e2d43ac82fca0185">More...</a><br /></td></tr>
<tr class="separator:aefa6b16e02f4faa0e2d43ac82fca0185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6caa6cc89d0b3c43a871101ba9fe6216">populateFuncToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a6caa6cc89d0b3c43a871101ba9fe6216">More...</a><br /></td></tr>
<tr class="separator:a6caa6cc89d0b3c43a871101ba9fe6216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050a225b8d7733734dc0c229e9e5a680"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a050a225b8d7733734dc0c229e9e5a680">createConvertFuncToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a050a225b8d7733734dc0c229e9e5a680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert the Func dialect into the LLVMIR dialect.  <a href="#a050a225b8d7733734dc0c229e9e5a680">More...</a><br /></td></tr>
<tr class="separator:a050a225b8d7733734dc0c229e9e5a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c23bdfdb099630bef62098393f87aa7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c23bdfdb099630bef62098393f87aa7">createConvertFuncToLLVMPass</a> (const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a2c23bdfdb099630bef62098393f87aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6b9ec4369b7b5946147ad4545d22d6c6">populateFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops.  <a href="#a6b9ec4369b7b5946147ad4545d22d6c6">More...</a><br /></td></tr>
<tr class="separator:a6b9ec4369b7b5946147ad4545d22d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b73c4fa68f99933c25bc8d889b7c3c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39b73c4fa68f99933c25bc8d889b7c3c">createConvertFuncToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a39b73c4fa68f99933c25bc8d889b7c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Func ops to SPIR-V ops.  <a href="#a39b73c4fa68f99933c25bc8d889b7c3c">More...</a><br /></td></tr>
<tr class="separator:a39b73c4fa68f99933c25bc8d889b7c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d2c4f2a1b6b34d83ef595b02236808"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a56d2c4f2a1b6b34d83ef595b02236808">createGpuToLLVMConversionPass</a> ()</td></tr>
<tr class="memdesc:a56d2c4f2a1b6b34d83ef595b02236808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert a GPU operations into a sequence of GPU runtime calls.  <a href="#a56d2c4f2a1b6b34d83ef595b02236808">More...</a><br /></td></tr>
<tr class="separator:a56d2c4f2a1b6b34d83ef595b02236808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2971eebb65dd07dfcb8318ede54f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc2971eebb65dd07dfcb8318ede54f56">populateGpuToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, StringRef gpuBinaryAnnotation={})</td></tr>
<tr class="memdesc:acc2971eebb65dd07dfcb8318ede54f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types.  <a href="#acc2971eebb65dd07dfcb8318ede54f56">More...</a><br /></td></tr>
<tr class="separator:acc2971eebb65dd07dfcb8318ede54f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23560b6de94f046854c32398b275f8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a23560b6de94f046854c32398b275f8b6">convertMMAToLLVMType</a> (<a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a> type)</td></tr>
<tr class="memdesc:a23560b6de94f046854c32398b275f8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>.  <a href="#a23560b6de94f046854c32398b275f8b6">More...</a><br /></td></tr>
<tr class="separator:a23560b6de94f046854c32398b275f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa896c9229c786edc4a7970b960b208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">configureGpuToNVVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a7fa896c9229c786edc4a7970b960b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#a7fa896c9229c786edc4a7970b960b208">More...</a><br /></td></tr>
<tr class="separator:a7fa896c9229c786edc4a7970b960b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0cfe15e8fb355926517f8b4dc0d0c0a">populateGpuToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#ac0cfe15e8fb355926517f8b4dc0d0c0a">More...</a><br /></td></tr>
<tr class="separator:ac0cfe15e8fb355926517f8b4dc0d0c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea1280606a190334088962debe41bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abea1280606a190334088962debe41bf0">populateGpuWMMAToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abea1280606a190334088962debe41bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#abea1280606a190334088962debe41bf0">More...</a><br /></td></tr>
<tr class="separator:abea1280606a190334088962debe41bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62610c48d7b8e08dfd726bdb51d433e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad62610c48d7b8e08dfd726bdb51d433e">createLowerGpuOpsToNVVMOpsPass</a> (<a class="el" href="classunsigned.html">unsigned</a> indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>)</td></tr>
<tr class="memdesc:ad62610c48d7b8e08dfd726bdb51d433e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts.  <a href="#ad62610c48d7b8e08dfd726bdb51d433e">More...</a><br /></td></tr>
<tr class="separator:ad62610c48d7b8e08dfd726bdb51d433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6de97155f64d87208f5ce9e4041885a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6de97155f64d87208f5ce9e4041885a">populateGpuToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime)</td></tr>
<tr class="memdesc:ac6de97155f64d87208f5ce9e4041885a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#ac6de97155f64d87208f5ce9e4041885a">More...</a><br /></td></tr>
<tr class="separator:ac6de97155f64d87208f5ce9e4041885a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">configureGpuToROCDLConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a65c490624b02da7c5cb78aa071e0aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#a65c490624b02da7c5cb78aa071e0aa2a">More...</a><br /></td></tr>
<tr class="separator:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30bd4322234c02f64f7915f71c71f5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa30bd4322234c02f64f7915f71c71f5a">createLowerGpuOpsToROCDLOpsPass</a> (<a class="el" href="classunsigned.html">unsigned</a> indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>, <a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a> runtime=gpu::amd::Runtime::Unknown)</td></tr>
<tr class="memdesc:aa30bd4322234c02f64f7915f71c71f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts.  <a href="#aa30bd4322234c02f64f7915f71c71f5a">More...</a><br /></td></tr>
<tr class="separator:aa30bd4322234c02f64f7915f71c71f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822bcc3b680bed98c042cdabebc7f94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a822bcc3b680bed98c042cdabebc7f94a">populateGPUToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a822bcc3b680bed98c042cdabebc7f94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <a href="#a822bcc3b680bed98c042cdabebc7f94a">More...</a><br /></td></tr>
<tr class="separator:a822bcc3b680bed98c042cdabebc7f94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98081470e80af33268acc9e7463f4af1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98081470e80af33268acc9e7463f4af1">createConvertGPUToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a98081470e80af33268acc9e7463f4af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert GPU Ops to SPIR-V ops.  <a href="#a98081470e80af33268acc9e7463f4af1">More...</a><br /></td></tr>
<tr class="separator:a98081470e80af33268acc9e7463f4af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85822fd77ee16dc5df2c93c9f56b4bf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa85822fd77ee16dc5df2c93c9f56b4bf">createConvertVulkanLaunchFuncToVulkanCallsPass</a> ()</td></tr>
<tr class="separator:aa85822fd77ee16dc5df2c93c9f56b4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad39c9d3321b2f5f4aee088b02b535f9b">createConvertGpuLaunchFuncToVulkanLaunchFuncPass</a> ()</td></tr>
<tr class="separator:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1602ebfb960be063051996895d9eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f1602ebfb960be063051996895d9eae">populateLinalgToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2f1602ebfb960be063051996895d9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a2f1602ebfb960be063051996895d9eae">More...</a><br /></td></tr>
<tr class="separator:a2f1602ebfb960be063051996895d9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d81cd941f78768bc9dd0cbaca49d45a">createConvertLinalgToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the LLVMIR dialect.  <a href="#a5d81cd941f78768bc9dd0cbaca49d45a">More...</a><br /></td></tr>
<tr class="separator:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6131cb8a44ef9ffc0fc14b02e2c53365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6131cb8a44ef9ffc0fc14b02e2c53365">populateLinalgToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6131cb8a44ef9ffc0fc14b02e2c53365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Linalg ops to SPIR-V ops.  <a href="#a6131cb8a44ef9ffc0fc14b02e2c53365">More...</a><br /></td></tr>
<tr class="separator:a6131cb8a44ef9ffc0fc14b02e2c53365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7621ad17eef3b7af217a900ae413cfa5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7621ad17eef3b7af217a900ae413cfa5">createLinalgToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a7621ad17eef3b7af217a900ae413cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert Linalg ops to SPIR-V ops.  <a href="#a7621ad17eef3b7af217a900ae413cfa5">More...</a><br /></td></tr>
<tr class="separator:a7621ad17eef3b7af217a900ae413cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">createConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memdesc:aefb33f39a4ad0d4d52396f132bee84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the Standard dialect.  <a href="#aefb33f39a4ad0d4d52396f132bee84cf">More...</a><br /></td></tr>
<tr class="separator:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f16fcf3a83d26d5a59da3bf0138ca24">structFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="#a6f16fcf3a83d26d5a59da3bf0138ca24">More...</a><br /></td></tr>
<tr class="separator:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d145c5b783b4fe092fc78fd6879ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a173d145c5b783b4fe092fc78fd6879ec">barePtrFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a173d145c5b783b4fe092fc78fd6879ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="#a173d145c5b783b4fe092fc78fd6879ec">More...</a><br /></td></tr>
<tr class="separator:a173d145c5b783b4fe092fc78fd6879ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f399fbc6445ee4e3b3c7f261dcbefc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9f399fbc6445ee4e3b3c7f261dcbefc">populateMathToLibmConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit)</td></tr>
<tr class="memdesc:af9f399fbc6445ee4e3b3c7f261dcbefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Math to Libm calls.  <a href="#af9f399fbc6445ee4e3b3c7f261dcbefc">More...</a><br /></td></tr>
<tr class="separator:af9f399fbc6445ee4e3b3c7f261dcbefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be8ab8e597910498a4a64215faa2fb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa0be8ab8e597910498a4a64215faa2fb">createConvertMathToLibmPass</a> ()</td></tr>
<tr class="memdesc:aa0be8ab8e597910498a4a64215faa2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Math operations to libm calls.  <a href="#aa0be8ab8e597910498a4a64215faa2fb">More...</a><br /></td></tr>
<tr class="separator:aa0be8ab8e597910498a4a64215faa2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792d9749fb9af6417bcc2b3662e5090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa792d9749fb9af6417bcc2b3662e5090">populateMathToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:aa792d9749fb9af6417bcc2b3662e5090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f2f3afc604027ee4caae1d784cbbf9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8f2f3afc604027ee4caae1d784cbbf9">createConvertMathToLLVMPass</a> ()</td></tr>
<tr class="separator:ac8f2f3afc604027ee4caae1d784cbbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7a0a3321fbef0b7dcd1fe6e0bfba227">populateMathToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops.  <a href="#ac7a0a3321fbef0b7dcd1fe6e0bfba227">More...</a><br /></td></tr>
<tr class="separator:ac7a0a3321fbef0b7dcd1fe6e0bfba227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30843a2073f3fa196023a00ff6ae70e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae30843a2073f3fa196023a00ff6ae70e">createConvertMathToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:ae30843a2073f3fa196023a00ff6ae70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Math ops to SPIR-V ops.  <a href="#ae30843a2073f3fa196023a00ff6ae70e">More...</a><br /></td></tr>
<tr class="separator:ae30843a2073f3fa196023a00ff6ae70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9890e0455cf09221d2ca1db8c19f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0e9890e0455cf09221d2ca1db8c19f2c">populateMemRefToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0e9890e0455cf09221d2ca1db8c19f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#a0e9890e0455cf09221d2ca1db8c19f2c">More...</a><br /></td></tr>
<tr class="separator:a0e9890e0455cf09221d2ca1db8c19f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d57aaa8a2edf83eccef4145b4e2b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a988d57aaa8a2edf83eccef4145b4e2b9">createMemRefToLLVMPass</a> ()</td></tr>
<tr class="separator:a988d57aaa8a2edf83eccef4145b4e2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a95c0c6dd7df034b1f340ca9a14c9a0a6">populateMemRefToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops.  <a href="#a95c0c6dd7df034b1f340ca9a14c9a0a6">More...</a><br /></td></tr>
<tr class="separator:a95c0c6dd7df034b1f340ca9a14c9a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f123db56a9d730a0424f582f6a85bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59f123db56a9d730a0424f582f6a85bc">createConvertMemRefToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a59f123db56a9d730a0424f582f6a85bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert MemRef ops to SPIR-V ops.  <a href="#a59f123db56a9d730a0424f582f6a85bc">More...</a><br /></td></tr>
<tr class="separator:a59f123db56a9d730a0424f582f6a85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68bf61fe2cf12c77f265e4851897c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6a68bf61fe2cf12c77f265e4851897c8">populateNVGPUToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a6a68bf61fe2cf12c77f265e4851897c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ec0d969c9cb644bceb1394a1e9e5b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab98ec0d969c9cb644bceb1394a1e9e5b">createConvertNVGPUToNVVMPass</a> ()</td></tr>
<tr class="separator:ab98ec0d969c9cb644bceb1394a1e9e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075dcb844c996870c4c38bf277a4d175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a075dcb844c996870c4c38bf277a4d175">populateOpenACCToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a075dcb844c996870c4c38bf277a4d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect LLVMIR dialect.  <a href="#a075dcb844c996870c4c38bf277a4d175">More...</a><br /></td></tr>
<tr class="separator:a075dcb844c996870c4c38bf277a4d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd9779adcd4172eec44c1eb060d4867"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addd9779adcd4172eec44c1eb060d4867">createConvertOpenACCToLLVMPass</a> ()</td></tr>
<tr class="memdesc:addd9779adcd4172eec44c1eb060d4867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert the OpenACC dialect into the LLVMIR dialect.  <a href="#addd9779adcd4172eec44c1eb060d4867">More...</a><br /></td></tr>
<tr class="separator:addd9779adcd4172eec44c1eb060d4867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725b3caed685f9615fba2027124f359f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a725b3caed685f9615fba2027124f359f">populateOpenACCToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a725b3caed685f9615fba2027124f359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect.  <a href="#a725b3caed685f9615fba2027124f359f">More...</a><br /></td></tr>
<tr class="separator:a725b3caed685f9615fba2027124f359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3c1dc4bc47a3830e063b709a36e0ab91">createConvertOpenACCToSCFPass</a> ()</td></tr>
<tr class="memdesc:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert the OpenACC dialect into the LLVMIR dialect.  <a href="#a3c1dc4bc47a3830e063b709a36e0ab91">More...</a><br /></td></tr>
<tr class="separator:a3c1dc4bc47a3830e063b709a36e0ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732e2b51952bf0b2c474784272e790b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a732e2b51952bf0b2c474784272e790b4">configureOpenMPToLLVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a732e2b51952bf0b2c474784272e790b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a732e2b51952bf0b2c474784272e790b4">More...</a><br /></td></tr>
<tr class="separator:a732e2b51952bf0b2c474784272e790b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111bfc29c10d7cd2ebba33996e38509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1111bfc29c10d7cd2ebba33996e38509">populateOpenMPToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1111bfc29c10d7cd2ebba33996e38509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a1111bfc29c10d7cd2ebba33996e38509">More...</a><br /></td></tr>
<tr class="separator:a1111bfc29c10d7cd2ebba33996e38509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53acb3c78e9695b7e30e1e9efec285a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53acb3c78e9695b7e30e1e9efec285a">createConvertOpenMPToLLVMPass</a> ()</td></tr>
<tr class="memdesc:ae53acb3c78e9695b7e30e1e9efec285a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert OpenMP operations to the LLVMIR dialect.  <a href="#ae53acb3c78e9695b7e30e1e9efec285a">More...</a><br /></td></tr>
<tr class="separator:ae53acb3c78e9695b7e30e1e9efec285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882e712b4e426905d73c1c74bd0f353"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">createPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memdesc:af882e712b4e426905d73c1c74bd0f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="#af882e712b4e426905d73c1c74bd0f353">More...</a><br /></td></tr>
<tr class="separator:af882e712b4e426905d73c1c74bd0f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06609d5a7ea6d475070dcc8d271725"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab06609d5a7ea6d475070dcc8d271725">createReconcileUnrealizedCastsPass</a> ()</td></tr>
<tr class="memdesc:aab06609d5a7ea6d475070dcc8d271725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences.  <a href="#aab06609d5a7ea6d475070dcc8d271725">More...</a><br /></td></tr>
<tr class="separator:aab06609d5a7ea6d475070dcc8d271725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c65dfcafc10b8117f172e7c150ac1ad">populateReconcileUnrealizedCastsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with rewrite patterns that eliminate noop <code>unrealized_conversion_cast</code> operation sequences.  <a href="#a7c65dfcafc10b8117f172e7c150ac1ad">More...</a><br /></td></tr>
<tr class="separator:a7c65dfcafc10b8117f172e7c150ac1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9fc663ae01ea2b6384c3f6ce299be3b0">populateSCFToControlFlowConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect.  <a href="#a9fc663ae01ea2b6384c3f6ce299be3b0">More...</a><br /></td></tr>
<tr class="separator:a9fc663ae01ea2b6384c3f6ce299be3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c34cdb063f52ff5ea4efd82807621"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a877c34cdb063f52ff5ea4efd82807621">createConvertSCFToCFPass</a> ()</td></tr>
<tr class="memdesc:a877c34cdb063f52ff5ea4efd82807621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect.  <a href="#a877c34cdb063f52ff5ea4efd82807621">More...</a><br /></td></tr>
<tr class="separator:a877c34cdb063f52ff5ea4efd82807621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe63747d3d90805543a5697ca8aca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbe63747d3d90805543a5697ca8aca9">convertAffineLoopNestToGPULaunch</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> numBlockDims, <a class="el" href="classunsigned.html">unsigned</a> numThreadDims)</td></tr>
<tr class="memdesc:addbe63747d3d90805543a5697ca8aca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="#addbe63747d3d90805543a5697ca8aca9">More...</a><br /></td></tr>
<tr class="separator:addbe63747d3d90805543a5697ca8aca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1727b1783cbf671c6ee60cc2a5c2f132">populateParallelLoopToGPUPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list.  <a href="#a1727b1783cbf671c6ee60cc2a5c2f132">More...</a><br /></td></tr>
<tr class="separator:a1727b1783cbf671c6ee60cc2a5c2f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d59b73ef695a82338e96055101c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">configureParallelLoopToGPULegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:af01d59b73ef695a82338e96055101c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal.  <a href="#af01d59b73ef695a82338e96055101c16">More...</a><br /></td></tr>
<tr class="separator:af01d59b73ef695a82338e96055101c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04b8cb2bfcf870fb9909b4805c0aad13">finalizeParallelLoopToGPUConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after applyPartialConversion/applyFullConversion call.  <a href="#a04b8cb2bfcf870fb9909b4805c0aad13">More...</a><br /></td></tr>
<tr class="separator:a04b8cb2bfcf870fb9909b4805c0aad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ec40c7aecb333928b9b4e9e409f0670">createAffineForToGPUPass</a> (<a class="el" href="classunsigned.html">unsigned</a> numBlockDims, <a class="el" href="classunsigned.html">unsigned</a> numThreadDims)</td></tr>
<tr class="memdesc:a0ec40c7aecb333928b9b4e9e409f0670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts loop nests into GPU kernels.  <a href="#a0ec40c7aecb333928b9b4e9e409f0670">More...</a><br /></td></tr>
<tr class="separator:a0ec40c7aecb333928b9b4e9e409f0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305cc3472323a62580de136ce81cc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aec305cc3472323a62580de136ce81cc3">createAffineForToGPUPass</a> ()</td></tr>
<tr class="separator:aec305cc3472323a62580de136ce81cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">createParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memdesc:aa2f36107d7ffc6c1f873c746385d9de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts scf.parallel operations into a gpu.launch operation.  <a href="#aa2f36107d7ffc6c1f873c746385d9de0">More...</a><br /></td></tr>
<tr class="separator:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eeef76941bf1c659f41fe8f8ddbfe0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a79eeef76941bf1c659f41fe8f8ddbfe0">createConvertSCFToOpenMPPass</a> ()</td></tr>
<tr class="separator:a79eeef76941bf1c659f41fe8f8ddbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3094753f32222ddd712d5b2321c38eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3094753f32222ddd712d5b2321c38eea">populateSCFToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;scfToSPIRVContext, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3094753f32222ddd712d5b2321c38eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect.  <a href="#a3094753f32222ddd712d5b2321c38eea">More...</a><br /></td></tr>
<tr class="separator:a3094753f32222ddd712d5b2321c38eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fac2c28004ec7e1ee564a7c4f940444"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4fac2c28004ec7e1ee564a7c4f940444">createConvertSCFToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a4fac2c28004ec7e1ee564a7c4f940444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SCF ops into SPIR-V ops.  <a href="#a4fac2c28004ec7e1ee564a7c4f940444">More...</a><br /></td></tr>
<tr class="separator:a4fac2c28004ec7e1ee564a7c4f940444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32c331310df6a35924ac128fa789f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d32c331310df6a35924ac128fa789f3">populateShapeToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a9d32c331310df6a35924ac128fa789f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ecc9afba558cb026032d0453a7c95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc9ecc9afba558cb026032d0453a7c95">createConvertShapeToStandardPass</a> ()</td></tr>
<tr class="separator:abc9ecc9afba558cb026032d0453a7c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6e66615eb7e50976ed8c89b2bb05adc">populateConvertShapeConstraintsConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ae6e66615eb7e50976ed8c89b2bb05adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac85b8b89468b7fc2b347d361b512e8d3">createConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ac85b8b89468b7fc2b347d361b512e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8075944125730fed529e3b93dcfed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">encodeBindAttribute</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ab8075944125730fed529e3b93dcfed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes global variable's descriptor set and binding into its name if they both exist.  <a href="#ab8075944125730fed529e3b93dcfed5b">More...</a><br /></td></tr>
<tr class="separator:ab8075944125730fed529e3b93dcfed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66c52897a19a19fdec8d7022372b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aae66c52897a19a19fdec8d7022372b7d">populateSPIRVToLLVMTypeConversion</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:aae66c52897a19a19fdec8d7022372b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates type conversions with additional SPIR-V types.  <a href="#aae66c52897a19a19fdec8d7022372b7d">More...</a><br /></td></tr>
<tr class="separator:aae66c52897a19a19fdec8d7022372b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7de728c22748c6b736dd346296b69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb7de728c22748c6b736dd346296b69f">populateSPIRVToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aeb7de728c22748c6b736dd346296b69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#aeb7de728c22748c6b736dd346296b69f">More...</a><br /></td></tr>
<tr class="separator:aeb7de728c22748c6b736dd346296b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1eaf01d677b8c5bc75e77f5093d9ca8f">populateSPIRVToLLVMFunctionConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a1eaf01d677b8c5bc75e77f5093d9ca8f">More...</a><br /></td></tr>
<tr class="separator:a1eaf01d677b8c5bc75e77f5093d9ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a0a0e3398946973ed32c1fb07d8936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa1a0a0e3398946973ed32c1fb07d8936">populateSPIRVToLLVMModuleConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa1a0a0e3398946973ed32c1fb07d8936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#aa1a0a0e3398946973ed32c1fb07d8936">More...</a><br /></td></tr>
<tr class="separator:aa1a0a0e3398946973ed32c1fb07d8936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712e219558e911fe489fefff81dd8365"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a712e219558e911fe489fefff81dd8365">createLowerHostCodeToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a712e219558e911fe489fefff81dd8365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to emulate <code>gpu.launch_func</code> call in <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and lower the host module code to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a712e219558e911fe489fefff81dd8365">More...</a><br /></td></tr>
<tr class="separator:a712e219558e911fe489fefff81dd8365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd8a621caca1db19e02a6933d28fb3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41cd8a621caca1db19e02a6933d28fb3">createConvertSPIRVToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a41cd8a621caca1db19e02a6933d28fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SPIR-V operations to the LLVMIR dialect.  <a href="#a41cd8a621caca1db19e02a6933d28fb3">More...</a><br /></td></tr>
<tr class="separator:a41cd8a621caca1db19e02a6933d28fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6b62cc455701b989bc81364a091f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abaf6b62cc455701b989bc81364a091f7">populateTensorToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, int64_t byteCountThreshold, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abaf6b62cc455701b989bc81364a091f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops.  <a href="#abaf6b62cc455701b989bc81364a091f7">More...</a><br /></td></tr>
<tr class="separator:abaf6b62cc455701b989bc81364a091f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b4be089f949bfd574dc18e61b5b75"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a6b4be089f949bfd574dc18e61b5b75">createConvertTensorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a7a6b4be089f949bfd574dc18e61b5b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert Tensor ops to SPIR-V ops.  <a href="#a7a6b4be089f949bfd574dc18e61b5b75">More...</a><br /></td></tr>
<tr class="separator:a7a6b4be089f949bfd574dc18e61b5b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bcc994390d4acdd8d8369854974a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3bcc994390d4acdd8d8369854974a6c">populatePrepareVectorToMMAPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af3bcc994390d4acdd8d8369854974a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to transform vector ops into a canonical form to convert to MMA matrix operations.  <a href="#af3bcc994390d4acdd8d8369854974a6c">More...</a><br /></td></tr>
<tr class="separator:af3bcc994390d4acdd8d8369854974a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f785af8c75118bc4626ba3ca30db6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13f785af8c75118bc4626ba3ca30db6f">convertVectorToMMAOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp)</td></tr>
<tr class="memdesc:a13f785af8c75118bc4626ba3ca30db6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert vector ops to MMA matrix operations nested under <code>rootOp</code>.  <a href="#a13f785af8c75118bc4626ba3ca30db6f">More...</a><br /></td></tr>
<tr class="separator:a13f785af8c75118bc4626ba3ca30db6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b33b7329a47c5c93a85bde3f6c743bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b33b7329a47c5c93a85bde3f6c743bc">createConvertVectorToGPUPass</a> ()</td></tr>
<tr class="memdesc:a1b33b7329a47c5c93a85bde3f6c743bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from vector to GPU ops.  <a href="#a1b33b7329a47c5c93a85bde3f6c743bc">More...</a><br /></td></tr>
<tr class="separator:a1b33b7329a47c5c93a85bde3f6c743bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75cce579ffaa7f6e5b4da65897ae4e41">populateVectorToLLVMMatrixConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics.  <a href="#a75cce579ffaa7f6e5b4da65897ae4e41">More...</a><br /></td></tr>
<tr class="separator:a75cce579ffaa7f6e5b4da65897ae4e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a70c08f12898f5942f022ea27ba371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75a70c08f12898f5942f022ea27ba371">populateVectorToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool reassociateFPReductions=false, bool force32BitVectorIndices=false)</td></tr>
<tr class="memdesc:a75a70c08f12898f5942f022ea27ba371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a75a70c08f12898f5942f022ea27ba371">More...</a><br /></td></tr>
<tr class="separator:a75a70c08f12898f5942f022ea27ba371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d0c2f42ef94e822f398d917b39184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa5d0c2f42ef94e822f398d917b39184">createConvertVectorToLLVMPass</a> (const <a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a>())</td></tr>
<tr class="memdesc:afa5d0c2f42ef94e822f398d917b39184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to the LLVMIR dialect.  <a href="#afa5d0c2f42ef94e822f398d917b39184">More...</a><br /></td></tr>
<tr class="separator:afa5d0c2f42ef94e822f398d917b39184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd8b33175a786207a6ab4213f9b25a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affd8b33175a786207a6ab4213f9b25a1">populateVectorToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:affd8b33175a786207a6ab4213f9b25a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#affd8b33175a786207a6ab4213f9b25a1">More...</a><br /></td></tr>
<tr class="separator:affd8b33175a786207a6ab4213f9b25a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c2e8d8175dd430cb8048a29596d6ce3">createConvertVectorToROCDLPass</a> ()</td></tr>
<tr class="memdesc:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect.  <a href="#a4c2e8d8175dd430cb8048a29596d6ce3">More...</a><br /></td></tr>
<tr class="separator:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a96c6c9c53e199da9b2def6f5e62eec02">populateVectorToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:a96c6c9c53e199da9b2def6f5e62eec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func.  <a href="#a96c6c9c53e199da9b2def6f5e62eec02">More...</a><br /></td></tr>
<tr class="separator:a96c6c9c53e199da9b2def6f5e62eec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">createConvertVectorToSCFPass</a> (const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:ac5c71e471d7d8cdda288a27d1ae75642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of vector ops to SCF.  <a href="#ac5c71e471d7d8cdda288a27d1ae75642">More...</a><br /></td></tr>
<tr class="separator:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32404bdce26e3b9e768fa1e790e77a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32404bdce26e3b9e768fa1e790e77a44">populateVectorToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a32404bdce26e3b9e768fa1e790e77a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="#a32404bdce26e3b9e768fa1e790e77a44">More...</a><br /></td></tr>
<tr class="separator:a32404bdce26e3b9e768fa1e790e77a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e215016b82bc3a02bddb450f68fdaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30e215016b82bc3a02bddb450f68fdaf">createConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a30e215016b82bc3a02bddb450f68fdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="#a30e215016b82bc3a02bddb450f68fdaf">More...</a><br /></td></tr>
<tr class="separator:a30e215016b82bc3a02bddb450f68fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9933337bb49fef0db16ad0a2052f554f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9933337bb49fef0db16ad0a2052f554f">getSupportedReductions</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;supportedReductions)</td></tr>
<tr class="memdesc:a9933337bb49fef0db16ad0a2052f554f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>supportedReductions</code> with descriptors of the supported reductions.  <a href="#a9933337bb49fef0db16ad0a2052f554f">More...</a><br /></td></tr>
<tr class="separator:a9933337bb49fef0db16ad0a2052f554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada966ff0f510c4882f6a4882c070c1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ada966ff0f510c4882f6a4882c070c1c3">isLoopParallel</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt; *parallelReductions=nullptr)</td></tr>
<tr class="memdesc:ada966ff0f510c4882f6a4882c070c1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if `forOp' is a parallel loop.  <a href="#ada966ff0f510c4882f6a4882c070c1c3">More...</a><br /></td></tr>
<tr class="separator:ada966ff0f510c4882f6a4882c070c1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320e213a9c20060ae8292c150584fac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae320e213a9c20060ae8292c150584fac">isLoopMemoryParallel</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ae320e213a9c20060ae8292c150584fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if `forOp' doesn't have memory dependences preventing parallelization.  <a href="#ae320e213a9c20060ae8292c150584fac">More...</a><br /></td></tr>
<tr class="separator:ae320e213a9c20060ae8292c150584fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1522039bca148f6d365612eb404e0994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1522039bca148f6d365612eb404e0994">getReachableAffineApplyOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;affineApplyOps)</td></tr>
<tr class="memdesc:a1522039bca148f6d365612eb404e0994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp.  <a href="#a1522039bca148f6d365612eb404e0994">More...</a><br /></td></tr>
<tr class="separator:a1522039bca148f6d365612eb404e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170122f309092d69a928d6a64f1b2fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a170122f309092d69a928d6a64f1b2fe9">getIndexSet</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *domain)</td></tr>
<tr class="memdesc:a170122f309092d69a928d6a64f1b2fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order.  <a href="#a170122f309092d69a928d6a64f1b2fe9">More...</a><br /></td></tr>
<tr class="separator:a170122f309092d69a928d6a64f1b2fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e4b524ab21065019d9fdd55240b3d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2e4b524ab21065019d9fdd55240b3d4">checkMemrefAccessDependence</a> (const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;dstAccess, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *dependenceConstraints, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *dependenceComponents, bool allowRAR=false)</td></tr>
<tr class="separator:ae2e4b524ab21065019d9fdd55240b3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0139b17eb17bf529e630ec15f2051472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0139b17eb17bf529e630ec15f2051472">hasDependence</a> (<a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> result)</td></tr>
<tr class="memdesc:a0139b17eb17bf529e630ec15f2051472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result.  <a href="#a0139b17eb17bf529e630ec15f2051472">More...</a><br /></td></tr>
<tr class="separator:a0139b17eb17bf529e630ec15f2051472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a72abd84dcc66c8c890fc6c5e0d24f8">getDependenceComponents</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> maxLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *depCompsVec)</td></tr>
<tr class="memdesc:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth].  <a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">More...</a><br /></td></tr>
<tr class="separator:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac634e77ac1d86b4486ff25a7fc42249d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac634e77ac1d86b4486ff25a7fc42249d">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:ac634e77ac1d86b4486ff25a7fc42249d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <a href="#ac634e77ac1d86b4486ff25a7fc42249d">More...</a><br /></td></tr>
<tr class="separator:ac634e77ac1d86b4486ff25a7fc42249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb0652ec5bbbeff3cc18c60aa47bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2cb0652ec5bbbeff3cc18c60aa47bb6">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:aa2cb0652ec5bbbeff3cc18c60aa47bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="#aa2cb0652ec5bbbeff3cc18c60aa47bb6">More...</a><br /></td></tr>
<tr class="separator:aa2cb0652ec5bbbeff3cc18c60aa47bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7e68685a7df8a7a4c01d85a91cd136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ace7e68685a7df8a7a4c01d85a91cd136">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst=nullptr)</td></tr>
<tr class="separator:ace7e68685a7df8a7a4c01d85a91cd136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bcc9dc786aa8f64a60f1d51cdad3361">alignAffineMapWithValues</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *newSyms=nullptr)</td></tr>
<tr class="memdesc:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values.  <a href="#a5bcc9dc786aa8f64a60f1d51cdad3361">More...</a><br /></td></tr>
<tr class="separator:a5bcc9dc786aa8f64a60f1d51cdad3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617813f648e1d9b892b6c800d454fb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a617813f648e1d9b892b6c800d454fb2e">getRelationFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a617813f648e1d9b892b6c800d454fb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a relation from the given AffineMap/AffineValueMap <code>map</code>, containing all pairs of the form <code>operands -&gt; result</code> that satisfy <code>map</code>.  <a href="#a617813f648e1d9b892b6c800d454fb2e">More...</a><br /></td></tr>
<tr class="separator:a617813f648e1d9b892b6c800d454fb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d361d2d6501c9e34585acab051ea0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d361d2d6501c9e34585acab051ea0d4">getRelationFromMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;map, <a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;rel)</td></tr>
<tr class="separator:a6d361d2d6501c9e34585acab051ea0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc7770ed937494bbe2801d36c853ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af2cc7770ed937494bbe2801d36c853ac">getTripCountMapAndOperands</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:af2cc7770ed937494bbe2801d36c853ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise.  <a href="#af2cc7770ed937494bbe2801d36c853ac">More...</a><br /></td></tr>
<tr class="separator:af2cc7770ed937494bbe2801d36c853ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8cdcd2c284243df5d427fcdfe4edde75">getConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8cdcd2c284243df5d427fcdfe4edde75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop if it's a constant, None otherwise.  <a href="#a8cdcd2c284243df5d427fcdfe4edde75">More...</a><br /></td></tr>
<tr class="separator:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c3272c7e5d627a525a70f55fb93fb57">getLargestDivisorOfTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8c3272c7e5d627a525a70f55fb93fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest known integral divisor of the trip count.  <a href="#a8c3272c7e5d627a525a70f55fb93fb57">More...</a><br /></td></tr>
<tr class="separator:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4243a75480867bb61c05aa5879d2a32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="namespacemlir.html#a8c18458e843e6fbd7837dec1b0be4cd5">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4243a75480867bb61c05aa5879d2a32f">getInvariantAccesses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; indices)</td></tr>
<tr class="memdesc:a4243a75480867bb61c05aa5879d2a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>.  <a href="#a4243a75480867bb61c05aa5879d2a32f">More...</a><br /></td></tr>
<tr class="separator:a4243a75480867bb61c05aa5879d2a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76b6d2ee408bfc5909eb81779da3e0f1">isVectorizableLoopBody</a> (AffineForOp loop, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable; i.e.  <a href="#a76b6d2ee408bfc5909eb81779da3e0f1">More...</a><br /></td></tr>
<tr class="separator:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f2a9f8242f345de0163689c30304e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae13f2a9f8242f345de0163689c30304e">isVectorizableLoopBody</a> (AffineForOp loop, int *memRefDim, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:ae13f2a9f8242f345de0163689c30304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either:  <a href="#ae13f2a9f8242f345de0163689c30304e">More...</a><br /></td></tr>
<tr class="separator:ae13f2a9f8242f345de0163689c30304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65079eba69cbd732d43736887a06bff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac65079eba69cbd732d43736887a06bff">isOpwiseShiftValid</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts)</td></tr>
<tr class="memdesc:ac65079eba69cbd732d43736887a06bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.  <a href="#ac65079eba69cbd732d43736887a06bff">More...</a><br /></td></tr>
<tr class="separator:ac65079eba69cbd732d43736887a06bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7dc425822a826dd76ea2e8185aeb9fab">defaultFilterFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)</td></tr>
<tr class="separator:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e7b35354627941316244640aa4392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a991e7b35354627941316244640aa4392">getLoopIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a991e7b35354627941316244640aa4392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one.  <a href="#a991e7b35354627941316244640aa4392">More...</a><br /></td></tr>
<tr class="separator:a991e7b35354627941316244640aa4392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1ccc3f1298ad67bd387a804aa82fa65">getEnclosingAffineForAndIfOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *ops)</td></tr>
<tr class="memdesc:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> or <code>affine.if</code> operation to the innermost one.  <a href="#ad1ccc3f1298ad67bd387a804aa82fa65">More...</a><br /></td></tr>
<tr class="separator:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2db02976864d1e32f9f500d9d719d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2db02976864d1e32f9f500d9d719d5a">getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac2db02976864d1e32f9f500d9d719d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <a href="#ac2db02976864d1e32f9f500d9d719d5a">More...</a><br /></td></tr>
<tr class="separator:ac2db02976864d1e32f9f500d9d719d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b838aa59fec6e94e6afe4083478f52b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0b838aa59fec6e94e6afe4083478f52b">isLoopParallelAndContainsReduction</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a0b838aa59fec6e94e6afe4083478f52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a loop is a parallel loop and contains a reduction loop.  <a href="#a0b838aa59fec6e94e6afe4083478f52b">More...</a><br /></td></tr>
<tr class="separator:a0b838aa59fec6e94e6afe4083478f52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4052bdb6ce4bde76e5de054805848162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4052bdb6ce4bde76e5de054805848162">getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a4052bdb6ce4bde76e5de054805848162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <a href="#a4052bdb6ce4bde76e5de054805848162">More...</a><br /></td></tr>
<tr class="separator:a4052bdb6ce4bde76e5de054805848162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92965fea632fd01db2c6e8ae156df70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab92965fea632fd01db2c6e8ae156df70">getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *dependenceConstraints, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:ab92965fea632fd01db2c6e8ae156df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <a href="#ab92965fea632fd01db2c6e8ae156df70">More...</a><br /></td></tr>
<tr class="separator:ab92965fea632fd01db2c6e8ae156df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fa33c99e241ea5c601599c366c415e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3fa33c99e241ea5c601599c366c415e">getSliceIterationCount</a> (const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</td></tr>
<tr class="memdesc:af3fa33c99e241ea5c601599c366c415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for the <code>slicetripCountMap</code> provided.  <a href="#af3fa33c99e241ea5c601599c366c415e">More...</a><br /></td></tr>
<tr class="separator:af3fa33c99e241ea5c601599c366c415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66fe15b68ccfe9902bee711b0d1636"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f66fe15b68ccfe9902bee711b0d1636">buildSliceTripCountMap</a> (const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *tripCountMap)</td></tr>
<tr class="memdesc:a2f66fe15b68ccfe9902bee711b0d1636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'.  <a href="#a2f66fe15b68ccfe9902bee711b0d1636">More...</a><br /></td></tr>
<tr class="separator:a2f66fe15b68ccfe9902bee711b0d1636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53bb2629311efe042f2418b2c4233e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1SliceComputationResult.html">SliceComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa53bb2629311efe042f2418b2c4233e0">computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsB, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classunsigned.html">unsigned</a> numCommonLoops, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:aa53bb2629311efe042f2418b2c4233e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid.  <a href="#aa53bb2629311efe042f2418b2c4233e0">More...</a><br /></td></tr>
<tr class="separator:aa53bb2629311efe042f2418b2c4233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8c76f66345aba4e6cabb250bf7699c1">insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:aa8c76f66345aba4e6cabb250bf7699c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <a href="#aa8c76f66345aba4e6cabb250bf7699c1">More...</a><br /></td></tr>
<tr class="separator:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bd0c019a961c60a1fd09225b7dcd3be">getMemRefSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of memref data in bytes if it's statically shaped, None otherwise.  <a href="#a5bd0c019a961c60a1fd09225b7dcd3be">More...</a><br /></td></tr>
<tr class="separator:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer &gt; </td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, bool <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=true)</td></tr>
<tr class="memdesc:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <a href="#afdb92b40e131a0a6bd17fc39f1f3e371">More...</a><br /></td></tr>
<tr class="separator:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd698449e5677681454cc2e4f4718396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abd698449e5677681454cc2e4f4718396">getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;b)</td></tr>
<tr class="memdesc:abd698449e5677681454cc2e4f4718396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <a href="#abd698449e5677681454cc2e4f4718396">More...</a><br /></td></tr>
<tr class="separator:abd698449e5677681454cc2e4f4718396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670cd81ab396ba425cd0063d516b9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1670cd81ab396ba425cd0063d516b9a9">getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a1670cd81ab396ba425cd0063d516b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <a href="#a1670cd81ab396ba425cd0063d516b9a9">More...</a><br /></td></tr>
<tr class="separator:a1670cd81ab396ba425cd0063d516b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1cab5a79af53f1bc236af0c5ba5e7b54">simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <a href="#a1cab5a79af53f1bc236af0c5ba5e7b54">More...</a><br /></td></tr>
<tr class="separator:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde4236d0e9455a3983834b085f73224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abde4236d0e9455a3983834b085f73224">getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=nullptr)</td></tr>
<tr class="memdesc:abde4236d0e9455a3983834b085f73224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <a href="#abde4236d0e9455a3983834b085f73224">More...</a><br /></td></tr>
<tr class="separator:abde4236d0e9455a3983834b085f73224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa36b5164871eaf1d6423cd0a2eb4e4fd">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: These should be renamed if they are on the mlir namespace.  <a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">More...</a><br /></td></tr>
<tr class="separator:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1377153422b2a3cc25d7053a30e59bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1377153422b2a3cc25d7053a30e59bc">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:ac1377153422b2a3cc25d7053a30e59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code>.  <a href="#ac1377153422b2a3cc25d7053a30e59bc">More...</a><br /></td></tr>
<tr class="separator:ac1377153422b2a3cc25d7053a30e59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af721960fd29e7148cf561bb6e1f1fa07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af721960fd29e7148cf561bb6e1f1fa07">getAffineScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:af721960fd29e7148cf561bb6e1f1fa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest region enclosing <code>op</code> that is held by an operation with trait <code>AffineScope</code>; <code>nullptr</code> if there is no such region.  <a href="#af721960fd29e7148cf561bb6e1f1fa07">More...</a><br /></td></tr>
<tr class="separator:af721960fd29e7148cf561bb6e1f1fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e447f320894cc02bbaeff66dd31ccee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e447f320894cc02bbaeff66dd31ccee">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a9e447f320894cc02bbaeff66dd31ccee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="#a9e447f320894cc02bbaeff66dd31ccee">More...</a><br /></td></tr>
<tr class="separator:a9e447f320894cc02bbaeff66dd31ccee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31448f2e1927a26095c872bbfb4683a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31448f2e1927a26095c872bbfb4683a1">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a31448f2e1927a26095c872bbfb4683a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="#a31448f2e1927a26095c872bbfb4683a1">More...</a><br /></td></tr>
<tr class="separator:a31448f2e1927a26095c872bbfb4683a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f320624f15a47e5732c1142f99dc144"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f320624f15a47e5732c1142f99dc144">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a6f320624f15a47e5732c1142f99dc144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="#a6f320624f15a47e5732c1142f99dc144">More...</a><br /></td></tr>
<tr class="separator:a6f320624f15a47e5732c1142f99dc144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bfdb250aa76df12c7f6a5727e7ceb4b">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="#a6bfdb250aa76df12c7f6a5727e7ceb4b">More...</a><br /></td></tr>
<tr class="separator:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d0c425094498fc25bf4856eb029c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc3d0c425094498fc25bf4856eb029c8">parseDimAndSymbolList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, <a class="el" href="classunsigned.html">unsigned</a> &amp;numDims)</td></tr>
<tr class="memdesc:adc3d0c425094498fc25bf4856eb029c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses dimension and symbol list.  <a href="#adc3d0c425094498fc25bf4856eb029c8">More...</a><br /></td></tr>
<tr class="separator:adc3d0c425094498fc25bf4856eb029c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8bde50e2368b8864c8bc070a11fdd71">canonicalizeMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ad8bde50e2368b8864c8bc070a11fdd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies both <code>map</code> and <code>operands</code> in-place so as to:  <a href="#ad8bde50e2368b8864c8bc070a11fdd71">More...</a><br /></td></tr>
<tr class="separator:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d761b15655cb81ff4b40dbf49445db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a02d761b15655cb81ff4b40dbf49445db">canonicalizeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a02d761b15655cb81ff4b40dbf49445db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps.  <a href="#a02d761b15655cb81ff4b40dbf49445db">More...</a><br /></td></tr>
<tr class="separator:a02d761b15655cb81ff4b40dbf49445db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d30ccceb8aecf3060031371bc8a72b"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58d30ccceb8aecf3060031371bc8a72b">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a58d30ccceb8aecf3060031371bc8a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands.  <a href="#a58d30ccceb8aecf3060031371bc8a72b">More...</a><br /></td></tr>
<tr class="separator:a58d30ccceb8aecf3060031371bc8a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60836647618fe45d44620a7b41d3ca04"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a60836647618fe45d44620a7b41d3ca04">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a60836647618fe45d44620a7b41d3ca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>makeComposedAffineApply</code> which infers the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> from <code>e</code>.  <a href="#a60836647618fe45d44620a7b41d3ca04">More...</a><br /></td></tr>
<tr class="separator:a60836647618fe45d44620a7b41d3ca04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad746ee74e91801b5f975addf56cd8d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad746ee74e91801b5f975addf56cd8d5f">applyMapToValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:ad746ee74e91801b5f975addf56cd8d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values obtained by applying <code>map</code> to the list of values.  <a href="#ad746ee74e91801b5f975addf56cd8d5f">More...</a><br /></td></tr>
<tr class="separator:ad746ee74e91801b5f975addf56cd8d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab80da81dcbeeee5cc76ed25a83f10200">fullyComposeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ab80da81dcbeeee5cc76ed25a83f10200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp.  <a href="#ab80da81dcbeeee5cc76ed25a83f10200">More...</a><br /></td></tr>
<tr class="separator:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dd391dd6c617912e9c5e70caa5fb513">isForInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a0dd391dd6c617912e9c5e70caa5fb513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of a AffineForOp.  <a href="#a0dd391dd6c617912e9c5e70caa5fb513">More...</a><br /></td></tr>
<tr class="separator:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13093ebea6c814674ee1668daf5f81f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13093ebea6c814674ee1668daf5f81f8">extractForInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forInsts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *ivs)</td></tr>
<tr class="memdesc:a13093ebea6c814674ee1668daf5f81f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>.  <a href="#a13093ebea6c814674ee1668daf5f81f8">More...</a><br /></td></tr>
<tr class="separator:a13093ebea6c814674ee1668daf5f81f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63560e053a2ecec5eae27d99fe6d72c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a63560e053a2ecec5eae27d99fe6d72c7">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="memdesc:a63560e053a2ecec5eae27d99fe6d72c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator.  <a href="#a63560e053a2ecec5eae27d99fe6d72c7">More...</a><br /></td></tr>
<tr class="separator:a63560e053a2ecec5eae27d99fe6d72c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0366913a08a55f407cca2775a169d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0366913a08a55f407cca2775a169d7e">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="separator:ac0366913a08a55f407cca2775a169d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61278b37497f27fa382bcabb5cd043b8"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a61278b37497f27fa382bcabb5cd043b8">replaceForOpWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AffineForOp loop, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newYieldedValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterArgs, bool replaceLoopResults=true)</td></tr>
<tr class="memdesc:a61278b37497f27fa382bcabb5cd043b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>loop</code> with a new loop where <code>newIterOperands</code> are appended with new initialization values and <code>newYieldedValues</code> are added as new yielded values.  <a href="#a61278b37497f27fa382bcabb5cd043b8">More...</a><br /></td></tr>
<tr class="separator:a61278b37497f27fa382bcabb5cd043b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3742a7c72295f23d6fdd6b157b334074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3742a7c72295f23d6fdd6b157b334074">canFuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *srcSlice, <a class="el" href="classmlir_1_1FusionStrategy.html">FusionStrategy</a> fusionStrategy=<a class="el" href="classmlir_1_1FusionStrategy.html#af67d30ce20aaace9e674be9cae1001bfa190cb66109576270749d23427806eb6a">FusionStrategy::Generic</a>)</td></tr>
<tr class="memdesc:a3742a7c72295f23d6fdd6b157b334074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'.  <a href="#a3742a7c72295f23d6fdd6b157b334074">More...</a><br /></td></tr>
<tr class="separator:a3742a7c72295f23d6fdd6b157b334074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023cf013ed2352f349ed9e72e6bff12c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a023cf013ed2352f349ed9e72e6bff12c">fuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;srcSlice, bool isInnermostSiblingInsertionFusion=false)</td></tr>
<tr class="memdesc:a023cf013ed2352f349ed9e72e6bff12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'.  <a href="#a023cf013ed2352f349ed9e72e6bff12c">More...</a><br /></td></tr>
<tr class="separator:a023cf013ed2352f349ed9e72e6bff12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c56a4421761c1f8658aa16c292463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b8c56a4421761c1f8658aa16c292463">getLoopNestStats</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *stats)</td></tr>
<tr class="memdesc:a1b8c56a4421761c1f8658aa16c292463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect loop nest statistics (eg.  <a href="#a1b8c56a4421761c1f8658aa16c292463">More...</a><br /></td></tr>
<tr class="separator:a1b8c56a4421761c1f8658aa16c292463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eaf936f054b483e983fa6be1cb27f3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a61eaf936f054b483e983fa6be1cb27f3">getComputeCost</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;stats)</td></tr>
<tr class="memdesc:a61eaf936f054b483e983fa6be1cb27f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.  <a href="#a61eaf936f054b483e983fa6be1cb27f3">More...</a><br /></td></tr>
<tr class="separator:a61eaf936f054b483e983fa6be1cb27f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde43535284e6667536f8ed8c7906063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afde43535284e6667536f8ed8c7906063">getFusionComputeCost</a> (AffineForOp srcForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;srcStats, AffineForOp dstForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;dstStats, const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, int64_t *computeCost)</td></tr>
<tr class="memdesc:afde43535284e6667536f8ed8c7906063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'.  <a href="#afde43535284e6667536f8ed8c7906063">More...</a><br /></td></tr>
<tr class="separator:afde43535284e6667536f8ed8c7906063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df8e8b4e1357d7820daeffd9d17a742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7df8e8b4e1357d7820daeffd9d17a742">gatherProducerConsumerMemrefs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; srcOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; dstOps, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:a7df8e8b4e1357d7820daeffd9d17a742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'.  <a href="#a7df8e8b4e1357d7820daeffd9d17a742">More...</a><br /></td></tr>
<tr class="separator:a7df8e8b4e1357d7820daeffd9d17a742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9a5f6331a28a90f85a2d8498fd6f801">loopUnrollFull</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation completely if the trip count is known to be constant.  <a href="#ab9a5f6331a28a90f85a2d8498fd6f801">More...</a><br /></td></tr>
<tr class="separator:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66978e876ce5de46d58278fae24d4520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66978e876ce5de46d58278fae24d4520">loopUnrollByFactor</a> (AffineForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=nullptr)</td></tr>
<tr class="memdesc:a66978e876ce5de46d58278fae24d4520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="#a66978e876ce5de46d58278fae24d4520">More...</a><br /></td></tr>
<tr class="separator:a66978e876ce5de46d58278fae24d4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a6ed1cfcc6232ad7dae507d67db6462">loopUnrollUpToFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop by the specified unroll factor or its trip count, whichever is lower.  <a href="#a4a6ed1cfcc6232ad7dae507d67db6462">More...</a><br /></td></tr>
<tr class="separator:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac991f1476b0af97ff0620a3ddfdb3"><td class="memItemLeft" align="right" valign="top">bool LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdac991f1476b0af97ff0620a3ddfdb3">isPerfectlyNested</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:abdac991f1476b0af97ff0620a3ddfdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost.  <a href="#abdac991f1476b0af97ff0620a3ddfdb3">More...</a><br /></td></tr>
<tr class="separator:abdac991f1476b0af97ff0620a3ddfdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd53e808ea039aa9738dfab187468f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cd53e808ea039aa9738dfab187468f8">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;nestedLoops, AffineForOp root)</td></tr>
<tr class="memdesc:a7cd53e808ea039aa9738dfab187468f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="#a7cd53e808ea039aa9738dfab187468f8">More...</a><br /></td></tr>
<tr class="separator:a7cd53e808ea039aa9738dfab187468f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a63b71c0fe3f345278eab205e10a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad67a63b71c0fe3f345278eab205e10a3">loopUnrollJamByFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ad67a63b71c0fe3f345278eab205e10a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor.  <a href="#ad67a63b71c0fe3f345278eab205e10a3">More...</a><br /></td></tr>
<tr class="separator:ad67a63b71c0fe3f345278eab205e10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918847951e0d20706fe61380e119adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac918847951e0d20706fe61380e119adb">loopUnrollJamUpToFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ac918847951e0d20706fe61380e119adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower.  <a href="#ac918847951e0d20706fe61380e119adb">More...</a><br /></td></tr>
<tr class="separator:ac918847951e0d20706fe61380e119adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f574bfd0dab3a0967cf1e3c77780fd4">promoteIfSingleIteration</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration.  <a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">More...</a><br /></td></tr>
<tr class="separator:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac04a5178397b80a50634b35e015183a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac04a5178397b80a50634b35e015183a">promoteSingleIterationLoops</a> (func::FuncOp f)</td></tr>
<tr class="memdesc:aac04a5178397b80a50634b35e015183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="#aac04a5178397b80a50634b35e015183a">More...</a><br /></td></tr>
<tr class="separator:aac04a5178397b80a50634b35e015183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e4aaa747cf34698887690a5b52d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9a4e4aaa747cf34698887690a5b52d3f">affineForOpBodySkew</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts, bool unrollPrologueEpilogue=false)</td></tr>
<tr class="memdesc:a9a4e4aaa747cf34698887690a5b52d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew the operations in an affine.for's body with the specified operation-wise shifts.  <a href="#a9a4e4aaa747cf34698887690a5b52d3f">More...</a><br /></td></tr>
<tr class="separator:a9a4e4aaa747cf34698887690a5b52d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3feb8df27ef39080ba1e425ff1e112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4d3feb8df27ef39080ba1e425ff1e112">getTileableBands</a> (func::FuncOp f, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 6 &gt;&gt; *bands)</td></tr>
<tr class="memdesc:a4d3feb8df27ef39080ba1e425ff1e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify valid and profitable bands of loops to tile.  <a href="#a4d3feb8df27ef39080ba1e425ff1e112">More...</a><br /></td></tr>
<tr class="separator:a4d3feb8df27ef39080ba1e425ff1e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0191e64550dc17ce5ec5e35b74882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affb0191e64550dc17ce5ec5e35b74882">tilePerfectlyNested</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:affb0191e64550dc17ce5ec5e35b74882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops.  <a href="#affb0191e64550dc17ce5ec5e35b74882">More...</a><br /></td></tr>
<tr class="separator:affb0191e64550dc17ce5ec5e35b74882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7722fac9c5c7f3625d6a6fe1e2fbd52d">tilePerfectlyNestedParametric</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters.  <a href="#a7722fac9c5c7f3625d6a6fe1e2fbd52d">More...</a><br /></td></tr>
<tr class="separator:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ff3713bf5c6762b9f8239a980ded85a">interchangeLoops</a> (AffineForOp forOpA, AffineForOp forOpB)</td></tr>
<tr class="memdesc:a9ff3713bf5c6762b9f8239a980ded85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs loop interchange on 'forOpA' and 'forOpB'.  <a href="#a9ff3713bf5c6762b9f8239a980ded85a">More...</a><br /></td></tr>
<tr class="separator:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd689ef70c61ee029b443673c78a04e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacd689ef70c61ee029b443673c78a04e">isValidLoopInterchangePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; loopPermMap)</td></tr>
<tr class="memdesc:aacd689ef70c61ee029b443673c78a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange).  <a href="#aacd689ef70c61ee029b443673c78a04e">More...</a><br /></td></tr>
<tr class="separator:aacd689ef70c61ee029b443673c78a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48413a8aa4dcee8ffa93b222cbedfd1b">permuteLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permMap)</td></tr>
<tr class="memdesc:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ...  <a href="#a48413a8aa4dcee8ffa93b222cbedfd1b">More...</a><br /></td></tr>
<tr class="separator:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4e57efabe41ec9f1d263ed7a42c7f15">sinkSequentialLoops</a> (AffineForOp forOp)</td></tr>
<tr class="separator:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a623f987acfe618f9aa4823d6c7aec9d6">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="memdesc:a623f987acfe618f9aa4823d6c7aec9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="#a623f987acfe618f9aa4823d6c7aec9d6">More...</a><br /></td></tr>
<tr class="separator:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605009295454f6ebebbbaed546f7963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8605009295454f6ebebbbaed546f7963">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, AffineForOp target)</td></tr>
<tr class="memdesc:a8605009295454f6ebebbbaed546f7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="#a8605009295454f6ebebbbaed546f7963">More...</a><br /></td></tr>
<tr class="separator:a8605009295454f6ebebbbaed546f7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a0289ca213cc63e1b5cd46f19308c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa17a0289ca213cc63e1b5cd46f19308c">affineDataCopyGenerate</a> (<a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests)</td></tr>
<tr class="memdesc:aa17a0289ca213cc63e1b5cd46f19308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>.  <a href="#aa17a0289ca213cc63e1b5cd46f19308c">More...</a><br /></td></tr>
<tr class="separator:aa17a0289ca213cc63e1b5cd46f19308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d029c033843c69f361bcdb5ea12a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50d029c033843c69f361bcdb5ea12a90">affineDataCopyGenerate</a> (AffineForOp forOp, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests)</td></tr>
<tr class="memdesc:a50d029c033843c69f361bcdb5ea12a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp.  <a href="#a50d029c033843c69f361bcdb5ea12a90">More...</a><br /></td></tr>
<tr class="separator:a50d029c033843c69f361bcdb5ea12a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac4e3e10aeb7dc1e0f93a00c4a3723c0">generateCopyForMemRegion</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;memrefRegion, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *analyzedOp, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;result)</td></tr>
<tr class="memdesc:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region.  <a href="#aac4e3e10aeb7dc1e0f93a00c4a3723c0">More...</a><br /></td></tr>
<tr class="separator:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac009f613f7317c259820d40ce6e7aaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac009f613f7317c259820d40ce6e7aaf5">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:ac009f613f7317c259820d40ce6e7aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="#ac009f613f7317c259820d40ce6e7aaf5">More...</a><br /></td></tr>
<tr class="separator:ac009f613f7317c259820d40ce6e7aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc308b7190d3d087a4c12adb23b387b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdc308b7190d3d087a4c12adb23b387b">mapLoopToProcessorIds</a> (scf::ForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; processorId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; numProcessors)</td></tr>
<tr class="memdesc:abdc308b7190d3d087a4c12adb23b387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>.  <a href="#abdc308b7190d3d087a4c12adb23b387b">More...</a><br /></td></tr>
<tr class="separator:abdc308b7190d3d087a4c12adb23b387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c111ec17f2fc8f8c6bb94f432ddbb18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5c111ec17f2fc8f8c6bb94f432ddbb18">gatherLoops</a> (func::FuncOp func, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;depthToLoops)</td></tr>
<tr class="memdesc:a5c111ec17f2fc8f8c6bb94f432ddbb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all AffineForOps in 'func.func' grouped by loop depth.  <a href="#a5c111ec17f2fc8f8c6bb94f432ddbb18">More...</a><br /></td></tr>
<tr class="separator:a5c111ec17f2fc8f8c6bb94f432ddbb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cd7d19be1ff3cc542143dfd3f1c272a">createCanonicalizedAffineForOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap, int64_t step=1)</td></tr>
<tr class="memdesc:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped.  <a href="#a7cd7d19be1ff3cc542143dfd3f1c272a">More...</a><br /></td></tr>
<tr class="separator:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3e58dea8a192531cbf60dd5238c0ba8a">separateFullTiles</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; nest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *fullTileNest=nullptr)</td></tr>
<tr class="memdesc:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp.  <a href="#a3e58dea8a192531cbf60dd5238c0ba8a">More...</a><br /></td></tr>
<tr class="separator:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa270ad0c2440d049020def2b5e4810e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa270ad0c2440d049020def2b5e4810e7">createSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memdesc:aa270ad0c2440d049020def2b5e4810e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simplification pass for affine structures (maps and sets).  <a href="#aa270ad0c2440d049020def2b5e4810e7">More...</a><br /></td></tr>
<tr class="separator:aa270ad0c2440d049020def2b5e4810e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8408a2f43babc6e93ff9402ad83011c0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8408a2f43babc6e93ff9402ad83011c0">createAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a8408a2f43babc6e93ff9402ad83011c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops.  <a href="#a8408a2f43babc6e93ff9402ad83011c0">More...</a><br /></td></tr>
<tr class="separator:a8408a2f43babc6e93ff9402ad83011c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ab96a3dfea55443b28c25e202469d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49ab96a3dfea55443b28c25e202469d9">createAffineParallelizePass</a> ()</td></tr>
<tr class="memdesc:a49ab96a3dfea55443b28c25e202469d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops.  <a href="#a49ab96a3dfea55443b28c25e202469d9">More...</a><br /></td></tr>
<tr class="separator:a49ab96a3dfea55443b28c25e202469d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af496d2a5b5e0edbd94e89dcb165c10cc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af496d2a5b5e0edbd94e89dcb165c10cc">createAffineLoopNormalizePass</a> ()</td></tr>
<tr class="memdesc:af496d2a5b5e0edbd94e89dcb165c10cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply normalization transformations to affine loop-like ops.  <a href="#af496d2a5b5e0edbd94e89dcb165c10cc">More...</a><br /></td></tr>
<tr class="separator:af496d2a5b5e0edbd94e89dcb165c10cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5ccea551ca4ad0c967f9dd57a2304"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1b5ccea551ca4ad0c967f9dd57a2304">createAffineDataCopyGenerationPass</a> (<a class="el" href="classunsigned.html">unsigned</a> slowMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> tagMemorySpace=0, int minDmaTransferSize=1024, uint64_t fastMemCapacityBytes=std::numeric_limits&lt; uint64_t &gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>())</td></tr>
<tr class="memdesc:ac1b5ccea551ca4ad0c967f9dd57a2304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations.  <a href="#ac1b5ccea551ca4ad0c967f9dd57a2304">More...</a><br /></td></tr>
<tr class="separator:ac1b5ccea551ca4ad0c967f9dd57a2304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bf7e7ad773aae96caf0f7da3e81d1e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51bf7e7ad773aae96caf0f7da3e81d1e">createAffineDataCopyGenerationPass</a> ()</td></tr>
<tr class="memdesc:a51bf7e7ad773aae96caf0f7da3e81d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#a51bf7e7ad773aae96caf0f7da3e81d1e">More...</a><br /></td></tr>
<tr class="separator:a51bf7e7ad773aae96caf0f7da3e81d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57769d9aa30a79bb4c89dabc5cc42b19"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57769d9aa30a79bb4c89dabc5cc42b19">createAffineScalarReplacementPass</a> ()</td></tr>
<tr class="memdesc:a57769d9aa30a79bb4c89dabc5cc42b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs.  <a href="#a57769d9aa30a79bb4c89dabc5cc42b19">More...</a><br /></td></tr>
<tr class="separator:a57769d9aa30a79bb4c89dabc5cc42b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbb1c14e39ed0e8e1166fe47f25477"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adcdbb1c14e39ed0e8e1166fe47f25477">createLoopCoalescingPass</a> ()</td></tr>
<tr class="memdesc:adcdbb1c14e39ed0e8e1166fe47f25477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms perfectly nested loops with independent bounds into a single loop.  <a href="#adcdbb1c14e39ed0e8e1166fe47f25477">More...</a><br /></td></tr>
<tr class="separator:adcdbb1c14e39ed0e8e1166fe47f25477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0878a54dd2448d8b22a1130e8a97f91e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0878a54dd2448d8b22a1130e8a97f91e">createLoopFusionPass</a> (<a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace=0, uint64_t localBufSizeThreshold=0, bool maximalFusion=false, enum <a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0e">FusionMode</a> fusionMode=FusionMode::Greedy)</td></tr>
<tr class="memdesc:a0878a54dd2448d8b22a1130e8a97f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses loops according to type of fusion specified in <code>fusionMode</code>.  <a href="#a0878a54dd2448d8b22a1130e8a97f91e">More...</a><br /></td></tr>
<tr class="separator:a0878a54dd2448d8b22a1130e8a97f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a0ee58a5c3988f21bfca97f2e30e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad87a0ee58a5c3988f21bfca97f2e30e6">createLoopTilingPass</a> (uint64_t cacheSizeBytes)</td></tr>
<tr class="memdesc:ad87a0ee58a5c3988f21bfca97f2e30e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform tiling on loop nests.  <a href="#ad87a0ee58a5c3988f21bfca97f2e30e6">More...</a><br /></td></tr>
<tr class="separator:ad87a0ee58a5c3988f21bfca97f2e30e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cabf83ed09306f486a7cc38b6c7403"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a17cabf83ed09306f486a7cc38b6c7403">createLoopTilingPass</a> ()</td></tr>
<tr class="memdesc:a17cabf83ed09306f486a7cc38b6c7403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#a17cabf83ed09306f486a7cc38b6c7403">More...</a><br /></td></tr>
<tr class="separator:a17cabf83ed09306f486a7cc38b6c7403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cf2d54b2dd2f12fc29cb0f3ae34b8a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6cf2d54b2dd2f12fc29cb0f3ae34b8a">createLoopUnrollPass</a> (int unrollFactor=-1, bool unrollUpToFactor=false, bool unrollFull=false, const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;getUnrollFactor=nullptr)</td></tr>
<tr class="memdesc:ae6cf2d54b2dd2f12fc29cb0f3ae34b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unrolling pass with the provided parameters.  <a href="#ae6cf2d54b2dd2f12fc29cb0f3ae34b8a">More...</a><br /></td></tr>
<tr class="separator:ae6cf2d54b2dd2f12fc29cb0f3ae34b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8635999f36d969f8cc9ebdb0f9448a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d8635999f36d969f8cc9ebdb0f9448a">createLoopUnrollAndJamPass</a> (int unrollJamFactor=-1)</td></tr>
<tr class="memdesc:a3d8635999f36d969f8cc9ebdb0f9448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unroll jam pass to unroll jam by the specified factor.  <a href="#a3d8635999f36d969f8cc9ebdb0f9448a">More...</a><br /></td></tr>
<tr class="separator:a3d8635999f36d969f8cc9ebdb0f9448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2094c2e8b7d0cac9171ad4bee5609b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f2094c2e8b7d0cac9171ad4bee5609b">createPipelineDataTransferPass</a> ()</td></tr>
<tr class="memdesc:a3f2094c2e8b7d0cac9171ad4bee5609b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy.  <a href="#a3f2094c2e8b7d0cac9171ad4bee5609b">More...</a><br /></td></tr>
<tr class="separator:a3f2094c2e8b7d0cac9171ad4bee5609b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20309ba42298497f0d990ff1b8830c81"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a20309ba42298497f0d990ff1b8830c81">createSuperVectorizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; virtualVectorSize)</td></tr>
<tr class="memdesc:a20309ba42298497f0d990ff1b8830c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction.  <a href="#a20309ba42298497f0d990ff1b8830c81">More...</a><br /></td></tr>
<tr class="separator:a20309ba42298497f0d990ff1b8830c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c2fd7a15cf4162323670dd676f855c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a24c2fd7a15cf4162323670dd676f855c">createSuperVectorizePass</a> ()</td></tr>
<tr class="memdesc:a24c2fd7a15cf4162323670dd676f855c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#a24c2fd7a15cf4162323670dd676f855c">More...</a><br /></td></tr>
<tr class="separator:a24c2fd7a15cf4162323670dd676f855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab724a67cbde80c4bad01a84e213000c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab724a67cbde80c4bad01a84e213000c3">affineParallelize</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt; parallelReductions={})</td></tr>
<tr class="memdesc:ab724a67cbde80c4bad01a84e213000c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a parallel affine.for op with a 1-d affine.parallel op.  <a href="#ab724a67cbde80c4bad01a84e213000c3">More...</a><br /></td></tr>
<tr class="separator:ab724a67cbde80c4bad01a84e213000c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bafa91f432ad40bb6246fbcbd555fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe">hoistAffineIfOp</a> (AffineIfOp ifOp, bool *folded=nullptr)</td></tr>
<tr class="memdesc:a57bafa91f432ad40bb6246fbcbd555fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's.  <a href="#a57bafa91f432ad40bb6246fbcbd555fe">More...</a><br /></td></tr>
<tr class="separator:a57bafa91f432ad40bb6246fbcbd555fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb27777dc6968f4be7cb843de774be33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb27777dc6968f4be7cb843de774be33">affineScalarReplace</a> (func::FuncOp f, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDomInfo)</td></tr>
<tr class="memdesc:adb27777dc6968f4be7cb843de774be33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace affine store and load accesses by scalars by forwarding stores to loads and eliminate invariant affine loads; consequently, eliminate dead allocs.  <a href="#adb27777dc6968f4be7cb843de774be33">More...</a><br /></td></tr>
<tr class="separator:adb27777dc6968f4be7cb843de774be33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010e3124b85c19918a82d5d6ae922f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a010e3124b85c19918a82d5d6ae922f48">vectorizeAffineLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="namespacemlir.html#a8c18458e843e6fbd7837dec1b0be4cd5">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fastestVaryingPattern, const <a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a> &amp;reductionLoops=<a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a>())</td></tr>
<tr class="memdesc:a010e3124b85c19918a82d5d6ae922f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="#a010e3124b85c19918a82d5d6ae922f48">More...</a><br /></td></tr>
<tr class="separator:a010e3124b85c19918a82d5d6ae922f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d7280c80aed8b236533289e9d327be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4d7280c80aed8b236533289e9d327be">vectorizeAffineLoopNest</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;loops, const <a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;strategy)</td></tr>
<tr class="memdesc:ae4d7280c80aed8b236533289e9d327be"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest. ">VectorizationStrategy</a> definition).  <a href="#ae4d7280c80aed8b236533289e9d327be">More...</a><br /></td></tr>
<tr class="separator:ae4d7280c80aed8b236533289e9d327be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0a1fe4deb3e0ecb3d92460a0ffec72e">normalizeAffineParallel</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a affine.parallel op so that lower bounds are 0 and steps are 1.  <a href="#ac0a1fe4deb3e0ecb3d92460a0ffec72e">More...</a><br /></td></tr>
<tr class="separator:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e15aec55d8f7275d4f2f770e26f9041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8e15aec55d8f7275d4f2f770e26f9041">normalizeAffineFor</a> (AffineForOp op)</td></tr>
<tr class="memdesc:a8e15aec55d8f7275d4f2f770e26f9041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an affine.for op.  <a href="#a8e15aec55d8f7275d4f2f770e26f9041">More...</a><br /></td></tr>
<tr class="separator:a8e15aec55d8f7275d4f2f770e26f9041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa9eab34d9d03045c1ce109f34bb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14aa9eab34d9d03045c1ce109f34bb34">substWithMin</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> dim, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#af7cb11d1121f694b53c0981dc5e8ba9a">min</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>, bool positivePath=true)</td></tr>
<tr class="memdesc:a14aa9eab34d9d03045c1ce109f34bb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse <code>e</code> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> where all occurrences of <code>dim</code> have been replaced by either:  <a href="#a14aa9eab34d9d03045c1ce109f34bb34">More...</a><br /></td></tr>
<tr class="separator:a14aa9eab34d9d03045c1ce109f34bb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecf0a02c37964d01f1a90ca6cccffec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ecf0a02c37964d01f1a90ca6cccffec">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *domOpFilter=nullptr, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *postDomOpFilter=nullptr, bool allowNonDereferencingOps=false, bool replaceInDeallocOp=false)</td></tr>
<tr class="memdesc:a1ecf0a02c37964d01f1a90ca6cccffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>.  <a href="#a1ecf0a02c37964d01f1a90ca6cccffec">More...</a><br /></td></tr>
<tr class="separator:a1ecf0a02c37964d01f1a90ca6cccffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a7944174565a109d7a5efe97cd62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e5a7944174565a109d7a5efe97cd62e">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, bool allowNonDereferencingOps=false)</td></tr>
<tr class="memdesc:a9e5a7944174565a109d7a5efe97cd62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well.  <a href="#a9e5a7944174565a109d7a5efe97cd62e">More...</a><br /></td></tr>
<tr class="separator:a9e5a7944174565a109d7a5efe97cd62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df4a5521b82b16cc2530426e2aa724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a33df4a5521b82b16cc2530426e2aa724">normalizeMemRef</a> (memref::AllocOp *op)</td></tr>
<tr class="memdesc:a33df4a5521b82b16cc2530426e2aa724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses.  <a href="#a33df4a5521b82b16cc2530426e2aa724">More...</a><br /></td></tr>
<tr class="separator:a33df4a5521b82b16cc2530426e2aa724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad139b18a8e4fed885a7c7040ac8c9a42">normalizeMemRefType</a> (MemRefType memrefType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> builder, <a class="el" href="classunsigned.html">unsigned</a> numSymbolicOperands)</td></tr>
<tr class="memdesc:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the old memref type map layout and computes the new memref type to have a new shape and a layout map, where the old layout map has been normalized to an identity layout map.  <a href="#ad139b18a8e4fed885a7c7040ac8c9a42">More...</a><br /></td></tr>
<tr class="separator:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e839c359226fcf9fc26cb51ba6c3282">createComposedAffineApplyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; affineApplyOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *results)</td></tr>
<tr class="memdesc:a4e839c359226fcf9fc26cb51ba6c3282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and inserts into 'builder' a new AffineApplyOp, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'.  <a href="#a4e839c359226fcf9fc26cb51ba6c3282">More...</a><br /></td></tr>
<tr class="separator:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aebf452ef02d7d46f5c0f409ebb373b92">createAffineComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *opInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *sliceOps)</td></tr>
<tr class="memdesc:aebf452ef02d7d46f5c0f409ebb373b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation.  <a href="#aebf452ef02d7d46f5c0f409ebb373b92">More...</a><br /></td></tr>
<tr class="separator:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dbba661e76a7e45c145e652fbcc853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9dbba661e76a7e45c145e652fbcc853">expandAffineExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dimValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> symbolValues)</td></tr>
<tr class="memdesc:ab9dbba661e76a7e45c145e652fbcc853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values.  <a href="#ab9dbba661e76a7e45c145e652fbcc853">More...</a><br /></td></tr>
<tr class="separator:ab9dbba661e76a7e45c145e652fbcc853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c2a14651ef626d0d9fcee46698032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae58c2a14651ef626d0d9fcee46698032">expandAffineMap</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> affineMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae58c2a14651ef626d0d9fcee46698032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp).  <a href="#ae58c2a14651ef626d0d9fcee46698032">More...</a><br /></td></tr>
<tr class="separator:ae58c2a14651ef626d0d9fcee46698032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996cc8b761f1373132a5d77b16d2076a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a996cc8b761f1373132a5d77b16d2076a">populateAMXLegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a996cc8b761f1373132a5d77b16d2076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#a996cc8b761f1373132a5d77b16d2076a">More...</a><br /></td></tr>
<tr class="separator:a996cc8b761f1373132a5d77b16d2076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acc3c1de7f45b21ef1f9deddb22b03655">configureAMXLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:acc3c1de7f45b21ef1f9deddb22b03655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#acc3c1de7f45b21ef1f9deddb22b03655">More...</a><br /></td></tr>
<tr class="separator:acc3c1de7f45b21ef1f9deddb22b03655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7736bcb70dbd9f242cd5182dd443031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7736bcb70dbd9f242cd5182dd443031">matchConstantIndex</a> ()</td></tr>
<tr class="memdesc:ac7736bcb70dbd9f242cd5182dd443031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a ConstantIndexOp.  <a href="#ac7736bcb70dbd9f242cd5182dd443031">More...</a><br /></td></tr>
<tr class="separator:ac7736bcb70dbd9f242cd5182dd443031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe80a8d036b62be279ebe10c18dc953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fe80a8d036b62be279ebe10c18dc953">canonicalizeSubViewPart</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(int64_t)&gt; isDynamic)</td></tr>
<tr class="memdesc:a1fe80a8d036b62be279ebe10c18dc953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the <code>values</code> produced by a ConstantIndexOp and places the new constant in place of the corresponding sentinel value.  <a href="#a1fe80a8d036b62be279ebe10c18dc953">More...</a><br /></td></tr>
<tr class="separator:a1fe80a8d036b62be279ebe10c18dc953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memItemLeft" align="right" valign="top">llvm::SmallBitVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1bdf7e87740dbe0f603efdbc83c0a68">getPositionsOfShapeOne</a> (<a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="separator:ac1bdf7e87740dbe0f603efdbc83c0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa058eb9c12d3b97deb073543c1372195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa058eb9c12d3b97deb073543c1372195">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:aa058eb9c12d3b97deb073543c1372195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#aa058eb9c12d3b97deb073543c1372195">More...</a><br /></td></tr>
<tr class="separator:aa058eb9c12d3b97deb073543c1372195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7d8bbfc3d0c15e92f5cba28e5ef447b5">getValueOrCreateCastToIndexLike</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> targetType, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cast from an index-like value (index or integer) to another index-like value.  <a href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">More...</a><br /></td></tr>
<tr class="separator:a7d8bbfc3d0c15e92f5cba28e5ef447b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c62516a7b31fc96892014feeae832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab09c62516a7b31fc96892014feeae832">getValueOrCreateConstantIndexOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; valueOrAttrVec)</td></tr>
<tr class="memdesc:ab09c62516a7b31fc96892014feeae832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the other overload, but converts multiple OpFoldResults into Values.  <a href="#ab09c62516a7b31fc96892014feeae832">More...</a><br /></td></tr>
<tr class="separator:ab09c62516a7b31fc96892014feeae832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f862550b655bdc6a10caa74ce4ae0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f862550b655bdc6a10caa74ce4ae0af">populateArmSVELegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6f862550b655bdc6a10caa74ce4ae0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#a6f862550b655bdc6a10caa74ce4ae0af">More...</a><br /></td></tr>
<tr class="separator:a6f862550b655bdc6a10caa74ce4ae0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026c18765c0bc2d44d9ab120174d36ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a026c18765c0bc2d44d9ab120174d36ae">configureArmSVELegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a026c18765c0bc2d44d9ab120174d36ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#a026c18765c0bc2d44d9ab120174d36ae">More...</a><br /></td></tr>
<tr class="separator:a026c18765c0bc2d44d9ab120174d36ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4239fe8f68fb32a8788127f7a6850950"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4239fe8f68fb32a8788127f7a6850950">createAsyncParallelForPass</a> ()</td></tr>
<tr class="separator:a4239fe8f68fb32a8788127f7a6850950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755ae56707350858331f8a2d72036f86"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a755ae56707350858331f8a2d72036f86">createAsyncParallelForPass</a> (bool asyncDispatch, int32_t numWorkerThreads, int32_t minTaskSize)</td></tr>
<tr class="separator:a755ae56707350858331f8a2d72036f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda37b3719dc71d8caddd1d39ca215db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acda37b3719dc71d8caddd1d39ca215db">createAsyncToAsyncRuntimePass</a> ()</td></tr>
<tr class="separator:acda37b3719dc71d8caddd1d39ca215db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b480a928c4e1972270a410dd3e214"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac74b480a928c4e1972270a410dd3e214">createAsyncRuntimeRefCountingPass</a> ()</td></tr>
<tr class="separator:ac74b480a928c4e1972270a410dd3e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac29ec7fe477dccf07bddf61bec9c3ac7">createAsyncRuntimeRefCountingOptPass</a> ()</td></tr>
<tr class="separator:ac29ec7fe477dccf07bddf61bec9c3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5cda96fda85b96d4c5786f58680bd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89c5cda96fda85b96d4c5786f58680bd">createAsyncRuntimePolicyBasedRefCountingPass</a> ()</td></tr>
<tr class="separator:a89c5cda96fda85b96d4c5786f58680bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d3b3bbe9e749975af2eb5358df6f5fe">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;calculate)</td></tr>
<tr class="memdesc:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">More...</a><br /></td></tr>
<tr class="separator:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fb2ddb434a672f458f2ae6ab2a11570">constFoldUnaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;&amp;calculate)</td></tr>
<tr class="memdesc:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible.  <a href="#a8fb2ddb434a672f458f2ae6ab2a11570">More...</a><br /></td></tr>
<tr class="separator:a8fb2ddb434a672f458f2ae6ab2a11570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450f976e30737567db650586c193a92"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </td></tr>
<tr class="memitem:ac450f976e30737567db650586c193a92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac450f976e30737567db650586c193a92">constFoldCastOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classmlir_1_1Type.html">Type</a> resType, const CalculationT &amp;calculate)</td></tr>
<tr class="separator:ac450f976e30737567db650586c193a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65ee5fd8a8bcd80a922acd227a213e2e">populateDecomposeCallGraphTypesPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;decomposer, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>.  <a href="#a65ee5fd8a8bcd80a922acd227a213e2e">More...</a><br /></td></tr>
<tr class="separator:a65ee5fd8a8bcd80a922acd227a213e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155010c68de4c682e3cb8890e9460283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a155010c68de4c682e3cb8890e9460283">populateCallOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a155010c68de4c682e3cb8890e9460283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter.  <a href="#a155010c68de4c682e3cb8890e9460283">More...</a><br /></td></tr>
<tr class="separator:a155010c68de4c682e3cb8890e9460283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df32552b0e40b3e55a3a098fb0f8f52">populateBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt; shouldConvertBranchOperand=nullptr)</td></tr>
<tr class="memdesc:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework.  <a href="#a3df32552b0e40b3e55a3a098fb0f8f52">More...</a><br /></td></tr>
<tr class="separator:a3df32552b0e40b3e55a3a098fb0f8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af233cbc2b6252b0f87bbc95f2bc8c553">isLegalForBranchOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is a BranchOpInterface op whose operands are all legal according to converter.  <a href="#af233cbc2b6252b0f87bbc95f2bc8c553">More...</a><br /></td></tr>
<tr class="separator:af233cbc2b6252b0f87bbc95f2bc8c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb02814adc084d318ce037a93a326df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2eb02814adc084d318ce037a93a326df">populateReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a2eb02814adc084d318ce037a93a326df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework.  <a href="#a2eb02814adc084d318ce037a93a326df">More...</a><br /></td></tr>
<tr class="separator:a2eb02814adc084d318ce037a93a326df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b78043105c4babf3635efc8a0c5db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab6b78043105c4babf3635efc8a0c5db1">isLegalForReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter, bool returnOpAlwaysLegal=false)</td></tr>
<tr class="memdesc:ab6b78043105c4babf3635efc8a0c5db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ReturnLike ops (except <code>return</code>), return True.  <a href="#ab6b78043105c4babf3635efc8a0c5db1">More...</a><br /></td></tr>
<tr class="separator:ab6b78043105c4babf3635efc8a0c5db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625259a35e521a9f6d7b7fe115423e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a625259a35e521a9f6d7b7fe115423e87">isNotBranchOpInterfaceOrReturnLikeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a625259a35e521a9f6d7b7fe115423e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is neither BranchOpInterface nor ReturnLike.  <a href="#a625259a35e521a9f6d7b7fe115423e87">More...</a><br /></td></tr>
<tr class="separator:a625259a35e521a9f6d7b7fe115423e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, <a class="el" href="classunsigned.html">unsigned</a> arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <a href="#a7173c36d6b113dcdb0599eb672526b43">More...</a><br /></td></tr>
<tr class="separator:a7173c36d6b113dcdb0599eb672526b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa3d787cb93ed1e8219f6cf6b2572d30f">greedilyMapParallelSCFToGPU</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the parallel loops found in the given function to workgroups.  <a href="#aa3d787cb93ed1e8219f6cf6b2572d30f">More...</a><br /></td></tr>
<tr class="separator:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66200178a198c2f8aae15e94882f0788"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66200178a198c2f8aae15e94882f0788">createGpuLauchSinkIndexComputationsPass</a> ()</td></tr>
<tr class="memdesc:a66200178a198c2f8aae15e94882f0788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> that moves ops which are likely an index computation into gpu.launch body.  <a href="#a66200178a198c2f8aae15e94882f0788">More...</a><br /></td></tr>
<tr class="separator:a66200178a198c2f8aae15e94882f0788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628f55b8a69b490ef848ceb63d234b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae628f55b8a69b490ef848ceb63d234b9">createGpuKernelOutliningPass</a> (StringRef dataLayoutStr=StringRef())</td></tr>
<tr class="memdesc:ae628f55b8a69b490ef848ceb63d234b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function.  <a href="#ae628f55b8a69b490ef848ceb63d234b9">More...</a><br /></td></tr>
<tr class="separator:ae628f55b8a69b490ef848ceb63d234b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd2637570ab4c74519de8ed73747b5f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8bd2637570ab4c74519de8ed73747b5f">createGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memdesc:a8bd2637570ab4c74519de8ed73747b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a function region so that GPU ops execute asynchronously.  <a href="#a8bd2637570ab4c74519de8ed73747b5f">More...</a><br /></td></tr>
<tr class="separator:a8bd2637570ab4c74519de8ed73747b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701a7692a76e65edd69bd6f22156776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9701a7692a76e65edd69bd6f22156776">populateGpuAllReducePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9701a7692a76e65edd69bd6f22156776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite all-reduce ops within the GPU dialect.  <a href="#a9701a7692a76e65edd69bd6f22156776">More...</a><br /></td></tr>
<tr class="separator:a9701a7692a76e65edd69bd6f22156776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ae1d309360c9e54edaa39ddb48d3ea1">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all patterns to rewrite ops within the GPU dialect.  <a href="#a4ae1d309360c9e54edaa39ddb48d3ea1">More...</a><br /></td></tr>
<tr class="separator:a4ae1d309360c9e54edaa39ddb48d3ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408ccd7b20bede5af6274d2243aaf4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a408ccd7b20bede5af6274d2243aaf4ce">registerGpuSerializeToCubinPass</a> ()</td></tr>
<tr class="memdesc:a408ccd7b20bede5af6274d2243aaf4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register pass to serialize GPU kernel functions to a CUBIN binary annotation.  <a href="#a408ccd7b20bede5af6274d2243aaf4ce">More...</a><br /></td></tr>
<tr class="separator:a408ccd7b20bede5af6274d2243aaf4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a309cdd85b1689eff02c2259ef8d0bb6c">registerGpuSerializeToHsacoPass</a> ()</td></tr>
<tr class="memdesc:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register pass to serialize GPU kernel functions to a HSAco binary annotation.  <a href="#a309cdd85b1689eff02c2259ef8d0bb6c">More...</a><br /></td></tr>
<tr class="separator:a309cdd85b1689eff02c2259ef8d0bb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c464614f40cbae1452d716d1a35636"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67c464614f40cbae1452d716d1a35636">createGpuSerializeToHsacoPass</a> (StringRef triple, StringRef arch, StringRef features, int optLevel)</td></tr>
<tr class="memdesc:a67c464614f40cbae1452d716d1a35636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of the GPU kernel function to HSAco binary serialization pass.  <a href="#a67c464614f40cbae1452d716d1a35636">More...</a><br /></td></tr>
<tr class="separator:a67c464614f40cbae1452d716d1a35636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9152a09d079148a1a2f40d4946f7c17"><td class="memItemLeft" align="right" valign="top">gpu::GPUFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">outlineKernelFunc</a> (gpu::LaunchOp launchOp, StringRef kernelFnName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:ae9152a09d079148a1a2f40d4946f7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>.  <a href="#ae9152a09d079148a1a2f40d4946f7c17">More...</a><br /></td></tr>
<tr class="separator:ae9152a09d079148a1a2f40d4946f7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6e007ae66428f560626d4ba3c58dfe2">sinkOperationsIntoLaunchOp</a> (gpu::LaunchOp launchOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; isSinkingBeneficiary)</td></tr>
<tr class="memdesc:aa6e007ae66428f560626d4ba3c58dfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region.  <a href="#aa6e007ae66428f560626d4ba3c58dfe2">More...</a><br /></td></tr>
<tr class="separator:aa6e007ae66428f560626d4ba3c58dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc492b94e5d0848e7244b2682da91021"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc492b94e5d0848e7244b2682da91021">createConvertElementwiseToLinalgPass</a> ()</td></tr>
<tr class="separator:abc492b94e5d0848e7244b2682da91021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa750e27e8b520efa98466e75aece0f7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa750e27e8b520efa98466e75aece0f7b">createLinalgFoldUnitExtentDimsPass</a> ()</td></tr>
<tr class="separator:aa750e27e8b520efa98466e75aece0f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa174a4f487204b0e8221ed0ab2dfb737"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa174a4f487204b0e8221ed0ab2dfb737">createLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="separator:aa174a4f487204b0e8221ed0ab2dfb737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdb1d516a9d3198ae11daf05637b05"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0fcdb1d516a9d3198ae11daf05637b05">createFoldReshapeOpsByLinearizationPass</a> ()</td></tr>
<tr class="separator:a0fcdb1d516a9d3198ae11daf05637b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad448648b1ff12e114f53247cbad44e5c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad448648b1ff12e114f53247cbad44e5c">createLinalgNamedOpConversionPass</a> ()</td></tr>
<tr class="separator:ad448648b1ff12e114f53247cbad44e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa789c41bff7faeb5252aba958a6fa088"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa789c41bff7faeb5252aba958a6fa088">createLinalgTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes={}, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">linalg::LinalgTilingLoopType</a> loopType=<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">linalg::LinalgTilingLoopType::Loops</a>)</td></tr>
<tr class="separator:aa789c41bff7faeb5252aba958a6fa088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f65cae8ffad8440599fe8550b95d62"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41f65cae8ffad8440599fe8550b95d62">createLinalgPromotionPass</a> (bool dynamicBuffers, bool useAlloca)</td></tr>
<tr class="separator:a41f65cae8ffad8440599fe8550b95d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff9ea093740aa2c290fa9c68fe92422"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ff9ea093740aa2c290fa9c68fe92422">createLinalgPromotionPass</a> ()</td></tr>
<tr class="separator:a4ff9ea093740aa2c290fa9c68fe92422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1086a21637aa5a39c59574052b80c17"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1086a21637aa5a39c59574052b80c17">createLinalgInlineScalarOperandsPass</a> ()</td></tr>
<tr class="separator:ae1086a21637aa5a39c59574052b80c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ca3f94f0e3472846128d08e1db05f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a048ca3f94f0e3472846128d08e1db05f">createConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memdesc:a048ca3f94f0e3472846128d08e1db05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.for loops and memref.load/memref.store accesses.  <a href="#a048ca3f94f0e3472846128d08e1db05f">More...</a><br /></td></tr>
<tr class="separator:a048ca3f94f0e3472846128d08e1db05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb8ccd7e77282559488dfb6408a632"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2eb8ccd7e77282559488dfb6408a632">createConvertLinalgToParallelLoopsPass</a> ()</td></tr>
<tr class="memdesc:ac2eb8ccd7e77282559488dfb6408a632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.parallel loops and memref.load/memref.store accesses.  <a href="#ac2eb8ccd7e77282559488dfb6408a632">More...</a><br /></td></tr>
<tr class="separator:ac2eb8ccd7e77282559488dfb6408a632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49b8d9d8ebc6d954a9bb1d61ff789bc0">createConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memdesc:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses.  <a href="#a49b8d9d8ebc6d954a9bb1d61ff789bc0">More...</a><br /></td></tr>
<tr class="separator:a49b8d9d8ebc6d954a9bb1d61ff789bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f62eee11fc4d50304d949db78be4cc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2f62eee11fc4d50304d949db78be4cc">createLinalgInitTensorEliminationPass</a> ()</td></tr>
<tr class="memdesc:ae2f62eee11fc4d50304d949db78be4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that tries to eliminate init_tensor ops that are anchored on insert_slice ops.  <a href="#ae2f62eee11fc4d50304d949db78be4cc">More...</a><br /></td></tr>
<tr class="separator:ae2f62eee11fc4d50304d949db78be4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacc6c56dc4a5f06f5a3dbff9a70f2126">createLinalgBufferizePass</a> ()</td></tr>
<tr class="memdesc:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations which work on tensors to use buffers instead.  <a href="#aacc6c56dc4a5f06f5a3dbff9a70f2126">More...</a><br /></td></tr>
<tr class="separator:aacc6c56dc4a5f06f5a3dbff9a70f2126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac2762b3662cb64525cf03fbf69f83"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abbac2762b3662cb64525cf03fbf69f83">createLinalgGeneralizationPass</a> ()</td></tr>
<tr class="memdesc:abbac2762b3662cb64525cf03fbf69f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert named Linalg operations to Linalg generic operations.  <a href="#abbac2762b3662cb64525cf03fbf69f83">More...</a><br /></td></tr>
<tr class="separator:abbac2762b3662cb64525cf03fbf69f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a888e0ad22e8609a0c5042ccecdb7adc7">createLinalgDetensorizePass</a> ()</td></tr>
<tr class="memdesc:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to equivalent operations that work on primitive types, if possible.  <a href="#a888e0ad22e8609a0c5042ccecdb7adc7">More...</a><br /></td></tr>
<tr class="separator:a888e0ad22e8609a0c5042ccecdb7adc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e18468e243694650c3609c28b180bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a37e18468e243694650c3609c28b180bc">createLinalgStrategyTileAndFusePass</a> (StringRef opName=&quot;&quot;, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">linalg::LinalgTilingAndFusionOptions</a> &amp;opt={}, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a37e18468e243694650c3609c28b180bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg strategy passes.  <a href="#a37e18468e243694650c3609c28b180bc">More...</a><br /></td></tr>
<tr class="separator:a37e18468e243694650c3609c28b180bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f31d9a7e747fb08f033d2d5ffc02b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad13f31d9a7e747fb08f033d2d5ffc02b">createLinalgStrategyTilePass</a> (StringRef opName=&quot;&quot;, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">linalg::LinalgTilingOptions</a> &amp;opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">linalg::LinalgTilingOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:ad13f31d9a7e747fb08f033d2d5ffc02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyTilePass.  <a href="#ad13f31d9a7e747fb08f033d2d5ffc02b">More...</a><br /></td></tr>
<tr class="separator:ad13f31d9a7e747fb08f033d2d5ffc02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2981e60ad32d264605bf2c8380b81e3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af2981e60ad32d264605bf2c8380b81e3">createLinalgStrategyPadPass</a> (StringRef opName=&quot;&quot;, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">linalg::LinalgPaddingOptions</a> &amp;opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">linalg::LinalgPaddingOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:af2981e60ad32d264605bf2c8380b81e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyPadPass.  <a href="#af2981e60ad32d264605bf2c8380b81e3">More...</a><br /></td></tr>
<tr class="separator:af2981e60ad32d264605bf2c8380b81e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cec3ef5dec1e2cb120f09a8deda2891"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cec3ef5dec1e2cb120f09a8deda2891">createLinalgStrategyPromotePass</a> (StringRef opName=&quot;&quot;, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">linalg::LinalgPromotionOptions</a> &amp;opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">linalg::LinalgPromotionOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a4cec3ef5dec1e2cb120f09a8deda2891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyPromotePass.  <a href="#a4cec3ef5dec1e2cb120f09a8deda2891">More...</a><br /></td></tr>
<tr class="separator:a4cec3ef5dec1e2cb120f09a8deda2891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2d167c817c47333388491d1315416"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a08e2d167c817c47333388491d1315416">createLinalgStrategyGeneralizePass</a> (StringRef opName=&quot;&quot;, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a08e2d167c817c47333388491d1315416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyGeneralizePass.  <a href="#a08e2d167c817c47333388491d1315416">More...</a><br /></td></tr>
<tr class="separator:a08e2d167c817c47333388491d1315416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639dc6b42b5f5478ad1c38c02fec31c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac639dc6b42b5f5478ad1c38c02fec31c">createLinalgStrategyDecomposePass</a> (const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:ac639dc6b42b5f5478ad1c38c02fec31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyDecomposePass.  <a href="#ac639dc6b42b5f5478ad1c38c02fec31c">More...</a><br /></td></tr>
<tr class="separator:ac639dc6b42b5f5478ad1c38c02fec31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec40da96f981679ba8c2041787b038de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aec40da96f981679ba8c2041787b038de">createLinalgStrategyInterchangePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; iteratorInterchange={}, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:aec40da96f981679ba8c2041787b038de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyInterchangePass.  <a href="#aec40da96f981679ba8c2041787b038de">More...</a><br /></td></tr>
<tr class="separator:aec40da96f981679ba8c2041787b038de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd3555e3f7e8942327aced220ac0719"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd3555e3f7e8942327aced220ac0719">createLinalgStrategyVectorizePass</a> (StringRef opName=&quot;&quot;, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>(), bool padVectorize=false)</td></tr>
<tr class="memdesc:a4bd3555e3f7e8942327aced220ac0719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyVectorizePass.  <a href="#a4bd3555e3f7e8942327aced220ac0719">More...</a><br /></td></tr>
<tr class="separator:a4bd3555e3f7e8942327aced220ac0719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4787019742ca99ff270deb246fd2cd53"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4787019742ca99ff270deb246fd2cd53">createLinalgStrategyEnablePass</a> (<a class="el" href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html">linalg::LinalgEnablingOptions</a> opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html">linalg::LinalgEnablingOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a4787019742ca99ff270deb246fd2cd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyEnablePass.  <a href="#a4787019742ca99ff270deb246fd2cd53">More...</a><br /></td></tr>
<tr class="separator:a4787019742ca99ff270deb246fd2cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2c05cb94a4479a9c8b351f8b714802"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afd2c05cb94a4479a9c8b351f8b714802">createLinalgStrategyLowerVectorsPass</a> (<a class="el" href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html">linalg::LinalgVectorLoweringOptions</a> opt=<a class="el" href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html">linalg::LinalgVectorLoweringOptions</a>(), const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:afd2c05cb94a4479a9c8b351f8b714802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyLowerVectorsPass.  <a href="#afd2c05cb94a4479a9c8b351f8b714802">More...</a><br /></td></tr>
<tr class="separator:afd2c05cb94a4479a9c8b351f8b714802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6b1553c58aa431c610a488f8cc37ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3c6b1553c58aa431c610a488f8cc37ac">createLinalgStrategyRemoveMarkersPass</a> ()</td></tr>
<tr class="memdesc:a3c6b1553c58aa431c610a488f8cc37ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LinalgStrategyRemoveMarkersPass.  <a href="#a3c6b1553c58aa431c610a488f8cc37ac">More...</a><br /></td></tr>
<tr class="separator:a3c6b1553c58aa431c610a488f8cc37ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2fbc60c17752a76af9b0f28ffa36d4f9">populateExpandTanhPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a2fbc60c17752a76af9b0f28ffa36d4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b91bacc09bde115c3e891deb5ebe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a747b91bacc09bde115c3e891deb5ebe5">populateMathAlgebraicSimplificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a747b91bacc09bde115c3e891deb5ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada84ecb306c38b4e2a547962acc98dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ada84ecb306c38b4e2a547962acc98dfd">populateMathPolynomialApproximationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>={})</td></tr>
<tr class="separator:ada84ecb306c38b4e2a547962acc98dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7e879c874e4fdc6aaf9d4742abdb876">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:ac7e879c874e4fdc6aaf9d4742abdb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e134959101de052e7dbfd12610b5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">getOrCreateRanges</a> (OffsetSizeAndStrideOpInterface op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a45e134959101de052e7dbfd12610b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> (i.e.  <a href="#a45e134959101de052e7dbfd12610b5d6">More...</a><br /></td></tr>
<tr class="separator:a45e134959101de052e7dbfd12610b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">createSCFBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8c2a7464fefab1d85cec445e487f0d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that bufferizes the SCF dialect.  <a href="#a8c2a7464fefab1d85cec445e487f0d0c">More...</a><br /></td></tr>
<tr class="separator:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">createForLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes for loop for unrolling and vectorization.  <a href="#a1d49e4ae28aeaaa552466850cc5e04ec">More...</a><br /></td></tr>
<tr class="separator:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfeadb8fff74a53be77ccf540be99b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acfeadb8fff74a53be77ccf540be99b">createForLoopPeelingPass</a> ()</td></tr>
<tr class="memdesc:a7acfeadb8fff74a53be77ccf540be99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that peels for loops at their upper bounds for better vectorization.  <a href="#a7acfeadb8fff74a53be77ccf540be99b">More...</a><br /></td></tr>
<tr class="separator:a7acfeadb8fff74a53be77ccf540be99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac7f8ebf7a2133d1c68cea6e20fba0ea8">createSCFForLoopCanonicalizationPass</a> ()</td></tr>
<tr class="memdesc:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds.  <a href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">More...</a><br /></td></tr>
<tr class="separator:ac7f8ebf7a2133d1c68cea6e20fba0ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d8e77b6503a81d7aa03b636c98e2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a525d8e77b6503a81d7aa03b636c98e2e">createParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memdesc:a525d8e77b6503a81d7aa03b636c98e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables.  <a href="#a525d8e77b6503a81d7aa03b636c98e2e">More...</a><br /></td></tr>
<tr class="separator:a525d8e77b6503a81d7aa03b636c98e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00701d01638289dd08ec9e255076f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">createParallelLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:ad00701d01638289dd08ec9e255076f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses parallel loops.  <a href="#ad00701d01638289dd08ec9e255076f50">More...</a><br /></td></tr>
<tr class="separator:ad00701d01638289dd08ec9e255076f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9f8678ec66eed9c66536834540184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">createParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a16b9f8678ec66eed9c66536834540184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes parallel loop for unrolling and vectorization.  <a href="#a16b9f8678ec66eed9c66536834540184">More...</a><br /></td></tr>
<tr class="separator:a16b9f8678ec66eed9c66536834540184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213571bc56b32e75bc35cf02098982a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a213571bc56b32e75bc35cf02098982a1">createParallelLoopTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSize={}, bool noMinMaxBounds=false)</td></tr>
<tr class="memdesc:a213571bc56b32e75bc35cf02098982a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tiles innermost parallel loops.  <a href="#a213571bc56b32e75bc35cf02098982a1">More...</a><br /></td></tr>
<tr class="separator:a213571bc56b32e75bc35cf02098982a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a6597022fdb6de5a99b895b2bfc9e0a">createForLoopRangeFoldingPass</a> ()</td></tr>
<tr class="memdesc:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which folds arith ops on induction variable into loop range.  <a href="#a2a6597022fdb6de5a99b895b2bfc9e0a">More...</a><br /></td></tr>
<tr class="separator:a2a6597022fdb6de5a99b895b2bfc9e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76018eef454fd668d103ea3cc6afc52a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76018eef454fd668d103ea3cc6afc52a">createForToWhileLoopPass</a> ()</td></tr>
<tr class="separator:a76018eef454fd668d103ea3cc6afc52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8502dc067cc5f52028a818a810146a59"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8502dc067cc5f52028a818a810146a59">cloneWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, scf::ForOp loop, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newYieldedValues, bool replaceLoopResults=true)</td></tr>
<tr class="memdesc:a8502dc067cc5f52028a818a810146a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of <code>loop</code> with <code>newIterOperands</code> added as new initialization values and <code>newYieldedValues</code> added as new yielded values.  <a href="#a8502dc067cc5f52028a818a810146a59">More...</a><br /></td></tr>
<tr class="separator:a8502dc067cc5f52028a818a810146a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135bdb9acf35637041fa45613a4121b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a135bdb9acf35637041fa45613a4121b4">outlineSingleBlockRegion</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef funcName)</td></tr>
<tr class="memdesc:a135bdb9acf35637041fa45613a4121b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline a region with a single block into a new FuncOp.  <a href="#a135bdb9acf35637041fa45613a4121b4">More...</a><br /></td></tr>
<tr class="separator:a135bdb9acf35637041fa45613a4121b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aad3624e000c0585087c96357ea857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10aad3624e000c0585087c96357ea857">outlineIfOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, scf::IfOp ifOp, func::FuncOp *thenFn, StringRef thenFnName, func::FuncOp *elseFn, StringRef elseFnName)</td></tr>
<tr class="memdesc:a10aad3624e000c0585087c96357ea857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the then and/or else regions of <code>ifOp</code> as follows:  <a href="#a10aad3624e000c0585087c96357ea857">More...</a><br /></td></tr>
<tr class="separator:a10aad3624e000c0585087c96357ea857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820f3296c3cd59eaed418f42f874a217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a820f3296c3cd59eaed418f42f874a217">getInnermostParallelLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *rootOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;result)</td></tr>
<tr class="memdesc:a820f3296c3cd59eaed418f42f874a217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of innermost parallel loops contained in <code>rootOp</code>.  <a href="#a820f3296c3cd59eaed418f42f874a217">More...</a><br /></td></tr>
<tr class="separator:a820f3296c3cd59eaed418f42f874a217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caaf930536d4bd103682ff878725908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8caaf930536d4bd103682ff878725908">getSCFMinMaxExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;symbols, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; loopFilter=nullptr)</td></tr>
<tr class="memdesc:a8caaf930536d4bd103682ff878725908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop.  <a href="#a8caaf930536d4bd103682ff878725908">More...</a><br /></td></tr>
<tr class="separator:a8caaf930536d4bd103682ff878725908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f13b0be0ce31ecaf0272879eace768b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f13b0be0ce31ecaf0272879eace768b">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a1f13b0be0ce31ecaf0272879eace768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="#a1f13b0be0ce31ecaf0272879eace768b">More...</a><br /></td></tr>
<tr class="separator:a1f13b0be0ce31ecaf0272879eace768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a225e1cd29fad1b00f569d9567bc6cb2e">collapseParallelLoops</a> (scf::ParallelOp loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt; combinedDimensions)</td></tr>
<tr class="memdesc:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension.  <a href="#a225e1cd29fad1b00f569d9567bc6cb2e">More...</a><br /></td></tr>
<tr class="separator:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e4727751a2af7968a7f722b77620ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab5e4727751a2af7968a7f722b77620ff">promoteIfSingleIteration</a> (scf::ForOp forOp)</td></tr>
<tr class="memdesc:ab5e4727751a2af7968a7f722b77620ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a scf::ForOp to its containing block if the loop was known to have a single iteration.  <a href="#ab5e4727751a2af7968a7f722b77620ff">More...</a><br /></td></tr>
<tr class="separator:ab5e4727751a2af7968a7f722b77620ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c47f3f5d15eecb05a18c6343df489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a040c47f3f5d15eecb05a18c6343df489">loopUnrollByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=nullptr)</td></tr>
<tr class="memdesc:a040c47f3f5d15eecb05a18c6343df489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="#a040c47f3f5d15eecb05a18c6343df489">More...</a><br /></td></tr>
<tr class="separator:a040c47f3f5d15eecb05a18c6343df489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecdaa20d0acb7aec0f05cb700b1e09df">extractFixedOuterLoops</a> (scf::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="separator:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; targets)</td></tr>
<tr class="memdesc:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="#ab15bd4c107bb9ea52b7fcc11c283c129">More...</a><br /></td></tr>
<tr class="separator:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, scf::ForOp target)</td></tr>
<tr class="memdesc:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="#adb3ac25a4d763e0e5234f6b347c7f17a">More...</a><br /></td></tr>
<tr class="separator:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76588ffa46e04caaa584360fa5cdde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">tilePerfectlyNested</a> (scf::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a76588ffa46e04caaa584360fa5cdde4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes.  <a href="#a76588ffa46e04caaa584360fa5cdde4c">More...</a><br /></td></tr>
<tr class="separator:a76588ffa46e04caaa584360fa5cdde4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c6258ba17b3a08e25cde241861c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;nestedLoops, scf::ForOp root)</td></tr>
<tr class="memdesc:a002c6258ba17b3a08e25cde241861c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="#a002c6258ba17b3a08e25cde241861c3f">More...</a><br /></td></tr>
<tr class="separator:a002c6258ba17b3a08e25cde241861c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e7653e9cef5f155370ca0425994e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">createShapeToShapeLowering</a> ()</td></tr>
<tr class="memdesc:a050e7653e9cef5f155370ca0425994e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arithmetic.  <a href="#a050e7653e9cef5f155370ca0425994e9">More...</a><br /></td></tr>
<tr class="separator:a050e7653e9cef5f155370ca0425994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b739b7424900d4d98c15c81e4609e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a068b739b7424900d4d98c15c81e4609e">populateShapeRewritePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a068b739b7424900d4d98c15c81e4609e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Shape dialect.  <a href="#a068b739b7424900d4d98c15c81e4609e">More...</a><br /></td></tr>
<tr class="separator:a068b739b7424900d4d98c15c81e4609e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac260b877914dd5ce7bf80eb50ff87a4b">populateRemoveShapeConstraintsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:ac260b877914dd5ce7bf80eb50ff87a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad79c79f5d3c3fd8668be6d76e33bad9a">createRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:ad79c79f5d3c3fd8668be6d76e33bad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d4bb16485795a758c5c60d8413c6f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a801d4bb16485795a758c5c60d8413c6f">createShapeBufferizePass</a> ()</td></tr>
<tr class="separator:a801d4bb16485795a758c5c60d8413c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856cbb46a654a0b0402a4624edd911f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a856cbb46a654a0b0402a4624edd911f3">sparseParallelizationStrategy</a> (int32_t flag)</td></tr>
<tr class="memdesc:a856cbb46a654a0b0402a4624edd911f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts command-line parallelization flag to the strategy enum.  <a href="#a856cbb46a654a0b0402a4624edd911f3">More...</a><br /></td></tr>
<tr class="separator:a856cbb46a654a0b0402a4624edd911f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a09e3695ba40c8c2a2669d62ba540a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2">SparseVectorizationStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1a09e3695ba40c8c2a2669d62ba540a8">sparseVectorizationStrategy</a> (int32_t flag)</td></tr>
<tr class="memdesc:a1a09e3695ba40c8c2a2669d62ba540a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts command-line vectorization flag to the strategy enum.  <a href="#a1a09e3695ba40c8c2a2669d62ba540a8">More...</a><br /></td></tr>
<tr class="separator:a1a09e3695ba40c8c2a2669d62ba540a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86f7f8933f0baf6ebeddfdc698327c31">populateSparsificationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>())</td></tr>
<tr class="memdesc:a86f7f8933f0baf6ebeddfdc698327c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparsification rewriting rules with the given options.  <a href="#a86f7f8933f0baf6ebeddfdc698327c31">More...</a><br /></td></tr>
<tr class="separator:a86f7f8933f0baf6ebeddfdc698327c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0be4f778219bfb3917a2c7d3e7e1bd0">createSparsificationPass</a> ()</td></tr>
<tr class="separator:ae0be4f778219bfb3917a2c7d3e7e1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11b0dcc4a707e4e560a7a2f69a95a7c9">createSparsificationPass</a> (const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a11b0dcc4a707e4e560a7a2f69a95a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3aa1a4192d65a00261a1f969b16c3e8a">sparseToSparseConversionStrategy</a> (int32_t flag)</td></tr>
<tr class="memdesc:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts command-line sparse2sparse flag to the strategy enum.  <a href="#a3aa1a4192d65a00261a1f969b16c3e8a">More...</a><br /></td></tr>
<tr class="separator:a3aa1a4192d65a00261a1f969b16c3e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e144d2e73a085c2781475b2808bb059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e144d2e73a085c2781475b2808bb059">populateSparseTensorConversionPatterns</a> (<a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a>())</td></tr>
<tr class="memdesc:a7e144d2e73a085c2781475b2808bb059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up sparse tensor conversion rules.  <a href="#a7e144d2e73a085c2781475b2808bb059">More...</a><br /></td></tr>
<tr class="separator:a7e144d2e73a085c2781475b2808bb059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fe6af993ee7df395f88312234f0dc0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50fe6af993ee7df395f88312234f0dc0">createSparseTensorConversionPass</a> ()</td></tr>
<tr class="separator:a50fe6af993ee7df395f88312234f0dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8654e2dbbf377b3df5383b90c7f9b2c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8654e2dbbf377b3df5383b90c7f9b2c">createSparseTensorConversionPass</a> (const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:aa8654e2dbbf377b3df5383b90c7f9b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplParams" colspan="2">template&lt;typename EnumClass , typename ParserType &gt; </td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cdbef9427aac1eeac4dbf017bae583b">parseEnumKeywordAttr</a> (EnumClass &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, ParserType &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a4cdbef9427aac1eeac4dbf017bae583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>.  <a href="#a4cdbef9427aac1eeac4dbf017bae583b">More...</a><br /></td></tr>
<tr class="separator:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3a9a918bfb0fc3727c4d2490164be0c3">populateBuiltinFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect.  <a href="#a3a9a918bfb0fc3727c4d2490164be0c3">More...</a><br /></td></tr>
<tr class="separator:a3a9a918bfb0fc3727c4d2490164be0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae811b6513cd07f50d4b60bcd270d4171"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae811b6513cd07f50d4b60bcd270d4171">createTensorBufferizePass</a> ()</td></tr>
<tr class="memdesc:ae811b6513cd07f50d4b60bcd270d4171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of <code>tensor</code> dialect bufferization pass.  <a href="#ae811b6513cd07f50d4b60bcd270d4171">More...</a><br /></td></tr>
<tr class="separator:ae811b6513cd07f50d4b60bcd270d4171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">linearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the linearized index of 'offsets' w.r.t. 'basis'.  <a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">More...</a><br /></td></tr>
<tr class="separator:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28299bcd34ce71bd72f2a29478f06e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae28299bcd34ce71bd72f2a29478f06e3">delinearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t linearIndex)</td></tr>
<tr class="memdesc:ae28299bcd34ce71bd72f2a29478f06e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, returns the vector-space offsets in each dimension for a de-linearized index.  <a href="#ae28299bcd34ce71bd72f2a29478f06e3">More...</a><br /></td></tr>
<tr class="separator:ae28299bcd34ce71bd72f2a29478f06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:adbcff71555e8c1965e508f324f43a55a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adbcff71555e8c1965e508f324f43a55a">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:adbcff71555e8c1965e508f324f43a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="#adbcff71555e8c1965e508f324f43a55a">More...</a><br /></td></tr>
<tr class="separator:adbcff71555e8c1965e508f324f43a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092d13f2e1680d4a62d9d623c1fe5fba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a092d13f2e1680d4a62d9d623c1fe5fba">getI64SubArray</a> (ArrayAttr arrayAttr, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="CRunnerUtils_8h.html#aa3eaa688e40e1afbf39c1a4736aae30b">dropFront</a>=0, <a class="el" href="classunsigned.html">unsigned</a> dropBack=0)</td></tr>
<tr class="memdesc:a092d13f2e1680d4a62d9d623c1fe5fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns a subset of <code>arrayAttr</code> as a vector of int64_t.  <a href="#a092d13f2e1680d4a62d9d623c1fe5fba">More...</a><br /></td></tr>
<tr class="separator:a092d13f2e1680d4a62d9d623c1fe5fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12acf2020ef95ce0a5d7c3f2bbb6af14">getReassociationAttrName</a> ()</td></tr>
<tr class="memdesc:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the ArrayAttr which encodes reassociation indices.  <a href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">More...</a><br /></td></tr>
<tr class="separator:a12acf2020ef95ce0a5d7c3f2bbb6af14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ed88de63bce19c4d23b6c62f7f5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d4ed88de63bce19c4d23b6c62f7f5d3">composeReassociationIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; producerReassociations, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; consumerReassociations, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a3d4ed88de63bce19c4d23b6c62f7f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer.  <a href="#a3d4ed88de63bce19c4d23b6c62f7f5d3">More...</a><br /></td></tr>
<tr class="separator:a3d4ed88de63bce19c4d23b6c62f7f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2799e8f52860dadc460b88a8f2df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b2799e8f52860dadc460b88a8f2df32">convertReassociationIndicesToExprs</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociationIndices)</td></tr>
<tr class="memdesc:a9b2799e8f52860dadc460b88a8f2df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert reassociation indices to affine expressions.  <a href="#a9b2799e8f52860dadc460b88a8f2df32">More...</a><br /></td></tr>
<tr class="separator:a9b2799e8f52860dadc460b88a8f2df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561d5231fcefc471a4c9069fce2eaf87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a561d5231fcefc471a4c9069fce2eaf87">getSymbolLessAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a561d5231fcefc471a4c9069fce2eaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;.  <a href="#a561d5231fcefc471a4c9069fce2eaf87">More...</a><br /></td></tr>
<tr class="separator:a561d5231fcefc471a4c9069fce2eaf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ecbdeef85cdbc2ce3b49a088fa5946a">getReassociationIndicesAttribute</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a list of reassociations in an ArrayAttr.  <a href="#a8ecbdeef85cdbc2ce3b49a088fa5946a">More...</a><br /></td></tr>
<tr class="separator:a8ecbdeef85cdbc2ce3b49a088fa5946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ef18cead6fd6974a5031544f3c46cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ef18cead6fd6974a5031544f3c46cb">convertReassociationMapsToIndices</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt; reassociationExprs)</td></tr>
<tr class="memdesc:af3ef18cead6fd6974a5031544f3c46cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;.  <a href="#af3ef18cead6fd6974a5031544f3c46cb">More...</a><br /></td></tr>
<tr class="separator:af3ef18cead6fd6974a5031544f3c46cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87146cf16eb05a0abd56d11db525fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab87146cf16eb05a0abd56d11db525fcc">getReassociationIndicesForReshape</a> (ShapedType sourceType, ShapedType targetType)</td></tr>
<tr class="memdesc:ab87146cf16eb05a0abd56d11db525fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reassociations maps to use to reshape given the source type and the target type when possible.  <a href="#ab87146cf16eb05a0abd56d11db525fcc">More...</a><br /></td></tr>
<tr class="separator:ab87146cf16eb05a0abd56d11db525fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfec7faa9f6efd40ec23d4a1147bb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9dfec7faa9f6efd40ec23d4a1147bb49">getReassociationIndicesForCollapse</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:a9dfec7faa9f6efd40ec23d4a1147bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible.  <a href="#a9dfec7faa9f6efd40ec23d4a1147bb49">More...</a><br /></td></tr>
<tr class="separator:a9dfec7faa9f6efd40ec23d4a1147bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e3d6f94b6a941066c3e7e5535817a9b">isReassociationValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; reassociation, int *invalidIndex=nullptr)</td></tr>
<tr class="memdesc:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the reassociation specification is valid, false otherwise.  <a href="#a9e3d6f94b6a941066c3e7e5535817a9b">More...</a><br /></td></tr>
<tr class="separator:a9e3d6f94b6a941066c3e7e5535817a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplParams" colspan="2">template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </td></tr>
<tr class="memitem:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b0271e4a2b1e694242618a6e91a9c37">foldReshapeOp</a> (ReshapeOpTy reshapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="separator:a2b0271e4a2b1e694242618a6e91a9c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename T &gt; </td></tr>
<tr class="memitem:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59e37ef38e035b072204c4cc6f2bc6a5">verifyReshapeLikeTypes</a> (<a class="el" href="classmlir_1_1Op.html">Op</a> op, T expandedType, T collapsedType, bool isExpansion)</td></tr>
<tr class="memdesc:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common verifier for reshape-like types.  <a href="#a59e37ef38e035b072204c4cc6f2bc6a5">More...</a><br /></td></tr>
<tr class="separator:a59e37ef38e035b072204c4cc6f2bc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a364dd32a6190474be758d1a6b9d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a64a364dd32a6190474be758d1a6b9d5f">reshapeLikeShapesAreCompatible</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociationMaps, bool isExpandingReshape)</td></tr>
<tr class="memdesc:a64a364dd32a6190474be758d1a6b9d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that shapes of the reshaped types using following rules 1) if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape.  <a href="#a64a364dd32a6190474be758d1a6b9d5f">More...</a><br /></td></tr>
<tr class="separator:a64a364dd32a6190474be758d1a6b9d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29ab36fc05840316f3a7e56271818a6"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:ad29ab36fc05840316f3a7e56271818a6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad29ab36fc05840316f3a7e56271818a6">verifyReshapeLikeShapes</a> (OpTy op, ShapedType collapsedType, ShapedType expandedType, bool isExpandingReshape)</td></tr>
<tr class="separator:ad29ab36fc05840316f3a7e56271818a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1858ec5ab152ee2a09d4ceaf95cf2811">hasNonIdentityLayout</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the type is a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> and has a non-identity layout.  <a href="#a1858ec5ab152ee2a09d4ceaf95cf2811">More...</a><br /></td></tr>
<tr class="separator:a1858ec5ab152ee2a09d4ceaf95cf2811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ec51b29d236bdb33886fb9d6c8e002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a18ec51b29d236bdb33886fb9d6c8e002">dispatchIndexOpFoldResult</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec, int64_t sentinel)</td></tr>
<tr class="memdesc:a18ec51b29d236bdb33886fb9d6c8e002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> is dispached to the <code>dynamicVec</code>.  <a href="#a18ec51b29d236bdb33886fb9d6c8e002">More...</a><br /></td></tr>
<tr class="separator:a18ec51b29d236bdb33886fb9d6c8e002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51331ef3eb49bd63cbbe47d2c33cf117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51331ef3eb49bd63cbbe47d2c33cf117">dispatchIndexOpFoldResults</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicVec, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;staticVec, int64_t sentinel)</td></tr>
<tr class="memdesc:a51331ef3eb49bd63cbbe47d2c33cf117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a>.  <a href="#a51331ef3eb49bd63cbbe47d2c33cf117">More...</a><br /></td></tr>
<tr class="separator:a51331ef3eb49bd63cbbe47d2c33cf117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48355da3ce92decf18a91c2148e3d4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48355da3ce92decf18a91c2148e3d4c6">extractFromI64ArrayAttr</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a48355da3ce92decf18a91c2148e3d4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract int64_t values from the assumed ArrayAttr of IntegerAttr.  <a href="#a48355da3ce92decf18a91c2148e3d4c6">More...</a><br /></td></tr>
<tr class="separator:a48355da3ce92decf18a91c2148e3d4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b7af1333485b34ebfe4bf6300c362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac19b7af1333485b34ebfe4bf6300c362">getAsOpFoldResult</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac19b7af1333485b34ebfe4bf6300c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="#ac19b7af1333485b34ebfe4bf6300c362">More...</a><br /></td></tr>
<tr class="separator:ac19b7af1333485b34ebfe4bf6300c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a3d623deef4b86e5222482bf85a01a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a42a3d623deef4b86e5222482bf85a01a">getAsOpFoldResult</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values)</td></tr>
<tr class="memdesc:a42a3d623deef4b86e5222482bf85a01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> from each value.  <a href="#a42a3d623deef4b86e5222482bf85a01a">More...</a><br /></td></tr>
<tr class="separator:a42a3d623deef4b86e5222482bf85a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b180faadcfcd901fa117f7a2a6c362f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b180faadcfcd901fa117f7a2a6c362f">getConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a5b180faadcfcd901fa117f7a2a6c362f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ofr is a constant integer or an IntegerAttr, return the integer.  <a href="#a5b180faadcfcd901fa117f7a2a6c362f">More...</a><br /></td></tr>
<tr class="separator:a5b180faadcfcd901fa117f7a2a6c362f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043789541ff1881513700b717bf5491d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a043789541ff1881513700b717bf5491d">isConstantIntValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a043789541ff1881513700b717bf5491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>ofr</code> is constant integer equal to <code>value</code>.  <a href="#a043789541ff1881513700b717bf5491d">More...</a><br /></td></tr>
<tr class="separator:a043789541ff1881513700b717bf5491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee77c6f0feb82212b1b817785f95f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2ee77c6f0feb82212b1b817785f95f48">isEqualConstantIntOrValue</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr1, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr2)</td></tr>
<tr class="memdesc:a2ee77c6f0feb82212b1b817785f95f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value.  <a href="#a2ee77c6f0feb82212b1b817785f95f48">More...</a><br /></td></tr>
<tr class="separator:a2ee77c6f0feb82212b1b817785f95f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f9bcf99efe125a11237ad6b64642c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">isRowMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:ae53f9bcf99efe125a11237ad6b64642c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major matmul.  <a href="#ae53f9bcf99efe125a11237ad6b64642c">More...</a><br /></td></tr>
<tr class="separator:ae53f9bcf99efe125a11237ad6b64642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">isColumnMajorMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a column major matmul.  <a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">More...</a><br /></td></tr>
<tr class="separator:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28d7afae3a8e6d54489b5857b938d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa28d7afae3a8e6d54489b5857b938d07">isRowMajorBatchMatmul</a> (ArrayAttr indexingMaps)</td></tr>
<tr class="memdesc:aa28d7afae3a8e6d54489b5857b938d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given maps describe a row major batch matmul.  <a href="#aa28d7afae3a8e6d54489b5857b938d07">More...</a><br /></td></tr>
<tr class="separator:aa28d7afae3a8e6d54489b5857b938d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348eec2f2303d75aeea3e11b11a9b864"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a348eec2f2303d75aeea3e11b11a9b864">getIndexingMapsAttrName</a> ()</td></tr>
<tr class="memdesc:a348eec2f2303d75aeea3e11b11a9b864"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands.  <a href="#a348eec2f2303d75aeea3e11b11a9b864">More...</a><br /></td></tr>
<tr class="separator:a348eec2f2303d75aeea3e11b11a9b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb614cbb4a83d4b3ec1ef9b5c7cade43">getIteratorTypesAttrName</a> ()</td></tr>
<tr class="memdesc:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators.  <a href="#aeb614cbb4a83d4b3ec1ef9b5c7cade43">More...</a><br /></td></tr>
<tr class="separator:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8da5ff5136bb59fe4a47ef22fc765e9"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8da5ff5136bb59fe4a47ef22fc765e9">getDistributionTypesAttrName</a> ()</td></tr>
<tr class="memdesc:aa8da5ff5136bb59fe4a47ef22fc765e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the distribution type for <code>linalg.tiled_loop</code>.  <a href="#aa8da5ff5136bb59fe4a47ef22fc765e9">More...</a><br /></td></tr>
<tr class="separator:aa8da5ff5136bb59fe4a47ef22fc765e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c6eb5b9274486d9ed3f4dff655d4cbd">getDocAttrName</a> ()</td></tr>
<tr class="memdesc:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StringAttr which encodes an optional documentation string of the structured op.  <a href="#a8c6eb5b9274486d9ed3f4dff655d4cbd">More...</a><br /></td></tr>
<tr class="separator:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d25e27ccff1d123995abe189add986"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39d25e27ccff1d123995abe189add986">getLibraryCallAttrName</a> ()</td></tr>
<tr class="memdesc:a39d25e27ccff1d123995abe189add986"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op.  <a href="#a39d25e27ccff1d123995abe189add986">More...</a><br /></td></tr>
<tr class="separator:a39d25e27ccff1d123995abe189add986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3fe0298dee33ee77887d8ad11cc67c"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aed3fe0298dee33ee77887d8ad11cc67c">getStridesAttrName</a> ()</td></tr>
<tr class="memdesc:aed3fe0298dee33ee77887d8ad11cc67c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of strides.  <a href="#aed3fe0298dee33ee77887d8ad11cc67c">More...</a><br /></td></tr>
<tr class="separator:aed3fe0298dee33ee77887d8ad11cc67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4509af87b284808008015597b3f96a"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a4509af87b284808008015597b3f96a">getDilationsAttrName</a> ()</td></tr>
<tr class="memdesc:a4a4509af87b284808008015597b3f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of dilations.  <a href="#a4a4509af87b284808008015597b3f96a">More...</a><br /></td></tr>
<tr class="separator:a4a4509af87b284808008015597b3f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47d572d82ccbf6419876301669cd6a"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef47d572d82ccbf6419876301669cd6a">getPaddingAttrName</a> ()</td></tr>
<tr class="memdesc:aef47d572d82ccbf6419876301669cd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of paddings.  <a href="#aef47d572d82ccbf6419876301669cd6a">More...</a><br /></td></tr>
<tr class="separator:aef47d572d82ccbf6419876301669cd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3cf9bb42bc7ec9e1668e6e121d0b69b0">getParallelIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has parallel semantics.  <a href="#a3cf9bb42bc7ec9e1668e6e121d0b69b0">More...</a><br /></td></tr>
<tr class="separator:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d7472008e08ed39dd3e9d83c42775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a588d7472008e08ed39dd3e9d83c42775">isParallelIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a588d7472008e08ed39dd3e9d83c42775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52c9b6dd4f7515747a96c7de3ed325f9">getReductionIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has reduction semantics.  <a href="#a52c9b6dd4f7515747a96c7de3ed325f9">More...</a><br /></td></tr>
<tr class="separator:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea20c60a2e61974ab7981f341e562c4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aea20c60a2e61974ab7981f341e562c4c">isReductionIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:aea20c60a2e61974ab7981f341e562c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14df83d38352e9dfc0eb0e01fc86230"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae14df83d38352e9dfc0eb0e01fc86230">getWindowIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:ae14df83d38352e9dfc0eb0e01fc86230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#ae14df83d38352e9dfc0eb0e01fc86230">More...</a><br /></td></tr>
<tr class="separator:ae14df83d38352e9dfc0eb0e01fc86230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846930bde2aa600816a8dadd31bbddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af846930bde2aa600816a8dadd31bbddc">isWindowIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:af846930bde2aa600816a8dadd31bbddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79d3eafe91790995ee06ed0e61ebc82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac79d3eafe91790995ee06ed0e61ebc82">getAllIteratorTypeNames</a> ()</td></tr>
<tr class="memdesc:ac79d3eafe91790995ee06ed0e61ebc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#ac79d3eafe91790995ee06ed0e61ebc82">More...</a><br /></td></tr>
<tr class="separator:ac79d3eafe91790995ee06ed0e61ebc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729f6e1552c6df7db231ce20f67947b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a729f6e1552c6df7db231ce20f67947b2">getNumIterators</a> (StringRef name, ArrayAttr iteratorTypes)</td></tr>
<tr class="memdesc:a729f6e1552c6df7db231ce20f67947b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator of a certain type.  <a href="#a729f6e1552c6df7db231ce20f67947b2">More...</a><br /></td></tr>
<tr class="separator:a729f6e1552c6df7db231ce20f67947b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d068f0cba2b5a92fe603c4118664b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d068f0cba2b5a92fe603c4118664b61">getNumIterators</a> (ArrayAttr iteratorTypes)</td></tr>
<tr class="separator:a6d068f0cba2b5a92fe603c4118664b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1515f52892c837f5105efe3f5c5c060"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1515f52892c837f5105efe3f5c5c060">toString</a> (<a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> t)</td></tr>
<tr class="separator:ae1515f52892c837f5105efe3f5c5c060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c157bd2c9cf4949b45235593f6ef994"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">computeMaxLinearIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:a9c157bd2c9cf4949b45235593f6ef994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis, <code>0</code> if empty.  <a href="#a9c157bd2c9cf4949b45235593f6ef994">More...</a><br /></td></tr>
<tr class="separator:a9c157bd2c9cf4949b45235593f6ef994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1a5f445f0e1451c0dde7b93a2e1d7ab">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the shape and sizes of a vector, returns the corresponding strides for each dimension.  <a href="#af1a5f445f0e1451c0dde7b93a2e1d7ab">More...</a><br /></td></tr>
<tr class="separator:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138bbf83686d046fd85553cdd10eaf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a138bbf83686d046fd85553cdd10eaf18">computeElementOffsetsFromVectorSliceOffsets</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorOffsets)</td></tr>
<tr class="memdesc:a138bbf83686d046fd85553cdd10eaf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the target sizes of a vector, together with vector-space offsets, returns the element-space offsets for each dimension.  <a href="#a138bbf83686d046fd85553cdd10eaf18">More...</a><br /></td></tr>
<tr class="separator:a138bbf83686d046fd85553cdd10eaf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3741dc3ccffcfafa71e4540ba59f08c0">shapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; superShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; subShape)</td></tr>
<tr class="memdesc:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>.  <a href="#a3741dc3ccffcfafa71e4540ba59f08c0">More...</a><br /></td></tr>
<tr class="separator:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a937430eb9b6e13bfb05e6ecc5649a816">shapeRatio</a> (VectorType superVectorType, VectorType subVectorType)</td></tr>
<tr class="memdesc:a937430eb9b6e13bfb05e6ecc5649a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>.  <a href="#a937430eb9b6e13bfb05e6ecc5649a816">More...</a><br /></td></tr>
<tr class="separator:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec093f212c96c69468a9e7df149fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1ec093f212c96c69468a9e7df149fb5">populateX86VectorLegalizeForLLVMExportPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac1ec093f212c96c69468a9e7df149fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#ac1ec093f212c96c69468a9e7df149fb5">More...</a><br /></td></tr>
<tr class="separator:ac1ec093f212c96c69468a9e7df149fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8013cee2241cd53aa923b23e4e3575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa8013cee2241cd53aa923b23e4e3575">configureX86VectorLegalizeForExportTarget</a> (<a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:afa8013cee2241cd53aa923b23e4e3575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics.  <a href="#afa8013cee2241cd53aa923b23e4e3575">More...</a><br /></td></tr>
<tr class="separator:afa8013cee2241cd53aa923b23e4e3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfe9337070eb0f67cb7a3098ee136ee">JitRunnerMain</a> (int argc, char **argv, const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, <a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a> config={})</td></tr>
<tr class="memdesc:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for all CPU runners.  <a href="#a4bfe9337070eb0f67cb7a3098ee136ee">More...</a><br /></td></tr>
<tr class="separator:a4bfe9337070eb0f67cb7a3098ee136ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">registerAllDialects</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all the MLIR dialects to the provided registry.  <a href="#afe55df95d48191f0fa2c5ab8f4e81e34">More...</a><br /></td></tr>
<tr class="separator:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5fcd07e2ad26a58627d961ce8e544f1b">registerAllDialects</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all the MLIR dialects to the registry contained in the given context.  <a href="#a5fcd07e2ad26a58627d961ce8e544f1b">More...</a><br /></td></tr>
<tr class="separator:a5fcd07e2ad26a58627d961ce8e544f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb552a159c6c887b98b3583dfd5cbe5d">registerAllPasses</a> ()</td></tr>
<tr class="separator:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a267e7e7ec38e0a09285a20831414d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a267e7e7ec38e0a09285a20831414d3">registerFromLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a7a267e7e7ec38e0a09285a20831414d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef91a9901d4d87a042990ccb79f2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ef91a9901d4d87a042990ccb79f2be">registerFromSPIRVTranslation</a> ()</td></tr>
<tr class="separator:a51ef91a9901d4d87a042990ccb79f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520bc0aa5f34c15a39f2202fdf521382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a520bc0aa5f34c15a39f2202fdf521382">registerToCppTranslation</a> ()</td></tr>
<tr class="separator:a520bc0aa5f34c15a39f2202fdf521382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d72c96a8bffacc207ba165212e2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a003d72c96a8bffacc207ba165212e2db">registerToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a003d72c96a8bffacc207ba165212e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7f5d34c37689ae9b05537a040d9e0a0">registerToSPIRVTranslation</a> ()</td></tr>
<tr class="separator:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d16808b31b66905b067720d428adf61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d16808b31b66905b067720d428adf61">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a8d16808b31b66905b067720d428adf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426b7e62d7400b01d368a3db835df9d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a426b7e62d7400b01d368a3db835df9d3">insideMutuallyExclusiveRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b)</td></tr>
<tr class="memdesc:a426b7e62d7400b01d368a3db835df9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface.  <a href="#a426b7e62d7400b01d368a3db835df9d3">More...</a><br /></td></tr>
<tr class="separator:a426b7e62d7400b01d368a3db835df9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222c6d1f54e57a5f71291f205911da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59222c6d1f54e57a5f71291f205911da">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a59222c6d1f54e57a5f71291f205911da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="#a59222c6d1f54e57a5f71291f205911da">More...</a><br /></td></tr>
<tr class="separator:a59222c6d1f54e57a5f71291f205911da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4281da1b0006e0c9622cff14858a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abea4281da1b0006e0c9622cff14858a7">getEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:abea4281da1b0006e0c9622cff14858a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists.  <a href="#abea4281da1b0006e0c9622cff14858a7">More...</a><br /></td></tr>
<tr class="separator:abea4281da1b0006e0c9622cff14858a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220af1b0ef10468f05c1e37e24371e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9220af1b0ef10468f05c1e37e24371e4">isRegionReturnLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation)</td></tr>
<tr class="memdesc:a9220af1b0ef10468f05c1e37e24371e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is either annotated with the <code>ReturnLike</code> trait or implements the <code>RegionBranchTerminatorOpInterface</code>.  <a href="#a9220af1b0ef10468f05c1e37e24371e4">More...</a><br /></td></tr>
<tr class="separator:a9220af1b0ef10468f05c1e37e24371e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd1caaa81149a00bb1df4563cbbe43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9fd1caaa81149a00bb1df4563cbbe43e">getMutableRegionBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; regionIndex)</td></tr>
<tr class="memdesc:a9fd1caaa81149a00bb1df4563cbbe43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable operands that are passed to the region with the given <code>regionIndex</code>.  <a href="#a9fd1caaa81149a00bb1df4563cbbe43e">More...</a><br /></td></tr>
<tr class="separator:a9fd1caaa81149a00bb1df4563cbbe43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e7b43a7eea0ad307e6bb31a8a9671b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77e7b43a7eea0ad307e6bb31a8a9671b">getRegionBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; regionIndex)</td></tr>
<tr class="memdesc:a77e7b43a7eea0ad307e6bb31a8a9671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the read only operands that are passed to the region with the given <code>regionIndex</code>.  <a href="#a77e7b43a7eea0ad307e6bb31a8a9671b">More...</a><br /></td></tr>
<tr class="separator:a77e7b43a7eea0ad307e6bb31a8a9671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">isOpTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8583719d6a8f0699c36ac4c4b53057f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation is unused, and has no side effects on memory that prevent erasing.  <a href="#a8583719d6a8f0699c36ac4c4b53057f2">More...</a><br /></td></tr>
<tr class="separator:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">wouldOpBeTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing.  <a href="#a655db45ed8c23d04d5ed5ee0abe041ad">More...</a><br /></td></tr>
<tr class="separator:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c33e0935147ad8c78aaf86e0c34f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a04c33e0935147ad8c78aaf86e0c34f47">getMixedOffsets</a> (OffsetSizeAndStrideOpInterface op, ArrayAttr staticOffsets, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> offsets)</td></tr>
<tr class="memdesc:a04c33e0935147ad8c78aaf86e0c34f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all the static or dynamic offsets of the op from provided external static and dynamic offsets.  <a href="#a04c33e0935147ad8c78aaf86e0c34f47">More...</a><br /></td></tr>
<tr class="separator:a04c33e0935147ad8c78aaf86e0c34f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a7324142d5fe09a81b017a6f41f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a995a7324142d5fe09a81b017a6f41f49">getMixedSizes</a> (OffsetSizeAndStrideOpInterface op, ArrayAttr staticSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> sizes)</td></tr>
<tr class="memdesc:a995a7324142d5fe09a81b017a6f41f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all the static or dynamic sizes of the op from provided external static and dynamic sizes.  <a href="#a995a7324142d5fe09a81b017a6f41f49">More...</a><br /></td></tr>
<tr class="separator:a995a7324142d5fe09a81b017a6f41f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590c21e69ed359489b5d7804ea0f587f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a590c21e69ed359489b5d7804ea0f587f">getMixedStrides</a> (OffsetSizeAndStrideOpInterface op, ArrayAttr staticStrides, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> strides)</td></tr>
<tr class="memdesc:a590c21e69ed359489b5d7804ea0f587f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of all the static or dynamic strides of the op from provided external static and dynamic strides.  <a href="#a590c21e69ed359489b5d7804ea0f587f">More...</a><br /></td></tr>
<tr class="separator:a590c21e69ed359489b5d7804ea0f587f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf47b41fcadeb8f453dae11fa9f93c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cf47b41fcadeb8f453dae11fa9f93c6">printOperandsOrIntegersOffsetsOrStridesList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, ArrayAttr integers)</td></tr>
<tr class="memdesc:a2cf47b41fcadeb8f453dae11fa9f93c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printer hook for custom directive in assemblyFormat.  <a href="#a2cf47b41fcadeb8f453dae11fa9f93c6">More...</a><br /></td></tr>
<tr class="separator:a2cf47b41fcadeb8f453dae11fa9f93c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bc42c73fba28565d395032d99a7fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8bc42c73fba28565d395032d99a7fc7">printOperandsOrIntegersSizesList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, ArrayAttr integers)</td></tr>
<tr class="memdesc:ac8bc42c73fba28565d395032d99a7fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printer hook for custom directive in assemblyFormat.  <a href="#ac8bc42c73fba28565d395032d99a7fc7">More...</a><br /></td></tr>
<tr class="separator:ac8bc42c73fba28565d395032d99a7fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94cc8a71386c0f81c3e657a6f78ef26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af94cc8a71386c0f81c3e657a6f78ef26">parseOperandsOrIntegersOffsetsOrStridesList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, ArrayAttr &amp;integers)</td></tr>
<tr class="memdesc:af94cc8a71386c0f81c3e657a6f78ef26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pasrer hook for custom directive in assemblyFormat.  <a href="#af94cc8a71386c0f81c3e657a6f78ef26">More...</a><br /></td></tr>
<tr class="separator:af94cc8a71386c0f81c3e657a6f78ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5431766655470cf319cac81fb638e5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5431766655470cf319cac81fb638e5e7">parseOperandsOrIntegersSizesList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, ArrayAttr &amp;integers)</td></tr>
<tr class="memdesc:a5431766655470cf319cac81fb638e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pasrer hook for custom directive in assemblyFormat.  <a href="#a5431766655470cf319cac81fb638e5e7">More...</a><br /></td></tr>
<tr class="separator:a5431766655470cf319cac81fb638e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b025daa91f0ef533bd16102dabbe10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a42b025daa91f0ef533bd16102dabbe10">verifyListOfOperandsOrIntegers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef name, <a class="el" href="classunsigned.html">unsigned</a> expectedNumElements, ArrayAttr attr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(int64_t)&gt; isDynamic)</td></tr>
<tr class="memdesc:a42b025daa91f0ef533bd16102dabbe10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true.  <a href="#a42b025daa91f0ef533bd16102dabbe10">More...</a><br /></td></tr>
<tr class="separator:a42b025daa91f0ef533bd16102dabbe10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable.  <a href="#ad9141d8b586a68549d2ecaccbce99a69">More...</a><br /></td></tr>
<tr class="separator:ad9141d8b586a68549d2ecaccbce99a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9137193b56dc5134c3092273b13e3f47">operator*</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a9137193b56dc5134c3092273b13e3f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <a href="#addfd4323ef72147332661606b030d04d">More...</a><br /></td></tr>
<tr class="separator:addfd4323ef72147332661606b030d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:aefb7ba5a55b4f16631528884d3617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (int64_t constant, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ab26cdced424aa629fde4150cc8674d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="separator:a6e8a0f44c623301035b6151ca51cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad71c14bebce843758768ff160e2283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">getAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; flatExprs, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8ad71c14bebce843758768ff160e2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat ArrayRef.  <a href="#a8ad71c14bebce843758768ff160e2283">More...</a><br /></td></tr>
<tr class="separator:a8ad71c14bebce843758768ff160e2283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69078b1d3f3263a1769df2e0f1730df"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae69078b1d3f3263a1769df2e0f1730df">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:ae69078b1d3f3263a1769df2e0f1730df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <a href="#acbf369c69cfb613cd018ef4ce188809c">More...</a><br /></td></tr>
<tr class="separator:acbf369c69cfb613cd018ef4ce188809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a3d147ba82716614172eb7e9b5209d3eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3d147ba82716614172eb7e9b5209d3eb">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a3d147ba82716614172eb7e9b5209d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 .  <a href="#a3d147ba82716614172eb7e9b5209d3eb">More...</a><br /></td></tr>
<tr class="separator:a3d147ba82716614172eb7e9b5209d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8df39b3ef750e258dbe3dfe5b251cea5">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;...exprs)</td></tr>
<tr class="memdesc:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to SymbolExpr at positions: [0 .  <a href="#a8df39b3ef750e258dbe3dfe5b251cea5">More...</a><br /></td></tr>
<tr class="separator:a8df39b3ef750e258dbe3dfe5b251cea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results.  <a href="#a014d8e82c51794d145267690b2b5bd58">More...</a><br /></td></tr>
<tr class="separator:a014d8e82c51794d145267690b2b5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99f84d2ce14eec6c85a20251582e5cc1">compressUnusedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a99f84d2ce14eec6c85a20251582e5cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used.  <a href="#a99f84d2ce14eec6c85a20251582e5cc1">More...</a><br /></td></tr>
<tr class="separator:a99f84d2ce14eec6c85a20251582e5cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae2a3cbce4381f83b710fe6cfc9a867c9">compressUnusedDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not used by any of the individual maps in <code>maps</code>.  <a href="#ae2a3cbce4381f83b710fe6cfc9a867c9">More...</a><br /></td></tr>
<tr class="separator:ae2a3cbce4381f83b710fe6cfc9a867c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05caafff59182b2191e4645cdceb5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab05caafff59182b2191e4645cdceb5d5">compressDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedDims)</td></tr>
<tr class="memdesc:ab05caafff59182b2191e4645cdceb5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the dims that are not listed in <code>unusedDims</code>.  <a href="#ab05caafff59182b2191e4645cdceb5d5">More...</a><br /></td></tr>
<tr class="separator:ab05caafff59182b2191e4645cdceb5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4c401a074fdcc1cb0efb7e5369b2ef3">compressUnusedSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used.  <a href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">More...</a><br /></td></tr>
<tr class="separator:ae4c401a074fdcc1cb0efb7e5369b2ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26d1a643586acb4362f535168be129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a26d1a643586acb4362f535168be129">compressUnusedSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a4a26d1a643586acb4362f535168be129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not used by any of the individual maps in <code>maps</code>.  <a href="#a4a26d1a643586acb4362f535168be129">More...</a><br /></td></tr>
<tr class="separator:a4a26d1a643586acb4362f535168be129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5b9ec7c351db7ed870d0df7248342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6de5b9ec7c351db7ed870d0df7248342">compressSymbols</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;unusedSymbols)</td></tr>
<tr class="memdesc:a6de5b9ec7c351db7ed870d0df7248342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the symbols that are not listed in <code>unusedSymbols</code>.  <a href="#a6de5b9ec7c351db7ed870d0df7248342">More...</a><br /></td></tr>
<tr class="separator:a6de5b9ec7c351db7ed870d0df7248342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">removeDuplicateExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>.  <a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">More...</a><br /></td></tr>
<tr class="separator:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <a href="#a52b322818d83a2256d4e4391acbf78a2">More...</a><br /></td></tr>
<tr class="separator:a52b322818d83a2256d4e4391acbf78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39612be2ef116102866d3bb9c6a8ca88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39612be2ef116102866d3bb9c6a8ca88">inverseAndBroadcastProjectedPermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a39612be2ef116102866d3bb9c6a8ca88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s.  <a href="#a39612be2ef116102866d3bb9c6a8ca88">More...</a><br /></td></tr>
<tr class="separator:a39612be2ef116102866d3bb9c6a8ca88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a6d24d64d6db077b8d5c88316b0d6c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps.  <a href="#a6d24d64d6db077b8d5c88316b0d6c717">More...</a><br /></td></tr>
<tr class="separator:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c6fbc90fbdd4ec89b8ec1d3499bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa99c6fbc90fbdd4ec89b8ec1d3499bc2">getProjectedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const llvm::SmallBitVector &amp;projectedDimensions)</td></tr>
<tr class="memdesc:aa99c6fbc90fbdd4ec89b8ec1d3499bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>.  <a href="#aa99c6fbc90fbdd4ec89b8ec1d3499bc2">More...</a><br /></td></tr>
<tr class="separator:aa99c6fbc90fbdd4ec89b8ec1d3499bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b76f177cd65bd4fd394f9dc65d20be2">applyPermutationMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt; source)</td></tr>
<tr class="memdesc:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a permutation from <code>map</code> to <code>source</code> and return the result.  <a href="#a2b76f177cd65bd4fd394f9dc65d20be2">More...</a><br /></td></tr>
<tr class="separator:a2b76f177cd65bd4fd394f9dc65d20be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplParams" colspan="2">template&lt;typename AffineExprContainer &gt; </td></tr>
<tr class="memitem:a74485bec820f2186ce852a09f45ebd47"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74485bec820f2186ce852a09f45ebd47">getMaxDimAndSymbol</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt; exprsList, int64_t &amp;maxDim, int64_t &amp;maxSym)</td></tr>
<tr class="memdesc:a74485bec820f2186ce852a09f45ebd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates maxmimum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively.  <a href="#a74485bec820f2186ce852a09f45ebd47">More...</a><br /></td></tr>
<tr class="separator:a74485bec820f2186ce852a09f45ebd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f93a44db5e2d93372201d5a594e51cd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f93a44db5e2d93372201d5a594e51cd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a6f93a44db5e2d93372201d5a594e51cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a08aa6ed051f55e57bc35859a379f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">registerAsmPrinterCLOptions</a> ()</td></tr>
<tr class="memdesc:a894a08aa6ed051f55e57bc35859a379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers...">AsmPrinter</a>.  <a href="#a894a08aa6ed051f55e57bc35859a379f">More...</a><br /></td></tr>
<tr class="separator:a894a08aa6ed051f55e57bc35859a379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e8f0e932c305de3ac1584560d1b03d0">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="separator:a68bae84b1d7cdba11b048d9af3478a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b795f2f972c070efff53082563f976"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4b795f2f972c070efff53082563f976">hash_value</a> (const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;arg)</td></tr>
<tr class="separator:aa4b795f2f972c070efff53082563f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a543c4328a4fa5ed530aa88a9d7d158a9">operator==</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable.  <a href="#a543c4328a4fa5ed530aa88a9d7d158a9">More...</a><br /></td></tr>
<tr class="separator:a543c4328a4fa5ed530aa88a9d7d158a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db56ba5c170b04848e194937be59a56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8db56ba5c170b04848e194937be59a56">operator!=</a> (StringAttr lhs, std::nullptr_t)</td></tr>
<tr class="separator:a8db56ba5c170b04848e194937be59a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce38cb70a016263f28574d4982475b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40ce38cb70a016263f28574d4982475b">operator==</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a40ce38cb70a016263f28574d4982475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bb385e3105982b905c5ef4db9f9f21b">operator!=</a> (StringAttr lhs, StringAttr rhs)</td></tr>
<tr class="separator:a6bb385e3105982b905c5ef4db9f9f21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d7bf5dfe5d33c409763bc28330180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a075d7bf5dfe5d33c409763bc28330180">operator==</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="memdesc:a075d7bf5dfe5d33c409763bc28330180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow direct comparison with StringRef.  <a href="#a075d7bf5dfe5d33c409763bc28330180">More...</a><br /></td></tr>
<tr class="separator:a075d7bf5dfe5d33c409763bc28330180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48146d74baebce1c83140c378053f3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48146d74baebce1c83140c378053f3c2">operator!=</a> (StringAttr lhs, StringRef rhs)</td></tr>
<tr class="separator:a48146d74baebce1c83140c378053f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50c46bfb0a0fbbe700ef6c07a611dbf8">operator==</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a50c46bfb0a0fbbe700ef6c07a611dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bfbb1c5941d2cc005eb3f483e881202">operator!=</a> (StringRef lhs, StringAttr rhs)</td></tr>
<tr class="separator:a4bfbb1c5941d2cc005eb3f483e881202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390e026e19a6defcfee5c97da8f21e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; llvm::SmallDenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a390e026e19a6defcfee5c97da8f21e8f">computeRankReductionMask</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; originalShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; reducedShape)</td></tr>
<tr class="memdesc:a390e026e19a6defcfee5c97da8f21e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>.  <a href="#a390e026e19a6defcfee5c97da8f21e8f">More...</a><br /></td></tr>
<tr class="separator:a390e026e19a6defcfee5c97da8f21e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209f096d9240a818927afbab10f43b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae209f096d9240a818927afbab10f43b8">isRankReducedType</a> (ShapedType originalType, ShapedType candidateReducedType)</td></tr>
<tr class="memdesc:ae209f096d9240a818927afbab10f43b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>.  <a href="#ae209f096d9240a818927afbab10f43b8">More...</a><br /></td></tr>
<tr class="separator:ae209f096d9240a818927afbab10f43b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c478f802ab2f874c0b34a18bc091b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">getStridesAndOffset</a> (MemRefType t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="memdesc:a506c478f802ab2f874c0b34a18bc091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strides of the MemRef if the layout map is in strided form.  <a href="#a506c478f802ab2f874c0b34a18bc091b">More...</a><br /></td></tr>
<tr class="separator:a506c478f802ab2f874c0b34a18bc091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9d8af8a280cbdd7ffbf4629ee82ccc4">getStridesAndOffset</a> (MemRefType t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;strides, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;offset)</td></tr>
<tr class="separator:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which MemRefType::getDynamicStrideOrOffset() represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map.  <a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">More...</a><br /></td></tr>
<tr class="separator:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcfbd64b4c5038926d874e46edeea2"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">canonicalizeStridedLayout</a> (MemRefType t)</td></tr>
<tr class="memdesc:a80dcfbd64b4c5038926d874e46edeea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout.  <a href="#a80dcfbd64b4c5038926d874e46edeea2">More...</a><br /></td></tr>
<tr class="separator:a80dcfbd64b4c5038926d874e46edeea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2978611fa2c3143d6ea5ea01cd041"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a47f2978611fa2c3143d6ea5ea01cd041">eraseStridedLayout</a> (MemRefType t)</td></tr>
<tr class="memdesc:a47f2978611fa2c3143d6ea5ea01cd041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with a layout that has all dynamic offset and strides.  <a href="#a47f2978611fa2c3143d6ea5ea01cd041">More...</a><br /></td></tr>
<tr class="separator:a47f2978611fa2c3143d6ea5ea01cd041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; exprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>.  <a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">More...</a><br /></td></tr>
<tr class="separator:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}.  <a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">More...</a><br /></td></tr>
<tr class="separator:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c26bcf64137533f38f2cda9abd75af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">isStrided</a> (MemRefType t)</td></tr>
<tr class="memdesc:ad0c26bcf64137533f38f2cda9abd75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the layout for <code>t</code> is compatible with strided semantics.  <a href="#ad0c26bcf64137533f38f2cda9abd75af">More...</a><br /></td></tr>
<tr class="separator:ad0c26bcf64137533f38f2cda9abd75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559ba63af5021a813f897a05897f0451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a559ba63af5021a813f897a05897f0451">getStridedLinearLayoutMap</a> (MemRefType t)</td></tr>
<tr class="memdesc:a559ba63af5021a813f897a05897f0451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layout map in strided linear layout <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> form.  <a href="#a559ba63af5021a813f897a05897f0451">More...</a><br /></td></tr>
<tr class="separator:a559ba63af5021a813f897a05897f0451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862732caa2de01d6eee7720857215d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2862732caa2de01d6eee7720857215d9">isStaticShapeAndContiguousRowMajor</a> (MemRefType memrefType)</td></tr>
<tr class="memdesc:a2862732caa2de01d6eee7720857215d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper determining if a memref is static-shape and contiguous-row-major layout, while still allowing for an arbitrary offset (any static or dynamic value).  <a href="#a2862732caa2de01d6eee7720857215d9">More...</a><br /></td></tr>
<tr class="separator:a2862732caa2de01d6eee7720857215d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e36349258a6b2baeae78188a74550"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae72e36349258a6b2baeae78188a74550">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="separator:ae72e36349258a6b2baeae78188a74550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85b9a8e647d5e73b7e107b0669ec9e29">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ConvertFromLLVMIR_8cpp.html#a6d80ed55125bb93b1e2eb58f0827ce39">diag</a>)</td></tr>
<tr class="separator:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <a href="#a4e96b0c437652eb5a4890734bb6bcee7">More...</a><br /></td></tr>
<tr class="separator:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <a href="#a0768c8a572dc71b0b00d57414b56b60d">More...</a><br /></td></tr>
<tr class="separator:a0768c8a572dc71b0b00d57414b56b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <a href="#a8a9ca6fe9d5aab498bf090db3e878c87">More...</a><br /></td></tr>
<tr class="separator:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affdaf0aee1c1669e8b822bf98297b85f">emitOptionalError</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:affdaf0aee1c1669e8b822bf98297b85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <a href="#affdaf0aee1c1669e8b822bf98297b85f">More...</a><br /></td></tr>
<tr class="separator:affdaf0aee1c1669e8b822bf98297b85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a665c32efa8059ae855341f4946f7497c">emitOptionalWarning</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a665c32efa8059ae855341f4946f7497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab27e629384a23b9991e36201d87de462">emitOptionalRemark</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab27e629384a23b9991e36201d87de462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="separator:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097ddf5971ea2a3956fc814005f459f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab097ddf5971ea2a3956fc814005f459f">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:ab097ddf5971ea2a3956fc814005f459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="separator:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">m_Constant</a> ()</td></tr>
<tr class="memdesc:ad402a86ee4c9000c6fa1fceaddab560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <a href="#ad402a86ee4c9000c6fa1fceaddab560b">More...</a><br /></td></tr>
<tr class="separator:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <a href="#a10b6da5781fbe1b019fcb64dcd6921dd">More...</a><br /></td></tr>
<tr class="separator:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea33aa665368d4f2108eb2d41c85111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ea33aa665368d4f2108eb2d41c85111">m_AnyZeroFloat</a> ()</td></tr>
<tr class="memdesc:a8ea33aa665368d4f2108eb2d41c85111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero.  <a href="#a8ea33aa665368d4f2108eb2d41c85111">More...</a><br /></td></tr>
<tr class="separator:a8ea33aa665368d4f2108eb2d41c85111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774a1ae971f4ef00eb57389293dfe617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a774a1ae971f4ef00eb57389293dfe617">m_PosZeroFloat</a> ()</td></tr>
<tr class="memdesc:a774a1ae971f4ef00eb57389293dfe617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive zero.  <a href="#a774a1ae971f4ef00eb57389293dfe617">More...</a><br /></td></tr>
<tr class="separator:a774a1ae971f4ef00eb57389293dfe617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eba8d1292854c0da6c062988ecac9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9eba8d1292854c0da6c062988ecac9b">m_NegZeroFloat</a> ()</td></tr>
<tr class="memdesc:aa9eba8d1292854c0da6c062988ecac9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative zero.  <a href="#aa9eba8d1292854c0da6c062988ecac9b">More...</a><br /></td></tr>
<tr class="separator:aa9eba8d1292854c0da6c062988ecac9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0495d84f34cf3238a7741fa6974a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af0495d84f34cf3238a7741fa6974a485">m_OneFloat</a> ()</td></tr>
<tr class="memdesc:af0495d84f34cf3238a7741fa6974a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float ones.  <a href="#af0495d84f34cf3238a7741fa6974a485">More...</a><br /></td></tr>
<tr class="separator:af0495d84f34cf3238a7741fa6974a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93dfeaa35bda23b16591c462c335f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc93dfeaa35bda23b16591c462c335f6">m_PosInfFloat</a> ()</td></tr>
<tr class="memdesc:adc93dfeaa35bda23b16591c462c335f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float positive infinity.  <a href="#adc93dfeaa35bda23b16591c462c335f6">More...</a><br /></td></tr>
<tr class="separator:adc93dfeaa35bda23b16591c462c335f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89b015211525b010832d2d2c37650b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e89b015211525b010832d2d2c37650b">m_NegInfFloat</a> ()</td></tr>
<tr class="memdesc:a9e89b015211525b010832d2d2c37650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat float negative infinity.  <a href="#a9e89b015211525b010832d2d2c37650b">More...</a><br /></td></tr>
<tr class="separator:a9e89b015211525b010832d2d2c37650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7f5d8af15bd8994b1a7abeaaacfe1b06">m_Zero</a> ()</td></tr>
<tr class="memdesc:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <a href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">More...</a><br /></td></tr>
<tr class="separator:a7f5d8af15bd8994b1a7abeaaacfe1b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb42600b9be680591776fdc14a53cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94bb42600b9be680591776fdc14a53cd">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a94bb42600b9be680591776fdc14a53cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <a href="#a94bb42600b9be680591776fdc14a53cd">More...</a><br /></td></tr>
<tr class="separator:a94bb42600b9be680591776fdc14a53cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f415a4c803b15ef57db37cc732f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a907f415a4c803b15ef57db37cc732f39">m_One</a> ()</td></tr>
<tr class="memdesc:a907f415a4c803b15ef57db37cc732f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <a href="#a907f415a4c803b15ef57db37cc732f39">More...</a><br /></td></tr>
<tr class="separator:a907f415a4c803b15ef57db37cc732f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplParams" colspan="2">template&lt;typename OpClass &gt; </td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">m_Op</a> ()</td></tr>
<tr class="memdesc:ac2418532386147bec2ca5aadf5414406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <a href="#ac2418532386147bec2ca5aadf5414406">More...</a><br /></td></tr>
<tr class="separator:ac2418532386147bec2ca5aadf5414406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a0190228b09e7b51a4bc1e013c01d404c">More...</a><br /></td></tr>
<tr class="separator:a0190228b09e7b51a4bc1e013c01d404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">More...</a><br /></td></tr>
<tr class="separator:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">detail::constant_float_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41f267f37c147c72f6ca26a41ff9f7bb">m_ConstantFloat</a> (FloatAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value.  <a href="#a41f267f37c147c72f6ca26a41ff9f7bb">More...</a><br /></td></tr>
<tr class="separator:a41f267f37c147c72f6ca26a41ff9f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930dbe1d176d999aec049a4581838974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a930dbe1d176d999aec049a4581838974">m_ConstantInt</a> (IntegerAttr::ValueType *bind_value)</td></tr>
<tr class="memdesc:a930dbe1d176d999aec049a4581838974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <a href="#a930dbe1d176d999aec049a4581838974">More...</a><br /></td></tr>
<tr class="separator:a930dbe1d176d999aec049a4581838974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="separator:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254079fbbd31a78a3430bff18df2d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">registerMLIRContextCLOptions</a> ()</td></tr>
<tr class="memdesc:a5254079fbbd31a78a3430bff18df2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.  <a href="#a5254079fbbd31a78a3430bff18df2d7c">More...</a><br /></td></tr>
<tr class="separator:a5254079fbbd31a78a3430bff18df2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="#a8c357b30f2e56803678fe5f7b75e80a1">More...</a><br /></td></tr>
<tr class="separator:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07e7b01e09b3da975cc984b4e1c506d"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> op)</td></tr>
<tr class="memdesc:af07e7b01e09b3da975cc984b4e1c506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="#af07e7b01e09b3da975cc984b4e1c506d">More...</a><br /></td></tr>
<tr class="separator:af07e7b01e09b3da975cc984b4e1c506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0dd71f700f3e4336e89a94f69ff28de">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:ab0dd71f700f3e4336e89a94f69ff28de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dade5c2740697bc36ceb8d6554ee00"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45dade5c2740697bc36ceb8d6554ee00">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> info)</td></tr>
<tr class="separator:a45dade5c2740697bc36ceb8d6554ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="separator:ad93109842c1b05424c5052d9bd9a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912da94236cff04e9076f6e052676b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE</a> ()</td></tr>
<tr class="memdesc:af912da94236cff04e9076f6e052676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>.  <a href="#af912da94236cff04e9076f6e052676b1">More...</a><br /></td></tr>
<tr class="separator:af912da94236cff04e9076f6e052676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a97986a4859106d3c96b089e726e26c7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97986a4859106d3c96b089e726e26c7c">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a97986a4859106d3c96b089e726e26c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ab69273e2629a0b7e18af99582f687692"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab69273e2629a0b7e18af99582f687692">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:ab69273e2629a0b7e18af99582f687692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a424d21ac06bbb37dee5c29f22e9d261a">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const APFloat &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a424d21ac06bbb37dee5c29f22e9d261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac31efc2a6e3489b511bf1640b6e3b9eb">operator&lt;&lt;</a> (AsmPrinterT &amp;p, float <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:ac31efc2a6e3489b511bf1640b6e3b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad013c3d87cad19d6a7fa6ce16eb6bd58">operator&lt;&lt;</a> (AsmPrinterT &amp;p, double <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:ad013c3d87cad19d6a7fa6ce16eb6bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename T , typename std::enable_if&lt;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a462d4f34f404bcc705506899944185f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a462d4f34f404bcc705506899944185f6">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const T &amp;other)</td></tr>
<tr class="separator:a462d4f34f404bcc705506899944185f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a627aa7e5b958743b9a67a4ccbe1418c9">operator&lt;&lt;</a> (AsmPrinterT &amp;p, bool <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a627aa7e5b958743b9a67a4ccbe1418c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </td></tr>
<tr class="memitem:a26ecef972faf3b5c78d8415d69a86728"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a26ecef972faf3b5c78d8415d69a86728">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;types)</td></tr>
<tr class="separator:a26ecef972faf3b5c78d8415d69a86728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT &gt; </td></tr>
<tr class="memitem:a4d69cef9b50344549afeaaa734f8172d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4d69cef9b50344549afeaaa734f8172d">operator&lt;&lt;</a> (AsmPrinterT &amp;p, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="separator:a4d69cef9b50344549afeaaa734f8172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplParams" colspan="2">template&lt;typename AsmPrinterT , typename ElementT &gt; </td></tr>
<tr class="memitem:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d315bdf3396a4c2cac6ead94cfc0e26">operator&lt;&lt;</a> (AsmPrinterT &amp;p, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt; types)</td></tr>
<tr class="separator:a6d315bdf3396a4c2cac6ead94cfc0e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acabdc4e9d44aae13942c9ea9b41b9a33">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58c02ebe7d299d1683ae658ea4e9352c">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="separator:a58c02ebe7d299d1683ae658ea4e9352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad554d3204bdbdc4a87d291ed94c1e575">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Block.html">Block</a> *<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee66a47ca548fabe02261ad8b96eea5"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acee66a47ca548fabe02261ad8b96eea5">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:acee66a47ca548fabe02261ad8b96eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778366ed204055f8c0ae4e113220a5bd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a778366ed204055f8c0ae4e113220a5bd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1PDLValue.html#aa5a98d42f4638805a23d5390ddb28ac0">PDLValue::Kind</a> kind)</td></tr>
<tr class="separator:a778366ed204055f8c0ae4e113220a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78425f2c879f5b708f5c58af03931e9f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78425f2c879f5b708f5c58af03931e9f">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a> visibility)</td></tr>
<tr class="separator:a78425f2c879f5b708f5c58af03931e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3083728e72d361c987c5e5a0e8d2f39a">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a3083728e72d361c987c5e5a0e8d2f39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="#a3083728e72d361c987c5e5a0e8d2f39a">More...</a><br /></td></tr>
<tr class="separator:a3083728e72d361c987c5e5a0e8d2f39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98aa0f01173a481075d9d5a2ca50d8ab">failableParallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="#a98aa0f01173a481075d9d5a2ca50d8ab">More...</a><br /></td></tr>
<tr class="separator:a98aa0f01173a481075d9d5a2ca50d8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aa5179ec6f13db4eaa8fa255bde665">failableParallelForEachN</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af5aa5179ec6f13db4eaa8fa255bde665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="#af5aa5179ec6f13db4eaa8fa255bde665">More...</a><br /></td></tr>
<tr class="separator:af5aa5179ec6f13db4eaa8fa255bde665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename FuncT &gt; </td></tr>
<tr class="memitem:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7acf0c58d63da562112dd8f6a81b49e3">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, IteratorT begin, IteratorT end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a7acf0c58d63da562112dd8f6a81b49e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="#a7acf0c58d63da562112dd8f6a81b49e3">More...</a><br /></td></tr>
<tr class="separator:a7acf0c58d63da562112dd8f6a81b49e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename FuncT &gt; </td></tr>
<tr class="memitem:af1232c5821e793866aa3cf2234e1ba93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1232c5821e793866aa3cf2234e1ba93">parallelForEach</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, RangeT &amp;&amp;range, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:af1232c5821e793866aa3cf2234e1ba93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements in the provided range asynchronously.  <a href="#af1232c5821e793866aa3cf2234e1ba93">More...</a><br /></td></tr>
<tr class="separator:af1232c5821e793866aa3cf2234e1ba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4dba1fa6bb63b3b3fbdb5127f9d21b"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:a2c4dba1fa6bb63b3b3fbdb5127f9d21b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c4dba1fa6bb63b3b3fbdb5127f9d21b">parallelForEachN</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t begin, size_t end, FuncT &amp;&amp;func)</td></tr>
<tr class="memdesc:a2c4dba1fa6bb63b3b3fbdb5127f9d21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the given function on the elements between [begin, end) asynchronously.  <a href="#a2c4dba1fa6bb63b3b3fbdb5127f9d21b">More...</a><br /></td></tr>
<tr class="separator:a2c4dba1fa6bb63b3b3fbdb5127f9d21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">hash_value</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> arg)</td></tr>
<tr class="memdesc:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types. ">TypeRange</a> hashable.  <a href="#abb322b17530b4289c3e3ec1f4ad2ecce">More...</a><br /></td></tr>
<tr class="separator:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e22b31f6f0d59955e0e73f0d387613"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40e22b31f6f0d59955e0e73f0d387613">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="memdesc:a40e22b31f6f0d59955e0e73f0d387613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a type range to the given output stream.  <a href="#a40e22b31f6f0d59955e0e73f0d387613">More...</a><br /></td></tr>
<tr class="separator:a40e22b31f6f0d59955e0e73f0d387613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fc3d1f66f267d9111234fac1effdfce">operator==</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; lhs, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;rhs)</td></tr>
<tr class="separator:a8fc3d1f66f267d9111234fac1effdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bfd80339235fbb32a685ff75f4e16"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd5bfd80339235fbb32a685ff75f4e16">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:acd5bfd80339235fbb32a685ff75f4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a31eede9183d3fdae566e18d94a5ef51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a82686ceb29eb0f78b59e29021f1b2cdd">More...</a><br /></td></tr>
<tr class="separator:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a252aee27751e05d584d0b1a8e793ecf0">More...</a><br /></td></tr>
<tr class="separator:a252aee27751e05d584d0b1a8e793ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (TupleType t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">More...</a><br /></td></tr>
<tr class="separator:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <a href="#a4bd6b581b08699ce79d3e9f820c1ade9">More...</a><br /></td></tr>
<tr class="separator:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <a href="#acb414ad1d507c2ab841305c273f4deb8">More...</a><br /></td></tr>
<tr class="separator:acb414ad1d507c2ab841305c273f4deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <a href="#ac54e5e6c31f51ef648f7c03652a29ce6">More...</a><br /></td></tr>
<tr class="separator:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801a1733326688cf0c9bee8d633f234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2801a1733326688cf0c9bee8d633f234">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types1, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types2)</td></tr>
<tr class="memdesc:a2801a1733326688cf0c9bee8d633f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape.  <a href="#a2801a1733326688cf0c9bee8d633f234">More...</a><br /></td></tr>
<tr class="separator:a2801a1733326688cf0c9bee8d633f234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132fff065736d8e977fe8179f2e7086c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a132fff065736d8e977fe8179f2e7086c">verifyCompatibleShapes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types)</td></tr>
<tr class="memdesc:a132fff065736d8e977fe8179f2e7086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if all given types have compatible shapes.  <a href="#a132fff065736d8e977fe8179f2e7086c">More...</a><br /></td></tr>
<tr class="separator:a132fff065736d8e977fe8179f2e7086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961cf9926486f7d6e7160efa8f846d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a961cf9926486f7d6e7160efa8f846d64">verifyCompatibleDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dims)</td></tr>
<tr class="memdesc:a961cf9926486f7d6e7160efa8f846d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions are compatible if all non-dynamic dims are equal.  <a href="#a961cf9926486f7d6e7160efa8f846d64">More...</a><br /></td></tr>
<tr class="separator:a961cf9926486f7d6e7160efa8f846d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df16c49c963cdc57cf6f9e7c3e9f822">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <a href="#ab710b1f6f21f3f35197575b609aae4b4">More...</a><br /></td></tr>
<tr class="separator:ab710b1f6f21f3f35197575b609aae4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool verifyRecursively=true)</td></tr>
<tr class="memdesc:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <a href="#ae4b1ba650fd43b50351e92bbb75bd4c0">More...</a><br /></td></tr>
<tr class="separator:ae4b1ba650fd43b50351e92bbb75bd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c5d880e7caad7aa65e3946d395ec1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a79c5d880e7caad7aa65e3946d395ec1c">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr, <a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *asmState=nullptr)</td></tr>
<tr class="memdesc:a79c5d880e7caad7aa65e3946d395ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="#a79c5d880e7caad7aa65e3946d395ec1c">More...</a><br /></td></tr>
<tr class="separator:a79c5d880e7caad7aa65e3946d395ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1795d3dff83a21eba1ca1fc638b5154b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1795d3dff83a21eba1ca1fc638b5154b">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a1795d3dff83a21eba1ca1fc638b5154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and appends parsed operations to the given block.  <a href="#a1795d3dff83a21eba1ca1fc638b5154b">More...</a><br /></td></tr>
<tr class="separator:a1795d3dff83a21eba1ca1fc638b5154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8316c9bcfd2fc6ba5b3d0adcd3522e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae8316c9bcfd2fc6ba5b3d0adcd3522e2">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr, <a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *asmState=nullptr)</td></tr>
<tr class="memdesc:ae8316c9bcfd2fc6ba5b3d0adcd3522e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block.  <a href="#ae8316c9bcfd2fc6ba5b3d0adcd3522e2">More...</a><br /></td></tr>
<tr class="separator:ae8316c9bcfd2fc6ba5b3d0adcd3522e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca40e833eb161d3044d41db30225fb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aca40e833eb161d3044d41db30225fb47">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:aca40e833eb161d3044d41db30225fb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the IR string and appends parsed operations to the given block.  <a href="#aca40e833eb161d3044d41db30225fb47">More...</a><br /></td></tr>
<tr class="separator:aca40e833eb161d3044d41db30225fb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb9923f4483d3d4bfbba1cc6b3403b2"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:aceb9923f4483d3d4bfbba1cc6b3403b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aceb9923f4483d3d4bfbba1cc6b3403b2">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aceb9923f4483d3d4bfbba1cc6b3403b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="#aceb9923f4483d3d4bfbba1cc6b3403b2">More...</a><br /></td></tr>
<tr class="separator:aceb9923f4483d3d4bfbba1cc6b3403b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fad28df0c39bfb6bbfc87671696a2c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a53fad28df0c39bfb6bbfc87671696a2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53fad28df0c39bfb6bbfc87671696a2c">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a53fad28df0c39bfb6bbfc87671696a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename.  <a href="#a53fad28df0c39bfb6bbfc87671696a2c">More...</a><br /></td></tr>
<tr class="separator:a53fad28df0c39bfb6bbfc87671696a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610850e1634d4778915b85040a9a31f0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a610850e1634d4778915b85040a9a31f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a610850e1634d4778915b85040a9a31f0">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a610850e1634d4778915b85040a9a31f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr.  <a href="#a610850e1634d4778915b85040a9a31f0">More...</a><br /></td></tr>
<tr class="separator:a610850e1634d4778915b85040a9a31f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8d85f887b1cf46b129114282993b3c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a4d8d85f887b1cf46b129114282993b3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4d8d85f887b1cf46b129114282993b3c">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a4d8d85f887b1cf46b129114282993b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the provided string containing MLIR.  <a href="#a4d8d85f887b1cf46b129114282993b3c">More...</a><br /></td></tr>
<tr class="separator:a4d8d85f887b1cf46b129114282993b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa182f707b3cb6a071cf1a9937578d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1aa182f707b3cb6a071cf1a9937578d">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af1aa182f707b3cb6a071cf1a9937578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#af1aa182f707b3cb6a071cf1a9937578d">More...</a><br /></td></tr>
<tr class="separator:af1aa182f707b3cb6a071cf1a9937578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34310a5d6e4690062af470064089068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae34310a5d6e4690062af470064089068">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:ae34310a5d6e4690062af470064089068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2bd19a863e2bf8969c4bae3ecaa84a16">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">More...</a><br /></td></tr>
<tr class="separator:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d149703ad4537629141fab7417075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae61d149703ad4537629141fab7417075">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type, size_t &amp;numRead)</td></tr>
<tr class="separator:ae61d149703ad4537629141fab7417075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5ffe10560be9caf3b9e8de592c20e93">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac5ffe10560be9caf3b9e8de592c20e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#ac5ffe10560be9caf3b9e8de592c20e93">More...</a><br /></td></tr>
<tr class="separator:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafaf30c94bd5327a769f9fd691cd42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afafaf30c94bd5327a769f9fd691cd42a">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:afafaf30c94bd5327a769f9fd691cd42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#afafaf30c94bd5327a769f9fd691cd42a">More...</a><br /></td></tr>
<tr class="separator:afafaf30c94bd5327a769f9fd691cd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85903e615943c997c10e210bc3d5efb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85903e615943c997c10e210bc3d5efb1">parseIntegerSet</a> (llvm::StringRef str, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, bool printDiagnosticInfo=true)</td></tr>
<tr class="memdesc:a85903e615943c997c10e210bc3d5efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> to an MLIR context if it was valid.  <a href="#a85903e615943c997c10e210bc3d5efb1">More...</a><br /></td></tr>
<tr class="separator:a85903e615943c997c10e210bc3d5efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <a href="#aa5c4edce10b597637635af55bb162477">More...</a><br /></td></tr>
<tr class="separator:aa5c4edce10b597637635af55bb162477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b943c7bb07b96e86234204b79b3d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a706b943c7bb07b96e86234204b79b3d4">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a706b943c7bb07b96e86234204b79b3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <a href="#a706b943c7bb07b96e86234204b79b3d4">More...</a><br /></td></tr>
<tr class="separator:a706b943c7bb07b96e86234204b79b3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd78ebb9f95cfe7ea3856d9f9c46d030">applyDefaultTimingPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>.  <a href="#acd78ebb9f95cfe7ea3856d9f9c46d030">More...</a><br /></td></tr>
<tr class="separator:acd78ebb9f95cfe7ea3856d9f9c46d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83965c855ad737422194336251348893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a83965c855ad737422194336251348893">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;function, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt; optHandler)</td></tr>
<tr class="memdesc:a83965c855ad737422194336251348893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <a href="#a83965c855ad737422194336251348893">More...</a><br /></td></tr>
<tr class="separator:a83965c855ad737422194336251348893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4626059212aef6f3aa5fa7088ce667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a4626059212aef6f3aa5fa7088ce667">registerPass</a> (const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a5a4626059212aef6f3aa5fa7088ce667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <a href="#a5a4626059212aef6f3aa5fa7088ce667">More...</a><br /></td></tr>
<tr class="separator:a5a4626059212aef6f3aa5fa7088ce667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the textual representation of a pass pipeline, adding the result to 'pm' on success.  <a href="#ad8d10077c7edf58c1152a1170257d739">More...</a><br /></td></tr>
<tr class="separator:ad8d10077c7edf58c1152a1170257d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef5abaea7950d9dc385a018dbbb40d0b">parsePassPipeline</a> (StringRef pipeline, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:aef5abaea7950d9dc385a018dbbb40d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success.  <a href="#aef5abaea7950d9dc385a018dbbb40d0b">More...</a><br /></td></tr>
<tr class="separator:aef5abaea7950d9dc385a018dbbb40d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ed5140e30c6e204e8bdc35d08d0eb08">createReductionTreePass</a> ()</td></tr>
<tr class="separator:a4ed5140e30c6e204e8bdc35d08d0eb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87060fc8d3ef747e189053c6bd556a5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a87060fc8d3ef747e189053c6bd556a5a">createOptReductionPass</a> ()</td></tr>
<tr class="separator:a87060fc8d3ef747e189053c6bd556a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54881321f630a119cdee5af076de868d"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54881321f630a119cdee5af076de868d">debugString</a> (T &amp;&amp;op)</td></tr>
<tr class="separator:a54881321f630a119cdee5af076de868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile</a> (llvm::StringRef inputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">More...</a><br /></td></tr>
<tr class="separator:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">More...</a><br /></td></tr>
<tr class="separator:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a> (bool isSuccess=true)</td></tr>
<tr class="memdesc:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a>.  <a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">More...</a><br /></td></tr>
<tr class="separator:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a> (bool isFailure=true)</td></tr>
<tr class="memdesc:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a>.  <a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">More...</a><br /></td></tr>
<tr class="separator:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1cb2e1046f84d6328600b92c99e52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57a1cb2e1046f84d6328600b92c99e52">succeeded</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:a57a1cb2e1046f84d6328600b92c99e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a> corresponds to a success value.  <a href="#a57a1cb2e1046f84d6328600b92c99e52">More...</a><br /></td></tr>
<tr class="separator:a57a1cb2e1046f84d6328600b92c99e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:aeec13ab4fb753865cdfd2699aa01c23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a> corresponds to a failure value.  <a href="#aeec13ab4fb753865cdfd2699aa01c23b">More...</a><br /></td></tr>
<tr class="separator:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3d17c70f67aa2d18203667acaf114"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46a3d17c70f67aa2d18203667acaf114">ceilDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a46a3d17c70f67aa2d18203667acaf114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's ceildiv operation on constants.  <a href="#a46a3d17c70f67aa2d18203667acaf114">More...</a><br /></td></tr>
<tr class="separator:a46a3d17c70f67aa2d18203667acaf114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3983eab6c9a05efd28747c0e79dd9d44">floorDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a3983eab6c9a05efd28747c0e79dd9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's floordiv operation on constants.  <a href="#a3983eab6c9a05efd28747c0e79dd9d44">More...</a><br /></td></tr>
<tr class="separator:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca33cad5b0cd935568ea0fc0a439abd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:afca33cad5b0cd935568ea0fc0a439abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns MLIR's mod operation on constants.  <a href="#afca33cad5b0cd935568ea0fc0a439abd">More...</a><br /></td></tr>
<tr class="separator:afca33cad5b0cd935568ea0fc0a439abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f7a5c72c1e0e867f3aac796b26ec2aa">lcm</a> (int64_t a, int64_t b)</td></tr>
<tr class="memdesc:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the least common multiple of 'a' and 'b'.  <a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">More...</a><br /></td></tr>
<tr class="separator:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da5a75b8bc3193908b0e222a6da1d85">registerDefaultTimingManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:a1da5a75b8bc3193908b0e222a6da1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream. ">DefaultTimingManager</a></code>.  <a href="#a1da5a75b8bc3193908b0e222a6da1d85">More...</a><br /></td></tr>
<tr class="separator:a1da5a75b8bc3193908b0e222a6da1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41920e66a206248f862766a705125d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab41920e66a206248f862766a705125d1">applyDefaultTimingManagerCLOptions</a> (<a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;tm)</td></tr>
<tr class="memdesc:ab41920e66a206248f862766a705125d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream. ">DefaultTimingManager</a></code>.  <a href="#ab41920e66a206248f862766a705125d1">More...</a><br /></td></tr>
<tr class="separator:ab41920e66a206248f862766a705125d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2320d5e3423bb76edf4048a5674f8f8e">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> processChunkBuffer, raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a2320d5e3423bb76edf4048a5674f8f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>.  <a href="#a2320d5e3423bb76edf4048a5674f8f8e">More...</a><br /></td></tr>
<tr class="separator:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">hash_value</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a>.  <a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">More...</a><br /></td></tr>
<tr class="separator:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e68be8ebf61b3be9572769e19bc467"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1e68be8ebf61b3be9572769e19bc467">registerAllToLLVMIRTranslations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ad1e68be8ebf61b3be9572769e19bc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces.  <a href="#ad1e68be8ebf61b3be9572769e19bc467">More...</a><br /></td></tr>
<tr class="separator:ad1e68be8ebf61b3be9572769e19bc467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0465249a74e23df5fdc548001933239c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0465249a74e23df5fdc548001933239c">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a0465249a74e23df5fdc548001933239c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a0465249a74e23df5fdc548001933239c">More...</a><br /></td></tr>
<tr class="separator:a0465249a74e23df5fdc548001933239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a637ec7428727c66f27117b9892f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa4a637ec7428727c66f27117b9892f1e">registerAMXDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aa4a637ec7428727c66f27117b9892f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the AMX dialect and the translation from it in the registry associated with the given context.  <a href="#aa4a637ec7428727c66f27117b9892f1e">More...</a><br /></td></tr>
<tr class="separator:aa4a637ec7428727c66f27117b9892f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">More...</a><br /></td></tr>
<tr class="separator:ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a559f20bb41c97729f2d089e6f7a72e4e">registerArmNeonDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a559f20bb41c97729f2d089e6f7a72e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmNeon dialect and the translation from it in the registry associated with the given context.  <a href="#a559f20bb41c97729f2d089e6f7a72e4e">More...</a><br /></td></tr>
<tr class="separator:a559f20bb41c97729f2d089e6f7a72e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a53be2d34e1d4e96ea100bbf93af35a2c">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a53be2d34e1d4e96ea100bbf93af35a2c">More...</a><br /></td></tr>
<tr class="separator:a53be2d34e1d4e96ea100bbf93af35a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c160fac7074517c6f013864acee68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc9c160fac7074517c6f013864acee68">registerArmSVEDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:afc9c160fac7074517c6f013864acee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the ArmSVE dialect and the translation from it in the registry associated with the given context.  <a href="#afc9c160fac7074517c6f013864acee68">More...</a><br /></td></tr>
<tr class="separator:afc9c160fac7074517c6f013864acee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b9759ca57d83ec47b341d58d966b9e8">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a8b9759ca57d83ec47b341d58d966b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a8b9759ca57d83ec47b341d58d966b9e8">More...</a><br /></td></tr>
<tr class="separator:a8b9759ca57d83ec47b341d58d966b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74024a3b8ec9af8d50db598772774a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a74024a3b8ec9af8d50db598772774a96">registerLLVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a74024a3b8ec9af8d50db598772774a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="#a74024a3b8ec9af8d50db598772774a96">More...</a><br /></td></tr>
<tr class="separator:a74024a3b8ec9af8d50db598772774a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989267e0da323d644b3316b85b3942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2989267e0da323d644b3316b85b3942f">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a2989267e0da323d644b3316b85b3942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a2989267e0da323d644b3316b85b3942f">More...</a><br /></td></tr>
<tr class="separator:a2989267e0da323d644b3316b85b3942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d03cc4e706acdb35969f4d4e78142a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a00d03cc4e706acdb35969f4d4e78142a">registerNVVMDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a00d03cc4e706acdb35969f4d4e78142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context.  <a href="#a00d03cc4e706acdb35969f4d4e78142a">More...</a><br /></td></tr>
<tr class="separator:a00d03cc4e706acdb35969f4d4e78142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9bc345c5d25bda3847f7ddf6cebe9bc">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">More...</a><br /></td></tr>
<tr class="separator:ae9bc345c5d25bda3847f7ddf6cebe9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889d8518a5c67b981e76d27c9a256d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a889d8518a5c67b981e76d27c9a256d86">registerOpenACCDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a889d8518a5c67b981e76d27c9a256d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenACC dialect and the translation in the registry associated with the given context.  <a href="#a889d8518a5c67b981e76d27c9a256d86">More...</a><br /></td></tr>
<tr class="separator:a889d8518a5c67b981e76d27c9a256d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ea20d97a32efd36c02468e54db4b2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a6ea20d97a32efd36c02468e54db4b2e7">More...</a><br /></td></tr>
<tr class="separator:a6ea20d97a32efd36c02468e54db4b2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa35b353841b70d090e1ead360536308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa35b353841b70d090e1ead360536308">registerOpenMPDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:aaa35b353841b70d090e1ead360536308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the OpenMP dialect and the translation from it in the registry associated with the given context.  <a href="#aaa35b353841b70d090e1ead360536308">More...</a><br /></td></tr>
<tr class="separator:aaa35b353841b70d090e1ead360536308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab895c88d57833ccee805eb3233c04ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab895c88d57833ccee805eb3233c04ca6">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ab895c88d57833ccee805eb3233c04ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#ab895c88d57833ccee805eb3233c04ca6">More...</a><br /></td></tr>
<tr class="separator:ab895c88d57833ccee805eb3233c04ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e522221c6652cb1450a6a3803125534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e522221c6652cb1450a6a3803125534">registerROCDLDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a4e522221c6652cb1450a6a3803125534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context.  <a href="#a4e522221c6652cb1450a6a3803125534">More...</a><br /></td></tr>
<tr class="separator:a4e522221c6652cb1450a6a3803125534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a06304b237de21b74a8c5b3251ac35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06a06304b237de21b74a8c5b3251ac35">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a06a06304b237de21b74a8c5b3251ac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;.  <a href="#a06a06304b237de21b74a8c5b3251ac35">More...</a><br /></td></tr>
<tr class="separator:a06a06304b237de21b74a8c5b3251ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a087d9cf09c9d93a0bf0f287509afc5b4">registerX86VectorDialectTranslation</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the X86Vector dialect and the translation from it in the registry associated with the given context.  <a href="#a087d9cf09c9d93a0bf0f287509afc5b4">More...</a><br /></td></tr>
<tr class="separator:a087d9cf09c9d93a0bf0f287509afc5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc149979459c3123124db882fb765dba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc149979459c3123124db882fb765dba">translateModuleToLLVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *module, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;)</td></tr>
<tr class="memdesc:adc149979459c3123124db882fb765dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate operation that satisfies <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect module requirements into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context.  <a href="#adc149979459c3123124db882fb765dba">More...</a><br /></td></tr>
<tr class="separator:adc149979459c3123124db882fb765dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc1f3b8cc0f16fa8f9165cce0e5a875b">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#afc1f3b8cc0f16fa8f9165cce0e5a875b">More...</a><br /></td></tr>
<tr class="separator:afc1f3b8cc0f16fa8f9165cce0e5a875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f93379e5dbb5551bbe57170230a1d92"><td class="memItemLeft" align="right" valign="top">DataLayoutSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a> (const llvm::DataLayout &amp;dataLayout, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2f93379e5dbb5551bbe57170230a1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect.  <a href="#a2f93379e5dbb5551bbe57170230a1d92">More...</a><br /></td></tr>
<tr class="separator:a2f93379e5dbb5551bbe57170230a1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad163144fafb93cf9814b2235ccf59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3ad163144fafb93cf9814b2235ccf59">MlirLspServerMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:af3ad163144fafb93cf9814b2235ccf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-lsp-server</code>.  <a href="#af3ad163144fafb93cf9814b2235ccf59">More...</a><br /></td></tr>
<tr class="separator:af3ad163144fafb93cf9814b2235ccf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e665be5c248a4929119ca802c7e488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12e665be5c248a4929119ca802c7e488">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;passPipeline, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, bool splitInputFile, bool verifyDiagnostics, bool verifyPasses, bool allowUnregisteredDialects, bool preloadDialectsInContext=false)</td></tr>
<tr class="memdesc:a12e665be5c248a4929119ca802c7e488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the core processing behind <code>mlir-opt</code>:  <a href="#a12e665be5c248a4929119ca802c7e488">More...</a><br /></td></tr>
<tr class="separator:a12e665be5c248a4929119ca802c7e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6077c691513a852d0f978191f2d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ae6077c691513a852d0f978191f2d24">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, <a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">PassPipelineFn</a> passManagerSetupFn, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, bool splitInputFile, bool verifyDiagnostics, bool verifyPasses, bool allowUnregisteredDialects, bool preloadDialectsInContext=false)</td></tr>
<tr class="memdesc:a8ae6077c691513a852d0f978191f2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support a callback to setup the pass manager.  <a href="#a8ae6077c691513a852d0f978191f2d24">More...</a><br /></td></tr>
<tr class="separator:a8ae6077c691513a852d0f978191f2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aa62850bedfdb7b95db9d097579763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97aa62850bedfdb7b95db9d097579763">MlirOptMain</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, bool preloadDialectsInContext=false)</td></tr>
<tr class="memdesc:a97aa62850bedfdb7b95db9d097579763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-opt</code>.  <a href="#a97aa62850bedfdb7b95db9d097579763">More...</a><br /></td></tr>
<tr class="separator:a97aa62850bedfdb7b95db9d097579763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1fa346908020b9dbc2009bb3630ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afcf1fa346908020b9dbc2009bb3630ce">MlirPdllLspServerMain</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:afcf1fa346908020b9dbc2009bb3630ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-pdll-lsp-server</code>.  <a href="#afcf1fa346908020b9dbc2009bb3630ce">More...</a><br /></td></tr>
<tr class="separator:afcf1fa346908020b9dbc2009bb3630ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515fd3b6aebea7df681f094b42d9e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab515fd3b6aebea7df681f094b42d9e71">mlirReduceMain</a> (int argc, char **argv, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="separator:ab515fd3b6aebea7df681f094b42d9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab673e648679ec83d87417b04baf281dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab673e648679ec83d87417b04baf281dd">mlirTranslateMain</a> (int argc, char **argv, StringRef toolName)</td></tr>
<tr class="memdesc:ab673e648679ec83d87417b04baf281dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate to/from an MLIR module from/to an external representation (e.g.  <a href="#ab673e648679ec83d87417b04baf281dd">More...</a><br /></td></tr>
<tr class="separator:ab673e648679ec83d87417b04baf281dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6e826b7dff0a2629197a20d859cd4c7">controlFlowSink</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveIntoRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveIntoRegion)</td></tr>
<tr class="memdesc:ac6e826b7dff0a2629197a20d859cd4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform control flow sinking on them.  <a href="#ac6e826b7dff0a2629197a20d859cd4c7">More...</a><br /></td></tr>
<tr class="separator:ac6e826b7dff0a2629197a20d859cd4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ba8fe6354d3dbe610c81805e7f85c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78ba8fe6354d3dbe610c81805e7f85c6">getSinglyExecutedRegionsToSink</a> (RegionBranchOpInterface branch, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> *&gt; &amp;regions)</td></tr>
<tr class="memdesc:a78ba8fe6354d3dbe610c81805e7f85c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op.  <a href="#a78ba8fe6354d3dbe610c81805e7f85c6">More...</a><br /></td></tr>
<tr class="separator:a78ba8fe6354d3dbe610c81805e7f85c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12287a4adc9d89ce2ed49712b091c5fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a12287a4adc9d89ce2ed49712b091c5fa">populateFunctionOpInterfaceTypeConversionPattern</a> (StringRef functionLikeOpName, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a12287a4adc9d89ce2ed49712b091c5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter.  <a href="#a12287a4adc9d89ce2ed49712b091c5fa">More...</a><br /></td></tr>
<tr class="separator:a12287a4adc9d89ce2ed49712b091c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memTemplParams" colspan="2">template&lt;typename FuncOpT &gt; </td></tr>
<tr class="memitem:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ab8b50117bb49a7ce3d85628dd374b8">populateFunctionOpInterfaceTypeConversionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="separator:a1ab8b50117bb49a7ce3d85628dd374b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5389ac045ec2ac4974c95afdd9b84c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5389ac045ec2ac4974c95afdd9b84c7d">applyPartialConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *unconvertedOps=nullptr)</td></tr>
<tr class="memdesc:a5389ac045ec2ac4974c95afdd9b84c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Below we define several entry points for operation conversion.  <a href="#a5389ac045ec2ac4974c95afdd9b84c7d">More...</a><br /></td></tr>
<tr class="separator:a5389ac045ec2ac4974c95afdd9b84c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1345088a35fa723ab2859d621a472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46e1345088a35fa723ab2859d621a472">applyPartialConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *unconvertedOps=nullptr)</td></tr>
<tr class="separator:a46e1345088a35fa723ab2859d621a472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb362d368fe137a8d095c1255a95922e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb362d368fe137a8d095c1255a95922e">applyFullConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acb362d368fe137a8d095c1255a95922e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a complete conversion on the given operations, and all nested operations.  <a href="#acb362d368fe137a8d095c1255a95922e">More...</a><br /></td></tr>
<tr class="separator:acb362d368fe137a8d095c1255a95922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da50bb4604fb05010c585eb301e2789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1da50bb4604fb05010c585eb301e2789">applyFullConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a1da50bb4604fb05010c585eb301e2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef0289872c759ab0391abd45f04bc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeef0289872c759ab0391abd45f04bc54">applyAnalysisConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt; notifyCallback=nullptr)</td></tr>
<tr class="memdesc:aeef0289872c759ab0391abd45f04bc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an analysis conversion on the given operations, and all nested operations.  <a href="#aeef0289872c759ab0391abd45f04bc54">More...</a><br /></td></tr>
<tr class="separator:aeef0289872c759ab0391abd45f04bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78704e0492eb62321d0f92cbddf28ff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a78704e0492eb62321d0f92cbddf28ff4">applyAnalysisConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt; notifyCallback=nullptr)</td></tr>
<tr class="separator:a78704e0492eb62321d0f92cbddf28ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7681d8cdc07b159253f717b65a4c3c05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7681d8cdc07b159253f717b65a4c3c05">applyPatternsAndFoldGreedily</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>())</td></tr>
<tr class="memdesc:a7681d8cdc07b159253f717b65a4c3c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner.  <a href="#a7681d8cdc07b159253f717b65a4c3c05">More...</a><br /></td></tr>
<tr class="separator:a7681d8cdc07b159253f717b65a4c3c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218fc6e0abad6c66d8c518853b50f084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a218fc6e0abad6c66d8c518853b50f084">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> config=<a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>())</td></tr>
<tr class="memdesc:a218fc6e0abad6c66d8c518853b50f084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the given regions, which must be isolated from above.  <a href="#a218fc6e0abad6c66d8c518853b50f084">More...</a><br /></td></tr>
<tr class="separator:a218fc6e0abad6c66d8c518853b50f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858fc38fd77156306692e198959ecd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa858fc38fd77156306692e198959ecd4">applyOpPatternsAndFold</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, bool *erased=nullptr)</td></tr>
<tr class="memdesc:aa858fc38fd77156306692e198959ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the specified patterns on <code>op</code> alone while also trying to fold it, by selecting the highest benefits patterns in a greedy manner.  <a href="#aa858fc38fd77156306692e198959ecd4">More...</a><br /></td></tr>
<tr class="separator:aa858fc38fd77156306692e198959ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bb09ea240cca60e28f3fa5d5f14fd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a34bb09ea240cca60e28f3fa5d5f14fd4">applyOpPatternsAndFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;patterns, bool strict)</td></tr>
<tr class="memdesc:a34bb09ea240cca60e28f3fa5d5f14fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the specified rewrite patterns on <code>ops</code> while also trying to fold these ops as well as any other ops that were in turn created due to such rewrites.  <a href="#a34bb09ea240cca60e28f3fa5d5f14fd4">More...</a><br /></td></tr>
<tr class="separator:a34bb09ea240cca60e28f3fa5d5f14fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a20bc0a33de855f1c9a1a0ccfd8665e78">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <a href="#a20bc0a33de855f1c9a1a0ccfd8665e78">More...</a><br /></td></tr>
<tr class="separator:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4aa94f3f9b2d783ae99a61d93b5268c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4aa94f3f9b2d783ae99a61d93b5268c">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:ad4aa94f3f9b2d783ae99a61d93b5268c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e080a2ba31bfcc4dd18b9a480051c74">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <a href="#a6e080a2ba31bfcc4dd18b9a480051c74">More...</a><br /></td></tr>
<tr class="separator:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba290a2c8d06fe6d8a126ff21cdadd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ba290a2c8d06fe6d8a126ff21cdadd2">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Block.html">Block</a> *inlineBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="separator:a1ba290a2c8d06fe6d8a126ff21cdadd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82b2f82348c0eacc76f1c4a862a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:afa82b2f82348c0eacc76f1c4a862a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <a href="#afa82b2f82348c0eacc76f1c4a862a796">More...</a><br /></td></tr>
<tr class="separator:afa82b2f82348c0eacc76f1c4a862a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="#a2d3bd1afbf84ef9cca6c336a104d7280">More...</a><br /></td></tr>
<tr class="separator:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c6823f94d6ce99fa7da7547658345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">generateLocationsFromIR</a> (StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:af16c6823f94d6ce99fa7da7547658345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#af16c6823f94d6ce99fa7da7547658345">More...</a><br /></td></tr>
<tr class="separator:af16c6823f94d6ce99fa7da7547658345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9bde94caabba0feba96a044a09afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a94e9bde94caabba0feba96a044a09afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="#a94e9bde94caabba0feba96a044a09afc">More...</a><br /></td></tr>
<tr class="separator:a94e9bde94caabba0feba96a044a09afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170389f5f17475f89037e332018b4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">generateLocationsFromIR</a> (StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:ab170389f5f17475f89037e332018b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#ab170389f5f17475f89037e332018b4f8">More...</a><br /></td></tr>
<tr class="separator:ab170389f5f17475f89037e332018b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fbf6253902c584461fa6a43a59ad5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">createLocationSnapshotPass</a> (<a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags, StringRef fileName=&quot;&quot;, StringRef tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a415fbf6253902c584461fa6a43a59ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#a415fbf6253902c584461fa6a43a59ad5">More...</a><br /></td></tr>
<tr class="separator:a415fbf6253902c584461fa6a43a59ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">createLocationSnapshotPass</a> ()</td></tr>
<tr class="memdesc:abb0bdadbeb0d7f5b8cef57668447640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload utilizing pass options for initialization.  <a href="#abb0bdadbeb0d7f5b8cef57668447640b">More...</a><br /></td></tr>
<tr class="separator:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770d05a67ea19ac133fde220298b3c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7770d05a67ea19ac133fde220298b3c7">moveLoopInvariantCode</a> (<a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; isDefinedOutsideRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; shouldMoveOutOfRegion, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; moveOutOfRegion)</td></tr>
<tr class="memdesc:a7770d05a67ea19ac133fde220298b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of regions, perform loop-invariant code motion.  <a href="#a7770d05a67ea19ac133fde220298b3c7">More...</a><br /></td></tr>
<tr class="separator:a7770d05a67ea19ac133fde220298b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b9f2d2e0330c53880b673633907ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a56b9f2d2e0330c53880b673633907ac6">moveLoopInvariantCode</a> (LoopLikeOpInterface loopLike)</td></tr>
<tr class="memdesc:a56b9f2d2e0330c53880b673633907ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface.  <a href="#a56b9f2d2e0330c53880b673633907ac6">More...</a><br /></td></tr>
<tr class="separator:a56b9f2d2e0330c53880b673633907ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line).  <a href="#aab0069355214b578476e81bc909f7f13">More...</a><br /></td></tr>
<tr class="separator:aab0069355214b578476e81bc909f7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf39c11aba136a3fcc349249993911b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf39c11aba136a3fcc349249993911b9">createCanonicalizerPass</a> (const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;config, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; disabledPatterns=llvm::None, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; enabledPatterns=llvm::None)</td></tr>
<tr class="memdesc:aaf39c11aba136a3fcc349249993911b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass with the specified config.  <a href="#aaf39c11aba136a3fcc349249993911b9">More...</a><br /></td></tr>
<tr class="separator:aaf39c11aba136a3fcc349249993911b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1d125e949d2172433639f2f31d3e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac1f1d125e949d2172433639f2f31d3e6">createControlFlowSinkPass</a> ()</td></tr>
<tr class="memdesc:ac1f1d125e949d2172433639f2f31d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform control-flow sinking.  <a href="#ac1f1d125e949d2172433639f2f31d3e6">More...</a><br /></td></tr>
<tr class="separator:ac1f1d125e949d2172433639f2f31d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <a href="#a14895da9723acd9c7f910c2694ff9f65">More...</a><br /></td></tr>
<tr class="separator:a14895da9723acd9c7f910c2694ff9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <a href="#a319fde65e573dbc3a947d58196cb2b3a">More...</a><br /></td></tr>
<tr class="separator:a319fde65e573dbc3a947d58196cb2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b152134b4d44a148dac8bfc24070dcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:a3b152134b4d44a148dac8bfc24070dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="#a3b152134b4d44a148dac8bfc24070dcd">More...</a><br /></td></tr>
<tr class="separator:a3b152134b4d44a148dac8bfc24070dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d86bdab25e38eed8e3ab9a35012b1e8">createPrintOpStatsPass</a> ()</td></tr>
<tr class="memdesc:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module.  <a href="#a2d86bdab25e38eed8e3ab9a35012b1e8">More...</a><br /></td></tr>
<tr class="separator:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="#a6c6ad0644a283c257d1fbc15be6adc18">More...</a><br /></td></tr>
<tr class="separator:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1372ce1294d9b98b652930aa6baf1386"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines)</td></tr>
<tr class="memdesc:a1372ce1294d9b98b652930aa6baf1386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="#a1372ce1294d9b98b652930aa6baf1386">More...</a><br /></td></tr>
<tr class="separator:a1372ce1294d9b98b652930aa6baf1386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a282d4666d1a10f4c41e6b114bf5e6a7f">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; defaultPipelineBuilder)</td></tr>
<tr class="memdesc:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="#a282d4666d1a10f4c41e6b114bf5e6a7f">More...</a><br /></td></tr>
<tr class="separator:a282d4666d1a10f4c41e6b114bf5e6a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119493f8c83de427f34658e5e39cbfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">createSCCPPass</a> ()</td></tr>
<tr class="memdesc:a6119493f8c83de427f34658e5e39cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which performs sparse conditional constant propagation over nested operations.  <a href="#a6119493f8c83de427f34658e5e39cbfe">More...</a><br /></td></tr>
<tr class="separator:a6119493f8c83de427f34658e5e39cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69605e45210627de9b7fde4644fa50c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">createSymbolDCEPass</a> ()</td></tr>
<tr class="memdesc:a69605e45210627de9b7fde4644fa50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which delete symbol operations that are unreachable.  <a href="#a69605e45210627de9b7fde4644fa50c1">More...</a><br /></td></tr>
<tr class="separator:a69605e45210627de9b7fde4644fa50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0b0f8a089ed821a240c7dd4e5573573">createSymbolPrivatizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; excludeSymbols={})</td></tr>
<tr class="memdesc:ae0b0f8a089ed821a240c7dd4e5573573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>.  <a href="#ae0b0f8a089ed821a240c7dd4e5573573">More...</a><br /></td></tr>
<tr class="separator:ae0b0f8a089ed821a240c7dd4e5573573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <code>limit</code> region.  <a href="#ac680df79552c596c048cd9cb27638c5f">More...</a><br /></td></tr>
<tr class="separator:ac680df79552c596c048cd9cb27638c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> replacement, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <code>orig</code> within the given region with <code>replacement</code>.  <a href="#a15a5d204dd78ac563241168e6b2e40eb">More...</a><br /></td></tr>
<tr class="separator:a15a5d204dd78ac563241168e6b2e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>.  <a href="#ae644ec0854505ef60f12c23b96de595b">More...</a><br /></td></tr>
<tr class="separator:ae644ec0854505ef60f12c23b96de595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">More...</a><br /></td></tr>
<tr class="separator:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f08e970a346cd42559db87f97f0b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98f08e970a346cd42559db87f97f0b91">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a98f08e970a346cd42559db87f97f0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants.  <a href="#a98f08e970a346cd42559db87f97f0b91">More...</a><br /></td></tr>
<tr class="separator:a98f08e970a346cd42559db87f97f0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c45b388f069e9396c50660f41a7eacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2c45b388f069e9396c50660f41a7eacf">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a2c45b388f069e9396c50660f41a7eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors.  <a href="#a2c45b388f069e9396c50660f41a7eacf">More...</a><br /></td></tr>
<tr class="separator:a2c45b388f069e9396c50660f41a7eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c016066a116564e82772ece3edd84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50c016066a116564e82772ece3edd84c">simplifyRegions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a50c016066a116564e82772ece3edd84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <a href="#a50c016066a116564e82772ece3edd84c">More...</a><br /></td></tr>
<tr class="separator:a50c016066a116564e82772ece3edd84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ab9585c8607c12142232e0f58ebcc8b">eraseUnreachableBlocks</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a6ab9585c8607c12142232e0f58ebcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the unreachable blocks within the provided regions.  <a href="#a6ab9585c8607c12142232e0f58ebcc8b">More...</a><br /></td></tr>
<tr class="separator:a6ab9585c8607c12142232e0f58ebcc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9eb183dcb73d44f0e0aedb09b73c7fd7">runRegionDCE</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns success if any operations or arguments were deleted, failure otherwise.  <a href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">More...</a><br /></td></tr>
<tr class="separator:a9eb183dcb73d44f0e0aedb09b73c7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5893e8e846dfeb812cdc30cd9228ec43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5893e8e846dfeb812cdc30cd9228ec43">isSideEffectFree</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5893e8e846dfeb812cdc30cd9228ec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given operation is side-effect free.  <a href="#a5893e8e846dfeb812cdc30cd9228ec43">More...</a><br /></td></tr>
<tr class="separator:a5893e8e846dfeb812cdc30cd9228ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045e1f32a8d90260d292aad61149c0ef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a045e1f32a8d90260d292aad61149c0ef">createPrintOpGraphPass</a> (raw_ostream &amp;os=llvm::errs())</td></tr>
<tr class="memdesc:a045e1f32a8d90260d292aad61149c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <a href="#a045e1f32a8d90260d292aad61149c0ef">More...</a><br /></td></tr>
<tr class="separator:a045e1f32a8d90260d292aad61149c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfff33b4e364b14e039f109ea3d9669"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteDialect &gt; </td></tr>
<tr class="memitem:accfff33b4e364b14e039f109ea3d9669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#accfff33b4e364b14e039f109ea3d9669">registerDialect</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:accfff33b4e364b14e039f109ea3d9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d12621b13993f83de878d26d2d7ef8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d12621b13993f83de878d26d2d7ef8b">vectorizeAffineLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fastestVaryingPattern, const <a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a> &amp;reductionLoops)</td></tr>
<tr class="memdesc:a0d12621b13993f83de878d26d2d7ef8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="#a0d12621b13993f83de878d26d2d7ef8b">More...</a><br /></td></tr>
<tr class="separator:a0d12621b13993f83de878d26d2d7ef8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b336390b16983a364b2d95bd2a64a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b336390b16983a364b2d95bd2a64a2f">registerTestRoundtripSPIRV</a> ()</td></tr>
<tr class="separator:a2b336390b16983a364b2d95bd2a64a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed913befc935e3b4b3e622838655b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ed913befc935e3b4b3e622838655b30">registerTestRoundtripDebugSPIRV</a> ()</td></tr>
<tr class="separator:a9ed913befc935e3b4b3e622838655b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2887883f00b094c5ca61c631d7b093a0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a> = 0</td></tr>
<tr class="memdesc:a2887883f00b094c5ca61c631d7b093a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout.  <a href="#a2887883f00b094c5ca61c631d7b093a0">More...</a><br /></td></tr>
<tr class="separator:a2887883f00b094c5ca61c631d7b093a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89827c63faec642164c91b4f8eb0bbbb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a89827c63faec642164c91b4f8eb0bbbb">kPtrBasePosInDataDescriptor</a> = 0</td></tr>
<tr class="separator:a89827c63faec642164c91b4f8eb0bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b10e5f178951c728a16e10de4d038c0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b10e5f178951c728a16e10de4d038c0">kPtrPosInDataDescriptor</a> = 1</td></tr>
<tr class="separator:a5b10e5f178951c728a16e10de4d038c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d7fcc466ac5f8bdada62aa526a821e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a17d7fcc466ac5f8bdada62aa526a821e">kSizePosInDataDescriptor</a> = 2</td></tr>
<tr class="separator:a17d7fcc466ac5f8bdada62aa526a821e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafef60380fb7774fcdb69f86f7b0bbb2"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafef60380fb7774fcdb69f86f7b0bbb2">makeOptimizingTransformer</a> (<a class="el" href="classunsigned.html">unsigned</a> optLevel, <a class="el" href="classunsigned.html">unsigned</a> sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:aafef60380fb7774fcdb69f86f7b0bbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <a href="#aafef60380fb7774fcdb69f86f7b0bbb2">More...</a><br /></td></tr>
<tr class="separator:aafef60380fb7774fcdb69f86f7b0bbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Include the generated interface declarations. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9afb3b6f82b256aea9f20e913e8afd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9afb3b6f82b256aea9f20e913e8afd5">&#9670;&nbsp;</a></span>AllocFunType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">mlir::AllocFunType</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a> *(size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00036">36</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="aad8f5011648c4f698028afb8a96b31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5011648c4f698028afb8a96b31ce">&#9670;&nbsp;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">mlir::AttributeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00179">179</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="af5aaca5fea0016501841c1e98a14e7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aaca5fea0016501841c1e98a14e7ab">&#9670;&nbsp;</a></span>BlobGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">mlir::BlobGenerator</a> = typedef std::function&lt;<a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00043">43</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="aafb0c2458571cd80ebb876d979e24346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0c2458571cd80ebb876d979e24346">&#9670;&nbsp;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">mlir::ChunkBufferHandler</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00028">28</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="a33732a3813b186ef51131421fac26f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33732a3813b186ef51131421fac26f4a">&#9670;&nbsp;</a></span>DataLayoutEntryKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a33732a3813b186ef51131421fac26f4a">mlir::DataLayoutEntryKey</a> = typedef <a class="el" href="classllvm_1_1PointerUnion.html">llvm::PointerUnion</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>, StringAttr&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00025">25</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a72a4f77607d05cf551b24ceb9362c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4f77607d05cf551b24ceb9362c034">&#9670;&nbsp;</a></span>DataLayoutEntryList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">mlir::DataLayoutEntryList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt;DataLayoutEntryInterface, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00028">28</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a577834e9b93afb653df29d66a6975ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577834e9b93afb653df29d66a6975ecf">&#9670;&nbsp;</a></span>DataLayoutEntryListRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">mlir::DataLayoutEntryListRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt;DataLayoutEntryInterface&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8h_source.html#l00029">29</a> of file <a class="el" href="DataLayoutInterfaces_8h_source.html">DataLayoutInterfaces.h</a>.</p>

</div>
</div>
<a id="a759bdae349015b16ce375bdd46c1e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bdae349015b16ce375bdd46c1e16c">&#9670;&nbsp;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">mlir::DefaultAttributeStorage</a> = typedef <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00171">171</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a8b36f0e85767ed4e793d86f40bd8fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36f0e85767ed4e793d86f40bd8fe55">&#9670;&nbsp;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">mlir::DefaultTypeStorage</a> = typedef <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00149">149</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="ad7f731697783a754f6f0e3821d1264b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f731697783a754f6f0e3821d1264b2">&#9670;&nbsp;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">mlir::DenseMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00103">103</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a8c18458e843e6fbd7837dec1b0be4cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c18458e843e6fbd7837dec1b0be4cd5">&#9670;&nbsp;</a></span>DenseMapInfo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8c18458e843e6fbd7837dec1b0be4cd5">mlir::DenseMapInfo</a> = typedef <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a>&lt;T, Enable&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00099">99</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a59d6aae8a616cd9d13c8b1edb1095948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6aae8a616cd9d13c8b1edb1095948">&#9670;&nbsp;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">mlir::DenseSet</a> = typedef <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00105">105</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a2e943fa4f63d44d69d846e504c16d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e943fa4f63d44d69d846e504c16d5f6">&#9670;&nbsp;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">mlir::DialectAllocatorFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00027">27</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="a6ffd752ab3a9dd88587958c328e34e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffd752ab3a9dd88587958c328e34e70">&#9670;&nbsp;</a></span>DialectAllocatorFunctionRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6ffd752ab3a9dd88587958c328e34e70">mlir::DialectAllocatorFunctionRef</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectRegistry_8h_source.html#l00028">28</a> of file <a class="el" href="DialectRegistry_8h_source.html">DialectRegistry.h</a>.</p>

</div>
</div>
<a id="aedbc3d0362a57c5175f05dd95fb59641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc3d0362a57c5175f05dd95fb59641">&#9670;&nbsp;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">mlir::DominanceInfoNode</a> = typedef llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00029">29</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="ae076c6e0e79ca32d89266007db06f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae076c6e0e79ca32d89266007db06f358">&#9670;&nbsp;</a></span>ElementWiseVisitor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae076c6e0e79ca32d89266007db06f358">mlir::ElementWiseVisitor</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(T &amp;ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient callback to "visit" a memref element by element. </p>
<p>This takes a reference to an individual element as well as the coordinates. It can be used in conjuction with a <a class="el" href="classStridedMemrefIterator.html" title="Iterate over all elements in a strided memref. ">StridedMemrefIterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00129">129</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a899fdaa9e41cd3d5abb2b4cc44dba232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">&#9670;&nbsp;</a></span>FilterFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">mlir::FilterFunctionType</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that: </p>
<ol type="1">
<li>recursively matches a substructure in the tree;</li>
<li>uses a filter function to refine matches with extra semantic constraints (passed via a lambda of type FilterFunctionType);</li>
<li>TODO: optionally applies actions (lambda).</li>
</ol>
<p>Nested patterns are meant to capture imperfectly nested loops while matching properties over the whole loop nest. For instance, in vectorization we are interested in capturing all the imperfectly nested loops of a certain type and such that all the load and stores have certain access patterns along the loops' induction variables). Such NestedMatches are first captured using the <code>match</code> function and are later processed to analyze properties and apply transformations in a non-greedy way.</p>
<p>The NestedMatches captured in the IR can grow large, especially after aggressive unrolling. As experience has shown, it is generally better to use a plain walk over operations to match flat patterns but the current implementation is competitive nonetheless. </p>

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00090">90</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a0bff6226b7c81b6134b8c1130403a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff6226b7c81b6134b8c1130403a172">&#9670;&nbsp;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00129">129</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a4ddb6704fdaa06a1d6d81b12d73eac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">&#9670;&nbsp;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">mlir::GenFunction</a> = typedef std::function&lt;bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00025">25</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="ad5c8735b67af7a64e4deff16477a06eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c8735b67af7a64e4deff16477a06eb">&#9670;&nbsp;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">mlir::Loops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00131">131</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a594a45ae9aa1ccffd960f369da94d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a45ae9aa1ccffd960f369da94d156">&#9670;&nbsp;</a></span>LoweringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">mlir::LoweringCallback</a> = typedef std::function&lt;std::unique_ptr&lt;llvm::Module&gt;( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00045">45</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="af2d45da2e2b2d5f705d618b778e36d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d45da2e2b2d5f705d618b778e36d52">&#9670;&nbsp;</a></span>OpAsmSetBlockNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af2d45da2e2b2d5f705d618b778e36d52">mlir::OpAsmSetBlockNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of blocks in regions directly nested under an operation. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01324">1324</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab0887111bf825d1f766ef9e0911394d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0887111bf825d1f766ef9e0911394d5">&#9670;&nbsp;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">mlir::OpAsmSetValueNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01320">1320</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3789e28c54bcaf5d2c3baf5f99eb615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789e28c54bcaf5d2c3baf5f99eb615f">&#9670;&nbsp;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">mlir::OperandElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00085">85</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="afd0d8f38577d05b87e540d717a7ba9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d8f38577d05b87e540d717a7ba9c5">&#9670;&nbsp;</a></span>OwnedBlob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">mlir::OwnedBlob</a> = typedef std::unique_ptr&lt;std::vector&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00041">41</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a48db7fd5d49bfa7ca8c81e5a6a058683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db7fd5d49bfa7ca8c81e5a6a058683">&#9670;&nbsp;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">mlir::PassAllocatorFunction</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00038">38</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="aa22124ccf5219095aee552486366ccc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22124ccf5219095aee552486366ccc0">&#9670;&nbsp;</a></span>PassPipelineFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">mlir::PassPipelineFn</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This defines the function type used to setup the pass manager. </p>
<p>This can be used to pass in a callback to setup a default pass pipeline to be applied on the loaded IR. </p>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8h_source.html#l00035">35</a> of file <a class="el" href="MlirOptMain_8h_source.html">MlirOptMain.h</a>.</p>

</div>
</div>
<a id="af4ccb1e7accf2ec0c57b1aea967ccd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">&#9670;&nbsp;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">mlir::PassRegistryFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return <a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed" title="Utility function to generate a LogicalResult. ">success()</a> if parsing succeeded. <code>errorHandler</code> is a functor used to emit errors during parsing. parameter corresponds to the raw location within the pipeline string. This should always return failure. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00037">37</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="ac8e9dd2cd47f4932caf7412344a0d902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e9dd2cd47f4932caf7412344a0d902">&#9670;&nbsp;</a></span>PDLConstraintFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac8e9dd2cd47f4932caf7412344a0d902">mlir::PDLConstraintFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic PDL pattern constraint function. </p>
<p>This function applies a constraint to a given set of opaque <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values. ">PDLValue</a> entities. Returns success if the constraint successfully held, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00806">806</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ab1b3453391c8240336255f36a7aaa9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b3453391c8240336255f36a7aaa9fc">&#9670;&nbsp;</a></span>PDLRewriteFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab1b3453391c8240336255f36a7aaa9fc">mlir::PDLRewriteFunction</a> = typedef std::function&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="el" href="classmlir_1_1PDLResultList.html">PDLResultList</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native PDL rewrite function. </p>
<p>This function performs a rewrite on the given set of values. Any results from this rewrite that should be passed back to PDL should be added to the provided result list. This method is only invoked when the corresponding match was successful. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00812">812</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ae5cf0e24a954fa30fb469105d4ca5dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cf0e24a954fa30fb469105d4ca5dd8">&#9670;&nbsp;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">mlir::ReassociationExprs</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00026">26</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="ab973fb931221b9539fe0ffd408e261ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab973fb931221b9539fe0ffd408e261ff">&#9670;&nbsp;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">mlir::ReassociationIndices</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00024">24</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a7ed845b40509fa999492a04654211321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed845b40509fa999492a04654211321">&#9670;&nbsp;</a></span>ReassociationIndicesRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">mlir::ReassociationIndicesRef</a> = typedef <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00025">25</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="a49c23a0a994193842991e0c87709e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c23a0a994193842991e0c87709e067">&#9670;&nbsp;</a></span>ReductionLoopMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">mlir::ReductionLoopMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a>, 2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00037">37</a> of file <a class="el" href="Dialect_2Affine_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a9d75e70e7cac31b335126e37dfe49b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d75e70e7cac31b335126e37dfe49b44">&#9670;&nbsp;</a></span>ReifiedRankedShapedTypeDims</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9d75e70e7cac31b335126e37dfe49b44">mlir::ReifiedRankedShapedTypeDims</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8h_source.html#l00029">29</a> of file <a class="el" href="InferTypeOpInterface_8h_source.html">InferTypeOpInterface.h</a>.</p>

</div>
</div>
<a id="a253b95ef2aaf79bdc612ae40fddc0732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b95ef2aaf79bdc612ae40fddc0732">&#9670;&nbsp;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">mlir::ResultElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00098">98</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a637916a3aeba97d795fa40975fbd7bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637916a3aeba97d795fa40975fbd7bd6">&#9670;&nbsp;</a></span>SetVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Vector  = std::vector&lt;T&gt;, typename Set  = DenseSet&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">mlir::SetVector</a> = typedef <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;T, <a class="el" href="structVector.html">Vector</a>, Set&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00108">108</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac2b3592ab67f8512cb18e62375d7ff4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b3592ab67f8512cb18e62375d7ff4b">&#9670;&nbsp;</a></span>StringSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">mlir::StringSet</a> = typedef <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00110">110</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac474b9f30a56412e090d9919e4dd8b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474b9f30a56412e090d9919e4dd8b34">&#9670;&nbsp;</a></span>StringSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">mlir::StringSwitch</a> = typedef <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00120">120</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a3f0d45d0562d47acc2c42934ccbfea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d45d0562d47acc2c42934ccbfea19">&#9670;&nbsp;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">mlir::TileLoops</a> = typedef std::pair&lt;<a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html#l00132">132</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a611e5b4f126ef025a241fda803748304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611e5b4f126ef025a241fda803748304">&#9670;&nbsp;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">mlir::TransitiveFilter</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs. </p>
<p>This can be used in particular to limit the propagation to a given Scope or to avoid passing through certain types of operation in a configurable manner. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00028">28</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a13b54e61e2491e2bc91c54f8ef429cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b54e61e2491e2bc91c54f8ef429cfa">&#9670;&nbsp;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">mlir::TranslateFromMLIRFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(ModuleOp, llvm::raw_ostream &amp;output)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the module. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00049">49</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="addbb54b5d484b1a53b08f04871fb0da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbb54b5d484b1a53b08f04871fb0da8">&#9670;&nbsp;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">mlir::TranslateFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given raw_ostream. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00057">57</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a099014bd868b4d3d9235a0dfd99c18d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099014bd868b4d3d9235a0dfd99c18d4">&#9670;&nbsp;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a099014bd868b4d3d9235a0dfd99c18d4">mlir::TranslateSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ModuleOp&gt;( llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR ModuleOp in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00037">37</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="adc82af5afce4525743199c60d03df7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc82af5afce4525743199c60d03df7d5">&#9670;&nbsp;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#adc82af5afce4525743199c60d03df7d5">mlir::TranslateStringRefToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ModuleOp&gt;(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR ModuleOp in the given context. If source-related error reporting is required from within the function, use TranslateSourceMgrToMLIRFunction instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00044">44</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a3bff85dd5cf397b62e521086d55e2d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bff85dd5cf397b62e521086d55e2d37">&#9670;&nbsp;</a></span>TypeRangeRangeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3bff85dd5cf397b62e521086d55e2d37">mlir::TypeRangeRangeIterator</a> = typedef llvm::mapped_iterator&lt;llvm::iota_range&lt;<a class="el" href="classunsigned.html">unsigned</a>&gt;::iterator, std::function&lt;<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>(<a class="el" href="classunsigned.html">unsigned</a>)&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00097">97</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="a01e9069ef9040ccc727d541c02d49ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9069ef9040ccc727d541c02d49ecd">&#9670;&nbsp;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">mlir::TypeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a utility allocator used to allocate memory for instances of derived Types. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00157">157</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="abcf44d03780c99376ac0c1dd1caed0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf44d03780c99376ac0c1dd1caed0f4">&#9670;&nbsp;</a></span>TypeSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ResultT  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">mlir::TypeSwitch</a> = typedef <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2LLVM_8h_source.html#l00123">123</a> of file <a class="el" href="Support_2LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="aa10a637dbeb6e0d2178032f95fb5ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a637dbeb6e0d2178032f95fb5ea1b">&#9670;&nbsp;</a></span>VectorizableLoopFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">mlir::VectorizableLoopFun</a> = typedef std::function&lt;bool(AffineForOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8h_source.html#l00062">62</a> of file <a class="el" href="LoopAnalysis_8h_source.html">LoopAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&nbsp;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00040">40</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a2c02a386e5ba59c4c88f83ac471f999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02a386e5ba59c4c88f83ac471f999d">&#9670;&nbsp;</a></span>ChangeResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">mlir::ChangeResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A result type used to indicate if a change happened. </p>
<p>Boolean operations on ChangeResult behave as though <code>Change</code> is truthy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999da4bac8cdf0a968472b519b3b295d0d48b"></a>NoChange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2c02a386e5ba59c4c88f83ac471f999daf4ec5f57bd4d31b803312d873be40da9"></a>Change&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataFlowAnalysis_8h_source.html#l00038">38</a> of file <a class="el" href="DataFlowAnalysis_8h_source.html">DataFlowAnalysis.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&nbsp;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00040">40</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="a6d4a641d6831cd23fcfd8e6d413acb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4a641d6831cd23fcfd8e6d413acb0e">&#9670;&nbsp;</a></span>FusionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0e">mlir::FusionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fusion mode to attempt. </p>
<p>The default mode <code>Greedy</code> does both producer-consumer and sibling fusion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d4a641d6831cd23fcfd8e6d413acb0eae6bf6be0c81b172c940a529947cbdcbf"></a>Greedy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d4a641d6831cd23fcfd8e6d413acb0ea4c84b1b2e881b0df9fbab23123827194"></a>ProducerConsumer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d4a641d6831cd23fcfd8e6d413acb0ea9c4a59afa1568bb286a15463cbfca62b"></a>Sibling&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l00029">29</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a77f701680752dfb55505285ab8ce8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f701680752dfb55505285ab8ce8b55">&#9670;&nbsp;</a></span>IteratorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum mlir::IteratorType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Typed representation for loop type strings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a"></a>Reduction&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00126">126</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&nbsp;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00163">163</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="abeb30aa1b062bf437bf3ea2b843a2ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">&#9670;&nbsp;</a></span>RegionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">mlir::RegionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of regions contained in an operation. </p>
<p>SSACFG regions require the SSA-Dominance property to hold. Graph regions do not require SSA-Dominance. If a registered operation does not implement RegionKindInterface, then any regions it contains are assumed to be SSACFG regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b"></a>SSACFG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd"></a>Graph&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8h_source.html#l00026">26</a> of file <a class="el" href="RegionKindInterface_8h_source.html">RegionKindInterface.h</a>.</p>

</div>
</div>
<a id="a11353e6611651b85531ad95629c57d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11353e6611651b85531ad95629c57d75">&#9670;&nbsp;</a></span>SliceVerificationResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">mlir::SliceVerificationResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum that captures information related to verifier error conditions on slice insert/extract type of ops. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271"></a>RankTooLarge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26"></a>SizeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e"></a>ElemTypeMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23"></a>MemSpaceMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca"></a>LayoutMismatch&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00338">338</a> of file <a class="el" href="IR_2BuiltinTypes_8h_source.html">BuiltinTypes.h</a>.</p>

</div>
</div>
<a id="a781474aef998ccce168b69ae973cd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781474aef998ccce168b69ae973cd832">&#9670;&nbsp;</a></span>SparseParallelizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">mlir::SparseParallelizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a parallelization strategy. </p>
<p>Any independent loop is a candidate for parallelization. The loop is made parallel if (1) allowed by the strategy (e.g., AnyStorageOuterLoop considers either a dense or sparse outermost loop only), and (2) the generated code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7"></a>kDenseOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af"></a>kAnyStorageOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8"></a>kDenseAnyLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7"></a>kAnyStorageAnyLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00039">39</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad6dfcab9b0dbfb18cf218eef50ba36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dfcab9b0dbfb18cf218eef50ba36ca">&#9670;&nbsp;</a></span>SparseToSparseConversionStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">mlir::SparseToSparseConversionStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a strategy for implementing sparse-to-sparse conversion. </p>
<p><code>kAuto</code> leaves it up to the compiler to automatically determine the method used. <code>kViaCOO</code> converts the source tensor to COO and then converts the COO to the target format. <code>kDirect</code> converts directly via the algorithm in <a href="https://arxiv.org/abs/2001.02609">https://arxiv.org/abs/2001.02609</a>; however, beware that there are many formats not supported by this conversion method.</p>
<p>The presence of the <code>kAuto</code> option violates our usual goal of keeping policy completely separated from mechanism. The reason it exists is because (at present) this strategy can only be specified on a per-file basis. To see why this is a problem, note that <code>kDirect</code> cannot support certain conversions; so if there is no <code>kAuto</code> setting, then whenever a file contains a single non-<code>kDirect</code>-able conversion the user would be forced to use <code>kViaCOO</code> for all conversions in that file! In the future, instead of using this enum as a <code><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a></code> option, we could instead move it to being an attribute on the conversion op; at which point <code>kAuto</code> would no longer be necessary. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7"></a>kAuto&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3"></a>kViaCOO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e"></a>kDirect&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00113">113</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a89ff3aa7fac07fd569937d78a0046fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ff3aa7fac07fd569937d78a0046fe2">&#9670;&nbsp;</a></span>SparseVectorizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2">mlir::SparseVectorizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a vectorization strategy. </p>
<p>Any inner loop is a candidate (full SIMD for parallel loops and horizontal SIMD for reduction loops). A loop is actually vectorized if (1) allowed by the strategy, and (2) the emitted code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89ff3aa7fac07fd569937d78a0046fe2a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a89ff3aa7fac07fd569937d78a0046fe2a580289a4bc04d1b8340b94829df37fbb"></a>kDenseInnerLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a89ff3aa7fac07fd569937d78a0046fe2a3bd27e991efaf1f1fad03867e363b410"></a>kAnyStorageInnerLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html#l00055">55</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9e4d5a3d224089fd8a2ebc3e933d08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">&#9670;&nbsp;</a></span>TraversalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">mlir::TraversalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the traversal method options to be used in the reduction tree traversal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96"></a>SinglePath&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1"></a>Backtrack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593"></a>MultiPath&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReductionNode_8h_source.html#l00037">37</a> of file <a class="el" href="ReductionNode_8h_source.html">ReductionNode.h</a>.</p>

</div>
</div>
<a id="a59fa9dd53c74f1ca73aa7ef263c94adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fa9dd53c74f1ca73aa7ef263c94adc">&#9670;&nbsp;</a></span>WalkOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">mlir::WalkOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal order for region, block and operation walk utilities. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc"></a>PreOrder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163"></a>PostOrder&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00062">62</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa17a0289ca213cc63e1b5cd46f19308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a0289ca213cc63e1b5cd46f19308c">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>. </p>
<p><code>copyOptions</code> provides various parameters, and the output argument <code>copyNests</code> is the set of all copy nests inserted, each represented by its root affine.for. Since we generate alloc's and dealloc's for all fast buffers (before and after the range of operations resp. or at a hoisted position), all of the fast memory capacity is assumed to be available for processing this block range. When 'filterMemRef' is specified, copies are only generated for the provided MemRef. Returns success if the explicit copying succeeded for all memrefs on which affine load/stores were encountered. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02374">2374</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8h_source.html#l00168">mlir::AffineCopyOptions::fastMemCapacityBytes</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01873">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02333">getFullMemRefAsRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01242">getNestingDepth()</a>, <a class="el" href="LoopUtils_8h_source.html#l00162">mlir::AffineCopyOptions::slowMemorySpace</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02564">affineDataCopyGenerate()</a>, and <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00091">createAffineDataCopyGenerationPass()</a>.</p>

</div>
</div>
<a id="a50d029c033843c69f361bcdb5ea12a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d029c033843c69f361bcdb5ea12a90">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02564">2564</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a9a4e4aaa747cf34698887690a5b52d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4e4aaa747cf34698887690a5b52d3f">&#9670;&nbsp;</a></span>affineForOpBodySkew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::affineForOpBodySkew </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollPrologueEpilogue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skew the operations in an affine.for's body with the specified operation-wise shifts. </p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied. If <code>unrollPrologueEpilogue</code> is set, fully unroll the prologue and epilogue loops when possible. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00236">236</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00349">isOpwiseShiftValid()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="ab724a67cbde80c4bad01a84e213000c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab724a67cbde80c4bad01a84e213000c3">&#9670;&nbsp;</a></span>affineParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::affineParallelize </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt;&#160;</td>
          <td class="paramname"><em>parallelReductions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a parallel affine.for op with a 1-d affine.parallel op. </p>
<p><code>forOp</code>'s body is taken by the affine.parallel op and the former is erased. (<a class="el" href="namespacemlir.html#ada966ff0f510c4882f6a4882c070c1c3" title="Returns true if `forOp&#39; is a parallel loop. ">mlir::isLoopParallel</a> can be used to detect a parallel affine.for op.) The reductions specified in <code>parallelReductions</code> are also parallelized. Parallelization will fail in the presence of loop iteration arguments that are not listed in <code>parallelReductions</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00348">348</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8h_source.html#l00373">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00376">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00273">mlir::Operation::getOperand()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00330">mlir::Operation::getResult()</a>, <a class="el" href="OperationSupport_8h_source.html#l01162">mlir::ValueRange::getTypes()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00035">mlir::LoopReduction::kind</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00200">mlir::Operation::setOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00041">mlir::LoopReduction::value</a>.</p>

</div>
</div>
<a id="adb27777dc6968f4be7cb843de774be33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb27777dc6968f4be7cb843de774be33">&#9670;&nbsp;</a></span>affineScalarReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affineScalarReplace </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>postDomInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace affine store and load accesses by scalars by forwarding stores to loads and eliminate invariant affine loads; consequently, eliminate dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01024">1024</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00899">findUnusedStore()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00944">loadCSE()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineScalarReplacement_8cpp_source.html#l00038">createAffineScalarReplacementPass()</a>.</p>

</div>
</div>
<a id="a5bcc9dc786aa8f64a60f1d51cdad3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcc9dc786aa8f64a60f1d51cdad3361">&#9670;&nbsp;</a></span>alignAffineMapWithValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::alignAffineMapWithValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>newSyms</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-indexes the dimensions and symbols of an affine map with given <code>operands</code> values to align with <code>dims</code> and <code>syms</code> values. </p>
<p>Each dimension/symbol of the map, bound to an operand <code>o</code>, is replaced with dimension <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>dims</code>. If <code>o</code> is not in <code>dims</code>, replace it with symbol <code>i</code>, where <code>i</code> is the position of <code>o</code> within <code>syms</code>. If <code>o</code> is not in <code>syms</code> either, replace it with a new symbol.</p>
<p>Note: If a value appears multiple times as a dimension/symbol (or both), all corresponding dim/sym expressions are replaced with the first dimension bound to that value (or first symbol if no such dimension exists).</p>
<p>The resulting affine map has <code>dims.size()</code> many dimensions and at least <code>syms.size()</code> many symbols.</p>
<p>The SSA values of the symbols of the resulting map are optionally returned via <code>newSyms</code>. This is a concatenation of <code>syms</code> with the SSA values of the newly added symbols.</p>
<p>Note: As part of this re-indexing, dimensions may turn into symbols, or vice versa. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01537">1537</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00289">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00392">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01208">mlir::FlatAffineValueConstraints::computeAlignedMap()</a>.</p>

</div>
</div>
<a id="aeef0289872c759ab0391abd45f04bc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef0289872c759ab0391abd45f04bc54">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>notifyCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an analysis conversion on the given operations, and all nested operations. </p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops'. There's an additional argument <code>notifyCallback</code> which is used for collecting match failure diagnostics generated during the conversion. Diagnostics are only reported to this callback may only be available in debug mode. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03299">3299</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00816">mlir::ConversionTarget::addIllegalDialect()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03309">applyAnalysisConversion()</a>.</p>

</div>
</div>
<a id="a78704e0492eb62321d0f92cbddf28ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78704e0492eb62321d0f92cbddf28ff4">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>notifyCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03309">3309</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03299">applyAnalysisConversion()</a>.</p>

</div>
</div>
<a id="ab41920e66a206248f862766a705125d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41920e66a206248f862766a705125d1">&#9670;&nbsp;</a></span>applyDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DefaultTimingManager.html">DefaultTimingManager</a> &amp;&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values that were registered with 'registerDefaultTimingManagerOptions' to a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream. ">DefaultTimingManager</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00561">561</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00461">mlir::DefaultTimingManager::setDisplayMode()</a>, and <a class="el" href="Timing_8cpp_source.html#l00455">mlir::DefaultTimingManager::setEnabled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManagerOptions_8cpp_source.html#l00150">applyDefaultTimingPassManagerCLOptions()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00047">performActions()</a>.</p>

</div>
</div>
<a id="acd78ebb9f95cfe7ea3856d9f9c46d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd78ebb9f95cfe7ea3856d9f9c46d030">&#9670;&nbsp;</a></span>applyDefaultTimingPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyDefaultTimingPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the timing manager options that were registered with <code>registerDefaultTimingManagerOptions</code>. </p>
<p>This is a handy helper function if you do not want to bother creating your own timing manager and passing it to the pass manager. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00150">150</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00561">applyDefaultTimingManagerCLOptions()</a>, and <a class="el" href="PassTiming_8cpp_source.html#l00145">mlir::PassManager::enableTiming()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00292">mlir::PassManager::IRPrinterConfig::getOpPrintingFlags()</a>.</p>

</div>
</div>
<a id="acb362d368fe137a8d095c1255a95922e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb362d368fe137a8d095c1255a95922e">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a complete conversion on the given operations, and all nested operations. </p>
<p>This method returns failure if the conversion of any operation fails, or if there are unreachable blocks in any of the regions nested within 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03284">3284</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00816">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03290">applyFullConversion()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00114">mlir::linalg::populateLinalgToStandardConversionPatterns()</a>, <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html#l00091">populateSPIRVLayoutInfoPatterns()</a>, and <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="a1da50bb4604fb05010c585eb301e2789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da50bb4604fb05010c585eb301e2789">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03290">3290</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03284">applyFullConversion()</a>.</p>

</div>
</div>
<a id="ad746ee74e91801b5f975addf56cd8d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad746ee74e91801b5f975addf56cd8d5f">&#9670;&nbsp;</a></span>applyMapToValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::applyMapToValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values obtained by applying <code>map</code> to the list of values. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00736">736</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00041">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00074">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="Tiling_8cpp_source.html#l00044">mlir::linalg::makeTiledLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00152">ReifyExpandOrCollapseShapeOp&lt; OpTy &gt;::reifyResultShapes()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00138">mlir::linalg::LinalgTilingOptions::scalarizeDynamicDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00538">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="aa858fc38fd77156306692e198959ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858fc38fd77156306692e198959ecd4">&#9670;&nbsp;</a></span>applyOpPatternsAndFold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyOpPatternsAndFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>erased</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the specified patterns on <code>op</code> alone while also trying to fold it, by selecting the highest benefits patterns in a greedy manner. </p>
<p>Rewrites only <code>op</code> using the supplied canonicalization patterns and folding.</p>
<p>Returns success if no more patterns can be matched. <code>erased</code> is set to true if <code>op</code> was folded away or erased as a result of becoming dead. Note: This does not apply any patterns recursively to the regions of <code>op</code>.</p>
<p><code>erased</code> is set to true if the op is erased as a result of being folded, replaced, or dead. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">649</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00038">mlir::GreedyRewriteConfig::maxIterations</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReductionTreePass_8cpp_source.html#l00037">applyPatterns()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00068">applyPatternsAndFoldGreedily()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00091">createAffineDataCopyGenerationPass()</a>, <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00075">createSimplifyAffineStructuresPass()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a34bb09ea240cca60e28f3fa5d5f14fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bb09ea240cca60e28f3fa5d5f14fd4">&#9670;&nbsp;</a></span>applyOpPatternsAndFold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::applyOpPatternsAndFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the specified rewrite patterns on <code>ops</code> while also trying to fold these ops as well as any other ops that were in turn created due to such rewrites. </p>
<p>Furthermore, any pre-existing ops in the IR outside of <code>ops</code> remain completely unmodified if <code>strict</code> is set to true. If <code>strict</code> is false, other operations that use results of rewritten ops or supply operands to such ops are in turn simplified; any other ops still remain unmodified (i.e., regardless of <code>strict</code>). Note that ops in <code>ops</code> could be erased as a result of folding, becoming dead, or via pattern rewrites. If more far reaching simplification is desired, applyPatternsAndFoldGreedily should be used. Returns true if at all any IR was rewritten. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00666">666</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

</div>
</div>
<a id="a5389ac045ec2ac4974c95afdd9b84c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5389ac045ec2ac4974c95afdd9b84c7d">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Below we define several entry points for operation conversion. </p>
<p>It is important to note that the patterns provided to the conversion framework may have additional constraints. See the <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a> Hooks</code> section of the <a class="el" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns. ">ConversionPatternRewriter</a>, to see what additional constraints are imposed on the use of the <a class="el" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...">PatternRewriter</a>. Apply a partial conversion on the given operations and all nested operations. This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there ops explicitly marked as illegal. If an <code>unconvertedOps</code> set is provided, all operations that are found not to be legalizable to the given <code>target</code> are placed within that set. (Note that if there is an op explicitly marked as illegal, the conversion terminates and the <code>unconvertedOps</code> set will not necessarily be complete.) </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03264">3264</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00816">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03273">applyPartialConversion()</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00159">convertCmpPredicate()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00662">funcsToCoroutines()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00387">ConvertStore::matchAndRewrite()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00539">populateAffineToVectorConversionPatterns()</a>, <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00811">mlir::arith::populateArithmeticToSPIRVPatterns()</a>, <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00077">populateBufferizationToMemRefConversionPatterns()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00302">populateComplexToLLVMConversionPatterns()</a>, <a class="el" href="ComplexToStandard_8cpp_source.html#l00709">populateComplexToStandardConversionPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00106">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00116">mlir::linalg::populateElementwiseToLinalgConversionPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00070">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="MathToLibm_8cpp_source.html#l00116">populateMathToLibmConversionPatterns()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>, <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00140">populateOpenACCToLLVMConversionPatterns()</a>, <a class="el" href="OpenACCToSCF_8cpp_source.html#l00051">populateOpenACCToSCFConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="SCFToControlFlow_8cpp_source.html#l00615">populateSCFToControlFlowConversionPatterns()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00149">populateVectorToROCDLConversionPatterns()</a>, and <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>.</p>

</div>
</div>
<a id="a46e1345088a35fa723ab2859d621a472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e1345088a35fa723ab2859d621a472">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03273">3273</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>.</p>

</div>
</div>
<a id="a706b943c7bb07b96e86234204b79b3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b943c7bb07b96e86234204b79b3d4">&#9670;&nbsp;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00133">133</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassCrashRecovery_8cpp_source.html#l00409">mlir::PassManager::enableCrashReproducerGeneration()</a>, and <a class="el" href="PassStatistics_8cpp_source.html#l00249">mlir::PassManager::enableStatistics()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00292">mlir::PassManager::IRPrinterConfig::getOpPrintingFlags()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00047">performActions()</a>.</p>

</div>
</div>
<a id="a7681d8cdc07b159253f717b65a4c3c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7681d8cdc07b159253f717b65a4c3c05">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner. </p>
<p>This variant may stop after a predefined number of iterations, see the alternative below to provide a specific number of iterations before stopping in absence of convergence.</p>
<p>Return success if the iterative process converged and no more patterns can be matched in the result operation regions.</p>
<p>Note: This does not apply patterns to the top-level operation itself. These methods also perform folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>You may configure several aspects of this with <a class="el" href="classmlir_1_1GreedyRewriteConfig.html" title="This class allows control over how the GreedyPatternRewriteDriver works. ">GreedyRewriteConfig</a>.</p>
<p>Return success if no more patterns can be matched in the result operation regions. Note: This does not apply patterns to the top-level operation itself. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">378</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00645">mlir::Operation::getUsers()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">isOpTriviallyDead()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00040">mlir::GreedyRewriteConfig::kNoIterationLimit</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00038">mlir::GreedyRewriteConfig::maxIterations</a>, <a class="el" href="IR_2Operation_8h_source.html#l00297">mlir::Operation::operand_begin()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00298">mlir::Operation::operand_end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00444">applyExtractSliceOfPadTensorSwapPattern()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00068">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00743">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00517">convertVectorToMMAOps()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00649">doSequentialDispatch()</a>, <a class="el" href="Generalization_8cpp_source.html#l00042">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00343">mlir::linalg::hoistRedundantVectorTransfersOnTensor()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00030">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00039">populateConvertShapeConstraintsConversionPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01684">mlir::linalg::populateElementwiseOpsFusionPatterns()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00245">mlir::memref::populateFoldSubViewOpPatterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00544">mlir::linalg::populateFoldUnitExtentDimsPatterns()</a>, <a class="el" href="InlineScalarOperands_8cpp_source.html#l00090">mlir::linalg::populateInlineConstantOperandsPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00130">mlir::memref::populateResolveShapedTypeResultDimsPatterns()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l01262">populateVectorToSCFConversionPatterns()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00074">reshapeLowerToHigher()</a>, and <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="a218fc6e0abad6c66d8c518853b50f084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218fc6e0abad6c66d8c518853b50f084">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the given regions, which must be isolated from above. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00068">68</a> of file <a class="el" href="GreedyPatternRewriteDriver_8h_source.html">GreedyPatternRewriteDriver.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">applyOpPatternsAndFold()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="a2b76f177cd65bd4fd394f9dc65d20be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b76f177cd65bd4fd394f9dc65d20be2">&#9670;&nbsp;</a></span>applyPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;T&gt; mlir::applyPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a permutation from <code>map</code> to <code>source</code> and return the result. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00531">531</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00478">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00201">buildVectorWrite()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>.</p>

</div>
</div>
<a id="adbcff71555e8c1965e508f324f43a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff71555e8c1965e508f324f43a55a">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector `inVec = ['a', 'b', 'c']<code>and a permutation vector </code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8h_source.html#l00038">38</a> of file <a class="el" href="IndexingUtils_8h_source.html">IndexingUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00117">dropFront()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00033">getI64SubArray()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00150">computeTransposedType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00424">mlir::linalg::tileConsumerAndFuseProducers()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00099">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&nbsp;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <code>limit</code> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00024">24</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00079">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00059">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00024">replaceAllUsesInRegionWith()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00366">runRegionDCE()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00730">simplifyRegions()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00032">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00107">checkAffineLoopNestMappableImpl()</a>.</p>

</div>
</div>
<a id="a173d145c5b783b4fe092fc78fd6879ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d145c5b783b4fe092fc78fd6879ec">&#9670;&nbsp;</a></span>barePtrFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::barePtrFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>It converts MemRef function arguments to bare pointers to the MemRef element type. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00562">562</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00431">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00209">mlir::LLVMTypeConverter::convertFunctionSignature()</a>.</p>

</div>
</div>
<a id="a3d147ba82716614172eb7e9b5209d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d147ba82716614172eb7e9b5209d3eb">&#9670;&nbsp;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00328">328</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00941">mlir::linalg::addTileLoopIvsToIndexOpResults()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00076">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00381">buildLoopIterationCount()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00034">contractSupportsMMAMatrixType()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00039">mlir::tensor::createPadHighOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00189">createSubViewIntersection()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00343">HoistingAnalysis::getPackedTensorSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00282">mlir::linalg::makeComposedExtractSliceOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01176">mlir::vector::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00538">mlir::linalg::updateBoundsForCyclicDistribution()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00642">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a8df39b3ef750e258dbe3dfe5b251cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df39b3ef750e258dbe3dfe5b251cea5">&#9670;&nbsp;</a></span>bindSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to SymbolExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00335">335</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00381">buildLoopIterationCount()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00343">HoistingAnalysis::getPackedTensorSizes()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, and <a class="el" href="LoopSpecialization_8cpp_source.html#l00111">peelForLoop()</a>.</p>

</div>
</div>
<a id="afdb92b40e131a0a6bd17fc39f1f3e371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb92b40e131a0a6bd17fc39f1f3e371">&#9670;&nbsp;</a></span>boundCheckLoadOrStoreOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOpPointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::boundCheckLoadOrStoreOp </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOpPointer&#160;</td>
          <td class="paramname"><em>loadOrStoreOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise. </p>
<p>Emits a diagnostic error (with location information) if emitError is true. </p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">getMemRefSizeInBytes()</a>.</p>

</div>
</div>
<a id="a63560e053a2ecec5eae27d99fe6d72c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63560e053a2ecec5eae27d99fe6d72c7">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator. </p>
<p>The loops iterate from "lbs" to "ubs" with "steps". The body of the innermost loop is populated by calling "bodyBuilderFn" and providing it with an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a>, a <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> and a list of loop induction variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02032">2032</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02010">buildAffineLoopFromConstants()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01969">buildAffineLoopNestImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00508">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="ac0366913a08a55f407cca2775a169d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0366913a08a55f407cca2775a169d7e">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02040">2040</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02019">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01969">buildAffineLoopNestImpl()</a>.</p>

</div>
</div>
<a id="a2f66fe15b68ccfe9902bee711b0d1636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f66fe15b68ccfe9902bee711b0d1636">&#9670;&nbsp;</a></span>buildSliceTripCountMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::buildSliceTripCountMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'. </p>
<p>Returns true on success, false otherwise (if a non-constant trip count was encountered). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">993</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00974">getConstDifference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01946">getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00078">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00080">mlir::ComputationSliceState::lbs</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00082">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00580">getFusionComputeCost()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00107">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a3742a7c72295f23d6fdd6b157b334074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3742a7c72295f23d6fdd6b157b334074">&#9670;&nbsp;</a></span>canFuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> mlir::canFuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>srcSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FusionStrategy.html">FusionStrategy</a>&#160;</td>
          <td class="paramname"><em>fusionStrategy</em> = <code><a class="el" href="classmlir_1_1FusionStrategy.html#af67d30ce20aaace9e674be9cae1001bfa190cb66109576270749d23427806eb6a">FusionStrategy::Generic</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'. </p>
<p>Returns <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> 'Success' if fusion of the src/dst loop nests is feasible (i.e. they are in the same block and dependences would not be violated). Otherwise returns a <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> explaining why fusion is not feasible. NOTE: This function is not feature complete and should only be used in testing. TODO: Update comments when this function is fully implemented. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00260">260</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00035">mlir::FusionResult::FailBlockDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00036">mlir::FusionResult::FailFusionDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00038">mlir::FusionResult::FailIncorrectSlice</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00034">mlir::FusionResult::FailPrecondition</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00179">gatherLoadsAndStores()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00062">mlir::FusionStrategy::Generic</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00066">mlir::SliceComputationResult::GenericFailure</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00138">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01272">getNumCommonSurroundingLoops()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00090">mlir::FusionStrategy::getSiblingFusionMemRef()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00087">mlir::FusionStrategy::getStrategy()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00065">mlir::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00067">mlir::FusionStrategy::ProducerConsumer</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00073">mlir::FusionStrategy::Sibling</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00033">mlir::FusionResult::Success</a>, and <a class="el" href="structmlir_1_1SliceComputationResult.html#a7d569cd37458f0f02bb46ce6dca958d7">mlir::SliceComputationResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8h_source.html#l00090">mlir::FusionStrategy::getSiblingFusionMemRef()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="ad8bde50e2368b8864c8bc070a11fdd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bde50e2368b8864c8bc070a11fdd71">&#9670;&nbsp;</a></span>canonicalizeMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::canonicalizeMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies both <code>map</code> and <code>operands</code> in-place so as to: </p>
<ol type="1">
<li>drop duplicate operands</li>
<li>drop unused dims and symbols from map</li>
<li>promote valid symbols to symbolic operands in case they appeared as dimensional operands</li>
<li>propagate constant operands and drop them </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00873">873</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01240">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01622">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01631">canonicalizeLoopBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">canonicalizeSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02633">createCanonicalizedAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00727">createFoldedComposedAffineApply()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00738">mlir::linalg::fullyComposeAndAffineApply()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01953">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00497">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00056">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a02d761b15655cb81ff4b40dbf49445db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d761b15655cb81ff4b40dbf49445db">&#9670;&nbsp;</a></span>canonicalizeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::canonicalizeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00878">878</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00873">canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02655">createSeparationCondition()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a80dcfbd64b4c5038926d874e46edeea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcfbd64b4c5038926d874e46edeea2">&#9670;&nbsp;</a></span>canonicalizeStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::canonicalizeStridedLayout </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout. </p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout.</p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout. If <code>t</code> has multiple layout maps or a multi-result layout, just return <code>t</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00907">907</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00255">mlir::AffineMap::isIdentity()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00186">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01042">isStaticShapeAndContiguousRowMajor()</a>.</p>

</div>
</div>
<a id="a1fe80a8d036b62be279ebe10c18dc953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe80a8d036b62be279ebe10c18dc953">&#9670;&nbsp;</a></span>canonicalizeSubViewPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::canonicalizeSubViewPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(int64_t)&gt;&#160;</td>
          <td class="paramname"><em>isDynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects the <code>values</code> produced by a ConstantIndexOp and places the new constant in place of the corresponding sentinel value. </p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>, and <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00022">matchConstantIndex()</a>.</p>

</div>
</div>
<a id="a46a3d17c70f67aa2d18203667acaf114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a3d17c70f67aa2d18203667acaf114">&#9670;&nbsp;</a></span>ceilDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::ceilDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's ceildiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00023">23</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00381">buildLoopIterationCount()</a>, <a class="el" href="Fraction_8h_source.html#l00065">mlir::presburger::ceil()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01459">mlir::presburger::IntegerRelation::computeConstantLowerOrUpperBound()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00336">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00104">computeStrides()</a>, <a class="el" href="IRModule_8h_source.html#l00920">mlir::python::PyAffineExpr::get()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01331">mlir::presburger::IntegerRelation::getConstantBoundOnDimSize()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">getTripCountMapAndOperands()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">loopUnrollByFactor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00295">promoteIfSingleIteration()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00645">setInterTileBoundsParametric()</a>.</p>

</div>
</div>
<a id="ae2e4b524ab21065019d9fdd55240b3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e4b524ab21065019d9fdd55240b3d4">&#9670;&nbsp;</a></span>checkMemrefAccessDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> mlir::checkMemrefAccessDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>dstAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *&#160;</td>
          <td class="paramname"><em>dependenceComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowRAR</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">598</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00409">computeDirectionVector()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03123">mlir::Operation::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02101">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00163">mlir::DependenceResult::Failure</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01582">mlir::FlatAffineRelation::getDomainSet()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00285">getNumCommonLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00161">mlir::DependenceResult::HasDependence</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01654">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00504">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00081">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00162">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00082">mlir::MemRefAccess::opInst</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00358">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkTilingLegalityImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00165">mlir::DependenceResult::DependenceResult()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00661">hasNoInterveningEffect()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00138">isLoopMemoryParallel()</a>.</p>

</div>
</div>
<a id="a8502dc067cc5f52028a818a810146a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8502dc067cc5f52028a818a810146a59">&#9670;&nbsp;</a></span>cloneWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::cloneWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newYieldedValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceLoopResults</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a clone of <code>loop</code> with <code>newIterOperands</code> added as new initialization values and <code>newYieldedValues</code> added as new yielded values. </p>
<p>The returned ForOp has <code>newYieldedValues.size()</code> new result values. The <code>loop</code> induction variable and <code>newIterOperands</code> are remapped to the new induction variable and the new entry block arguments respectively.</p>
<p>Additionally, if <code>replaceLoopResults</code> is true, all uses of <code>loop.getResults()</code> are replaced with the first <code>loop.getNumResults()</code> return values respectively. This additional replacement is provided as a convenience to update the consumers of <code>loop</code>, in the case e.g. when <code>loop</code> is soon to be deleted.</p>
<p>Return the cloned loop.</p>
<p>This convenience function is useful to factorize common mechanisms related to hoisting roundtrips to memory into yields. It does not perform any legality checks.</p>
<p>Prerequisite: <code>newYieldedValues.size() == newYieldedValues.size()</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00039">39</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00468">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00209">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00261">hoistReadWrite()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00395">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="a1f13b0be0ce31ecaf0272879eace768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f13b0be0ce31ecaf0272879eace768b">&#9670;&nbsp;</a></span>coalesceLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00572">572</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00501">normalizeLoop()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00024">replaceAllUsesInRegionWith()</a>, and <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="ac009f613f7317c259820d40ce6e7aaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac009f613f7317c259820d40ce6e7aaf5">&#9670;&nbsp;</a></span>coalesceLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops outermost to innermost that are normalized (step one and lower bound of zero) and with bounds and steps independent of any loop induction variable involved in the nest. Coalescing affine.for loops is not always possible, i.e., the result may not be representable using affine.for. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01720">1720</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00766">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00289">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00452">mlir::AffineBound::getMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00462">mlir::AffineBound::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00024">replaceAllUsesInRegionWith()</a>, <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a225e1cd29fad1b00f569d9567bc6cb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e1cd29fad1b00f569d9567bc6cb2e">&#9670;&nbsp;</a></span>collapseParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::collapseParallelLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ParallelOp&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>combinedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension. </p>
<p>combinedDimensions must contain each index into loops exactly once. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00628">628</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00209">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00501">normalizeLoop()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00024">replaceAllUsesInRegionWith()</a>.</p>

</div>
</div>
<a id="a3d4ed88de63bce19c4d23b6c62f7f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4ed88de63bce19c4d23b6c62f7f5d3">&#9670;&nbsp;</a></span>composeReassociationIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::composeReassociationIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>producerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerReassociations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose reassociation maps that are used in pair of reshape ops where one is a producer and other is the consumer. </p>
<p>Only valid to use this method when both the producer and consumer are collapsing dimensions or both are expanding dimensions.</p>
<p>For example, producerReassociation = [[0, 1], [2], [3, 4]] consumerReassociation = [[0, 1], [2]]</p>
<p>is folded into</p>
<p>result = [[0, 1, 2], [3, 4]]. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00096">96</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00173">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab05caafff59182b2191e4645cdceb5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05caafff59182b2191e4645cdceb5d5">&#9670;&nbsp;</a></span>compressDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not listed in <code>unusedDims</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">543</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00562">compressUnusedDims()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00720">getProjectedMap()</a>.</p>

</div>
</div>
<a id="a6de5b9ec7c351db7ed870d0df7248342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5b9ec7c351db7ed870d0df7248342">&#9670;&nbsp;</a></span>compressSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>unusedSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not listed in <code>unusedSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">606</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedSymbols()</a>, and <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>.</p>

</div>
</div>
<a id="a99f84d2ce14eec6c85a20251582e5cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f84d2ce14eec6c85a20251582e5cc1">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00562">562</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">compressDims()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00382">mlir::AffineMap::walkExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00601">compressUnusedDims()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, and <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00148">TransferWritePermutationLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae2a3cbce4381f83b710fe6cfc9a867c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a3cbce4381f83b710fe6cfc9a867c9">&#9670;&nbsp;</a></span>compressUnusedDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the dims that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00601">601</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00562">compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00572">compressUnusedImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>.</p>

</div>
</div>
<a id="ae4c401a074fdcc1cb0efb7e5369b2ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c401a074fdcc1cb0efb7e5369b2ef3">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">625</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">compressSymbols()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00382">mlir::AffineMap::walkExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">compressUnusedSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00720">getProjectedMap()</a>.</p>

</div>
</div>
<a id="a4a26d1a643586acb4362f535168be129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a26d1a643586acb4362f535168be129">&#9670;&nbsp;</a></span>compressUnusedSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; mlir::compressUnusedSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the symbols that are not used by any of the individual maps in <code>maps</code>. </p>
<p>Asserts that all maps in <code>maps</code> are normalized to the same number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">634</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00572">compressUnusedImpl()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>.</p>

</div>
</div>
<a id="a138bbf83686d046fd85553cdd10eaf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138bbf83686d046fd85553cdd10eaf18">&#9670;&nbsp;</a></span>computeElementOffsetsFromVectorSliceOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::computeElementOffsetsFromVectorSliceOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the target sizes of a vector, together with vector-space offsets, returns the element-space offsets for each dimension. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00028">getVectorOffset()</a>.</p>

</div>
</div>
<a id="a9c157bd2c9cf4949b45235593f6ef994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c157bd2c9cf4949b45235593f6ef994">&#9670;&nbsp;</a></span>computeMaxLinearIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of elements of basis, <code>0</code> if empty. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00097">97</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>.</p>

</div>
</div>
<a id="a390e026e19a6defcfee5c97da8f21e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390e026e19a6defcfee5c97da8f21e8f">&#9670;&nbsp;</a></span>computeRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; llvm::SmallDenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; mlir::computeRankReductionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>originalShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>reducedShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>. </p>
<p>The returned mask can be applied as a projection to <code>originalShape</code> to obtain the <code>reducedShape</code>. This mask is useful to track which dimensions must be kept when e.g. compute MemRef strides under rank-reducing operations. Return None if reducedShape cannot be obtained by dropping only <code>1</code> entries in <code>originalShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00415">415</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00441">isRankReducedType()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00310">mlir::VectorType::Builder::operator Type()</a>.</p>

</div>
</div>
<a id="aa53bb2629311efe042f2418b2c4233e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53bb2629311efe042f2418b2c4233e0">&#9670;&nbsp;</a></span>computeSliceUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1SliceComputationResult.html">SliceComputationResult</a> mlir::computeSliceUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numCommonLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceUnion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid. </p>
<p>The parameter 'numCommonLoops' is the number of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice' is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a function of IVs and symbols of loop nest surrounding ops in 'opsB' at 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop nest surrounding ops in 'opsB', as a function of IVs and symbols of loop nest surrounding ops in 'opsA' at 'loopDepth'. Returns '<a class="el" href="structmlir_1_1SliceComputationResult.html#acd1afb0dd9601a5c6e02d06655c26fcaaabd461ba07689c8a7196bf81dfcb6044">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate 'failure' otherwise.</p>
<p>Returns '<a class="el" href="structmlir_1_1SliceComputationResult.html#acd1afb0dd9601a5c6e02d06655c26fcaaabd461ba07689c8a7196bf81dfcb6044">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">811</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00335">mlir::FlatAffineValueConstraints::areIdsAlignedWithOther()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00119">mlir::ComputationSliceState::clearBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00551">mlir::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00163">mlir::DependenceResult::Failure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00066">mlir::SliceComputationResult::GenericFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00779">getInnermostCommonLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01242">getNestingDepth()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">mlir::FlatAffineValueConstraints::getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">mlir::FlatAffineValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00065">mlir::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00088">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00078">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00084">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00080">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00081">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00439">mlir::FlatAffineValueConstraints::mergeAndAlignIdsWithOther()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00162">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00082">mlir::MemRefAccess::opInst</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00064">mlir::SliceComputationResult::Success</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00086">mlir::ComputationSliceState::ubOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00082">mlir::ComputationSliceState::ubs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01385">mlir::FlatAffineValueConstraints::unionBoundingBox()</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00260">canFuseLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00107">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="af1a5f445f0e1451c0dde7b93a2e1d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a5f445f0e1451c0dde7b93a2e1d7ab">&#9670;&nbsp;</a></span>computeStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the shape and sizes of a vector, returns the corresponding strides for each dimension. </p>
<p>TODO: needs better doc of how it is used. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00104">104</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00028">getVectorOffset()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>.</p>

</div>
</div>
<a id="a6d24d64d6db077b8d5c88316b0d6c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24d64d6db077b8d5c88316b0d6c717">&#9670;&nbsp;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <code>maps</code>' dims and the concatenated results as its results. Returns an empty map if all input <code>maps</code> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div><div class="line">  (i, j, k) -&gt; (i, k),</div><div class="line">  (i, j, k) -&gt; (k, j),</div><div class="line">  (i, j, k) -&gt; (i, j)</div><div class="line">}</div></div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00703">703</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>.</p>

</div>
</div>
<a id="acc3c1de7f45b21ef1f9deddb22b03655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3c1de7f45b21ef1f9deddb22b03655">&#9670;&nbsp;</a></span>configureAMXLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureAMXLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00220">220</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a026c18765c0bc2d44d9ab120174d36ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026c18765c0bc2d44d9ab120174d36ae">&#9670;&nbsp;</a></span>configureArmSVELegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureArmSVELegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00095">95</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a7fa896c9229c786edc4a7970b960b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa896c9229c786edc4a7970b960b208">&#9670;&nbsp;</a></span>configureGpuToNVVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToNVVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00305">305</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00811">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a65c490624b02da7c5cb78aa071e0aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c490624b02da7c5cb78aa071e0aa2a">&#9670;&nbsp;</a></span>configureGpuToROCDLConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToROCDLConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00096">96</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00811">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a732e2b51952bf0b2c474784272e790b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732e2b51952bf0b2c474784272e790b4">&#9670;&nbsp;</a></span>configureOpenMPToLLVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureOpenMPToLLVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure dynamic conversion legality of regionless operations from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00062">62</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03003">mlir::TypeConverter::isLegal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">populateOpenMPToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="af01d59b73ef695a82338e96055101c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d59b73ef695a82338e96055101c16">&#9670;&nbsp;</a></span>configureParallelLoopToGPULegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureParallelLoopToGPULegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00673">673</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00031">mlir::gpu::getMappingAttrName()</a>, and <a class="el" href="SCFToGPU_8cpp_source.html#l00055">kVisitedAttrName</a>.</p>

</div>
</div>
<a id="afa8013cee2241cd53aa923b23e4e3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8013cee2241cd53aa923b23e4e3575">&#9670;&nbsp;</a></span>configureX86VectorLegalizeForExportTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureX86VectorLegalizeForExportTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the target to support lowering X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00168">168</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2X86Vector_2Transforms_8h_source.html#l00162">mlir::x86vector::avx2::LoweringOptions::setTransposeOptions()</a>.</p>

</div>
</div>
<a id="a5d3b3bbe9e749975af2eb5358df6f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">&#9670;&nbsp;</a></span>constFoldBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00030">30</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="ac450f976e30737567db650586c193a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac450f976e30737567db650586c193a92">&#9670;&nbsp;</a></span>constFoldCastOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class TargetAttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class TargetElementValueT  = typename TargetAttrElementT::ValueType, class CalculationT  = function_ref&lt;TargetElementValueT(ElementValueT, bool)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldCastOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00116">116</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

</div>
</div>
<a id="a8fb2ddb434a672f458f2ae6ab2a11570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb2ddb434a672f458f2ae6ab2a11570">&#9670;&nbsp;</a></span>constFoldUnaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldUnaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the one attributes in <code>operands</code> and returns the result if possible. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00078">78</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00676">mlir::DenseElementsAttr::get()</a>.</p>

</div>
</div>
<a id="ac6e826b7dff0a2629197a20d859cd4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e826b7dff0a2629197a20d859cd4c7">&#9670;&nbsp;</a></span>controlFlowSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::controlFlowSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveIntoRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveIntoRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform control flow sinking on them. </p>
<p>For each region, control-flow sinking moves operations that dominate the region but whose only users are in the region into the regions so that they aren't executed on paths where their results are not needed.</p>
<p>TODO: For the moment, this is a <em>simple</em> control-flow sink, i.e., no duplicating of ops. It should be made to accept a cost model to determine whether duplicating a particular op is profitable.</p>
<p>Example:</p>
<div class="fragment"><div class="line">%0 = arith.addi %arg0, %arg1</div><div class="line">scf.if %cond {</div><div class="line">  scf.yield %0</div><div class="line">} else {</div><div class="line">  scf.yield %arg2</div><div class="line">}</div></div><!-- fragment --><p>After control-flow sink:</p>
<div class="fragment"><div class="line">scf.if %cond {</div><div class="line">  %0 = arith.addi %arg0, %arg1</div><div class="line">  scf.yield %0</div><div class="line">} else {</div><div class="line">  scf.yield %arg2</div><div class="line">}</div></div><!-- fragment --><p>Users must supply a callback <code>shouldMoveIntoRegion</code> that determines whether the given operation that only has users in the given operation should be moved into that region. If this returns true, <code>moveIntoRegion</code> is called on the same operation and region.</p>
<p><code>moveIntoRegion</code> must move the operation into the region such that dominance of the operation is preserved; for example, by moving the operation to the start of the entry block. This ensures the preservation of SSA dominance of the operation's results.</p>
<p>Returns the number of operations sunk. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00127">127</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

</div>
</div>
<a id="addbe63747d3d90805543a5697ca8aca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe63747d3d90805543a5697ca8aca9">&#9670;&nbsp;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00299">299</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToGPU_8cpp_source.html#l00283">convertAffineLoopNestToGPULaunch()</a>.</p>

</div>
</div>
<a id="a23560b6de94f046854c32398b275f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23560b6de94f046854c32398b275f8b6">&#9670;&nbsp;</a></span>convertMMAToLLVMType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> mlir::convertMMAToLLVMType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1gpu_1_1MMAMatrixType.html">gpu::MMAMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMStructureType corresponding to the MMAMatrixType <code>type</code>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00362">362</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVOps_8cpp_source.html#l00687">getElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00393">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00060">mlir::gpu::MMAMatrixType::getOperand()</a>, and <a class="el" href="namespacemlir_1_1NVVM.html#a9170fc7a1b003011ad20e99749fe0f78">mlir::NVVM::inferMMAType()</a>.</p>

</div>
</div>
<a id="a9b2799e8f52860dadc460b88a8f2df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2799e8f52860dadc460b88a8f2df32">&#9670;&nbsp;</a></span>convertReassociationIndicesToExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;, 2 &gt; mlir::convertReassociationIndicesToExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert reassociation indices to affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00132">132</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00762">computeTensorReshapeCollapsedType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00704">getNumElements()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01610">verifyCollapsedShape()</a>.</p>

</div>
</div>
<a id="af3ef18cead6fd6974a5031544f3c46cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ef18cead6fd6974a5031544f3c46cb">&#9670;&nbsp;</a></span>convertReassociationMapsToIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a>, 2 &gt; mlir::convertReassociationMapsToIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Array&lt;Array&lt;AffineExpr&gt;&gt; to Array&lt;Array&lt;int64_t&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00169">169</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00312">mlir::AffineDimExpr::getPosition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>.</p>

</div>
</div>
<a id="a13f785af8c75118bc4626ba3ca30db6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f785af8c75118bc4626ba3ca30db6f">&#9670;&nbsp;</a></span>convertVectorToMMAOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::convertVectorToMMAOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert vector ops to MMA matrix operations nested under <code>rootOp</code>. </p>
<p>This will convert slice of operations that can be legally converted to MMA operations. The rest of the vector operations are left untouched. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l00517">517</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00419">convertBroadcastOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00401">convertConstantOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00389">convertContractOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00501">convertElementwiseOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00131">convertElementwiseOpToMMA()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00458">convertForOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00351">convertTransferReadOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00375">convertTransferWriteOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00482">convertYieldOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00206">getOpToConvert()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l00512">populatePrepareVectorToMMAPatterns()</a>.</p>

</div>
</div>
<a id="aebf452ef02d7d46f5c0f409ebb373b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf452ef02d7d46f5c0f409ebb373b92">&#9670;&nbsp;</a></span>createAffineComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::createAffineComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>opInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *&#160;</td>
          <td class="paramname"><em>sliceOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation. </p>
<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation operation.</p>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... v = "compute"(idx, ...)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) v = "compute"(idx_, ...) This allows the application of different transformations on send and compute (for eg. different shifts/delays)</p>
<p>Fills <code>sliceOps</code> with the list of affine.apply operations. In the following cases, <code>sliceOps</code> remains empty:</p><ol type="1">
<li>If none of opInst's operands were the result of an affine.apply (i.e., there was no affine computation slice to create).</li>
<li>If all the affine.apply op's supplying operands to this opInst did not have any uses other than those in this opInst.</li>
</ol>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) "compute"(idx)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) "compute"(idx_)</p>
<p>This allows applying different transformations on send and compute (for eg. different shifts/delays).</p>
<p>Returns nullptr either if none of opInst's operands were the result of an affine.apply and thus there was no affine computation slice to create, or if all the affine.apply op's supplying operands to this opInst did not have any uses besides this opInst; otherwise returns the list of affine.apply operations created in output argument <code>sliceOps</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01369">1369</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00308">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00194">getReachableAffineApplyOps()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00274">mlir::Operation::setOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="ac1b5ccea551ca4ad0c967f9dd57a2304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5ccea551ca4ad0c967f9dd57a2304">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>slowMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>tagMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDmaTransferSize</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fastMemCapacityBytes</em> = <code>std::numeric_limits&lt;uint64_t&gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations. </p>
<p>Generates copies for memref's living in 'slowMemorySpace' into newly created buffers in 'fastMemorySpace', and replaces memory operations to the former by the latter.</p>
<p>Only load op's handled for now. TODO: extend this to store op's. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00081">81</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="a51bf7e7ad773aae96caf0f7da3e81d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bf7e7ad773aae96caf0f7da3e81d1e">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00091">91</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">applyOpPatternsAndFold()</a>, <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00139">mlir::Block::empty()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01331">getMemoryFootprintBytes()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a0ec40c7aecb333928b9b4e9e409f0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec40c7aecb333928b9b4e9e409f0670">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts loop nests into GPU kernels. </p>
<p>It considers top-level affine.for operations as roots of loop nests and converts them to the gpu.launch operations if possible.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00066">66</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="aec305cc3472323a62580de136ce81cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305cc3472323a62580de136ce81cc3">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00070">70</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a8408a2f43babc6e93ff9402ad83011c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8408a2f43babc6e93ff9402ad83011c0">&#9670;&nbsp;</a></span>createAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00242">242</a> of file <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html">AffineLoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="af496d2a5b5e0edbd94e89dcb165c10cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af496d2a5b5e0edbd94e89dcb165c10cc">&#9670;&nbsp;</a></span>createAffineLoopNormalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineLoopNormalizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply normalization transformations to affine loop-like ops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00041">41</a> of file <a class="el" href="AffineLoopNormalize_8cpp_source.html">AffineLoopNormalize.cpp</a>.</p>

</div>
</div>
<a id="a49ab96a3dfea55443b28c25e202469d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ab96a3dfea55443b28c25e202469d9">&#9670;&nbsp;</a></span>createAffineParallelizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineParallelizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops. </p>

<p class="definition">Definition at line <a class="el" href="AffineParallelize_8cpp_source.html#l00085">85</a> of file <a class="el" href="AffineParallelize_8cpp_source.html">AffineParallelize.cpp</a>.</p>

</div>
</div>
<a id="a57769d9aa30a79bb4c89dabc5cc42b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57769d9aa30a79bb4c89dabc5cc42b19">&#9670;&nbsp;</a></span>createAffineScalarReplacementPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createAffineScalarReplacementPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="AffineScalarReplacement_8cpp_source.html#l00038">38</a> of file <a class="el" href="AffineScalarReplacement_8cpp_source.html">AffineScalarReplacement.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01024">affineScalarReplace()</a>.</p>

</div>
</div>
<a id="a4239fe8f68fb32a8788127f7a6850950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4239fe8f68fb32a8788127f7a6850950">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00938">938</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a755ae56707350858331f8a2d72036f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755ae56707350858331f8a2d72036f86">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asyncDispatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numWorkerThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minTaskSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00942">942</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a89c5cda96fda85b96d4c5786f58680bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c5cda96fda85b96d4c5786f58680bd">&#9670;&nbsp;</a></span>createAsyncRuntimePolicyBasedRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimePolicyBasedRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00557">557</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="ac29ec7fe477dccf07bddf61bec9c3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29ec7fe477dccf07bddf61bec9c3ac7">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html#l00228">228</a> of file <a class="el" href="AsyncRuntimeRefCountingOpt_8cpp_source.html">AsyncRuntimeRefCountingOpt.cpp</a>.</p>

</div>
</div>
<a id="ac74b480a928c4e1972270a410dd3e214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b480a928c4e1972270a410dd3e214">&#9670;&nbsp;</a></span>createAsyncRuntimeRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createAsyncRuntimeRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00553">553</a> of file <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html">AsyncRuntimeRefCounting.cpp</a>.</p>

</div>
</div>
<a id="acda37b3719dc71d8caddd1d39ca215db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda37b3719dc71d8caddd1d39ca215db">&#9670;&nbsp;</a></span>createAsyncToAsyncRuntimePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createAsyncToAsyncRuntimePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00824">824</a> of file <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html">AsyncToAsyncRuntime.cpp</a>.</p>

</div>
</div>
<a id="ae01b05ed73bc512e7ae40bc6d37ae1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01b05ed73bc512e7ae40bc6d37ae1a0">&#9670;&nbsp;</a></span>createBufferizationToMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferizationToMemRefPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00103">103</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

</div>
</div>
<a id="a7cd7d19be1ff3cc542143dfd3f1c272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7d19be1ff3cc542143dfd3f1c272a">&#9670;&nbsp;</a></span>createCanonicalizedAffineForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::createCanonicalizedAffineForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>ubMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02633">2633</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00649">removeDuplicateExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01953">generatePointWiseCopy()</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass, configured with default settings (which can be overridden by pass options on the command line). </p>
<p>Create a Canonicalizer pass.</p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00064">64</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalgPass_8cpp_source.html#l00069">mlir::tosa::addTosaToLinalgPasses()</a>, <a class="el" href="Inliner_8cpp_source.html#l00032">defaultInlinerOptPipeline()</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="aaf39c11aba136a3fcc349249993911b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf39c11aba136a3fcc349249993911b9">&#9670;&nbsp;</a></span>createCanonicalizerPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1GreedyRewriteConfig.html">GreedyRewriteConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>disabledPatterns</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>enabledPatterns</em> = <code>llvm::None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass with the specified config. </p>
<p><code>disabledPatterns</code> is a set of labels used to filter out input patterns with a debug label or debug name in this set. <code>enabledPatterns</code> is a set of labels used to filter out input patterns that do not have one of the labels in this set. Debug labels must be set explicitly on patterns or when adding them with <code><a class="el" href="classmlir_1_1RewritePatternSet.html#aa3495784414684ff80ba6453553c49de" title="An overload of the above add method that allows for attaching a set of debug labels to the attached p...">RewritePatternSet::addWithLabel</a></code>. Debug names may be empty, but patterns created with <code><a class="el" href="classmlir_1_1RewritePattern.html#a6be24a0e5e1a846f53affe293fc2655f" title="This method provides a convenient interface for creating and initializing derived rewrite patterns of...">RewritePattern::create</a></code> have their default debug name set to their type name. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00070">70</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

</div>
</div>
<a id="a4e839c359226fcf9fc26cb51ba6c3282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e839c359226fcf9fc26cb51ba6c3282">&#9670;&nbsp;</a></span>createComposedAffineApplyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::createComposedAffineApplyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and inserts into 'builder' a new AffineApplyOp, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'. </p>
<p>If different operands were drawing results from multiple affine apply ops, these will also be collected into a single (multi-result) affine apply op. The final results of the composed AffineApplyOp are returned in output parameter 'results'. Returns the affine apply op created. </p>

</div>
</div>
<a id="ac1f1d125e949d2172433639f2f31d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f1d125e949d2172433639f2f31d3e6">&#9670;&nbsp;</a></span>createControlFlowSinkPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createControlFlowSinkPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform control-flow sinking. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSink_8cpp_source.html#l00052">52</a> of file <a class="el" href="ControlFlowSink_8cpp_source.html">ControlFlowSink.cpp</a>.</p>

</div>
</div>
<a id="a4655b459042808cdaf22b54faf67aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4655b459042808cdaf22b54faf67aaf6">&#9670;&nbsp;</a></span>createConvertArmNeon2dToIntrPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertArmNeon2dToIntrPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to lower Arm NEON 2D ops to intrinsics, i.e. </p>
<p>equivalent ops operating on flattened 1D vectors and mapping more directly to the corresponding Arm NEON instruction. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00069">69</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

</div>
</div>
<a id="a4fa49d15d05958ebff1ab8aac3e55cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa49d15d05958ebff1ab8aac3e55cfc">&#9670;&nbsp;</a></span>createConvertAsyncToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertAsyncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Async operations to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01113">1113</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a38a35442d74f5c37a94afbbcce5059e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a35442d74f5c37a94afbbcce5059e8">&#9670;&nbsp;</a></span>createConvertComplexToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertComplexToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00339">339</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

</div>
</div>
<a id="ad891730d98fe42a400b188049ff923f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891730d98fe42a400b188049ff923f2">&#9670;&nbsp;</a></span>createConvertComplexToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertComplexToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Complex operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l00750">750</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

</div>
</div>
<a id="a282b8506125737d8301a4345418bbcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282b8506125737d8301a4345418bbcec">&#9670;&nbsp;</a></span>createConvertControlFlowToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertControlFlowToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert ControlFlow ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html#l00049">49</a> of file <a class="el" href="ControlFlowToSPIRVPass_8cpp_source.html">ControlFlowToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="abc492b94e5d0848e7244b2682da91021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc492b94e5d0848e7244b2682da91021">&#9670;&nbsp;</a></span>createConvertElementwiseToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertElementwiseToLinalgPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00143">143</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

</div>
</div>
<a id="a050a225b8d7733734dc0c229e9e5a680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050a225b8d7733734dc0c229e9e5a680">&#9670;&nbsp;</a></span>createConvertFuncToLLVMPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertFuncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert the Func dialect into the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00734">734</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a2c23bdfdb099630bef62098393f87aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c23bdfdb099630bef62098393f87aa7">&#9670;&nbsp;</a></span>createConvertFuncToLLVMPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertFuncToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00739">739</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4ac6cc2ffb89010532e07c736361b52e95">mlir::LowerToLLVMOptions::AlignedAlloc</a>, <a class="el" href="LoweringOptions_8h_source.html#l00050">mlir::LowerToLLVMOptions::allocLowering</a>, <a class="el" href="LoweringOptions_8h_source.html#l00055">mlir::LowerToLLVMOptions::dataLayout</a>, <a class="el" href="LoweringOptions_8h_source.html#l00036">mlir::LowerToLLVMOptions::emitCWrappers</a>, <a class="el" href="LoweringOptions_8h_source.html#l00065">mlir::LowerToLLVMOptions::getIndexBitwidth()</a>, <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4a6adf97f83acf6453d4a6a4b1070f3754">mlir::LowerToLLVMOptions::None</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

</div>
</div>
<a id="a39b73c4fa68f99933c25bc8d889b7c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b73c4fa68f99933c25bc8d889b7c3c">&#9670;&nbsp;</a></span>createConvertFuncToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertFuncToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Func ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRVPass_8cpp_source.html#l00049">49</a> of file <a class="el" href="FuncToSPIRVPass_8cpp_source.html">FuncToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ad39c9d3321b2f5f4aee088b02b535f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c9d3321b2f5f4aee088b02b535f9b">&#9670;&nbsp;</a></span>createConvertGpuLaunchFuncToVulkanLaunchFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertGpuLaunchFuncToVulkanLaunchFuncPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html#l00190">190</a> of file <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html">ConvertGPULaunchFuncToVulkanLaunchFunc.cpp</a>.</p>

</div>
</div>
<a id="a98081470e80af33268acc9e7463f4af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98081470e80af33268acc9e7463f4af1">&#9670;&nbsp;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRVPass_8cpp_source.html#l00075">75</a> of file <a class="el" href="GPUToSPIRVPass_8cpp_source.html">GPUToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a49b8d9d8ebc6d954a9bb1d61ff789bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b8d9d8ebc6d954a9bb1d61ff789bc0">&#9670;&nbsp;</a></span>createConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses. </p>
<p>Placeholder for now, this is NYI. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00352">352</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a5d81cd941f78768bc9dd0cbaca49d45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d81cd941f78768bc9dd0cbaca49d45a">&#9670;&nbsp;</a></span>createConvertLinalgToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertLinalgToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00097">97</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a048ca3f94f0e3472846128d08e1db05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048ca3f94f0e3472846128d08e1db05f">&#9670;&nbsp;</a></span>createConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.for loops and memref.load/memref.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00342">342</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ac2eb8ccd7e77282559488dfb6408a632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eb8ccd7e77282559488dfb6408a632">&#9670;&nbsp;</a></span>createConvertLinalgToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createConvertLinalgToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.parallel loops and memref.load/memref.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00347">347</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aefb33f39a4ad0d4d52396f132bee84cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb33f39a4ad0d4d52396f132bee84cf">&#9670;&nbsp;</a></span>createConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00142">142</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

</div>
</div>
<a id="aa0be8ab8e597910498a4a64215faa2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0be8ab8e597910498a4a64215faa2fb">&#9670;&nbsp;</a></span>createConvertMathToLibmPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertMathToLibmPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Math operations to libm calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00151">151</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

</div>
</div>
<a id="ac8f2f3afc604027ee4caae1d784cbbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f2f3afc604027ee4caae1d784cbbf9">&#9670;&nbsp;</a></span>createConvertMathToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertMathToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00293">293</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ae30843a2073f3fa196023a00ff6ae70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30843a2073f3fa196023a00ff6ae70e">&#9670;&nbsp;</a></span>createConvertMathToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertMathToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRVPass_8cpp_source.html#l00046">46</a> of file <a class="el" href="MathToSPIRVPass_8cpp_source.html">MathToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a59f123db56a9d730a0424f582f6a85bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f123db56a9d730a0424f582f6a85bc">&#9670;&nbsp;</a></span>createConvertMemRefToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertMemRefToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRVPass_8cpp_source.html#l00060">60</a> of file <a class="el" href="MemRefToSPIRVPass_8cpp_source.html">MemRefToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ab98ec0d969c9cb644bceb1394a1e9e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98ec0d969c9cb644bceb1394a1e9e5b">&#9670;&nbsp;</a></span>createConvertNVGPUToNVVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertNVGPUToNVVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00306">306</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

</div>
</div>
<a id="addd9779adcd4172eec44c1eb060d4867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd9779adcd4172eec44c1eb060d4867">&#9670;&nbsp;</a></span>createConvertOpenACCToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertOpenACCToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert the OpenACC dialect into the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00237">237</a> of file <a class="el" href="OpenACCToLLVM_8cpp_source.html">OpenACCToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a3c1dc4bc47a3830e063b709a36e0ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1dc4bc47a3830e063b709a36e0ab91">&#9670;&nbsp;</a></span>createConvertOpenACCToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertOpenACCToSCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert the OpenACC dialect into the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00088">88</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

</div>
</div>
<a id="ae53acb3c78e9695b7e30e1e9efec285a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53acb3c78e9695b7e30e1e9efec285a">&#9670;&nbsp;</a></span>createConvertOpenMPToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertOpenMPToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert OpenMP operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00110">110</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a877c34cdb063f52ff5ea4efd82807621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c34cdb063f52ff5ea4efd82807621">&#9670;&nbsp;</a></span>createConvertSCFToCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertSCFToCFPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF operations to CFG branch-based operation in the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00636">636</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a79eeef76941bf1c659f41fe8f8ddbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eeef76941bf1c659f41fe8f8ddbfe0">&#9670;&nbsp;</a></span>createConvertSCFToOpenMPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertSCFToOpenMPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToOpenMP_8cpp_source.html#l00457">457</a> of file <a class="el" href="SCFToOpenMP_8cpp_source.html">SCFToOpenMP.cpp</a>.</p>

</div>
</div>
<a id="a4fac2c28004ec7e1ee564a7c4f940444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fac2c28004ec7e1ee564a7c4f940444">&#9670;&nbsp;</a></span>createConvertSCFToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertSCFToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SCF ops into SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRVPass_8cpp_source.html#l00056">56</a> of file <a class="el" href="SCFToSPIRVPass_8cpp_source.html">SCFToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="ac85b8b89468b7fc2b347d361b512e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85b8b89468b7fc2b347d361b512e8d3">&#9670;&nbsp;</a></span>createConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00066">66</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="abc9ecc9afba558cb026032d0453a7c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ecc9afba558cb026032d0453a7c95">&#9670;&nbsp;</a></span>createConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00708">708</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

</div>
</div>
<a id="a41cd8a621caca1db19e02a6933d28fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cd8a621caca1db19e02a6933d28fb3">&#9670;&nbsp;</a></span>createConvertSPIRVToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertSPIRVToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SPIR-V operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVMPass_8cpp_source.html#l00056">56</a> of file <a class="el" href="SPIRVToLLVMPass_8cpp_source.html">SPIRVToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="a7a6b4be089f949bfd574dc18e61b5b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6b4be089f949bfd574dc18e61b5b75">&#9670;&nbsp;</a></span>createConvertTensorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertTensorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert Tensor ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRVPass_8cpp_source.html#l00053">53</a> of file <a class="el" href="TensorToSPIRVPass_8cpp_source.html">TensorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a1b33b7329a47c5c93a85bde3f6c743bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b33b7329a47c5c93a85bde3f6c743bc">&#9670;&nbsp;</a></span>createConvertVectorToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from vector to GPU ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l00556">556</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

</div>
</div>
<a id="afa5d0c2f42ef94e822f398d917b39184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5d0c2f42ef94e822f398d917b39184">&#9670;&nbsp;</a></span>createConvertVectorToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html#l00117">117</a> of file <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html">ConvertVectorToLLVMPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a4c2e8d8175dd430cb8048a29596d6ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2e8d8175dd430cb8048a29596d6ce3">&#9670;&nbsp;</a></span>createConvertVectorToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertVectorToROCDLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorToROCDL_8cpp_source.html#l00179">179</a> of file <a class="el" href="VectorToROCDL_8cpp_source.html">VectorToROCDL.cpp</a>.</p>

</div>
</div>
<a id="ac5c71e471d7d8cdda288a27d1ae75642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c71e471d7d8cdda288a27d1ae75642">&#9670;&nbsp;</a></span>createConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of vector ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01320">1320</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>, and <a class="el" href="VectorToSCF_8h_source.html#l00071">mlir::VectorTransferToSCFOptions::enableFullUnroll()</a>.</p>

</div>
</div>
<a id="a30e215016b82bc3a02bddb450f68fdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e215016b82bc3a02bddb450f68fdaf">&#9670;&nbsp;</a></span>createConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRVPass_8cpp_source.html#l00060">60</a> of file <a class="el" href="VectorToSPIRVPass_8cpp_source.html">VectorToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="aa85822fd77ee16dc5df2c93c9f56b4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85822fd77ee16dc5df2c93c9f56b4bf">&#9670;&nbsp;</a></span>createConvertVulkanLaunchFuncToVulkanCallsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertVulkanLaunchFuncToVulkanCallsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToVulkanCalls_8cpp_source.html#l00429">429</a> of file <a class="el" href="ConvertLaunchFuncToVulkanCalls_8cpp_source.html">ConvertLaunchFuncToVulkanCalls.cpp</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&nbsp;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00351">351</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="a0fcdb1d516a9d3198ae11daf05637b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdb1d516a9d3198ae11daf05637b05">&#9670;&nbsp;</a></span>createFoldReshapeOpsByLinearizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createFoldReshapeOpsByLinearizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7acfeadb8fff74a53be77ccf540be99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfeadb8fff74a53be77ccf540be99b">&#9670;&nbsp;</a></span>createForLoopPeelingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopPeelingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that peels for loops at their upper bounds for better vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00277">277</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a2a6597022fdb6de5a99b895b2bfc9e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6597022fdb6de5a99b895b2bfc9e0a">&#9670;&nbsp;</a></span>createForLoopRangeFoldingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopRangeFoldingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which folds arith ops on induction variable into loop range. </p>

<p class="definition">Definition at line <a class="el" href="LoopRangeFolding_8cpp_source.html#l00084">84</a> of file <a class="el" href="LoopRangeFolding_8cpp_source.html">LoopRangeFolding.cpp</a>.</p>

</div>
</div>
<a id="a1d49e4ae28aeaaa552466850cc5e04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49e4ae28aeaaa552466850cc5e04ec">&#9670;&nbsp;</a></span>createForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes for loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00273">273</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a76018eef454fd668d103ea3cc6afc52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76018eef454fd668d103ea3cc6afc52a">&#9670;&nbsp;</a></span>createForToWhileLoopPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForToWhileLoopPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ForToWhile_8cpp_source.html#l00112">112</a> of file <a class="el" href="ForToWhile_8cpp_source.html">ForToWhile.cpp</a>.</p>

</div>
</div>
<a id="a8bd2637570ab4c74519de8ed73747b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd2637570ab4c74519de8ed73747b5f">&#9670;&nbsp;</a></span>createGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites a function region so that GPU ops execute asynchronously. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00343">343</a> of file <a class="el" href="AsyncRegionRewriter_8cpp_source.html">AsyncRegionRewriter.cpp</a>.</p>

</div>
</div>
<a id="ae628f55b8a69b490ef848ceb63d234b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae628f55b8a69b490ef848ceb63d234b9">&#9670;&nbsp;</a></span>createGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dataLayoutStr</em> = <code>StringRef()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00390">390</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="a66200178a198c2f8aae15e94882f0788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66200178a198c2f8aae15e94882f0788">&#9670;&nbsp;</a></span>createGpuLauchSinkIndexComputationsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createGpuLauchSinkIndexComputationsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> that moves ops which are likely an index computation into gpu.launch body. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00385">385</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="a67c464614f40cbae1452d716d1a35636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c464614f40cbae1452d716d1a35636">&#9670;&nbsp;</a></span>createGpuSerializeToHsacoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createGpuSerializeToHsacoPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of the GPU kernel function to HSAco binary serialization pass. </p>

</div>
</div>
<a id="a56d2c4f2a1b6b34d83ef595b02236808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d2c4f2a1b6b34d83ef595b02236808">&#9670;&nbsp;</a></span>createGpuToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createGpuToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert a GPU operations into a sequence of GPU runtime calls. </p>
<p>This pass does not generate code to call GPU runtime APIs directly but instead uses a small wrapper library that exports a stable and conveniently typed ABI on top of GPU runtimes such as CUDA or ROCm (HIP). </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00876">876</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00756">756</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="a1372ce1294d9b98b652930aa6baf1386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1372ce1294d9b98b652930aa6baf1386">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the default inliner pipeline during optimization. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00760">760</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Inliner_8cpp_source.html#l00032">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a282d4666d1a10f4c41e6b114bf5e6a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d4666d1a10f4c41e6b114bf5e6a7f">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>defaultPipelineBuilder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the provided default pipeline builder. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00764">764</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="aacc6c56dc4a5f06f5a3dbff9a70f2126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc6c56dc4a5f06f5a3dbff9a70f2126">&#9670;&nbsp;</a></span>createLinalgBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations which work on tensors to use buffers instead. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00045">45</a> of file <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a888e0ad22e8609a0c5042ccecdb7adc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e0ad22e8609a0c5042ccecdb7adc7">&#9670;&nbsp;</a></span>createLinalgDetensorizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgDetensorizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to equivalent operations that work on primitive types, if possible. </p>

<p class="definition">Definition at line <a class="el" href="Detensorize_8cpp_source.html#l00554">554</a> of file <a class="el" href="Detensorize_8cpp_source.html">Detensorize.cpp</a>.</p>

</div>
</div>
<a id="aa174a4f487204b0e8221ed0ab2dfb737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa174a4f487204b0e8221ed0ab2dfb737">&#9670;&nbsp;</a></span>createLinalgElementwiseOpFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgElementwiseOpFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01747">1747</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="aa750e27e8b520efa98466e75aece0f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa750e27e8b520efa98466e75aece0f7b">&#9670;&nbsp;</a></span>createLinalgFoldUnitExtentDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00573">573</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

</div>
</div>
<a id="abbac2762b3662cb64525cf03fbf69f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac2762b3662cb64525cf03fbf69f83">&#9670;&nbsp;</a></span>createLinalgGeneralizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgGeneralizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert named Linalg operations to Linalg generic operations. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00089">89</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ae2f62eee11fc4d50304d949db78be4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f62eee11fc4d50304d949db78be4cc">&#9670;&nbsp;</a></span>createLinalgInitTensorEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgInitTensorEliminationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that tries to eliminate init_tensor ops that are anchored on insert_slice ops. </p>

<p class="definition">Definition at line <a class="el" href="InitTensorElimination_8cpp_source.html#l00048">48</a> of file <a class="el" href="InitTensorElimination_8cpp_source.html">InitTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="ae1086a21637aa5a39c59574052b80c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1086a21637aa5a39c59574052b80c17">&#9670;&nbsp;</a></span>createLinalgInlineScalarOperandsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgInlineScalarOperandsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00112">112</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

</div>
</div>
<a id="ad448648b1ff12e114f53247cbad44e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad448648b1ff12e114f53247cbad44e5c">&#9670;&nbsp;</a></span>createLinalgNamedOpConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgNamedOpConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NamedOpConversions_8cpp_source.html#l00158">158</a> of file <a class="el" href="NamedOpConversions_8cpp_source.html">NamedOpConversions.cpp</a>.</p>

</div>
</div>
<a id="a41f65cae8ffad8440599fe8550b95d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f65cae8ffad8440599fe8550b95d62">&#9670;&nbsp;</a></span>createLinalgPromotionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgPromotionPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamicBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00418">418</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="a4ff9ea093740aa2c290fa9c68fe92422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff9ea093740aa2c290fa9c68fe92422">&#9670;&nbsp;</a></span>createLinalgPromotionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgPromotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00421">421</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="ac639dc6b42b5f5478ad1c38c02fec31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639dc6b42b5f5478ad1c38c02fec31c">&#9670;&nbsp;</a></span>createLinalgStrategyDecomposePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyDecomposePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyDecomposePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00138">mlir::linalg::Decompose::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="a4787019742ca99ff270deb246fd2cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4787019742ca99ff270deb246fd2cd53">&#9670;&nbsp;</a></span>createLinalgStrategyEnablePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyEnablePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html">linalg::LinalgEnablingOptions</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html">linalg::LinalgEnablingOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyEnablePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::configurePassPipeline()</a>.</p>

</div>
</div>
<a id="a08e2d167c817c47333388491d1315416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e2d167c817c47333388491d1315416">&#9670;&nbsp;</a></span>createLinalgStrategyGeneralizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyGeneralizePass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyGeneralizePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00107">mlir::linalg::Generalize::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="aec40da96f981679ba8c2041787b038de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec40da96f981679ba8c2041787b038de">&#9670;&nbsp;</a></span>createLinalgStrategyInterchangePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyInterchangePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>iteratorInterchange</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyInterchangePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00124">mlir::linalg::Interchange::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="afd2c05cb94a4479a9c8b351f8b714802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2c05cb94a4479a9c8b351f8b714802">&#9670;&nbsp;</a></span>createLinalgStrategyLowerVectorsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyLowerVectorsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html">linalg::LinalgVectorLoweringOptions</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html">linalg::LinalgVectorLoweringOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyLowerVectorsPass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00177">mlir::linalg::VectorLowering::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="af2981e60ad32d264605bf2c8380b81e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2981e60ad32d264605bf2c8380b81e3">&#9670;&nbsp;</a></span>createLinalgStrategyPadPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyPadPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">linalg::LinalgPaddingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">linalg::LinalgPaddingOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyPadPass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00074">mlir::linalg::Pad::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="a4cec3ef5dec1e2cb120f09a8deda2891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cec3ef5dec1e2cb120f09a8deda2891">&#9670;&nbsp;</a></span>createLinalgStrategyPromotePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyPromotePass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">linalg::LinalgPromotionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">linalg::LinalgPromotionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyPromotePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00091">mlir::linalg::Promote::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="a3c6b1553c58aa431c610a488f8cc37ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6b1553c58aa431c610a488f8cc37ac">&#9670;&nbsp;</a></span>createLinalgStrategyRemoveMarkersPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgStrategyRemoveMarkersPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyRemoveMarkersPass. </p>

<p class="definition">Definition at line <a class="el" href="LinalgStrategyPasses_8cpp_source.html#l00534">534</a> of file <a class="el" href="LinalgStrategyPasses_8cpp_source.html">LinalgStrategyPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::configurePassPipeline()</a>.</p>

</div>
</div>
<a id="a37e18468e243694650c3609c28b180bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e18468e243694650c3609c28b180bc">&#9670;&nbsp;</a></span>createLinalgStrategyTileAndFusePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyTileAndFusePass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">linalg::LinalgTilingAndFusionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg strategy passes. </p>
<p>Create a LinalgStrategyTileAndFusePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00040">mlir::linalg::TileAndFuse::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="ad13f31d9a7e747fb08f033d2d5ffc02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13f31d9a7e747fb08f033d2d5ffc02b">&#9670;&nbsp;</a></span>createLinalgStrategyTilePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyTilePass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">linalg::LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">linalg::LinalgTilingOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyTilePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00057">mlir::linalg::Tile::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="a4bd3555e3f7e8942327aced220ac0719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd3555e3f7e8942327aced220ac0719">&#9670;&nbsp;</a></span>createLinalgStrategyVectorizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::createLinalgStrategyVectorizePass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>opName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>padVectorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LinalgStrategyVectorizePass. </p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8h_source.html#l00158">mlir::linalg::Vectorize::addToPassPipeline()</a>.</p>

</div>
</div>
<a id="aa789c41bff7faeb5252aba958a6fa088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa789c41bff7faeb5252aba958a6fa088">&#9670;&nbsp;</a></span>createLinalgTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLinalgTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">linalg::LinalgTilingLoopType</a>&#160;</td>
          <td class="paramname"><em>loopType</em> = <code><a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">linalg::LinalgTilingLoopType::Loops</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00495">495</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a7621ad17eef3b7af217a900ae413cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7621ad17eef3b7af217a900ae413cfa5">&#9670;&nbsp;</a></span>createLinalgToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createLinalgToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert Linalg ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToSPIRVPass_8cpp_source.html#l00049">49</a> of file <a class="el" href="LinalgToSPIRVPass_8cpp_source.html">LinalgToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a415fbf6253902c584461fa6a43a59ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fbf6253902c584461fa6a43a59ad5">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. If a 'tag' is non-empty, the generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. Otherwise, the existing locations are replaced. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00145">145</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="abb0bdadbeb0d7f5b8cef57668447640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0bdadbeb0d7f5b8cef57668447640b">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload utilizing pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00150">150</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="adcdbb1c14e39ed0e8e1166fe47f25477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdbb1c14e39ed0e8e1166fe47f25477">&#9670;&nbsp;</a></span>createLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms perfectly nested loops with independent bounds into a single loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopCoalescing_8cpp_source.html#l00100">100</a> of file <a class="el" href="LoopCoalescing_8cpp_source.html">LoopCoalescing.cpp</a>.</p>

</div>
</div>
<a id="a0878a54dd2448d8b22a1130e8a97f91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0878a54dd2448d8b22a1130e8a97f91e">&#9670;&nbsp;</a></span>createLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopFusionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximalFusion</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="namespacemlir.html#a6d4a641d6831cd23fcfd8e6d413acb0e">FusionMode</a>&#160;</td>
          <td class="paramname"><em>fusionMode</em> = <code>FusionMode::Greedy</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses loops according to type of fusion specified in <code>fusionMode</code>. </p>
<p>Buffers of size less than or equal to <code>localBufSizeThreshold</code> are promoted to memory space <code>fastMemorySpace</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00065">65</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00650">gatherProducerConsumerMemrefs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00160">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getEffect()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00138">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00474">mlir::Operation::getNumRegions()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00645">mlir::Operation::getUsers()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00271">mlir::Operation::isBeforeInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00771">print()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00569">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&nbsp;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00037">37</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="ad87a0ee58a5c3988f21bfca97f2e30e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87a0ee58a5c3988f21bfca97f2e30e6">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cacheSizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform tiling on loop nests. </p>
<p>Creates a pass to perform loop tiling on all suitable loop nests of a Function.</p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00057">57</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a17cabf83ed09306f486a7cc38b6c7403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cabf83ed09306f486a7cc38b6c7403">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00060">60</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a3d8635999f36d969f8cc9ebdb0f9448a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8635999f36d969f8cc9ebdb0f9448a">&#9670;&nbsp;</a></span>createLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unroll jam pass to unroll jam by the specified factor. </p>
<p>A factor of -1 lets the pass use the default factor or the one on the command line if provided. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00067">67</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="ae6cf2d54b2dd2f12fc29cb0f3ae34b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cf2d54b2dd2f12fc29cb0f3ae34b8a">&#9670;&nbsp;</a></span>createLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createLoopUnrollPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollFactor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollUpToFactor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollFull</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;&#160;</td>
          <td class="paramname"><em>getUnrollFactor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unrolling pass with the provided parameters. </p>
<p>'getUnrollFactor' is a function callback for clients to supply a function that computes an unroll factor - the callback takes precedence over unroll factors supplied through other means. If -1 is passed as the unrollFactor and no callback is provided, anything passed from the command-line (if at all) or the default unroll factor is used (LoopUnroll:kDefaultUnrollFactor). </p>

<p class="definition">Definition at line <a class="el" href="LoopUnroll_8cpp_source.html#l00135">135</a> of file <a class="el" href="LoopUnroll_8cpp_source.html">LoopUnroll.cpp</a>.</p>

</div>
</div>
<a id="ae09ce34232ab009ce688d7cdc63695a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09ce34232ab009ce688d7cdc63695a8">&#9670;&nbsp;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives). </p>
<p>Lowers If and For operations within a function into their lower level CFG equivalent blocks.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00566">566</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="ad62610c48d7b8e08dfd726bdb51d433e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62610c48d7b8e08dfd726bdb51d433e">&#9670;&nbsp;</a></span>createLowerGpuOpsToNVVMOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToNVVMOpsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00382">382</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

</div>
</div>
<a id="aa30bd4322234c02f64f7915f71c71f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30bd4322234c02f64f7915f71c71f5a">&#9670;&nbsp;</a></span>createLowerGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em> = <code>gpu::amd::Runtime::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00175">175</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="a712e219558e911fe489fefff81dd8365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712e219558e911fe489fefff81dd8365">&#9670;&nbsp;</a></span>createLowerHostCodeToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createLowerHostCodeToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to emulate <code>gpu.launch_func</code> call in <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and lower the host module code to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>This transformation creates a sequence of global variables that are later linked to the variables in the kernel module, and a series of copies to/from them to emulate the memory transfer from the host or to the device sides. It also converts the remaining Arithmetic, Func, and MemRef dialects into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, emitting C wrappers. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00313">313</a> of file <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html">ConvertLaunchFuncToLLVMCalls.cpp</a>.</p>

</div>
</div>
<a id="a988d57aaa8a2edf83eccef4145b4e2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988d57aaa8a2edf83eccef4145b4e2b9">&#9670;&nbsp;</a></span>createMemRefToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createMemRefToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l01983">1983</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a87060fc8d3ef747e189053c6bd556a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87060fc8d3ef747e189053c6bd556a5a">&#9670;&nbsp;</a></span>createOptReductionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createOptReductionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OptReductionPass_8cpp_source.html#l00086">86</a> of file <a class="el" href="OptReductionPass_8cpp_source.html">OptReductionPass.cpp</a>.</p>

</div>
</div>
<a id="a525d8e77b6503a81d7aa03b636c98e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525d8e77b6503a81d7aa03b636c98e2e">&#9670;&nbsp;</a></span>createParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopCollapsing_8cpp_source.html#l00043">43</a> of file <a class="el" href="ParallelLoopCollapsing_8cpp_source.html">ParallelLoopCollapsing.cpp</a>.</p>

</div>
</div>
<a id="ad00701d01638289dd08ec9e255076f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00701d01638289dd08ec9e255076f50">&#9670;&nbsp;</a></span>createParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00175">175</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a16b9f8678ec66eed9c66536834540184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f8678ec66eed9c66536834540184">&#9670;&nbsp;</a></span>createParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes parallel loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00269">269</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a213571bc56b32e75bc35cf02098982a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213571bc56b32e75bc35cf02098982a1">&#9670;&nbsp;</a></span>createParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noMinMaxBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tiles innermost parallel loops. </p>
<p>If noMinMaxBounds, the upper bound of the inner loop will be a same value among different outter loop iterations, and an additional inbound check will be emitted inside the internal loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00210">210</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

</div>
</div>
<a id="aa2f36107d7ffc6c1f873c746385d9de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f36107d7ffc6c1f873c746385d9de0">&#9670;&nbsp;</a></span>createParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts scf.parallel operations into a gpu.launch operation. </p>
<p>The mapping of loop dimensions to launch dimensions is derived from mapping attributes. See ParallelToGpuLaunchLowering::matchAndRewrite for a description of the used attributes. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00074">74</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="af882e712b4e426905d73c1c74bd0f353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af882e712b4e426905d73c1c74bd0f353">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l00946">946</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>.</p>

</div>
</div>
<a id="a3f2094c2e8b7d0cac9171ad4bee5609b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2094c2e8b7d0cac9171ad4bee5609b">&#9670;&nbsp;</a></span>createPipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createPipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00045">45</a> of file <a class="el" href="PipelineDataTransfer_8cpp_source.html">PipelineDataTransfer.cpp</a>.</p>

</div>
</div>
<a id="a045e1f32a8d90260d292aad61149c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045e1f32a8d90260d292aad61149c0ef">&#9670;&nbsp;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00318">318</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

</div>
</div>
<a id="a2d86bdab25e38eed8e3ab9a35012b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d86bdab25e38eed8e3ab9a35012b1e8">&#9670;&nbsp;</a></span>createPrintOpStatsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00083">83</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="aab06609d5a7ea6d475070dcc8d271725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06609d5a7ea6d475070dcc8d271725">&#9670;&nbsp;</a></span>createReconcileUnrealizedCastsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReconcileUnrealizedCastsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that eliminates noop <code>unrealized_conversion_cast</code> operation sequences. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00078">78</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a4ed5140e30c6e204e8bdc35d08d0eb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed5140e30c6e204e8bdc35d08d0eb08">&#9670;&nbsp;</a></span>createReductionTreePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createReductionTreePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8cpp_source.html#l00247">247</a> of file <a class="el" href="ReductionTreePass_8cpp_source.html">ReductionTreePass.cpp</a>.</p>

</div>
</div>
<a id="ad79c79f5d3c3fd8668be6d76e33bad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79c79f5d3c3fd8668be6d76e33bad9a">&#9670;&nbsp;</a></span>createRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00064">64</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="a6119493f8c83de427f34658e5e39cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119493f8c83de427f34658e5e39cbfe">&#9670;&nbsp;</a></span>createSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCCPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which performs sparse conditional constant propagation over nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SCCP_8cpp_source.html#l00258">258</a> of file <a class="el" href="SCCP_8cpp_source.html">SCCP.cpp</a>.</p>

</div>
</div>
<a id="a8c2a7464fefab1d85cec445e487f0d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2a7464fefab1d85cec445e487f0d0c">&#9670;&nbsp;</a></span>createSCFBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that bufferizes the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html#l00040">40</a> of file <a class="el" href="SCF_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="ac7f8ebf7a2133d1c68cea6e20fba0ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8ebf7a2133d1c68cea6e20fba0ea8">&#9670;&nbsp;</a></span>createSCFForLoopCanonicalizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFForLoopCanonicalizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that canonicalizes affine.min and affine.max operations inside of scf.for loops with known lower and upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00206">206</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

</div>
</div>
<a id="a801d4bb16485795a758c5c60d8413c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d4bb16485795a758c5c60d8413c6f">&#9670;&nbsp;</a></span>createShapeBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createShapeBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Shape_2Transforms_2Bufferize_8cpp_source.html#l00040">40</a> of file <a class="el" href="Shape_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a050e7653e9cef5f155370ca0425994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e7653e9cef5f155370ca0425994e9">&#9670;&nbsp;</a></span>createShapeToShapeLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createShapeToShapeLowering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Arithmetic. </p>
<p>For example, <code>shape.num_elements</code> get transformed to <code>shape.reduce</code>, which can be lowered to SCF and Arithmetic. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00079">79</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

</div>
</div>
<a id="aa270ad0c2440d049020def2b5e4810e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa270ad0c2440d049020def2b5e4810e7">&#9670;&nbsp;</a></span>createSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simplification pass for affine structures (maps and sets). </p>
<p>In addition, this pass also normalizes memrefs to have the trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00075">75</a> of file <a class="el" href="SimplifyAffineStructures_8cpp_source.html">SimplifyAffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">applyOpPatternsAndFold()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00362">mlir::Operation::getAttrs()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00057">mlir::Operation::getName()</a>.</p>

</div>
</div>
<a id="a50fe6af993ee7df395f88312234f0dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fe6af993ee7df395f88312234f0dc0">&#9670;&nbsp;</a></span>createSparseTensorConversionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00184">184</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="aa8654e2dbbf377b3df5383b90c7f9b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8654e2dbbf377b3df5383b90c7f9b2c">&#9670;&nbsp;</a></span>createSparseTensorConversionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparseTensorConversionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00188">188</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="ae0be4f778219bfb3917a2c7d3e7e1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be4f778219bfb3917a2c7d3e7e1bd0">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00175">175</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a11b0dcc4a707e4e560a7a2f69a95a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b0dcc4a707e4e560a7a2f69a95a7c9">&#9670;&nbsp;</a></span>createSparsificationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSparsificationPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00180">180</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a3b152134b4d44a148dac8bfc24070dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b152134b4d44a148dac8bfc24070dcd">&#9670;&nbsp;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00041">41</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

</div>
</div>
<a id="a20309ba42298497f0d990ff1b8830c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20309ba42298497f0d990ff1b8830c81">&#9670;&nbsp;</a></span>createSuperVectorizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createSuperVectorizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>virtualVectorSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01868">1868</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a24c2fd7a15cf4162323670dd676f855c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c2fd7a15cf4162323670dd676f855c">&#9670;&nbsp;</a></span>createSuperVectorizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::createSuperVectorizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01871">1871</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a69605e45210627de9b7fde4644fa50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69605e45210627de9b7fde4644fa50c1">&#9670;&nbsp;</a></span>createSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which delete symbol operations that are unreachable. </p>
<p>This pass may <em>only</em> be scheduled on an operation that defines a <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolDCE_8cpp_source.html#l00144">144</a> of file <a class="el" href="SymbolDCE_8cpp_source.html">SymbolDCE.cpp</a>.</p>

</div>
</div>
<a id="ae0b0f8a089ed821a240c7dd4e5573573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0f8a089ed821a240c7dd4e5573573">&#9670;&nbsp;</a></span>createSymbolPrivatizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolPrivatizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>excludeSymbols</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which marks top-level symbol operations as <code>private</code> unless listed in <code>excludeSymbols</code>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolPrivatize_8cpp_source.html#l00056">56</a> of file <a class="el" href="SymbolPrivatize_8cpp_source.html">SymbolPrivatize.cpp</a>.</p>

</div>
</div>
<a id="ae811b6513cd07f50d4b60bcd270d4171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae811b6513cd07f50d4b60bcd270d4171">&#9670;&nbsp;</a></span>createTensorBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTensorBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of <code>tensor</code> dialect bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2Bufferize_8cpp_source.html#l00048">48</a> of file <a class="el" href="Tensor_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a54881321f630a119cdee5af076de868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54881321f630a119cdee5af076de868d">&#9670;&nbsp;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00028">28</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>.</p>

</div>
</div>
<a id="a7dc425822a826dd76ea2e8185aeb9fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc425822a826dd76ea2e8185aeb9fab">&#9670;&nbsp;</a></span>defaultFilterFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::defaultFilterFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00091">91</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="ae28299bcd34ce71bd72f2a29478f06e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28299bcd34ce71bd72f2a29478f06e3">&#9670;&nbsp;</a></span>delinearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; int64_t, 4 &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>linearIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, returns the vector-space offsets in each dimension for a de-linearized index. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00021">21</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncParallelFor_8cpp_source.html#l00249">createParallelComputeFunction()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01356">foldExtractFromShapeCast()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00028">getVectorOffset()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>.</p>

</div>
</div>
<a id="a18ec51b29d236bdb33886fb9d6c8e002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ec51b29d236bdb33886fb9d6c8e002">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::dispatchIndexOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> into <code>staticVec</code> if: a) it is an IntegerAttr In other cases, the <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> is dispached to the <code>dynamicVec</code>. </p>
<p>In such dynamic cases, a copy of the <code>sentinel</code> value is also pushed to <code>staticVec</code>. This is useful to extract mixed static and dynamic entries that come from an AttrSizedOperandSegments trait. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">22</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="StaticValueUtils_8cpp_source.html#l00036">dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="a51331ef3eb49bd63cbbe47d2c33cf117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51331ef3eb49bd63cbbe47d2c33cf117">&#9670;&nbsp;</a></span>dispatchIndexOpFoldResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::dispatchIndexOpFoldResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>staticVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to dispatch multiple OpFoldResults according to the behavior of <code>dispatchIndexOpFoldResult(<a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> ofr</code> for a single <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00036">36</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">dispatchIndexOpFoldResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00076">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01383">mlir::tensor::createCanonicalRankReducingExtractSliceOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">322</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00027">acceptBitWidth()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00625">addRuntimePreemptionSpecifier()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02107">buildLLVMFunctionType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00132">buildSequentialConstant()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00441">buildUnresolvedTargetMaterialization()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00299">checkTensorElementType()</a>, <a class="el" href="PDLTypes_8cpp_source.html#l00060">mlir::pdl::PDLType::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00384">mlir::BoolAttr::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01238">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00033">computeConversionSet()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00567">mlir::LLVM::ModuleTranslation::convertBlock()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00596">convertOmpSections()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00405">mlir::spirv::Deserializer::processOp&lt; spirv::ControlBarrierOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00501">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00329">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00372">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00434">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00476">mlir::spirv::Deserializer::processOp&lt; spirv::MemoryBarrierOp &gt;()</a>, <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00096">mlir::ImplicitLocOpBuilder::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00140">mlir::detail::RecoveryReproducerContext::enable()</a>, <a class="el" href="OpDefinition_8h_source.html#l00114">mlir::OpState::erase()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00032">extractOpcode()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00228">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00180">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00116">findDuplicateElement()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01217">foldMemRefCast()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00773">forwardPassthroughAttributes()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00829">getCachedIntegerType()</a>, <a class="el" href="DLTI_8cpp_source.html#l00139">mlir::DataLayoutSpecAttr::getChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00045">mlir::LLVM::LLVMArrayType::getChecked()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00045">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00108">mlir::LLVM::LLVMFunctionType::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00253">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00179">mlir::LLVM::LLVMPointerType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00225">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00724">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00261">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00138">mlir::DynamicType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00313">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00617">mlir::LLVM::LLVMFixedVectorType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00375">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00654">mlir::LLVM::LLVMScalableVectorType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01090">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="OpImplementation_8h_source.html#l00636">mlir::AsmParser::getChecked()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01027">mlir::detail::getDefaultDiagnosticEmitFn()</a>, <a class="el" href="SerializeToBlob_8cpp_source.html#l00108">mlir::gpu::SerializeToBlobPass::getDependentDialects()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00972">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00738">getElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00140">mlir::FloatType::getFPMantissaWidth()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00370">mlir::LLVM::LLVMStructType::getIdentifiedChecked()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00399">mlir::LLVM::LLVMStructType::getLiteralChecked()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00699">getLLVMAtomicOrdering()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00273">mlir::LLVM::detail::getLLVMConstant()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00716">getLoadStoreElementType()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">getMemRefSizeInBytes()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00410">mlir::LLVM::LLVMStructType::getOpaqueChecked()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00629">getOrInsertBuiltinVariable()</a>, <a class="el" href="IR_8cpp_source.html#l00284">inferOperationTypes()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00307">mlir::TensorType::isValidElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01872">isZeroAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="Verifier_8cpp_source.html#l00099">mayBeValidWithoutTerminator()</a>, <a class="el" href="CAPI_2IR_2Diagnostics_8cpp_source.html#l00077">mlirEmitError()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">mlirReduceMain()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00167">mlir::LLVM::LLVMFunctionType::params()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00684">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="OpImplementation_8h_source.html#l00664">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00953">mlir::AsmParser::parseColonType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00728">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l00905">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00237">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00280">mlir::detail::Parser::parseExtendedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00555">mlir::AsmParser::parseInteger()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00693">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="OpImplementation_8h_source.html#l00485">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00513">mlir::AsmParser::parseKeywordOrString()</a>, <a class="el" href="OpImplementation_8h_source.html#l00567">mlir::AsmParser::parseOptionalInteger()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00057">mlir::detail::Parser::parsePrettyDialectSymbolName()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04322">parsePtrAccessChainOpImpl()</a>, <a class="el" href="OpImplementation_8h_source.html#l00474">mlir::AsmParser::parseString()</a>, <a class="el" href="OpImplementation_8h_source.html#l00845">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpImplementation_8h_source.html#l00876">mlir::AsmParser::parseType()</a>, <a class="el" href="DLTI_8cpp_source.html#l00301">mlir::DataLayoutSpecAttr::print()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00298">printAsyncDependencies()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">printAtomicReductionRegion()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00043">printNVVMIntrinsicOp()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00593">printOperation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00351">printSwitchOpCases()</a>, <a class="el" href="Serializer_8cpp_source.html#l00135">mlir::spirv::Serializer::printValueIDMap()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00092">processBuffer()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Lexer_8h_source.html#l00191">mlir::pdll::Lexer::resetPointer()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="OpImplementation_8h_source.html#l01169">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Serializer_8cpp_source.html#l00273">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00250">mlir::detail::ElementsAttrRange&lt; IteratorT &gt;::size()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00057">translateDataLayout()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01127">translateLLVMIRToModule()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01158">translateLLVMIRToModule()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00032">mlir::quant::QuantizedType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00166">mlir::spirv::InterfaceVarABIAttr::verify()</a>, <a class="el" href="DLTI_8cpp_source.html#l00146">mlir::DataLayoutSpecAttr::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00059">mlir::LLVM::LLVMArrayType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00262">mlir::spirv::VerCapExtAttr::verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00067">mlir::gpu::MMAMatrixType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00142">mlir::LLVM::LLVMFunctionType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00344">mlir::spirv::TargetEnvAttr::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00200">mlir::LLVM::LLVMPointerType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00732">mlir::spirv::SampledImageType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00441">mlir::LLVM::LLVMStructType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00637">mlir::LLVM::LLVMFixedVectorType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00383">mlir::quant::CalibratedQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01096">mlir::spirv::MatrixType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00677">mlir::LLVM::LLVMScalableVectorType::verify()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00081">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01174">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03767">verifyCoopMatrixMulAdd()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00474">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00330">mlir::LLVM::LLVMPointerType::verifyEntries()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00562">mlir::LLVM::LLVMStructType::verifyEntries()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00341">verifyNumBlockArgs()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01238">verifyRegionAttribute()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">verifyReshapeLikeTypes()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00440">verifySynchronizationHint()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00599">verifyVectorConstructionInvariants()</a>, and <a class="el" href="SerializeOps_8cpp_source.html#l00042">visitInPrettyBlockOrder()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00323">323</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00300">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00486">emitOptionalError()</a>.</p>

</div>
</div>
<a id="affdaf0aee1c1669e8b822bf98297b85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdaf0aee1c1669e8b822bf98297b85f">&#9670;&nbsp;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported. ">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00486">486</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00323">emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00449">mlir::vector::getVectorReductionOp()</a>.</p>

</div>
</div>
<a id="ab27e629384a23b9991e36201d87de462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e629384a23b9991e36201d87de462">&#9670;&nbsp;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00498">498</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00339">emitRemark()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="a665c32efa8059ae855341f4946f7497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c32efa8059ae855341f4946f7497c">&#9670;&nbsp;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00492">492</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00331">emitWarning()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00336">336</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00104">mlir::ImplicitLocOpBuilder::emitRemark()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00252">mlir::Operation::emitRemark()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00114">mlir::OpState::erase()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00339">339</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00300">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00498">emitOptionalRemark()</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">328</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ImplicitLocOpBuilder_8h_source.html#l00100">mlir::ImplicitLocOpBuilder::emitWarning()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00243">mlir::Operation::emitWarning()</a>, <a class="el" href="OpDefinition_8h_source.html#l00114">mlir::OpState::erase()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00331">331</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00300">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00492">emitOptionalWarning()</a>.</p>

</div>
</div>
<a id="ab8075944125730fed529e3b93dcfed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8075944125730fed529e3b93dcfed5b">&#9670;&nbsp;</a></span>encodeBindAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::encodeBindAttribute </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes global variable's descriptor set and binding into its name if they both exist. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01578">1578</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01576">kBinding</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01577">kDescriptorSet</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00962">mlir::SymbolTable::replaceAllSymbolUses()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00214">mlir::SymbolTable::setSymbolName()</a>.</p>

</div>
</div>
<a id="a47f2978611fa2c3143d6ea5ea01cd041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f2978611fa2c3143d6ea5ea01cd041">&#9670;&nbsp;</a></span>eraseStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::eraseStridedLayout </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with a layout that has all dynamic offset and strides. </p>
<p>This is used to erase the static layout. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00982">982</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">makeStridedLinearLayoutMap()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00186">mlir::MemRefType::Builder::setLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>, and <a class="el" href="LinalgToStandard_8cpp_source.html#l00026">extractOperandTypes()</a>.</p>

</div>
</div>
<a id="a6ab9585c8607c12142232e0f58ebcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9585c8607c12142232e0f58ebcc8b">&#9670;&nbsp;</a></span>eraseUnreachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::eraseUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the unreachable blocks within the provided regions. </p>
<p>Returns success if any blocks were erased, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00079">79</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::end()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00265">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00730">simplifyRegions()</a>.</p>

</div>
</div>
<a id="ab9dbba661e76a7e45c145e652fbcc853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dbba661e76a7e45c145e652fbcc853">&#9670;&nbsp;</a></span>expandAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">mlir::Value</a> mlir::expandAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dimValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>symbolValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values. </p>
<p>Create a sequence of operations that implement the <code>expr</code> applied to the given dimension and symbol values.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00215">215</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00223">expandAffineMap()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00090">lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="ae58c2a14651ef626d0d9fcee46698032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58c2a14651ef626d0d9fcee46698032">&#9670;&nbsp;</a></span>expandAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt; mlir::expandAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>affineMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00223">223</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00215">expandAffineExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, and <a class="el" href="namespacemlir_1_1presburger.html#a12e7fe91c72844f54ad9361f279ad2b3a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00090">lowerAffineLowerBound()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00061">lowerAffineMapMax()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00071">lowerAffineMapMin()</a>.</p>

</div>
</div>
<a id="aecdaa20d0acb7aec0f05cb700b1e09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaa20d0acb7aec0f05cb700b1e09df">&#9670;&nbsp;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootFOrOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00885">885</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00251">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00780">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01697">tile()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00758">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="a13093ebea6c814674ee1668daf5f81f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13093ebea6c814674ee1668daf5f81f8">&#9670;&nbsp;</a></span>extractForInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::extractForInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forInsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>. </p>
<p>Extracts the induction variables from a list of AffineForOps and returns them.</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01959">1959</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02333">getFullMemRefAsRegion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">getIndexSet()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00860">tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00904">tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a48355da3ce92decf18a91c2148e3d4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48355da3ce92decf18a91c2148e3d4c6">&#9670;&nbsp;</a></span>extractFromI64ArrayAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::extractFromI64ArrayAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract int64_t values from the assumed ArrayAttr of IntegerAttr. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00045">45</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00130">mlir::Attribute::cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00033">replaceUsesAndPropagateType()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l01442">verifyInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a3083728e72d361c987c5e5a0e8d2f39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083728e72d361c987c5e5a0e8d2f39a">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00036">36</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00974">mlir::ParallelDiagnosticHandler::eraseOrderIDForThread()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00544">mlir::MLIRContext::getThreadPool()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00486">mlir::MLIRContext::isMultithreadingEnabled()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00186">min()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00968">mlir::ParallelDiagnosticHandler::setOrderIDForThread()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00095">failableParallelForEach()</a>, <a class="el" href="Threading_8h_source.html#l00110">failableParallelForEachN()</a>, <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, and <a class="el" href="Threading_8h_source.html#l00122">parallelForEach()</a>.</p>

</div>
</div>
<a id="a98aa0f01173a481075d9d5a2ca50d8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aa0f01173a481075d9d5a2ca50d8ab">&#9670;&nbsp;</a></span>failableParallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00095">95</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="af5aa5179ec6f13db4eaa8fa255bde665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa5179ec6f13db4eaa8fa255bde665">&#9670;&nbsp;</a></span>failableParallelForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failableParallelForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>If the given function returns a failure when processing any of the elements, execution is stopped and a failure is returned from this function. This means that in the case of failure, not all elements of the range will be processed. Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00110">110</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>.</p>

</div>
</div>
<a id="aeec13ab4fb753865cdfd2699aa01c23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec13ab4fb753865cdfd2699aa01c23b">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::failed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a> corresponds to a failure value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00072">72</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00044">mlir::LogicalResult::failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00027">acceptBitWidth()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00587">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00639">mlir::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">mlir::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Simplex_8cpp_source.html#l01076">mlir::presburger::Simplex::addInequality()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00625">addRuntimePreemptionSpecifier()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">mlir::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00915">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01024">affineScalarReplace()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00880">mlir::bufferization::analyzeOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00650">analyzeProfitability()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">applyOpPatternsAndFold()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00743">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00059">applyTilingToAll()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00124">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="OpDefinition_8h_source.html#l01685">mlir::Op&lt; AffineDmaWaitOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResult, OpTrait::OpInvariants, AffineMapAccessInterface::Trait &gt;::attachInterface()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00222">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00403">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">mlir::bufferization::bufferizeOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="PatternMatch_8h_source.html#l01175">mlir::detail::pdl_function_builder::buildConstraintFn()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02107">buildLLVMFunctionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00372">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00263">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00115">castDataPtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00023">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">mlir::linalg::LinalgTransformationFilter::checkAndNotify()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00071">checkAndUpdateCapabilityRequirements()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00184">checkDoubleConsume()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00442">checkIfHyperRectangular()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">checkMemrefAccessDependence()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01238">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00538">mlir::presburger::SetCoalescer::coalesce()</a>, <a class="el" href="MLIRGen_8cpp_source.html#l00599">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00090">mlir::spirv::combine()</a>, <a class="el" href="DLTI_8cpp_source.html#l00246">mlir::DataLayoutSpecAttr::combineWith()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">mlir::FlatAffineValueConstraints::composeMatchingMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01818">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00033">computeConversionSet()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01703">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="Simplex_8cpp_source.html#l01328">mlir::presburger::Simplex::computeOptimum()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00216">mlir::presburger::computeSingleVarRepr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01310">mlir::presburger::IntegerRelation::constantFoldIdRange()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00039">mlir::detail::constructContainerOpForParserIfNecessary()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00283">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00567">mlir::LLVM::ModuleTranslation::convertBlock()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03051">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01330">mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature()</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00159">convertCmpPredicate()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00279">convertDataOp()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00209">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01370">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01111">convertOmpAtomicCapture()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01040">convertOmpAtomicUpdate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00122">convertOmpOpRegions()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01208">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00888">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00682">convertOmpWsLoop()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01355">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03018">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03033">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00431">convertStandaloneDataOp()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02985">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02995">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="FoldUtils_8h_source.html#l00069">mlir::OperationFolder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00538">mlir::bufferization::createAllocDeallocOps()</a>, <a class="el" href="PassOptions_8h_source.html#l00329">mlir::PassPipelineOptions&lt; SparseCompilerOptions &gt;::createFromString()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00533">mlir::LLVM::detail::createIntrinsicCall()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00655">mlir::bufferization::deallocateBuffers()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00015">mlir::spirv::deserialize()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00062">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="Simplex_8cpp_source.html#l01394">mlir::presburger::Simplex::detectRedundant()</a>, <a class="el" href="Verifier_8cpp_source.html#l00274">diagnoseInvalidOperandDominance()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00649">doSequentialDispatch()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00066">doubleBuffer()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01578">encodeBindAttribute()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="LogicalResult_8h_source.html#l00081">mlir::FailureOr&lt; T &gt;::FailureOr()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00260">mlir::bufferization::finalizeBuffers()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00180">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="Simplex_8cpp_source.html#l00285">mlir::presburger::LexSimplex::findIntegerLexMin()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00079">findOptimal()</a>, <a class="el" href="Simplex_8cpp_source.html#l00214">mlir::presburger::LexSimplex::findRationalLexMin()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00152">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">mlir::FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01231">mlir::AffineDmaWaitOp::fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00773">forwardPassthroughAttributes()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00056">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00662">funcsToCoroutines()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00042">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02573">generateCopyForMemRegion()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00118">generateLocationsFromIR()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00826">mlir::SPIRVConversionTarget::get()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01484">mlir::FlatAffineValueConstraints::getAsIntegerSet()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00153">getBlockIt()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00274">mlir::bufferization::BufferizationState::getBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00155">getCastCompatibleMemRefType()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00157">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00253">mlir::DynamicAttr::getChecked()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00138">mlir::DynamicType::getChecked()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00242">getDefaultABIAttrs()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00791">mlir::spirv::getElementPtr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00972">getElementPtrType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00971">mlir::spirv::StructType::getEmpty()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00044">mlir::transform::TransformState::getHandleForPayloadOp()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00097">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">getIndexSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01438">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="MLIRServer_8cpp_source.html#l00179">getLspDiagnoticFromDiag()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01287">getMemoryFootprintBytes()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00059">getMemrefConstantHorizontalStride()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">getMemRefSizeInBytes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00333">mlir::OpPassManager::getNesting()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00376">mlir::LLVM::LLVMStructType::getNewIdentified()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01018">getOffsetExpr()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02970">getOption()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00199">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00110">getPermutationMapAttr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">getRelationFromMap()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01574">mlir::ConversionPatternRewriter::getRemappedValue()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01008">getStridedLinearLayoutMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00192">getTypeNumBytes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="PassOptions_8h_source.html#l00230">mlir::detail::PassOptions::ListOption&lt; DataType, OptionParser &gt;::handleOccurrence()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00984">hasAtMostSingleNonScalar()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00168">HoistingAnalysis::HoistingAnalysis()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00397">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00179">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02356">inferStridedSliceOpResultType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00332">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00418">inlineConvertOmpRegions()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00685">inPlaceAnalysis()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00411">isAsyncWithOneDependency()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00258">isConvolutionInterfaceImpl()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00541">isDefinedByCallTo()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01125">isLastMemrefDimUnitStride()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00307">mlir::TensorType::isValidElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01872">isZeroAttribute()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00314">JitRunnerMain()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02696">legalizeUnresolvedMaterialization()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00315">mlir::SymbolTable::lookupSymbolIn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00991">mlir::SymbolTableCollection::lookupSymbolIn()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00183">lowerAsEntryFunction()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02141">makeI64ArrayAttr()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00030">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00017">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00126">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00169">mlir::ConvertOpToLLVMPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00353">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01176">mlir::vector::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00387">ConvertStore::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01405">mlir::vector::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00438">mlir::OpConversionPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01439">mlir::vector::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00483">mlir::OpInterfaceConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00731">mlir::linalg::LinalgVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01105">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00922">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01688">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02830">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="Verifier_8cpp_source.html#l00099">mayBeValidWithoutTerminator()</a>, <a class="el" href="CAPI_2Interfaces_2Interfaces_8cpp_source.html#l00038">mlirInferTypeOpInterfaceInferReturnTypes()</a>, <a class="el" href="IR_8cpp_source.html#l00315">mlirOperationCreate()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">mlirReduceMain()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01481">NAryInferReturnTypes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">normalizeMemRef()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">normalizeMemRefType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00117">mlir::ParseResult::operator bool()</a>, <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00049">GpuAsyncRegionPass::ThreadTokenCallback::operator()()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00289">mlir::detail::ElementsAttrRange&lt; IteratorT &gt;::operator[]()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00203">outlineIfOp()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00169">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="DLTI_8cpp_source.html#l00068">mlir::DataLayoutEntryAttr::parse()</a>, <a class="el" href="DLTI_8cpp_source.html#l00280">mlir::DataLayoutSpecAttr::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00115">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; std::is_member_function_pointer&lt; decltype(&amp;ContainerT::push_back)&gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00257">mlir::vector::CombiningKindAttr::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="PassOptions_8h_source.html#l00360">llvm::cl::detail::VectorParserBase&lt; SmallVector&lt; T, N &gt;, T &gt;::parse()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00476">parseAndVerify&lt; unsigned &gt;()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00285">parseArrayType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00866">parseAttributions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01341">parseBound()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00300">parseCalibratedType()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00145">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00102">parseCreateOperationOpResults()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00375">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00421">parseElementAttrHexValues()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00097">parseExpressedTypeAndRange()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00301">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00539">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00902">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00876">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00513">mlir::AsmParser::parseKeywordOrString()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00194">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00056">parseOperandList()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00108">parseOperandsOrIntegersImpl()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00401">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDictWithKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00567">mlir::AsmParser::parseOptionalInteger()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01785">parseOptionalLLVMKeyword()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00672">parsePassPipeline()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00165">parseQuantParams()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00387">parseRuntimeArrayType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00536">parseSizeAssignment()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00139">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">parseSourceString()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00066">parseStorageRange()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00564">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00628">parseStructType()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00480">parseSwitchOpCases()</a>, <a class="el" href="OpImplementation_8h_source.html#l00845">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00381">parseSynchronizationHint()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00372">mlir::detail::Parser::parseTensorType()</a>, <a class="el" href="OpImplementation_8h_source.html#l01143">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="PassRegistry_8h_source.html#l00164">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00047">performActions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00539">populateAffineToVectorConversionPatterns()</a>, <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00811">mlir::arith::populateArithmeticToSPIRVPatterns()</a>, <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00077">populateBufferizationToMemRefConversionPatterns()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00302">populateComplexToLLVMConversionPatterns()</a>, <a class="el" href="ComplexToStandard_8cpp_source.html#l00709">populateComplexToStandardConversionPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00106">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00039">populateConvertShapeConstraintsConversionPatterns()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00116">mlir::linalg::populateElementwiseToLinalgConversionPatterns()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00070">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00114">mlir::linalg::populateLinalgToStandardConversionPatterns()</a>, <a class="el" href="MathToLibm_8cpp_source.html#l00116">populateMathToLibmConversionPatterns()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>, <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00140">populateOpenACCToLLVMConversionPatterns()</a>, <a class="el" href="OpenACCToSCF_8cpp_source.html#l00051">populateOpenACCToSCFConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00130">mlir::memref::populateResolveShapedTypeResultDimsPatterns()</a>, <a class="el" href="SCFToControlFlow_8cpp_source.html#l00615">populateSCFToControlFlowConversionPatterns()</a>, <a class="el" href="DecorateCompositeTypeLayoutPass_8cpp_source.html#l00091">populateSPIRVLayoutInfoPatterns()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00149">populateVectorToROCDLConversionPatterns()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01093">prepareLLVMModule()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00563">printGEPIndices()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01574">mlir::AsmPrinter::Impl::printLocation()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00315">printOperation()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02825">printTransferAttrs()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00197">processDataOperands()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="Promotion_8cpp_source.html#l00251">promoteSubViews()</a>, <a class="el" href="Transport_8cpp_source.html#l00265">readLine()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00026">mlir::ReductionNode::ReductionNode()</a>, <a class="el" href="Translation_8cpp_source.html#l00057">registerTranslateToMLIRFunction()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01255">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01254">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00074">reshapeLowerToHigher()</a>, <a class="el" href="AsmParserState_8cpp_source.html#l00070">mlir::AsmParserState::Impl::resolveSymbolUses()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00470">mlir::linalg::LinalgTilingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00508">mlir::linalg::LinalgPaddingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00580">mlir::linalg::LinalgTileAndFuseTensorOpsPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00646">mlir::linalg::GenericOpInterchangePattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00674">mlir::linalg::LinalgGeneralizationPattern::returningMatchAndRewrite()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00151">rewriteAffineOpAfterPeeling()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00255">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00657">mlir::PassManager::run()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00938">mlir::bufferization::runOneShotBufferize()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00418">mlir::bufferization::runOneShotModuleBufferize()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00542">mlir::detail::OpToOpPassAdaptor::runOnOperation()</a>, <a class="el" href="Inliner_8cpp_source.html#l00287">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02790">separateFullTiles()</a>, <a class="el" href="Serializer_8cpp_source.html#l00086">mlir::spirv::Serializer::serialize()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00083">serializeModule()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00666">mlir::spirv::Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00639">mlir::spirv::Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="Serializer_8cpp_source.html#l00273">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="SerializeToBlob_8cpp_source.html#l00035">mlir::gpu::SerializeToBlobPass::SerializeToBlobPass()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00492">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, <a class="el" href="Fusion_8cpp_source.html#l00819">tileAndFuseLinalgOpsImpl()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00424">mlir::linalg::tileConsumerAndFuseProducers()</a>, <a class="el" href="Tiling_8cpp_source.html#l00284">tilePadOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00860">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00904">tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00057">translateDataLayout()</a>, <a class="el" href="Translation_8cpp_source.html#l00091">mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01127">translateLLVMIRToModule()</a>, <a class="el" href="Builders_8cpp_source.html#l00398">mlir::OpBuilder::tryFold()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00070">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00085">updateCalls()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00051">updateSymbolAndAllUses()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01858">vectorizeAffineLoopNest()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01656">vectorizeLoops()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00595">vectorizeStaticLinalgOpPrecondition()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="PatternMatch_8h_source.html#l00885">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, Type &gt;::verifyAsArg()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00822">verifyAtomicUpdateOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00094">verifyCompatibleShapes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03767">verifyCoopMatrixMulAdd()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00311">mlir::detail::verifyDataLayoutOp()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00474">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01057">mlir::OpTrait::impl::verifyElementwise()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00898">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00206">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00667">verifyMemoryOpMetadata()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00341">verifyNumBlockArgs()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">mlir::detail::verifyOffsetSizeAndStrideOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01310">verifyOpAndAdjustFlags()</a>, <a class="el" href="OpDefinition_8h_source.html#l00902">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::verifyRegionTrait()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00180">verifyResultTypesAreInferrable()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00874">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00845">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00860">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00835">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00595">mlir::linalg::detail::verifyStructuredOpInterface()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00617">verifySymbolAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>, <a class="el" href="FunctionInterfaces_8h_source.html#l00209">mlir::function_interface_impl::verifyTrait()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00159">mlir::detail::verifyTypesAlongControlFlowEdges()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03714">verifyVectorMemoryOp()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00042">visitInPrettyBlockOrder()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00054">walkReferenceCountedValues()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00067">walkReturnOperations()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a07367c8c4a3d4a47a32bc2b9b7d8a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">&#9670;&nbsp;</a></span>failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFailure</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a>. </p>
<p>If isFailure is true a <code>failure</code> result is generated, otherwise a 'success' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00062">62</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00036">mlir::LogicalResult::failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00570">ableToUpdatePredOperands()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00027">acceptBitWidth()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00587">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00639">mlir::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00625">addRuntimePreemptionSpecifier()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">mlir::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00915">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00348">affineParallelize()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00880">mlir::bufferization::analyzeOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00650">analyzeProfitability()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00743">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00059">applyTilingToAll()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00124">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="OpDefinition_8h_source.html#l01685">mlir::Op&lt; AffineDmaWaitOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResult, OpTrait::OpInvariants, AffineMapAccessInterface::Trait &gt;::attachInterface()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00562">barePtrFuncArgTypeConverter()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01326">bindShapeDims()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00222">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00374">mlir::bufferization::func_ext::ReturnOpInterface::bufferize()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">mlir::bufferization::bufferizeOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01175">mlir::detail::pdl_function_builder::buildConstraintFn()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02107">buildLLVMFunctionType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00441">buildUnresolvedTargetMaterialization()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03277">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01631">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02775">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00263">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">canonicalizeSetAndOperands()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00145">castBoolToIntN()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00115">castDataPtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00023">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">mlir::linalg::LinalgTransformationFilter::checkAndNotify()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00067">checkCapabilityRequirements()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00184">checkDoubleConsume()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00039">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00442">checkIfHyperRectangular()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00538">mlir::presburger::SetCoalescer::coalesce()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01720">coalesceLoops()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00098">collapseBranch()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00039">collectValidReferencesFor()</a>, <a class="el" href="DLTI_8cpp_source.html#l00192">combineOneSpec()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">mlir::FlatAffineValueConstraints::composeMatchingMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01818">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00033">computeConversionSet()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01703">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00042">computeReshapeOutput()</a>, <a class="el" href="Simplex_8cpp_source.html#l00507">mlir::presburger::SymbolicLexSimplex::computeSymbolicIntegerLexMin()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00150">computeTransposedType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00331">mlir::AffineMap::constantFold()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01297">mlir::presburger::IntegerRelation::constantFoldId()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00283">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00567">mlir::LLVM::ModuleTranslation::convertBlock()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03051">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01330">mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00279">convertDataOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01370">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00122">convertOmpOpRegions()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00563">convertOmpOrderedRegion()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01208">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00888">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00682">convertOmpWsLoop()</a>, <a class="el" href="LLVMTranslationInterface_8h_source.html#l00043">mlir::LLVMTranslationDialectInterface::convertOperation()</a>, <a class="el" href="LLVMTranslationInterface_8h_source.html#l00071">mlir::LLVMTranslationInterface::convertOperation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00256">convertOperationImpl()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01355">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03018">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03033">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00431">convertStandaloneDataOp()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00222">convertToLaunchFuncOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02995">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00227">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00031">createDeviceFunctionCall()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00655">mlir::bufferization::deallocateBuffers()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00237">declareReduction()</a>, <a class="el" href="DecodeAttributesInterfaces_8h_source.html#l00029">mlir::DialectDecodeAttributesInterface::decode()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00062">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="Verifier_8cpp_source.html#l00274">diagnoseInvalidOperandDominance()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00649">doSequentialDispatch()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00035">dropRefIfNoUses()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00625">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00337">mlir::linalg::eliminateInitTensors()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00486">emitOptionalError()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00498">emitOptionalRemark()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00492">emitOptionalWarning()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00703">extractStrides()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00133">extractValueFromConstOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00260">mlir::bufferization::finalizeBuffers()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00180">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>, <a class="el" href="Fusion_8cpp_source.html#l00277">findFusableProducer()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02855">findLiveUserOfReplaced()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00144">findOptimal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">mlir::FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="FoldInterfaces_8h_source.html#l00034">mlir::DialectFoldInterface::fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01231">mlir::AffineDmaWaitOp::fold()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00496">mlir::Operation::fold()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01153">mlir::impl::foldCastInterfaceOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01084">foldExtractOpFromExtractChain()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01456">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01335">foldIdentityOffsetSizeAndStrideOpInterface()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01217">foldMemRefCast()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="OpDefinition_8h_source.html#l01501">mlir::op_definition_impl::foldTrait()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00773">forwardPassthroughAttributes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00662">funcsToCoroutines()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00354">fuseElementwiseOps()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00328">mlir::linalg::TileLoopNest::fuseProducer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00335">mlir::linalg::fuseProducerOfBuffer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00405">mlir::linalg::fuseProducerOfTensor()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00032">generalizeNamedOpPrecondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02573">generateCopyForMemRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01508">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00325">mlir::DynamicOpDefinition::get()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00213">getAllocEffectFor()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="SplitPadding_8cpp_source.html#l00036">getAsValue()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00153">getBlockIt()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00274">mlir::bufferization::BufferizationState::getBuffer()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01005">getCollapsableIterationSpaceDims()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00264">mlir::linalg::getConstantUpperBoundForIndex()</a>, <a class="el" href="Fusion_8cpp_source.html#l00482">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00242">getDefaultABIAttrs()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00090">getDivRepr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00972">getElementPtrType()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00214">mlir::spirv::getExecutionModel()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00908">getF64Values()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00032">getFirstIntValue()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="BufferUtils_8cpp_source.html#l00149">mlir::bufferization::getGlobalFor()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00044">mlir::transform::TransformState::getHandleForPayloadOp()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00097">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">getIndexSet()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01360">getInsertExtractValueElementType()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00071">getInterfaceVariables()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00068">getLdMatrixIntrinsicId()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00699">getLLVMAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00716">getLoadStoreElementType()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00225">mlir::spirv::getMemoryModel()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00081">getMemRefAlignment()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">getMemRefSizeInBytes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00333">mlir::OpPassManager::getNesting()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00199">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00110">getPermutationMapAttr()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00465">getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">getRelationFromMap()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="DataFlowAnalysis_8h_source.html#l00340">mlir::ForwardDataFlowAnalysis&lt; ValueT &gt;::getSuccessorsForOperands()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00449">mlir::vector::getVectorReductionOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00168">HoistingAnalysis::HoistingAnalysis()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00716">hoistOpsBetween()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00397">mlir::linalg::hoistPaddingOnTensors()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00100">inferDynamicDimsForConv()</a>, <a class="el" href="IR_8cpp_source.html#l00284">inferOperationTypes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00179">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02356">inferStridedSliceOpResultType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00332">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00418">inlineConvertOmpRegions()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00685">inPlaceAnalysis()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Interchange_8cpp_source.html#l00037">interchangeGenericOpPrecondition()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00411">isAsyncWithOneDependency()</a>, <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00270">isBoolScalarOrVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00541">isDefinedByCallTo()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00453">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00194">isInBounds()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="Simplex_8cpp_source.html#l00351">isRangeDivisibleBy()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00081">isSumOfMul()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00307">mlir::TensorType::isValidElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01872">isZeroAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02696">legalizeUnresolvedMaterialization()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00031">loadModule()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00325">lookupSymbolInImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00975">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">lowerAffineLowerBound()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02141">makeI64ArrayAttr()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00030">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00017">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00026">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00097">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00039">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00040">InnerOuterDimReductionConversion::matchAndRewrite()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00126">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00060">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00100">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00112">ReduceMultiDimReductionRank::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00116">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00125">ReshapeReshapeOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00148">TransferWritePermutationLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00156">SingleBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00169">mlir::ConvertOpToLLVMPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00173">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00196">ConstantTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00203">Convert1DExtractStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00205">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00208">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00223">TwoDimMultiReductionToElementWise::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00229">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00248">DecomposeNDExtractStridedSlice::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00259">NoOpOptimization::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00262">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00262">TwoDimMultiReductionToReduction::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00288">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00292">AddZeroOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00300">OneDimMultiReductionToTwoDim::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00340">mlir::detail::OpOrInterfaceRewritePatternBase&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00353">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00355">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00378">MaterializePadValue::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01176">mlir::vector::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01405">mlir::vector::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00425">MaxPool2dIsNoOp::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00438">mlir::OpConversionPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00460">ClampIsNoOp::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01439">mlir::vector::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00483">mlir::OpInterfaceConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00528">ClampClampOptimization::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00918">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00731">mlir::linalg::LinalgVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01105">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00781">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01173">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01257">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00922">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01429">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01688">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01703">SelectI1Simplify::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01796">TransferReadToVectorLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01882">VectorLoadToMemrefLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01900">VectorStoreToMemrefStoreLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01937">TransferWriteToVectorStoreLowering::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02004">BubbleDownVectorBitCastForExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02078">BubbleDownBitCastForStridedSliceExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02157">BubbleUpBitCastForStridedSliceInsert::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02276">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02329">VectorCreateMaskOpConversion::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02649">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02691">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02830">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="Verifier_8cpp_source.html#l00099">mayBeValidWithoutTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00652">mergeIdenticalBlocks()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00070">mlirExecutionEngineInvokePacked()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">mlirReduceMain()</a>, <a class="el" href="Simplex_8cpp_source.html#l00744">mlir::presburger::LexSimplexBase::moveRowUnknownToColumn()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00081">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00235">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00902">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">normalizeMemRef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00512">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01479">mlir::detail::ConversionPatternRewriterImpl::notifyMatchFailure()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00310">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00274">mlir::Diagnostic::operator FailureOr&lt; T &gt;()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00368">mlir::InFlightDiagnostic::operator FailureOr&lt; T &gt;()</a>, <a class="el" href="Diagnostic_8h_source.html#l00057">mlir::pdll::ast::Diagnostic::operator LogicalResult()</a>, <a class="el" href="Diagnostic_8h_source.html#l00109">mlir::pdll::ast::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00187">mlir::Diagnostic::operator LogicalResult()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00195">mlir::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00203">outlineIfOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">outlineSingleBlockRegion()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00169">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00857">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00065">mlir::FieldParser&lt; AttributeT, std::enable_if_t&lt; std::is_base_of&lt; Attribute, AttributeT &gt;::value, AttributeT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00077">mlir::FieldParser&lt; TypeT, std::enable_if_t&lt; std::is_base_of&lt; Type, TypeT &gt;::value, TypeT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00089">mlir::FieldParser&lt; IntT, std::enable_if_t&lt; std::is_integral&lt; IntT &gt;::value, IntT &gt; &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00100">mlir::FieldParser&lt; std::string &gt;::parse()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00115">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; std::is_member_function_pointer&lt; decltype(&amp;ContainerT::push_back)&gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01043">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01188">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00684">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02594">parseAffineMinMaxOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00072">parseAllocateAndAllocator()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00457">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseArrowTypeList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02332">parseAtomicBinOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01142">parseAtomicCompareExchangeImpl()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02358">parseAtomicOrdering()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00765">parseAtomicUpdateOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00044">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00664">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00264">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00866">parseAttributions()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00289">parseAwaitResultType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01341">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00115">parseClauseAttr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00472">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseColonType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00953">mlir::AsmParser::parseColonType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00478">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseColonTypeList()</a>, <a class="el" href="PassOptions_8h_source.html#l00038">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00124">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00229">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00102">parseCreateOperationOpResults()</a>, <a class="el" href="OpImplementation_8h_source.html#l00728">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l00905">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00447">parseDimAndSymbolList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00538">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00421">parseElementAttrHexValues()</a>, <a class="el" href="ParserUtils_8h_source.html#l00027">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00214">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseEnumStrAttr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00301">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00266">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00065">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00539">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00845">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00367">parseImageOperands()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00693">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00876">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00978">mlir::AsmParser::parseKeywordType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00764">parseLaunchFuncOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00141">parseLinearClause()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00250">parseMemoryAccessAttributes()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00194">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00201">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00194">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00094">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00067">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00115">parseOperandAndType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00056">parseOperandList()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00108">parseOperandsOrIntegersImpl()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00144">parseOperationOpAttributes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00480">mlir::ExtensibleDialect::parseOptionalDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00458">mlir::ExtensibleDialect::parseOptionalDynamicType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00252">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeyword()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01785">parseOptionalLLVMKeyword()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00100">parseOptionalOperand()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00129">parseOptionalOperandAndType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00235">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00423">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00023">mlir::detail::Parser::parseOptionalType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01094">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00672">parsePassPipeline()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04322">parsePtrAccessChainOpImpl()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00165">parseQuantParams()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00302">parseReductionVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00040">parseRegions()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00412">parseResultsValueType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00219">parseScheduleClause()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00536">parseSizeAssignment()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l02161">parseSourceFile()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00281">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00066">parseStorageRange()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00153">mlir::detail::Parser::parseStridedLayout()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00564">parseStructMemberDecorations()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00480">parseSwitchOpCases()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00381">parseSynchronizationHint()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00447">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00876">mlir::AsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00931">mlir::AsmParser::parseTypeList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00081">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00096">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00600">parseVariableDecorations()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00487">mlir::detail::Parser::parseVectorDimensionList()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00970">parseVerCapExtAttr()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00520">parseWsLoopControl()</a>, <a class="el" href="PassRegistry_8h_source.html#l00164">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00186">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00111">peelForLoop()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00047">performActions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01543">poolingInferReturnTypes()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">printAtomicReductionRegion()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00122">printCreateOperationOpResults()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00563">printGEPIndices()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00493">mlir::ExtensibleDialect::printIfDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00471">mlir::ExtensibleDialect::printIfDynamicType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00369">printInitializationList()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00043">printNVVMIntrinsicOp()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00315">printOperation()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02825">printTransferAttrs()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">printWsLoopControl()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00092">processBuffer()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00197">processDataOperands()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00295">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="Promotion_8cpp_source.html#l00251">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00359">mlir::linalg::promoteSubviewsPrecondition()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Lexer_8cpp_source.html#l00107">mlir::pdll::Lexer::pushInclude()</a>, <a class="el" href="Transport_8cpp_source.html#l00265">readLine()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00580">reductionPreconditions()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, <a class="el" href="Translation_8cpp_source.html#l00057">registerTranslateToMLIRFunction()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00324">mlir::detail::PassCrashReproducerGenerator::removeLastReproducerFor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00882">replaceAllSymbolUsesImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00594">replaceDimOrSym()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00041">replaceTransferOpWithMubuf()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>, <a class="el" href="SCCP_8cpp_source.html#l00170">replaceWithConstant()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00074">reshapeLowerToHigher()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01445">resolveBroadcastShape()</a>, <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00044">resolveSourceIndices()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00470">mlir::linalg::LinalgTilingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00508">mlir::linalg::LinalgPaddingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00580">mlir::linalg::LinalgTileAndFuseTensorOpsPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00646">mlir::linalg::GenericOpInterchangePattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00674">mlir::linalg::LinalgGeneralizationPattern::returningMatchAndRewrite()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00151">rewriteAffineOpAfterPeeling()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00255">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00839">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00901">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01055">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00203">mlir::lsp::LSPServer::run()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00657">mlir::PassManager::run()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00938">mlir::bufferization::runOneShotBufferize()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00418">mlir::bufferization::runOneShotModuleBufferize()</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00255">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00366">runRegionDCE()</a>, <a class="el" href="Inliner_8cpp_source.html#l00287">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02790">separateFullTiles()</a>, <a class="el" href="Serializer_8cpp_source.html#l00086">mlir::spirv::Serializer::serialize()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00083">serializeModule()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00570">mlir::spirv::Serializer::processOp&lt; spirv::ControlBarrierOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00666">mlir::spirv::Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00639">mlir::spirv::Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00620">mlir::spirv::Serializer::processOp&lt; spirv::MemoryBarrierOp &gt;()</a>, <a class="el" href="Serializer_8cpp_source.html#l00273">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="DebugAction_8h_source.html#l00079">mlir::DebugActionManager::GenericHandler::shouldExecute()</a>, <a class="el" href="DebugAction_8h_source.html#l00110">mlir::DebugActionManager::shouldExecute()</a>, <a class="el" href="DebugAction_8h_source.html#l00204">mlir::DebugAction&lt; ParameterTs &gt;::Handler::shouldExecute()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00144">simplifyBrToBlockWithSinglePred()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00681">simplifyConstSwitchValue()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00702">simplifyPassThroughSwitch()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00826">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00775">simplifySwitchFromSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00604">simplifySwitchWithOnlyDefault()</a>, <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00492">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00035">splatZero()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00127">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00533">structFuncArgTypeConverter()</a>, <a class="el" href="Fusion_8cpp_source.html#l00887">mlir::linalg::tileAndFuseLinalgOps()</a>, <a class="el" href="Fusion_8cpp_source.html#l00819">tileAndFuseLinalgOpsImpl()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00424">mlir::linalg::tileConsumerAndFuseProducers()</a>, <a class="el" href="Tiling_8cpp_source.html#l00269">mlir::linalg::tileLinalgOp()</a>, <a class="el" href="Tiling_8cpp_source.html#l00099">tileLinalgOpImpl()</a>, <a class="el" href="Tiling_8cpp_source.html#l00284">tilePadOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00860">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00904">tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00057">translateDataLayout()</a>, <a class="el" href="Translation_8cpp_source.html#l00091">mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration()</a>, <a class="el" href="Builders_8cpp_source.html#l00398">mlir::OpBuilder::tryFold()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00758">tryIsolateBands()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00070">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00721">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00025">typeOrAttrParser()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01914">mlir::presburger::IntegerRelation::unionBoundingBox()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00085">updateCalls()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01858">vectorizeAffineLoopNest()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00653">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01530">vectorizeLoopNest()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00595">vectorizeStaticLinalgOpPrecondition()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00117">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00762">mlir::SourceMgrDiagnosticVerifierHandler::verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01087">verifyAccessChain()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00885">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, Type &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l01069">mlir::detail::pdl_function_builder::verifyAsArgs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01174">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00822">verifyAtomicUpdateOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00057">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00094">verifyCompatibleShapes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00676">verifyConvOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03767">verifyCoopMatrixMulAdd()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00311">mlir::detail::verifyDataLayoutOp()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00474">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00094">verifyDependencies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00206">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01771">verifyLoopNesting()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00667">verifyMemoryOpMetadata()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">mlir::detail::verifyOffsetSizeAndStrideOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03698">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="OpDefinition_8h_source.html#l00902">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::verifyRegionTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01600">mlir::op_definition_impl::verifyRegionTraits()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00180">verifyResultTypesAreInferrable()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00874">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00845">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00860">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00835">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00595">mlir::linalg::detail::verifyStructuredOpInterface()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00617">verifySymbolAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>, <a class="el" href="FunctionInterfaces_8h_source.html#l00209">mlir::function_interface_impl::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01577">mlir::op_definition_impl::verifyTraits()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00159">mlir::detail::verifyTypesAlongControlFlowEdges()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03714">verifyVectorMemoryOp()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00042">visitInPrettyBlockOrder()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00054">walkReferenceCountedValues()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00067">walkReturnOperations()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a04b8cb2bfcf870fb9909b4805c0aad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b8cb2bfcf870fb9909b4805c0aad13">&#9670;&nbsp;</a></span>finalizeParallelLoopToGPUConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::finalizeParallelLoopToGPUConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up after applyPartialConversion/applyFullConversion call. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00681">681</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToGPU_8cpp_source.html#l00055">kVisitedAttrName</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00569">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a3983eab6c9a05efd28747c0e79dd9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983eab6c9a05efd28747c0e79dd9d44">&#9670;&nbsp;</a></span>floorDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::floorDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's floordiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00033">33</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01459">mlir::presburger::IntegerRelation::computeConstantLowerOrUpperBound()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00889">createPrivateMemRef()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00736">detectAsMod()</a>, <a class="el" href="Fraction_8h_source.html#l00063">mlir::presburger::floor()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00887">mlir::presburger::IntegerRelation::gcdTightenInequalities()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="IRModule_8h_source.html#l00920">mlir::python::PyAffineExpr::get()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00878">mlir::FlatAffineValueConstraints::getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00081">mlir::memref::multiBuffer()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00024">normalizeDivisionByGCD()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>, and <a class="el" href="Simplex_8cpp_source.html#l01702">mlir::presburger::GBRSimplex::removeLastEquality()</a>.</p>

</div>
</div>
<a id="a2b0271e4a2b1e694242618a6e91a9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0271e4a2b1e694242618a6e91a9c37">&#9670;&nbsp;</a></span>foldReshapeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReshapeOpTy , typename InverseReshapeOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::foldReshapeOp </td>
          <td>(</td>
          <td class="paramtype">ReshapeOpTy&#160;</td>
          <td class="paramname"><em>reshapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00084">84</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

</div>
</div>
<a id="ab80da81dcbeeee5cc76ed25a83f10200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80da81dcbeeee5cc76ed25a83f10200">&#9670;&nbsp;</a></span>fullyComposeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::fullyComposeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp. </p>
<p>When this function returns, <code>map</code> becomes the composed affine map, and each <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>operands</code> is guaranteed to be either a loop IV or a terminal symbol, i.e., a symbol defined at the top level or a block/function argument. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00699">699</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, and <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01240">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01369">createAffineComputationSlice()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02633">createCanonicalizedAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00727">createFoldedComposedAffineApply()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00738">mlir::linalg::fullyComposeAndAffineApply()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01953">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00497">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00056">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a023cf013ed2352f349ed9e72e6bff12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023cf013ed2352f349ed9e72e6bff12c">&#9670;&nbsp;</a></span>fuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::fuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInnermostSiblingInsertion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'. </p>
<p><code>isInnermostSiblingInsertionFusion</code> enables cleanup of `srcForOp that is a single-iteration reduction loop being sibling-fused into a 'dstForOp'.</p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">432</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">buildSliceTripCountMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00873">canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01946">getForInductionVarOwner()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01031">getSliceIterationCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00088">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01340">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00078">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00084">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00080">mlir::ComputationSliceState::lbs</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00086">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00082">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8h_source.html#l00090">mlir::FusionStrategy::getSiblingFusionMemRef()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5c111ec17f2fc8f8c6bb94f432ddbb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c111ec17f2fc8f8c6bb94f432ddbb18">&#9670;&nbsp;</a></span>gatherLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::gatherLoops </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>depthToLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers all AffineForOps in 'func.func' grouped by loop depth. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02617">2617</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02601">gatherLoopsInBlock()</a>.</p>

</div>
</div>
<a id="a7df8e8b4e1357d7820daeffd9d17a742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df8e8b4e1357d7820daeffd9d17a742">&#9670;&nbsp;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>srcOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>dstOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>producerConsumerMemrefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00650">650</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00065">createLoopFusionPass()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="aac4e3e10aeb7dc1e0f93a00c4a3723c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4e3e10aeb7dc1e0f93a00c4a3723c0">&#9670;&nbsp;</a></span>generateCopyForMemRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateCopyForMemRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>memrefRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>analyzedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region. </p>
<p><code>memrefRegion</code> is supposed to contain analysis information within analyzedOp. The generated prologue and epilogue always surround <code>analyzedOp</code>.</p>
<p>Note that <code>analyzedOp</code> is a single op for API convenience, and the [begin, end) version can be added as needed.</p>
<p>Also note that certain options in <code>copyOptions</code> aren't looked at anymore, like slowMemorySpace. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02573">2573</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8h_source.html#l00201">mlir::CopyGenerateResult::alloc</a>, <a class="el" href="LoopUtils_8h_source.html#l00205">mlir::CopyGenerateResult::copyNest</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00333">mlir::MemRefRegion::memref</a>, <a class="el" href="LoopUtils_8h_source.html#l00198">mlir::CopyGenerateResult::sizeInBytes</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a2d3bd1afbf84ef9cca6c336a104d7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bd1afbf84ef9cca6c336a104d7280">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations replace the current operation locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00094">94</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocationSnapshot_8cpp_source.html#l00110">generateLocationsFromIR()</a>, and <a class="el" href="LocationSnapshot_8cpp_source.html#l00064">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="af16c6823f94d6ce99fa7da7547658345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c6823f94d6ce99fa7da7547658345">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00101">101</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00024">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="a94e9bde94caabba0feba96a044a09afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9bde94caabba0feba96a044a09afc">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations are represented as a NameLoc with the given tag as the name, and then fused with the existing locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00110">110</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00094">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="ab170389f5f17475f89037e332018b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170389f5f17475f89037e332018b4f8">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00118">118</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00024">generateLocationsFromIR()</a>, and <a class="el" href="LocationSnapshot_8cpp_source.html#l00094">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&nbsp;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00045">45</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01572">createDimSizeExprForTiledLayout()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00246">operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00439">simplifySemiAffine()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00382">symbolicDivide()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&nbsp;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">514</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00188">mlir::StorageUniquer::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00943">mlir::MLIRContext::getAffineUniquer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00797">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00809">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00463">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">compressSymbols()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00062">createInBoundsCond()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00847">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00736">detectAsMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00766">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00293">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">getAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01484">mlir::FlatAffineValueConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00095">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00935">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00122">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00682">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00192">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00104">mlirAffineConstantExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00865">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00700">mlir::AffineExpr::operator*()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00640">mlir::AffineExpr::operator+()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00713">mlir::AffineExpr::operator-()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00246">operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00510">mlir::AffineExpr::operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00350">mlir::AffineMap::partialConstantFold()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00439">simplifySemiAffine()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00041">sliceTransferIndices()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00382">symbolicDivide()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&nbsp;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">489</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">DimId</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineDimOrSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00068">adjustMap()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00310">mlir::detail::bindDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01663">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00797">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00754">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00439">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">compressDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01408">computeLocalVars()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00879">mlir::linalg::computeTileSizes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00132">convertReassociationIndicesToExprs()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00062">createInBoundsCond()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">getAffineExprFromFlatForm()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01217">getCollapsedOpIndexingMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00822">getDimMap()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00244">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00110">getPermutationMapAttr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00935">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00682">inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00658">inversePermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00280">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00989">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00192">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">makeStridedLinearLayoutMap()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00781">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00072">mlirAffineDimExprGet()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00081">mlir::memref::multiBuffer()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00246">operator-()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00594">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00108">mlir::AffineExpr::shiftDims()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00041">sliceTransferIndices()</a>, and <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00053">mlir::scf::tileParallelLoop()</a>.</p>

</div>
</div>
<a id="a8ad71c14bebce843758768ff160e2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad71c14bebce843758768ff160e2283">&#9670;&nbsp;</a></span>getAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>flatExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat ArrayRef. </p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> for it, and is substituted into. The ArrayRef 'eq' is expected to be in the format [dims, symbols, locals, constant term].</p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <code>localExprs</code> is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> for it, and is substituted into. The ArrayRef <code>flatExprs</code> is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">892</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00198">mlir::AffineExpr::expr</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01484">mlir::FlatAffineValueConstraints::getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01438">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00878">mlir::FlatAffineValueConstraints::getLowerAndUpperBound()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">simplifyAffineExpr()</a>.</p>

</div>
</div>
<a id="af721960fd29e7148cf561bb6e1f1fa07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af721960fd29e7148cf561bb6e1f1fa07">&#9670;&nbsp;</a></span>getAffineScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getAffineScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest region enclosing <code>op</code> that is held by an operation with trait <code>AffineScope</code>; <code>nullptr</code> if there is no such region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00244">244</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00259">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01116">mlir::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01218">mlir::AffineDmaWaitOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&nbsp;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">499</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineDimOrSymbol()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00319">mlir::detail::bindSymbols()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00797">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00754">canonicalizePromotedSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00439">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">compressSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01408">computeLocalVars()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">getAffineExprFromFlatForm()</a>, <a class="el" href="Builders_8cpp_source.html#l00289">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00935">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00291">mlir::AffineExpr::isFunctionOfSymbol()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">makeStridedLinearLayoutMap()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00088">mlirAffineSymbolExprGet()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00246">operator-()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00594">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00120">mlir::AffineExpr::shiftSymbols()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00538">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="ac79d3eafe91790995ee06ed0e61ebc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79d3eafe91790995ee06ed0e61ebc82">&#9670;&nbsp;</a></span>getAllIteratorTypeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;StringRef&gt; mlir::getAllIteratorTypeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">101</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00080">getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">getReductionIteratorTypeName()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00094">getWindowIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00109">getNumIterators()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00595">mlir::linalg::detail::verifyStructuredOpInterface()</a>.</p>

</div>
</div>
<a id="ac19b7af1333485b34ebfe4bf6300c362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b7af1333485b34ebfe4bf6300c362">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a value, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">54</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00259">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00333">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00076">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00063">getAsOpFoldResult()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00255">mlir::linalg::rewriteAsPaddedOp()</a>.</p>

</div>
</div>
<a id="a42a3d623deef4b86e5222482bf85a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a3d623deef4b86e5222482bf85a01a">&#9670;&nbsp;</a></span>getAsOpFoldResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::getAsOpFoldResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an array of values, try to extract a constant <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> from each value. </p>
<p>If this fails, return the original value. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00063">63</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">getAsOpFoldResult()</a>.</p>

</div>
</div>
<a id="acdaff1f732caf76ab2f92ea649ed3a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaff1f732caf76ab2f92ea649ed3a53">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>backwardSlice</code> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at defs transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if an operation is already in <code>backwardSlice</code>, no need to traverse its definitions again. Since useuse-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>backwardSlice</code> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1>Example starting from node 8 </h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6} </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00113">113</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00078">getBackwardSliceImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00219">dependsOnCarriedVals()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00123">getBackwardSlice()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">getSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00169">getSliceContract()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00168">HoistingAnalysis::HoistingAnalysis()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00198">mlir::linalg::TileLoopNest::isEmpty()</a>.</p>

</div>
</div>
<a id="a7047e62d0c1056140acf328aeeb91ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7047e62d0c1056140acf328aeeb91ae4">&#9670;&nbsp;</a></span>getBackwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getBackwardSlice</code>. </p>
<p>Return the union of all backward slices for the op defining or owning the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00123">123</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00113">getBackwardSlice()</a>, and <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="ab92965fea632fd01db2c6e8ae156df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92965fea632fd01db2c6e8ae156df70">&#9670;&nbsp;</a></span>getComputationSliceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getComputationSliceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSourceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSinkOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'. </p>
<p>If 'isBackwardSlice' is true, a backwards slice is computed in which the slice bounds of loop nest surrounding 'depSourceAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess' at 'loopDepth'. If 'isBackwardSlice' is false, a forward slice is computed in which the slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at 'loopDepth'. The slice loop bounds and associated operands are returned in 'sliceState'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">1045</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">buildSliceTripCountMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01349">getSequentialLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01031">getSliceIterationCount()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">mlir::FlatAffineValueConstraints::getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">mlir::FlatAffineValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00088">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01340">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00078">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01040">kSliceFusionBarrierAttrName</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00084">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00080">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01377">mlir::FlatAffineValueConstraints::projectOut()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00086">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00082">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00107">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a61eaf936f054b483e983fa6be1cb27f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eaf936f054b483e983fa6be1cb27f3">&#9670;&nbsp;</a></span>getComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::getComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total cost of the loop nest rooted at 'forOp' using 'stats'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00569">569</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00533">getComputeCostHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5b180faadcfcd901fa117f7a2a6c362f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b180faadcfcd901fa117f7a2a6c362f">&#9670;&nbsp;</a></span>getConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; mlir::getConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If ofr is a constant integer or an IntegerAttr, return the integer. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">69</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="Matchers_8h_source.html#l00356">m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00333">matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00076">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01335">foldIdentityOffsetSizeAndStrideOpInterface()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00085">isConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">isEqualConstantIntOrValue()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00059">isEqualOffsetSizeOrStride()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="SplitPadding_8cpp_source.html#l00028">isZero()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00282">mlir::linalg::makeComposedExtractSliceOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00324">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00111">peelForLoop()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00317">mlir::scf::rewritePeeledMinMaxOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01055">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00138">mlir::linalg::LinalgTilingOptions::scalarizeDynamicDims()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00721">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>.</p>

</div>
</div>
<a id="a8cdcd2c284243df5d427fcdfe4edde75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdcd2c284243df5d427fcdfe4edde75">&#9670;&nbsp;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop if it's a constant, None otherwise. </p>
<p>This uses affine expression analysis and is able to determine constant trip count in non-trivial cases.</p>
<p>This method uses affine expression analysis (in turn using getTripCount) and is able to determine constant trip count in non-trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">83</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">getTripCountMapAndOperands()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00186">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00236">affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">buildSliceTripCountMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00774">constructTiledIndexSetHyperRect()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>, <a class="el" href="LoopUnroll_8cpp_source.html#l00074">gatherInnermostLoops()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00481">getLoopNestStats()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01092">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00975">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01152">loopUnrollJamUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00990">loopUnrollUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a7a72abd84dcc66c8c890fc6c5e0d24f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">&#9670;&nbsp;</a></span>getDependenceComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getDependenceComponents </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>depCompsVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth]. </p>
<p>Gathers dependence components for dependences between all ops in loop nest rooted at 'forOp' at loop depths in range [1, maxLoopDepth].</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">668</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">checkMemrefAccessDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00176">hasDependence()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8h_source.html#l00176">hasDependence()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01456">isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01562">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a4a4509af87b284808008015597b3f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4509af87b284808008015597b3f96a">&#9670;&nbsp;</a></span>getDilationsAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDilationsAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of dilations. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00074">74</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="aa8da5ff5136bb59fe4a47ef22fc765e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8da5ff5136bb59fe4a47ef22fc765e9">&#9670;&nbsp;</a></span>getDistributionTypesAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDistributionTypesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the distribution type for <code>linalg.tiled_loop</code>. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00058">58</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a8c6eb5b9274486d9ed3f4dff655d4cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6eb5b9274486d9ed3f4dff655d4cbd">&#9670;&nbsp;</a></span>getDocAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDocAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StringAttr which encodes an optional documentation string of the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00064">64</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00024">24</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00160">broadcastIfNeeded()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00201">buildVectorWrite()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00248">exp2I32()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00057">fillStructuredOpRegion()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00207">frexp()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00483">genBuffers()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00705">genInsertionLoad()</a>, <a class="el" href="Traits_8cpp_source.html#l00132">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00030">getElementTypeOrSelf()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00767">getUnderlyingType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00772">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00223">TwoDimMultiReductionToElementWise::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Linalg_8cpp_source.html#l00018">mlirLinalgFillBuiltinNamedOpRegion()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00169">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00653">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00805">verifyExtOp()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00874">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00860">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00595">mlir::linalg::detail::verifyStructuredOpInterface()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00818">verifyTruncateOp()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l01386">verifyYield()</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00034">34</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00024">getElementTypeOrSelf()</a>, and <a class="el" href="Attributes_8h_source.html#l00066">mlir::Attribute::getType()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00030">30</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00024">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ad1ccc3f1298ad67bd387a804aa82fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ccc3f1298ad67bd387a804aa82fa65">&#9670;&nbsp;</a></span>getEnclosingAffineForAndIfOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getEnclosingAffineForAndIfOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> or <code>affine.if</code> operation to the innermost one. </p>
<p>Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> operation to the innermost one.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00051">51</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00275">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a59222c6d1f54e57a5f71291f205911da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222c6d1f54e57a5f71291f205911da">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given op that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00330">330</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l00333">getCommonEnclosingRepetitiveRegion()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00205">mlir::InvocationBounds::getUnknown()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00396">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="abea4281da1b0006e0c9622cff14858a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4281da1b0006e0c9622cff14858a7">&#9670;&nbsp;</a></span>getEnclosingRepetitiveRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::getEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first enclosing region of the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> that may be executed repetitively as per RegionBranchOpInterface or <code>nullptr</code> if no such region exists. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00340">340</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>.</p>

</div>
</div>
<a id="ac634e77ac1d86b4486ff25a7fc42249d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac634e77ac1d86b4486ff25a7fc42249d">&#9670;&nbsp;</a></span>getFlattenedAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00105">105</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00118">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="aa2cb0652ec5bbbeff3cc18c60aa47bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb0652ec5bbbeff3cc18c60aa47bb6">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>localVarCst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and / symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., semi-affine expressions not handled yet). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00118">118</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00228">mlir::FlatAffineValueConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00152">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">mlir::FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00105">getFlattenedAffineExpr()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01718">getRelationFromMap()</a>.</p>

</div>
</div>
<a id="ace7e68685a7df8a7a4c01d85a91cd136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7e68685a7df8a7a4c01d85a91cd136">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00130">130</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00228">mlir::FlatAffineValueConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&nbsp;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype">TupleType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00038">38</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00805">getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01946">1946</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00309">mlir::BlockArgument::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00639">mlir::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">mlir::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">mlir::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00551">mlir::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00126">mlir::ComputationSliceState::dump()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00307">getCommonBlock()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00285">getNumCommonLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01940">isForInductionVar()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00068">isOpLoopInvariant()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01074">isUniformDefinition()</a>.</p>

</div>
</div>
<a id="a72c969b6eced23c4017b0b2c90574940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c969b6eced23c4017b0b2c90574940">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>forwardSlice</code> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at uses transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForOp or the scope within an IfOp.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if an operation is already in <code>forwardSlice</code>, no need to traverse its uses again. Since use-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>forwardSlice</code> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just just reverse the order in <code>forwardSlice</code> before returning.</p>
<h1>Example starting from node 0 </h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <code>forwardSlice</code> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00052">52</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00026">getForwardSliceImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">getSlice()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00169">getSliceContract()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00716">hoistOpsBetween()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00395">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a6a934c9a2093cf8857918f57c83852f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a934c9a2093cf8857918f57c83852f1">&#9670;&nbsp;</a></span>getForwardSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-rooted version of <code>getForwardSlice</code>. </p>
<p>Return the union of all forward slices for the uses of the value <code>root</code>. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00066">66</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00026">getForwardSliceImpl()</a>, and <a class="el" href="Value_8h_source.html#l00213">mlir::Value::getUsers()</a>.</p>

</div>
</div>
<a id="afde43535284e6667536f8ed8c7906063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde43535284e6667536f8ed8c7906063">&#9670;&nbsp;</a></span>getFusionComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFusionComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>srcStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>dstStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>computeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. Returns true on success, failure otherwise (e.g. non-constant trip counts).</p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00580">580</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00993">buildSliceTripCountMap()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00533">getComputeCostHelper()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01031">getSliceIterationCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00088">mlir::ComputationSliceState::insertPoint</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a092d13f2e1680d4a62d9d623c1fe5fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092d13f2e1680d4a62d9d623c1fe5fba">&#9670;&nbsp;</a></span>getI64SubArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">llvm::SmallVector</a>&lt; int64_t, 4 &gt; mlir::getI64SubArray </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>arrayAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dropFront</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dropBack</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper that returns a subset of <code>arrayAttr</code> as a vector of int64_t. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00033">33</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndexingUtils_8h_source.html#l00038">applyPermutationToVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02426">foldExtractStridedOpFromInsertChain()</a>, and <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00060">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a348eec2f2303d75aeea3e11b11a9b864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348eec2f2303d75aeea3e11b11a9b864">&#9670;&nbsp;</a></span>getIndexingMapsAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getIndexingMapsAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00050">50</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>.</p>

</div>
</div>
<a id="a170122f309092d69a928d6a64f1b2fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170122f309092d69a928d6a64f1b2fe9">&#9670;&nbsp;</a></span>getIndexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getIndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order. </p>
<p>Bounds of the loop are used to add appropriate inequalities. Constraints from the index sets of AffineIfOp are also added. Any symbols founds in the bound operands are added as symbols in the system. Returns failure for the yet unimplemented cases. <code>ops</code> accepts both AffineForOp and AffineIfOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">244</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00587">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00688">mlir::FlatAffineValueConstraints::addAffineIfOpDomain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01959">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00228">mlir::FlatAffineValueConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00442">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02655">createSeparationCondition()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00275">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="abde4236d0e9455a3983834b085f73224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde4236d0e9455a3983834b085f73224">&#9670;&nbsp;</a></span>getInnermostCommonLoopDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getInnermostCommonLoopDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>surroundingLoops</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the innermost common loop depth for the set of operations in 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00779">779</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00186">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a820f3296c3cd59eaed418f42f874a217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820f3296c3cd59eaed418f42f874a217">&#9670;&nbsp;</a></span>getInnermostParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getInnermostParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>rootOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ParallelOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of innermost parallel loops contained in <code>rootOp</code>. </p>
<p>Innermost parallel loops are those that do not contain further parallel loops themselves. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00226">226</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00053">mlir::scf::tileParallelLoop()</a>.</p>

</div>
</div>
<a id="a4243a75480867bb61c05aa5879d2a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4243a75480867bb61c05aa5879d2a32f">&#9670;&nbsp;</a></span>getInvariantAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getInvariantAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>. </p>
<p>Prerequisites (inherited from <code>isAccessInvariant</code> above):</p><ol type="1">
<li><code>iv</code> and <code>indices</code> of the proper type;</li>
<li>at most one affine.apply is reachable from each index in <code>indices</code>;</li>
</ol>
<p>Emits a note if it encounters a chain of affine.apply and conservatively those cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00183">183</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00192">makePermutationMap()</a>.</p>

</div>
</div>
<a id="aeb614cbb4a83d4b3ec1ef9b5c7cade43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb614cbb4a83d4b3ec1ef9b5c7cade43">&#9670;&nbsp;</a></span>getIteratorTypesAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getIteratorTypesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00054">54</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>.</p>

</div>
</div>
<a id="a8c3272c7e5d627a525a70f55fb93fb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3272c7e5d627a525a70f55fb93fb57">&#9670;&nbsp;</a></span>getLargestDivisorOfTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::getLargestDivisorOfTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest known integral divisor of the trip count. </p>
<p>Affine expression analysis is used (indirectly through getTripCount), and this method is thus able to determine non-trivial divisors. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00109">109</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">getTripCountMapAndOperands()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00774">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01092">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a39d25e27ccff1d123995abe189add986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d25e27ccff1d123995abe189add986">&#9670;&nbsp;</a></span>getLibraryCallAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getLibraryCallAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00068">68</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a991e7b35354627941316244640aa4392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e7b35354627941316244640aa4392">&#9670;&nbsp;</a></span>getLoopIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getLoopIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">35</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00065">createLoopFusionPass()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01873">findHighestBlockForPlacement()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02333">getFullMemRefAsRegion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00580">getFusionComputeCost()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00779">getInnermostCommonLoopDepth()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00093">getLastDependentOpInRange()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01272">getNumCommonSurroundingLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01161">insertBackwardComputationSlice()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00068">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="a1b8c56a4421761c1f8658aa16c292463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8c56a4421761c1f8658aa16c292463">&#9670;&nbsp;</a></span>getLoopNestStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getLoopNestStats </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect loop nest statistics (eg. </p>
<p>loop trip count and operation count) in 'stats' for loop nest rooted at 'forOp'. Returns true on success, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00481">481</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00130">mlir::LoopNestStats::loopMap</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00132">mlir::LoopNestStats::opCountMap</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00134">mlir::LoopNestStats::tripCountMap</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a74485bec820f2186ce852a09f45ebd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74485bec820f2186ce852a09f45ebd47">&#9670;&nbsp;</a></span>getMaxDimAndSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineExprContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::getMaxDimAndSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineExprContainer &gt;&#160;</td>
          <td class="paramname"><em>exprsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>maxSym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates maxmimum dimension and symbol positions from the expressions in <code>exprsLists</code> and stores them in <code>maxDim</code> and <code>maxSym</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00553">553</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00220">inferFromExprList()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00963">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="a1670cd81ab396ba425cd0063d516b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1670cd81ab396ba425cd0063d516b9a9">&#9670;&nbsp;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; mlir::getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01331">1331</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01287">getMemoryFootprintBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00091">createAffineDataCopyGenerationPass()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5bd0c019a961c60a1fd09225b7dcd3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd0c019a961c60a1fd09225b7dcd3be">&#9670;&nbsp;</a></span>getMemRefSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getMemRefSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memRefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of memref data in bytes if it's statically shaped, None otherwise. </p>
<p>If the element of the memref has vector type, takes into account size of the vector as well. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">644</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00602">getMemRefEltSizeInBytes()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::LB</a>, <a class="el" href="namespacemlir_1_1presburger.html#a12e7fe91c72844f54ad9361f279ad2b3a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger::None</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::UB</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>.</p>

</div>
</div>
<a id="a04c33e0935147ad8c78aaf86e0c34f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c33e0935147ad8c78aaf86e0c34f47">&#9670;&nbsp;</a></span>getMixedOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt; mlir::getMixedOffsets </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>staticOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of all the static or dynamic offsets of the op from provided external static and dynamic offsets. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00202">202</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>.</p>

</div>
</div>
<a id="a995a7324142d5fe09a81b017a6f41f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995a7324142d5fe09a81b017a6f41f49">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt; mlir::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>staticSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of all the static or dynamic sizes of the op from provided external static and dynamic sizes. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00217">217</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>.</p>

</div>
</div>
<a id="a590c21e69ed359489b5d7804ea0f587f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590c21e69ed359489b5d7804ea0f587f">&#9670;&nbsp;</a></span>getMixedStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, 4 &gt; mlir::getMixedStrides </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>staticStrides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector of all the static or dynamic strides of the op from provided external static and dynamic strides. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00232">232</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>.</p>

</div>
</div>
<a id="a9fd1caaa81149a00bb1df4563cbbe43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd1caaa81149a00bb1df4563cbbe43e">&#9670;&nbsp;</a></span>getMutableRegionBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> &gt; mlir::getMutableRegionBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mutable operands that are passed to the region with the given <code>regionIndex</code>. </p>
<p>If the operation does not implement the <code>RegionBranchTerminatorOpInterface</code> and is not marked as <code>ReturnLike</code>, the result will be <code>llvm::None</code>. In all other cases, the resulting <code><a class="el" href="classmlir_1_1OperandRange.html" title="This class implements the operand iterators for the Operation class. ">OperandRange</a></code> represents all operands that are passed to the specified successor region. If <code>regionIndex</code> is <code>llvm::None</code>, all operands that are passed to the parent operation will be returned. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00371">371</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00392">getRegionBranchSuccessorOperands()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00205">mlir::InvocationBounds::getUnknown()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>.</p>

</div>
</div>
<a id="ac2db02976864d1e32f9f500d9d719d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2db02976864d1e32f9f500d9d719d5a">&#9670;&nbsp;</a></span>getNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNestingDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation. </p>
<p>Returns the nesting depth of this statement, i.e., the number of loops surrounding this statement.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01242">1242</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01287">getMemoryFootprintBytes()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00138">isLoopMemoryParallel()</a>.</p>

</div>
</div>
<a id="abd698449e5677681454cc2e4f4718396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd698449e5677681454cc2e4f4718396">&#9670;&nbsp;</a></span>getNumCommonSurroundingLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumCommonSurroundingLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of surrounding loops common to both A and B. </p>
<p>Returns the number of surrounding loops common to 'loopsA' and 'loopsB', where each lists loops from outer-most to inner-most in loop nest.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01272">1272</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00186">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00260">canFuseLoops()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00661">hasNoInterveningEffect()</a>.</p>

</div>
</div>
<a id="a729f6e1552c6df7db231ce20f67947b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729f6e1552c6df7db231ce20f67947b2">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator of a certain type. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00109">109</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00130">mlir::Attribute::cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">getAllIteratorTypeNames()</a>.</p>

</div>
</div>
<a id="a6d068f0cba2b5a92fe603c4118664b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d068f0cba2b5a92fe603c4118664b61">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>iteratorTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00118">118</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a45e134959101de052e7dbfd12610b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e134959101de052e7dbfd12610b5d6">&#9670;&nbsp;</a></span>getOrCreateRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt; mlir::getOrCreateRanges </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> (i.e. </p>
<p>offset, size, stride). Each <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> entry contains either the dynamic value or a ConstantIndexOp constructed with <code>b</code> at location <code>loc</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02400">2400</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="aef47d572d82ccbf6419876301669cd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef47d572d82ccbf6419876301669cd6a">&#9670;&nbsp;</a></span>getPaddingAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getPaddingAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of paddings. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00077">77</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a3cf9bb42bc7ec9e1668e6e121d0b69b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9bb42bc7ec9e1668e6e121d0b69b0">&#9670;&nbsp;</a></span>getParallelIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getParallelIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has parallel semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00080">80</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00594">collectFusableLoops()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00822">getDimMap()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00019">mlir::tosa::getNParallelLoopsAttrs()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00774">getNParallelLoopsAttrs()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00258">isConvolutionInterfaceImpl()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00453">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00081">isParallelIterator()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00423">mlir::linalg::makeMemRefCopyOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00384">mlir::linalg::makeTransposeOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00128">toString()</a>.</p>

</div>
</div>
<a id="a7cd53e808ea039aa9738dfab187468f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd53e808ea039aa9738dfab187468f8">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00946">946</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00963">getTileableBands()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01562">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a002c6258ba17b3a08e25cde241861c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c6258ba17b3a08e25cde241861c3f">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00880">880</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00780">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="ac1bdf7e87740dbe0f603efdbc83c0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bdf7e87740dbe0f603efdbc83c0a68">&#9670;&nbsp;</a></span>getPositionsOfShapeOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallBitVector mlir::getPositionsOfShapeOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00041">41</a> of file <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="aa99c6fbc90fbdd4ec89b8ec1d3499bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c6fbc90fbdd4ec89b8ec1d3499bc2">&#9670;&nbsp;</a></span>getProjectedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getProjectedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map that results from projecting out the dimensions specified in <code>projectedDimensions</code>. </p>
<p>The projected dimensions are set to 0.</p>
<p>Example: 1) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {2} result : affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</p>
<p>2) map : affine_map&lt;(d0, d1) -&gt; (d0 + d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0) -&gt; (d0)&gt;</p>
<p>3) map : affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; projected_dimensions : {1} result : affine_map&lt;(d0, d1) -&gt; (d0, 0)&gt;</p>
<p>This function also compresses unused symbols away. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00720">720</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">compressDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00625">compressUnusedSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02433">getCanonicalSubViewResultType()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00466">pruneReductionDimsFromMap()</a>.</p>

</div>
</div>
<a id="a1522039bca148f6d365612eb404e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522039bca148f6d365612eb404e0994">&#9670;&nbsp;</a></span>getReachableAffineApplyOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getReachableAffineApplyOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp. </p>
<p>Returns the sequence of AffineApplyOp Operations operation in 'affineApplyOps', which are reachable via a search starting from 'operands', and ending at operands which are not defined by AffineApplyOps.</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00194">194</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01369">createAffineComputationSlice()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00159">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="a12acf2020ef95ce0a5d7c3f2bbb6af14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12acf2020ef95ce0a5d7c3f2bbb6af14">&#9670;&nbsp;</a></span>getReassociationAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getReassociationAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the ArrayAttr which encodes reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">29</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00096">composeReassociationIndices()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00132">convertReassociationIndicesToExprs()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00169">convertReassociationMapsToIndices()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00159">getReassociationIndicesAttribute()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00031">getReassociationIndicesForCollapse()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00019">getReassociationIndicesForReshape()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00183">getSymbolLessAffineMaps()</a>, and <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00196">isReassociationValid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00762">computeTensorReshapeCollapsedType()</a>.</p>

</div>
</div>
<a id="a8ecbdeef85cdbc2ce3b49a088fa5946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecbdeef85cdbc2ce3b49a088fa5946a">&#9670;&nbsp;</a></span>getReassociationIndicesAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayAttr mlir::getReassociationIndicesAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a list of reassociations in an ArrayAttr. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00159">159</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00205">mlir::Builder::getArrayAttr()</a>, and <a class="el" href="Builders_8cpp_source.html#l00220">mlir::Builder::getI64ArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00762">computeTensorReshapeCollapsedType()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>.</p>

</div>
</div>
<a id="a9dfec7faa9f6efd40ec23d4a1147bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfec7faa9f6efd40ec23d4a1147bb49">&#9670;&nbsp;</a></span>getReassociationIndicesForCollapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForCollapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sourceShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reassociation maps to collapse <code>sourceShape</code> to <code>targetShape</code> if possible. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00031">31</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00019">getReassociationIndicesForReshape()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00288">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab87146cf16eb05a0abd56d11db525fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87146cf16eb05a0abd56d11db525fcc">&#9670;&nbsp;</a></span>getReassociationIndicesForReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; &gt; mlir::getReassociationIndicesForReshape </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>targetType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reassociations maps to use to reshape given the source type and the target type when possible. </p>
<p>Return llvm::None when this computation failed. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00019">19</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00031">getReassociationIndicesForCollapse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>.</p>

</div>
</div>
<a id="a52c9b6dd4f7515747a96c7de3ed325f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c9b6dd4f7515747a96c7de3ed325f9">&#9670;&nbsp;</a></span>getReductionIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getReductionIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has reduction semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">87</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00822">getDimMap()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00258">isConvolutionInterfaceImpl()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00088">isReductionIterator()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00128">toString()</a>.</p>

</div>
</div>
<a id="a77e7b43a7eea0ad307e6bb31a8a9671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e7b43a7eea0ad307e6bb31a8a9671b">&#9670;&nbsp;</a></span>getRegionBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> &gt; mlir::getRegionBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the read only operands that are passed to the region with the given <code>regionIndex</code>. </p>
<p>See <code>getMutableRegionBranchSuccessorOperands</code> for more information. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00392">392</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00371">getMutableRegionBranchSuccessorOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00036">collectUnderlyingAddressValues()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00205">mlir::InvocationBounds::getUnknown()</a>, and <a class="el" href="BufferViewFlowAnalysis_8cpp_source.html#l00042">mlir::BufferViewFlowAnalysis::remove()</a>.</p>

</div>
</div>
<a id="a617813f648e1d9b892b6c800d454fb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617813f648e1d9b892b6c800d454fb2e">&#9670;&nbsp;</a></span>getRelationFromMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a relation from the given AffineMap/AffineValueMap <code>map</code>, containing all pairs of the form <code>operands -&gt; result</code> that satisfy <code>map</code>. </p>
<p><code>rel</code> is set to the relation built. For example, give the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>:</p>
<p>(d0, d1)[s0] -&gt; (d0 + s0, d0 - s0)</p>
<p>the resulting relation formed is:</p>
<p>(d0, d1) -&gt; (r1, r2) [d0 d1 r1 r2 s0 const] 1 0 -1 0 1 0 = 0 0 1 0 -1 -1 0 = 0</p>
<p>For <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a>, the domain and symbols have <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> set corresponding to the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>map</code>. Returns failure if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> could not be flattened (i.e., semi-affine is not yet handled). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01718">1718</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00184">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00272">mlir::FlatAffineValueConstraints::appendDimId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01754">getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a6d361d2d6501c9e34585acab051ea0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d361d2d6501c9e34585acab051ea0d4">&#9670;&nbsp;</a></span>getRelationFromMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01754">1754</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00523">mlir::FlatAffineRelation::getNumDomainDims()</a>, <a class="el" href="AffineStructures_8h_source.html#l00524">mlir::FlatAffineRelation::getNumRangeDims()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00092">mlir::AffineValueMap::getOperand()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">getRelationFromMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00421">mlir::FlatAffineValueConstraints::setValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a8caaf930536d4bd103682ff878725908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8caaf930536d4bd103682ff878725908">&#9670;&nbsp;</a></span>getSCFMinMaxExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;std::pair&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&gt; &gt; mlir::getSCFMinMaxExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>loopFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the min/max expressions for <code>value</code> if it is an induction variable from scf.for or scf.parallel loop. </p>
<p>if <code>loopFilter</code> is passed, the filter determines which loop to consider. Other induction variables are ignored. </p>

</div>
</div>
<a id="a4052bdb6ce4bde76e5de054805848162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4052bdb6ce4bde76e5de054805848162">&#9670;&nbsp;</a></span>getSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *&#160;</td>
          <td class="paramname"><em>sequentialLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01349">1349</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00095">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="a78ba8fe6354d3dbe610c81805e7f85c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ba8fe6354d3dbe610c81805e7f85c6">&#9670;&nbsp;</a></span>getSinglyExecutedRegionsToSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getSinglyExecutedRegionsToSink </td>
          <td>(</td>
          <td class="paramtype">RegionBranchOpInterface&#160;</td>
          <td class="paramname"><em>branch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>regions</code> with regions of the provided region branch op that are executed at most once at that are reachable given the current operands of the op. </p>
<p>These regions can be passed to <code>controlFlowSink</code> to perform sinking on the regions of the operation. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">135</a> of file <a class="el" href="ControlFlowSinkUtils_8cpp_source.html">ControlFlowSinkUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00201">mlir::InvocationBounds::getUpperBound()</a>, <a class="el" href="Matchers_8h_source.html#l00259">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00333">matchPattern()</a>.</p>

</div>
</div>
<a id="afb361921efff7983dd75b7b0f342879d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb361921efff7983dd75b7b0f342879d">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>backwardFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a611e5b4f126ef025a241fda803748304">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>forwardFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <code>SetVector&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> *&gt;</code> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1>Example starting from any node </h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <code>getBackwardSlice</code> and <code>getForwardSlice</code>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1>Additional implementation considerations </h1>
<p>Consider the defs-op-uses hourglass. </p><hr/>
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <code>getSlice</code> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1>Assumption: </h1>
<p>We wish to maintain the following property by a recursive argument: """ defs &lt;&lt; {op} &lt;&lt;uses are in topological order. """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">133</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00113">getBackwardSlice()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00052">getForwardSlice()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00195">topologicalSort()</a>.</p>

</div>
</div>
<a id="af3fa33c99e241ea5c601599c366c415e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fa33c99e241ea5c601599c366c415e">&#9670;&nbsp;</a></span>getSliceIterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::getSliceIterationCount </td>
          <td>(</td>
          <td class="paramtype">const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceTripCountMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for the <code>slicetripCountMap</code> provided. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01031">1031</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00580">getFusionComputeCost()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00107">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a559ba63af5021a813f897a05897f0451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559ba63af5021a813f897a05897f0451">&#9670;&nbsp;</a></span>getStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the layout map in strided linear layout <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> form. </p>
<p>Return null if the layout is not compatible with a strided layout. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01008">1008</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00805">getStridesAndOffset()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">makeStridedLinearLayoutMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>.</p>

</div>
</div>
<a id="a506c478f802ab2f874c0b34a18bc091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506c478f802ab2f874c0b34a18bc091b">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the strides of the MemRef if the layout map is in strided form. </p>
<p>MemRefs with a layout map in strided form include:</p><ol type="1">
<li>empty or identity layout map, in which case the stride information is the canonical form computed from sizes;</li>
<li>single affine map layout of the form <code>K + k0 * d0 + ... kn * dn</code>, where K and ki's are constants or symbols.</li>
</ol>
<p>A stride specification is a list of integer values that are either static or dynamic (encoded with getDynamicStrideOrOffset()). Strides encode the distance in the number of elements between successive entries along a particular dimension.</p>
<p>For example, <code>memref&lt;42x16xf32, (64 * d0 + d1)&gt;</code> specifies a view into a non-contiguous memory region of <code>42</code> by <code>16</code> <code>f32</code> elements in which the distance between two consecutive elements along the outer dimension is <code>1</code> and the distance between two consecutive elements along the inner dimension is <code>64</code>.</p>
<p>The convention is that the strides for dimensions d0, .. dn appear in order to make indexing intuitive into the result. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00805">805</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00687">getElementType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00038">getFlattenedTypes()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00372">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00023">mlir::bufferization::castOrReallocMemRefValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01818">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01703">computeExpandedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00043">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00155">getCastCompatibleMemRefType()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00791">mlir::spirv::getElementPtr()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00097">getIndexedPtrs()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00059">getMemrefConstantHorizontalStride()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01018">getOffsetExpr()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00068">mlir::ConvertToLLVMPattern::getStridedElementPtr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01008">getStridedLinearLayoutMap()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00192">getTypeNumBytes()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02302">haveCompatibleOffsets()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00115">mlir::vector::isLastMemrefDimUnitStride()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01125">isLastMemrefDimUnitStride()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="ab9d8af8a280cbdd7ffbf4629ee82ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d8af8a280cbdd7ffbf4629ee82ccc4">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In practice, a strided memref must be internally non-aliasing. Test against 0 as a proxy. TODO: static cases can have more advanced checks. TODO: dynamic cases would require a way to compare symbolic expressions and would probably need an affine set context propagated everywhere. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">747</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00703">extractStrides()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00023">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00255">mlir::AffineMap::isIdentity()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">simplifyAffineExpr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>.</p>

</div>
</div>
<a id="aed3fe0298dee33ee77887d8ad11cc67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3fe0298dee33ee77887d8ad11cc67c">&#9670;&nbsp;</a></span>getStridesAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getStridesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of strides. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00071">71</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l02356">inferStridedSliceOpResultType()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02141">makeI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="a9933337bb49fef0db16ad0a2052f554f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9933337bb49fef0db16ad0a2052f554f">&#9670;&nbsp;</a></span>getSupportedReductions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getSupportedReductions </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>supportedReductions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>supportedReductions</code> with descriptors of the supported reductions. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00079">79</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00095">isLoopParallel()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a561d5231fcefc471a4c9069fce2eaf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d5231fcefc471a4c9069fce2eaf87">&#9670;&nbsp;</a></span>getSymbolLessAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; mlir::getSymbolLessAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ae5cf0e24a954fa30fb469105d4ca5dd8">ReassociationExprs</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs affine maps out of Array&lt;Array&lt;AffineExpr&gt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00183">183</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00762">computeTensorReshapeCollapsedType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00704">getNumElements()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01610">verifyCollapsedShape()</a>.</p>

</div>
</div>
<a id="a4d3feb8df27ef39080ba1e425ff1e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3feb8df27ef39080ba1e425ff1e112">&#9670;&nbsp;</a></span>getTileableBands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getTileableBands </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 6 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>bands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify valid and profitable bands of loops to tile. </p>
<p>This is currently just a temporary placeholder to test the mechanics of tiled code generation. Returns all maximal outermost perfect loop nests to tile. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00963">963</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00946">getPerfectlyNestedLoops()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="af2cc7770ed937494bbe2801d36c853ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cc7770ed937494bbe2801d36c853ac">&#9670;&nbsp;</a></span>getTripCountMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getTripCountMapAndOperands </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>tripCountOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise. </p>
<p>Returns the trip count of the loop as an affine expression if the latter is expressible as an affine expression, and nullptr otherwise.</p>
<p>This method always succeeds as long as the lower bound is not a multi-result map. The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions</p>
<p>The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">35</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00095">mlir::AffineMap::getConstantMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00056">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00109">getLargestDivisorOfTripCount()</a>.</p>

</div>
</div>
<a id="a98f08e970a346cd42559db87f97f0b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f08e970a346cd42559db87f97f0b91">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00059">59</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00032">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>, <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00212">getParallelComputeFunctionType()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00066">getUsedValuesDefinedAbove()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00241">outlineExecuteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00146">outlineKernelFuncImpl()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">outlineSingleBlockRegion()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00110">sinkOperationsIntoLaunchOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a2c45b388f069e9396c50660f41a7eacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c45b388f069e9396c50660f41a7eacf">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00066">66</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00059">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a7d8bbfc3d0c15e92f5cba28e5ef447b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8bbfc3d0c15e92f5cba28e5ef447b5">&#9670;&nbsp;</a></span>getValueOrCreateCastToIndexLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateCastToIndexLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cast from an index-like value (index or integer) to another index-like value. </p>
<p>If the value type and the target type are the same, it returns the original value. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00062">62</a> of file <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02231">buildVectorComparison()</a>, and <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aa058eb9c12d3b97deb073543c1372195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa058eb9c12d3b97deb073543c1372195">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation. ">OpFoldResult</a> to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns the fold result if it casts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or creates a ConstantIndexOp if it casts to an IntegerAttribute. Other attribute types are not supported. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00053">53</a> of file <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00076">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00139">getAsValues()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00084">getValueOrCreateConstantIndexOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00282">mlir::linalg::makeComposedExtractSliceOp()</a>, and <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab09c62516a7b31fc96892014feeae832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09c62516a7b31fc96892014feeae832">&#9670;&nbsp;</a></span>getValueOrCreateConstantIndexOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getValueOrCreateConstantIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>valueOrAttrVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the other overload, but converts multiple OpFoldResults into Values. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00084">84</a> of file <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00053">getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="ae14df83d38352e9dfc0eb0e01fc86230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14df83d38352e9dfc0eb0e01fc86230">&#9670;&nbsp;</a></span>getWindowIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getWindowIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00094">94</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">getAllIteratorTypeNames()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00095">isWindowIterator()</a>.</p>

</div>
</div>
<a id="aa3d787cb93ed1e8219f6cf6b2572d30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d787cb93ed1e8219f6cf6b2572d30f">&#9670;&nbsp;</a></span>greedilyMapParallelSCFToGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::greedilyMapParallelSCFToGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the parallel loops found in the given function to workgroups. </p>
<p>The first loop encountered will be mapped to the global workgroup and the second loop encountered to the local workgroup. Within each mapping, the first three dimensions are mapped to x/y/z hardware ids and all following dimensions are mapped to sequential loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00148">148</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00122">mapParallelOp()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00279">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ParallelLoopMapper_8h_source.html#l00045">mlir::gpu::getProcessor()</a>.</p>

</div>
</div>
<a id="a0139b17eb17bf529e630ec15f2051472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0139b17eb17bf529e630ec15f2051472">&#9670;&nbsp;</a></span>hasDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00176">176</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">getDependenceComponents()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00161">mlir::DependenceResult::HasDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkTilingLegalityImpl()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00195">getMaxLoopDepth()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00661">hasNoInterveningEffect()</a>.</p>

</div>
</div>
<a id="abb322b17530b4289c3e3ec1f4ad2ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322b17530b4289c3e3ec1f4ad2ecce">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types. ">TypeRange</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00082">82</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00096">96</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00135">mlir::Attribute::hash_value</a>, and <a class="el" href="Location_8h_source.html#l00087">mlir::Location::impl</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2IntegerSet_8h_source.html#l00123">123</a> of file <a class="el" href="IR_2IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00135">135</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00101">mlir::Attribute::impl</a>.</p>

</div>
</div>
<a id="aafb3bcc9d23b2cfd1367b84f5b00b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00149">149</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="aa4b795f2f972c070efff53082563f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b795f2f972c070efff53082563f976">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00193">193</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00229">229</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00204">mlir::OperationName::getAsOpaquePointer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l01207">mlir::OperationEquivalence::directHashValue()</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00230">230</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00182">mlir::Type::impl</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00240">240</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00198">mlir::AffineExpr::expr</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2IntegerSet_8h_source.html#l00140">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00140">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="TypeRange_8h_source.html#l00193">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00248">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="IR_2Types_8h_source.html#l00269">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00290">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::getHashValue()</a>, <a class="el" href="TypeID_8h_source.html#l00346">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::getHashValue()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00354">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00476">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00586">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="OpDefinition_8h_source.html#l01949">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &gt; &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00231">mlir::Value::getImpl()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>, and <a class="el" href="IR_2IntegerSet_8h_source.html#l00077">mlir::IntegerSet::operator==()</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00322">322</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8h_source.html#l00232">mlir::AffineMap::shiftSymbols()</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00458">458</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00231">mlir::Value::getImpl()</a>.</p>

</div>
</div>
<a id="a1858ec5ab152ee2a09d4ceaf95cf2811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1858ec5ab152ee2a09d4ceaf95cf2811">&#9670;&nbsp;</a></span>hasNonIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasNonIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the type is a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> and has a non-identity layout. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00268">268</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00173">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00229">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00288">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00156">verifyReshapeLikeShapes()</a>.</p>

</div>
</div>
<a id="a57bafa91f432ad40bb6246fbcbd555fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bafa91f432ad40bb6246fbcbd555fe">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>folded</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's. </p>
<p>Returns success if any hoisting happened; folded` is set to true if the op was folded or erased. This hoisting could lead to significant code expansion in some cases. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">408</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00649">applyOpPatternsAndFold()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00259">getOutermostInvariantForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01940">isForInductionVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00229">isTopLevelValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="afa82b2f82348c0eacc76f1c4a862a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa82b2f82348c0eacc76f1c4a862a796">&#9670;&nbsp;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00332">332</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="DialectInterface_8h_source.html#l00162">mlir::DialectInterfaceCollection&lt; InterfaceType &gt;::getInterfaceFor()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00060">mlir::InlinerInterface::isLegalToInline()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00306">materializeConversion()</a>, <a class="el" href="Value_8h_source.html#l00162">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00190">mlir::Operation::replaceUsesOfWith()</a>, <a class="el" href="Builders_8h_source.html#l00343">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00160">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="a20bc0a33de855f1c9a1a0ccfd8665e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bc0a33de855f1c9a1a0ccfd8665e78">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'regionResultTypes' specifies the expected return types of the terminators in the region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00262">262</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00284">inlineRegion()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00160">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="ad4aa94f3f9b2d783ae99a61d93b5268c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4aa94f3f9b2d783ae99a61d93b5268c">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00274">274</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="a6e080a2ba31bfcc4dd18b9a480051c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e080a2ba31bfcc4dd18b9a480051c74">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00284">284</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, and <a class="el" href="InliningUtils_8cpp_source.html#l00262">inlineRegion()</a>.</p>

</div>
</div>
<a id="a1ba290a2c8d06fe6d8a126ff21cdadd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba290a2c8d06fe6d8a126ff21cdadd2">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>inlineBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00295">295</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>.</p>

</div>
</div>
<a id="aa8c76f66345aba4e6cabb250bf7699c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c76f66345aba4e6cabb250bf7699c1">&#9670;&nbsp;</a></span>insertBackwardComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::insertBackwardComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>dstOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'. </p>
<p>Creates a computation slice of the loop nest surrounding 'srcOpInst', updates the slice loop bounds with any non-null bound maps specified in 'sliceState', and inserts this slice into the loop nest surrounding 'dstOpInst' at loop depth 'dstLoopDepth'.</p>
<p>Returns the top-level loop of the computation slice on success, returns nullptr otherwise.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01161">1161</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00721">findInstPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00738">getInstAtPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">getLoopIVs()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00084">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00080">mlir::ComputationSliceState::lbs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00086">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00082">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00107">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a426b7e62d7400b01d368a3db835df9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426b7e62d7400b01d368a3db835df9d3">&#9670;&nbsp;</a></span>insideMutuallyExclusiveRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::insideMutuallyExclusiveRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions as per RegionBranchOpInterface. </p>
<p>Return <code>true</code> if <code>a</code> and <code>b</code> are in mutually exclusive regions.</p>
<ol type="1">
<li>Find the first common of <code>a</code> and <code>b</code> (ancestor) that implements RegionBranchOpInterface.</li>
<li>Determine the regions <code>regionA</code> and <code>regionB</code> in which <code>a</code> and <code>b</code> are contained.</li>
<li>Check if <code>regionA</code> and <code>regionB</code> are mutually exclusive. They are mutually exclusive if they are not reachable from each other as per RegionBranchOpInterface::getSuccessorRegions. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00286">286</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00175">mlir::Operation::getParentOfType()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00245">isRegionReachable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8h_source.html#l00205">mlir::InvocationBounds::getUnknown()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00396">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="a9ff3713bf5c6762b9f8239a980ded85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff3713bf5c6762b9f8239a980ded85a">&#9670;&nbsp;</a></span>interchangeLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs loop interchange on 'forOpA' and 'forOpB'. </p>
<p>Performs loop interchange on 'forOpA' and 'forOpB', where 'forOpB' is nested within 'forOpA' as the only non-terminator operation in its block.</p>
<p>Requires that 'forOpA' and 'forOpB' are part of a perfectly nested sequence of loops.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01399">1399</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="a39612be2ef116102866d3bb9c6a8ca88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39612be2ef116102866d3bb9c6a8ca88">&#9670;&nbsp;</a></span>inverseAndBroadcastProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inverseAndBroadcastProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reverse map of a projected permutation where the projected dimensions are transformed into 0s. </p>
<p>Prerequisites: <code>map</code> must be a projected permuation.</p>
<p>Example 1:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d0)&gt;</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d1, 0, d0, 0)&gt;</div></div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d3)&gt;</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0, d1)&gt;</div></div><!-- fragment --><p>Example 3:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2, d3) -&gt; (d2)&gt;</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0) -&gt; (0, 0, d0, 0)&gt;</div></div><!-- fragment --><p> Example 4:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1, d2) -&gt; (d0, 0)&gt;</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">affine_map&lt;(d0, d1) -&gt; (d0, 0, 0)&gt;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00682">682</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00478">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty. Returns null map (not empty map) if <code>map</code> is not invertible (i.e. <code>map</code> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><code>map</code> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0       2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0            2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00658">658</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00267">mlir::AffineMap::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00201">buildVectorWrite()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00250">fuseElementwiseOpsImpl()</a>, <a class="el" href="Fusion_8cpp_source.html#l00482">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00038">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00037">interchangeGenericOpPrecondition()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00384">mlir::linalg::makeTransposeOp()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00240">replaceUnitExtents()</a>, <a class="el" href="Tiling_8cpp_source.html#l00099">tileLinalgOpImpl()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a0dfea8ee2dd0eba944b0cd299591ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">&#9670;&nbsp;</a></span>isColumnMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isColumnMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a column major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00041">41</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00023">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a043789541ff1881513700b717bf5491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043789541ff1881513700b717bf5491d">&#9670;&nbsp;</a></span>isConstantIntValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isConstantIntValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <code>ofr</code> is constant integer equal to <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00085">85</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getConstantIntValue()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="a2ee77c6f0feb82212b1b817785f95f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee77c6f0feb82212b1b817785f95f48">&#9670;&nbsp;</a></span>isEqualConstantIntOrValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isEqualConstantIntOrValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ofr1 and ofr2 are the same integer constant attribute values or the same SSA value. </p>
<p>Ignore integer bitwitdh and type mismatch that come from the fact there is no IndexAttr and that IndexType have no bitwidth.</p>
<p>Ignore integer bitwidth and type mismatch that come from the fact there is no IndexAttr and that IndexType has no bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="StaticValueUtils_8cpp_source.html#l00094">94</a> of file <a class="el" href="StaticValueUtils_8cpp_source.html">StaticValueUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00950">PadOpVectorizationWithTransferWritePattern::hasSameTensorSize()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00324">mlir::linalg::makeComposedPadHighOp()</a>.</p>

</div>
</div>
<a id="a0dd391dd6c617912e9c5e70caa5fb513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd391dd6c617912e9c5e70caa5fb513">&#9670;&nbsp;</a></span>isForInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isForInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of a AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01940">1940</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01946">getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00564">mlir::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00285">getNumCommonLoops()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00159">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="af233cbc2b6252b0f87bbc95f2bc8c553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af233cbc2b6252b0f87bbc95f2bc8c553">&#9670;&nbsp;</a></span>isLegalForBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is a BranchOpInterface op whose operands are all legal according to converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00119">119</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00236">mlir::Block::getNumSuccessors()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03003">mlir::TypeConverter::isLegal()</a>.</p>

</div>
</div>
<a id="ab6b78043105c4babf3635efc8a0c5db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b78043105c4babf3635efc8a0c5db1">&#9670;&nbsp;</a></span>isLegalForReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLegalForReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnOpAlwaysLegal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For ReturnLike ops (except <code>return</code>), return True. </p>
<p>If op is a <code>return</code> &amp;&amp; returnOpAlwaysLegal is false, legalize op according to converter. Otherwise, return false. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00140">140</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03003">mlir::TypeConverter::isLegal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="ae320e213a9c20060ae8292c150584fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320e213a9c20060ae8292c150584fac">&#9670;&nbsp;</a></span>isLoopMemoryParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLoopMemoryParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if `forOp' doesn't have memory dependences preventing parallelization. </p>
<p>Memrefs that are allocated inside <code>forOp</code> do not impact its dependences and parallelism. This function does not check iter_args (for values other than memref types) and should be used only as a building block for complete parallelism-checking functions. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00138">138</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01242">getNestingDepth()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00118">isAllocLikeOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00125">isLocallyDefined()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00162">mlir::DependenceResult::NoDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00095">isLoopParallel()</a>.</p>

</div>
</div>
<a id="ada966ff0f510c4882f6a4882c070c1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada966ff0f510c4882f6a4882c070c1c3">&#9670;&nbsp;</a></span>isLoopParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLoopParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1LoopReduction.html">LoopReduction</a> &gt; *&#160;</td>
          <td class="paramname"><em>parallelReductions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if `forOp' is a parallel loop. </p>
<p>If <code>parallelReductions</code> is provided, populates it with descriptors of the parallelizable reductions and treats them as not preventing parallelization. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00095">95</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00079">getSupportedReductions()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00138">isLoopMemoryParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01716">createSuperVectorizePass()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01349">getSequentialLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01340">isLoopParallelAndContainsReduction()</a>.</p>

</div>
</div>
<a id="a0b838aa59fec6e94e6afe4083478f52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b838aa59fec6e94e6afe4083478f52b">&#9670;&nbsp;</a></span>isLoopParallelAndContainsReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLoopParallelAndContainsReduction </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a loop is a parallel loop and contains a reduction loop. </p>
<p>Returns whether a loop is parallel and contains a reduction loop. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01340">1340</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00095">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="a625259a35e521a9f6d7b7fe115423e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625259a35e521a9f6d7b7fe115423e87">&#9670;&nbsp;</a></span>isNotBranchOpInterfaceOrReturnLikeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isNotBranchOpInterfaceOrReturnLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if op is neither BranchOpInterface nor ReturnLike. </p>
<p>TODO Try to get rid of this function and invert the meaning of <code>isLegalForBranchOpInterfaceTypeConversionPattern</code> and <code>isLegalForReturnOpTypeConversionPattern</code>. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00154">154</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::back()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00531">mlir::Operation::mightHaveTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&nbsp;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dialect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>typeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00046">46</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>.</p>

</div>
</div>
<a id="a8583719d6a8f0699c36ac4c4b53057f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583719d6a8f0699c36ac4c4b53057f2">&#9670;&nbsp;</a></span>isOpTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation is unused, and has no side effects on memory that prevent erasing. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">32</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00624">mlir::Operation::use_empty()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00093">wouldOpBeTriviallyDead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>.</p>

</div>
</div>
<a id="ac65079eba69cbd732d43736887a06bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65079eba69cbd732d43736887a06bff">&#9670;&nbsp;</a></span>isOpwiseShiftValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpwiseShiftValid </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts. </p>
<p>Checks whether SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.</p>
<p>This method checks if a 'def' and all its uses have the same shift factor. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00349">349</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00213">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00236">affineForOpBodySkew()</a>, and <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00163">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="a588d7472008e08ed39dd3e9d83c42775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d7472008e08ed39dd3e9d83c42775">&#9670;&nbsp;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00081">81</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast_or_null()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00080">getParallelIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00034">contractSupportsMMAMatrixType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00448">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00558">mlir::linalg::generateParallelLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01005">getCollapsableIterationSpaceDims()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01176">mlir::vector::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="Fusion_8cpp_source.html#l00466">pruneReductionDimsFromMap()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00035">splatZero()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00424">mlir::linalg::tileConsumerAndFuseProducers()</a>.</p>

</div>
</div>
<a id="abdac991f1476b0af97ff0620a3ddfdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdac991f1476b0af97ff0620a3ddfdb3">&#9670;&nbsp;</a></span>isPerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVM_ATTRIBUTE_UNUSED mlir::isPerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01470">1470</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01492">permuteLoops()</a>.</p>

</div>
</div>
<a id="ae209f096d9240a818927afbab10f43b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209f096d9240a818927afbab10f43b8">&#9670;&nbsp;</a></span>isRankReducedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> mlir::isRankReducedType </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>candidateReducedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <code>originalType</code> can be rank reduced to <code>candidateReducedType</code> type by dropping some dimensions with static size <code>1</code>. </p>
<p>Return <code><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">SliceVerificationResult::Success</a></code> on success or an appropriate error code. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00441">441</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00415">computeRankReductionMask()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">ElemTypeMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">RankTooLarge</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">SizeMismatch</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02314">isRankReducedMemRefType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l01442">verifyInsertSliceOp()</a>.</p>

</div>
</div>
<a id="a9e3d6f94b6a941066c3e7e5535817a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3d6f94b6a941066c3e7e5535817a9b">&#9670;&nbsp;</a></span>isReassociationValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isReassociationValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>invalidIndex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the reassociation specification is valid, false otherwise. </p>
<p>When false, the <code>invalidIndex</code> integer pointer is optionally filled with the index of the offending reassociation map. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00196">196</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00762">computeTensorReshapeCollapsedType()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00029">getReassociationAttrName()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">verifyReshapeLikeTypes()</a>.</p>

</div>
</div>
<a id="aea20c60a2e61974ab7981f341e562c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea20c60a2e61974ab7981f341e562c4c">&#9670;&nbsp;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00088">88</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast_or_null()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">getReductionIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00034">contractSupportsMMAMatrixType()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01158">genFor()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01005">getCollapsableIterationSpaceDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00186">getReductionMask()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01176">mlir::vector::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00580">reductionPreconditions()</a>.</p>

</div>
</div>
<a id="a9220af1b0ef10468f05c1e37e24371e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9220af1b0ef10468f05c1e37e24371e4">&#9670;&nbsp;</a></span>isRegionReturnLike()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRegionReturnLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is either annotated with the <code>ReturnLike</code> trait or implements the <code>RegionBranchTerminatorOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00358">358</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l00834">assertDestinationPassingStyle()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00223">mlir::bufferization::OneShotAnalysisState::gatherYieldedTensors()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00205">mlir::InvocationBounds::getUnknown()</a>, <a class="el" href="BufferOptimizations_8cpp_source.html#l00060">leavesAllocationScope()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00067">walkReturnOperations()</a>.</p>

</div>
</div>
<a id="aa28d7afae3a8e6d54489b5857b938d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28d7afae3a8e6d54489b5857b938d07">&#9670;&nbsp;</a></span>isRowMajorBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorBatchMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major batch matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00067">67</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00023">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="ae53f9bcf99efe125a11237ad6b64642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f9bcf99efe125a11237ad6b64642c">&#9670;&nbsp;</a></span>isRowMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorMatmul </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given maps describe a row major matmul. </p>
<p>The test is permutation-invariant. Note that this only checks the affine maps from an operation, so does not perform any checks on the math being performed within the reduction. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00015">15</a> of file <a class="el" href="StructuredOpsUtils_8cpp_source.html">StructuredOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00023">mlir::AffineExpr::getContext()</a>.</p>

</div>
</div>
<a id="a5893e8e846dfeb812cdc30cd9228ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5893e8e846dfeb812cdc30cd9228ec43">&#9670;&nbsp;</a></span>isSideEffectFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isSideEffectFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given operation is side-effect free. </p>
<p>An operation is side-effect free if its implementation of <code>MemoryEffectOpInterface</code> indicates that it has no memory effects. For example, it may implement <code>NoSideEffect</code> in ODS. Alternatively, if the operation <code>HasRecursiveSideEffects</code>, then it is side-effect free if all of its nested operations are side-effect free.</p>
<p>If the operation has both, then it is side-effect free if both conditions are satisfied. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectUtils_8cpp_source.html#l00015">15</a> of file <a class="el" href="SideEffectUtils_8cpp_source.html">SideEffectUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00096">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a2862732caa2de01d6eee7720857215d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2862732caa2de01d6eee7720857215d9">&#9670;&nbsp;</a></span>isStaticShapeAndContiguousRowMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStaticShapeAndContiguousRowMajor </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper determining if a memref is static-shape and contiguous-row-major layout, while still allowing for an arbitrary offset (any static or dynamic value). </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01042">1042</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00907">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01018">getOffsetExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01028">makeContiguousRowMajorMemRefType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>.</p>

</div>
</div>
<a id="ad0c26bcf64137533f38f2cda9abd75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c26bcf64137533f38f2cda9abd75af">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStrided </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the layout for <code>t</code> is compatible with strided semantics. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00999">999</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00240">mlir::LLVMTypeConverter::convertFunctionTypeCWrapper()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01043">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01021">mlir::AffineDmaStartOp::print()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>.</p>

</div>
</div>
<a id="aa36b5164871eaf1d6423cd0a2eb4e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">&#9670;&nbsp;</a></span>isTopLevelValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: These should be renamed if they are on the mlir namespace. </p>
<p>A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code>.</p>
<p>Ideally, they should go in a mlir::affine:: namespace. A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code> or is a region argument for such an op. A value of index type defined at the top level is always a valid symbol for all its uses.</p>
<p>If the value is defined in an unlinked region, conservatively assume it is not top-level. A value of index type defined at the top level is always a valid symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00229">229</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00564">mlir::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00326">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00279">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ac1377153422b2a3cc25d7053a30e59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1377153422b2a3cc25d7053a30e59bc">&#9670;&nbsp;</a></span>isTopLevelValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code>. </p>
<p>A value of index type defined at the top level of a <code>AffineScope</code> region is always a valid symbol for all uses in that region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00033">33</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>.</p>

</div>
</div>
<a id="a9e447f320894cc02bbaeff66dd31ccee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e447f320894cc02bbaeff66dd31ccee">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00259">259</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00244">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00432">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00085">remainsLegalAfterInline()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a31448f2e1927a26095c872bbfb4683a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31448f2e1927a26095c872bbfb4683a1">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00279">279</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00229">isTopLevelValue()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00356">isValidSymbol()</a>.</p>

</div>
</div>
<a id="aacd689ef70c61ee029b443673c78a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd689ef70c61ee029b443673c78a04e">&#9670;&nbsp;</a></span>isValidLoopInterchangePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidLoopInterchangePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange). </p>
<p>Checks if the loop interchange permutation 'loopPermMap' of the perfectly nested sequence of loops in 'loops' would violate dependences.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01456">1456</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01422">checkLoopInterchangeDependences()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">getDependenceComponents()</a>.</p>

</div>
</div>
<a id="a6f320624f15a47e5732c1142f99dc144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f320624f15a47e5732c1142f99dc144">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00356">356</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00244">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00229">isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00754">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00312">isMemRefSizeValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00432">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00279">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00385">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00085">remainsLegalAfterInline()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a6bfdb250aa76df12c7f6a5727e7ceb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfdb250aa76df12c7f6a5727e7ceb4b">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>. </p>
<p>A value can be used as a symbol for <code>region</code> iff it meets one of the following conditions: *) It is a constant.</p>
<p>*) It is the result of an affine apply operation with symbol arguments. *) It is a result of the dim op on a memref whose corresponding size is a valid symbol. *) It is defined at the top level of 'region' or is its argument. *) It dominates <code>region</code>'s parent op. If <code>region</code> is null, conservatively assume the symbol definition scope does not exist and only accept the values that would be symbols regardless of the surrounding region structure, i.e. the first three cases above. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00385">385</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00326">isDimOpValidSymbol()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00229">isTopLevelValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">isValidSymbol()</a>, <a class="el" href="Matchers_8h_source.html#l00259">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00333">matchPattern()</a>.</p>

</div>
</div>
<a id="a76b6d2ee408bfc5909eb81779da3e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b6d2ee408bfc5909eb81779da3e0f1">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable; i.e. </p>
<p>:</p><ol type="1">
<li>no conditionals are nested under the loop;</li>
<li>all nested load/stores are to scalar MemRefs. TODO: relax the no-conditionals restriction </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00339">339</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00266">isVectorizableLoopBodyWithOpCond()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00920">isVectorizableLoopPtrFactory()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01530">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="ae13f2a9f8242f345de0163689c30304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f2a9f8242f345de0163689c30304e">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>memRefDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either: </p>
<ol type="1">
<li>invariant along the loop induction variable created by 'loop';</li>
<li>varying along at most one memory dimension. If such a unique dimension is found, it is written into <code>memRefDim</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00316">316</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00213">isContiguousAccess()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00266">isVectorizableLoopBodyWithOpCond()</a>.</p>

</div>
</div>
<a id="af846930bde2aa600816a8dadd31bbddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846930bde2aa600816a8dadd31bbddc">&#9670;&nbsp;</a></span>isWindowIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isWindowIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00095">95</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast_or_null()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00094">getWindowIteratorTypeName()</a>.</p>

</div>
</div>
<a id="a4bfe9337070eb0f67cb7a3098ee136ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe9337070eb0f67cb7a3098ee136ee">&#9670;&nbsp;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for all CPU runners. </p>
<p>Expects the common argc/argv arguments for standard C++ main functions. The supplied dialect registry is expected to contain any registers that appear in the input IR, they will be loaded on-demand by the parser.</p>
<p>Expects the common argc/argv arguments for standard C++ main functions. </p>

<p class="definition">Definition at line <a class="el" href="JitRunner_8cpp_source.html#l00314">314</a> of file <a class="el" href="JitRunner_8cpp_source.html">JitRunner.cpp</a>.</p>

<p class="reference">References <a class="el" href="JitRunner_8cpp_source.html#l00239">compileAndExecuteVoidFunction()</a>, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00130">getCommandLineOptLevel()</a>, <a class="el" href="JitRunner_8h_source.html#l00048">mlir::JitRunnerConfig::llvmModuleBuilder</a>, <a class="el" href="OptUtils_8h_source.html#l00034">makeOptimizingTransformer</a>, <a class="el" href="JitRunner_8cpp_source.html#l00125">makeStringError()</a>, <a class="el" href="JitRunner_8h_source.html#l00042">mlir::JitRunnerConfig::mlirTransformer</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="JitRunner_8cpp_source.html#l00110">parseMLIRInput()</a>, and <a class="el" href="JitRunner_8h_source.html#l00052">mlir::JitRunnerConfig::runtimesymbolMap</a>.</p>

</div>
</div>
<a id="a5f7a5c72c1e0e867f3aac796b26ec2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::lcm </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the least common multiple of 'a' and 'b'. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00051">51</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00103">mlir::presburger::SimplexBase::addRow()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00434">eliminateFromConstraint()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l01676">mlir::presburger::IntegerRelation::fourierMotzkinEliminate()</a>.</p>

</div>
</div>
<a id="ac84b6a6dfd9d9eb78ca02c17cabbebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">&#9670;&nbsp;</a></span>linearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the linearized index of 'offsets' w.r.t. 'basis'. </p>

<p class="definition">Definition at line <a class="el" href="IndexingUtils_8cpp_source.html#l00013">13</a> of file <a class="el" href="IndexingUtils_8cpp_source.html">IndexingUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l01356">foldExtractFromShapeCast()</a>.</p>

</div>
</div>
<a id="af912da94236cff04e9076f6e052676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912da94236cff04e9076f6e052676b1">&#9670;&nbsp;</a></span>LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>. </p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l01227">mlir::OperationEquivalence::exactValueMatch()</a>.</p>

</div>
</div>
<a id="a66978e876ce5de46d58278fae24d4520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66978e876ce5de46d58278fae24d4520">&#9670;&nbsp;</a></span>loopUnrollByFactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <code>annotateFn</code>.</p>
<p>Returns success if the loop is successfully unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01092">1092</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01003">generateUnrolledLoop()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00109">getLargestDivisorOfTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnroll_8cpp_source.html#l00074">gatherInnermostLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00975">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00990">loopUnrollUpToFactor()</a>.</p>

</div>
</div>
<a id="a040c47f3f5d15eecb05a18c6343df489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040c47f3f5d15eecb05a18c6343df489">&#9670;&nbsp;</a></span>loopUnrollByFactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <code>annotateFn</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">378</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00251">ceilDivPositive()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00325">generateUnrolledLoop()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="Arithmetic_8h_source.html#l00086">mlir::arith::ConstantIndexOp::value()</a>.</p>

</div>
</div>
<a id="ab9a5f6331a28a90f85a2d8498fd6f801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5f6331a28a90f85a2d8498fd6f801">&#9670;&nbsp;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation completely if the trip count is known to be constant. </p>
<p>Unrolls this loop completely.</p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00975">975</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01092">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnroll_8cpp_source.html#l00074">gatherInnermostLoops()</a>.</p>

</div>
</div>
<a id="ad67a63b71c0fe3f345278eab205e10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a63b71c0fe3f345278eab205e10a3">&#9670;&nbsp;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor. </p>
<p><code>forOp</code> can be a loop with iteration arguments performing supported reductions and its inner loops can have iteration arguments. Returns success if the loop is successfully unroll-jammed. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01203">1203</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01163">areInnerBoundsInvariant()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00109">getLargestDivisorOfTripCount()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00079">getSupportedReductions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01179">JamBlockGatherer::subBlocks</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, <a class="el" href="Value_8h_source.html#l00203">mlir::Value::use_empty()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01182">JamBlockGatherer::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00067">createLoopUnrollAndJamPass()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01152">loopUnrollJamUpToFactor()</a>.</p>

</div>
</div>
<a id="ac918847951e0d20706fe61380e119adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918847951e0d20706fe61380e119adb">&#9670;&nbsp;</a></span>loopUnrollJamUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01152">1152</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a4a6ed1cfcc6232ad7dae507d67db6462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ed1cfcc6232ad7dae507d67db6462">&#9670;&nbsp;</a></span>loopUnrollUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop by the specified unroll factor or its trip count, whichever is lower. </p>
<p>Unrolls this loop by the specified factor or by the trip count (if constant) whichever is lower.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00990">990</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01092">loopUnrollByFactor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnroll_8cpp_source.html#l00074">gatherInnermostLoops()</a>.</p>

</div>
</div>
<a id="afdf4bbbb9eb7a9678bd98d122b837cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">&#9670;&nbsp;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>
<p>Emit instructions that correspond to the affine map in the lower bound applied to the respective operands, and compute the maximum value across the results.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00090">90</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00130">mlir::Attribute::cast()</a>, <a class="el" href="Location_8h_source.html#l00067">mlir::Location::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00265">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00215">expandAffineExpr()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00223">expandAffineMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="AffineOps_8h_source.html#l00155">mlir::AffineDmaStartOp::getDstMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00134">mlir::AffineDmaStartOp::getDstMemRefOperandIndex()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01952">mlir::arith::getIdentityValue()</a>, <a class="el" href="OpDefinition_8h_source.html#l00108">mlir::OpState::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00273">mlir::Operation::getOperand()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01960">mlir::arith::getReductionOp()</a>, <a class="el" href="AffineOps_8h_source.html#l00116">mlir::AffineDmaStartOp::getSrcMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00107">mlir::AffineDmaStartOp::getSrcMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00104">mlir::AffineDmaStartOp::getSrcMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00308">mlir::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00184">mlir::AffineDmaStartOp::getTagMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00302">mlir::AffineDmaWaitOp::getTagMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00296">mlir::AffineDmaWaitOp::getTagMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00168">mlir::AffineDmaStartOp::getTagMemRefOperandIndex()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00339">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00061">lowerAffineMapMax()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00071">lowerAffineMapMin()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00082">lowerAffineUpperBound()</a>, <a class="el" href="PatternMatch_8h_source.html#l00512">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00367">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00091">getOrEmitLowerBound()</a>.</p>

</div>
</div>
<a id="a2d924b9762c352e82e8fe0fb1e222288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d924b9762c352e82e8fe0fb1e222288">&#9670;&nbsp;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>
<p>Emit instructions that correspond to the affine map in the upper bound applied to the respective operands, and compute the minimum value across the results.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00082">82</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineToStandard_8cpp_source.html#l00071">lowerAffineMapMin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00097">getOrEmitUpperBound()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00090">lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="a8ea33aa665368d4f2108eb2d41c85111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea33aa665368d4f2108eb2d41c85111">&#9670;&nbsp;</a></span>m_AnyZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_AnyZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float (both positive and negative) zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00272">272</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00047">isEmptyInit()</a>.</p>

</div>
</div>
<a id="ad402a86ee4c9000c6fa1fceaddab560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402a86ee4c9000c6fa1fceaddab560b">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a> mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00259">259</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00797">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00566">genVectorMask()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">getAsOpFoldResult()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00908">getF64Values()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00199">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00152">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00113">mlir::OperationFolder::insertKnownConstant()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00186">integerConstants()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00373">isDefinedOutsideOrConstant()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00194">isInBounds()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00063">isLikelyAnIndexComputation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00068">isOpLoopInvariant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00385">isValidSymbol()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00324">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00196">ConstantTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00259">NoOpOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00292">AddZeroOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01429">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00168">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>, <a class="el" href="Builders_8cpp_source.html#l00398">mlir::OpBuilder::tryFold()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="a10b6da5781fbe1b019fcb64dcd6921dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6da5781fbe1b019fcb64dcd6921dd">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;AttrT&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00266">266</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00037">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::bind_value</a>.</p>

</div>
</div>
<a id="a41f267f37c147c72f6ca26a41ff9f7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f267f37c147c72f6ca26a41ff9f7bb">&#9670;&nbsp;</a></span>m_ConstantFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">detail::constant_float_op_binder</a> mlir::m_ConstantFloat </td>
          <td>(</td>
          <td class="paramtype">FloatAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor float (splat) and writes the float value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00349">349</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a930dbe1d176d999aec049a4581838974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930dbe1d176d999aec049a4581838974">&#9670;&nbsp;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype">IntegerAttr::ValueType *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00356">356</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMDialect_8cpp_source.html#l00453">extractVectorElementType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getConstantIntValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>, and <a class="el" href="ControlFlowOps_8cpp_source.html#l00681">simplifyConstSwitchValue()</a>.</p>

</div>
</div>
<a id="a9e89b015211525b010832d2d2c37650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89b015211525b010832d2d2c37650b">&#9670;&nbsp;</a></span>m_NegInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00303">303</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="aa9eba8d1292854c0da6c062988ecac9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eba8d1292854c0da6c062988ecac9b">&#9670;&nbsp;</a></span>m_NegZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_NegZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float negative zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00282">282</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="a94bb42600b9be680591776fdc14a53cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb42600b9be680591776fdc14a53cd">&#9670;&nbsp;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00316">316</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>.</p>

</div>
</div>
<a id="a907f415a4c803b15ef57db37cc732f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907f415a4c803b15ef57db37cc732f39">&#9670;&nbsp;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00321">321</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00183">mlir::arith::ConstantIndexOp::classof()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00651">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, and <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="af0495d84f34cf3238a7741fa6974a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0495d84f34cf3238a7741fa6974a485">&#9670;&nbsp;</a></span>m_OneFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_OneFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float ones. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00287">287</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="ac2418532386147bec2ca5aadf5414406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2418532386147bec2ca5aadf5414406">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt;OpClass&gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00327">327</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...&#160;</td>
          <td class="paramname"><em>matchers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00361">361</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="adc93dfeaa35bda23b16591c462c335f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93dfeaa35bda23b16591c462c335f6">&#9670;&nbsp;</a></span>m_PosInfFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosInfFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive infinity. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00295">295</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="a774a1ae971f4ef00eb57389293dfe617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774a1ae971f4ef00eb57389293dfe617">&#9670;&nbsp;</a></span>m_PosZeroFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">detail::constant_float_predicate_matcher</a> mlir::m_PosZeroFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat float positive zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00277">277</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="a7f5d8af15bd8994b1a7abeaaacfe1b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d8af15bd8994b1a7abeaaacfe1b06">&#9670;&nbsp;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">detail::constant_int_predicate_matcher</a> mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00310">310</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00183">mlir::arith::ConstantIndexOp::classof()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01277">getBoolAttribute()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00047">isEmptyInit()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>, and <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>.</p>

</div>
</div>
<a id="ac603376cc0dac0b2bd27c2dcde3c2e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>. </p>
<p>Strides are multiplicative and once a dynamic dimension is encountered, all canonical strides become dynamic and need to be encoded with a different symbol. For canonical strides expressions, the offset is always 0 and and fastest varying stride is always <code>1</code>.</p>
<p>Examples:</p><ul>
<li>memref&lt;3x4x5xf32&gt; has canonical stride expression <code>20*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x?x5xf32&gt; has canonical stride expression <code>s0*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x4x?xf32&gt; has canonical stride expression <code>s1*exprs[0] + s0*exprs[1] + exprs[2]</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">945</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00907">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00989">makeCanonicalStridedLayoutExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01028">makeContiguousRowMajorMemRefType()</a>.</p>

</div>
</div>
<a id="ad25cd8672ecb721d7a4f0ecd22bac6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00989">989</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>.</p>

</div>
</div>
<a id="a58d30ccceb8aecf3060031371bc8a72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d30ccceb8aecf3060031371bc8a72b">&#9670;&nbsp;</a></span>makeComposedAffineApply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands. </p>
<p>The operands of the resulting AffineApplyOp do not change the length of AffineApplyOp chains. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00708">708</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, and <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00941">mlir::linalg::addTileLoopIvsToIndexOpResults()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00062">createInBoundsCond()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01001">createMask()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00039">mlir::tensor::createPadHighOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00718">makeComposedAffineApply()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00282">mlir::linalg::makeComposedExtractSliceOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00747">mlir::linalg::makeTiledShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00538">mlir::linalg::updateBoundsForCyclicDistribution()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a60836647618fe45d44620a7b41d3ca04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60836647618fe45d44620a7b41d3ca04">&#9670;&nbsp;</a></span>makeComposedAffineApply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>makeComposedAffineApply</code> which infers the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> from <code>e</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00718">718</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00708">makeComposedAffineApply()</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&nbsp;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which MemRefType::getDynamicStrideOrOffset() represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride cannot take value <code>0</code>.</p>
<h1>Examples: </h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">866</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00398">mlir::TensorType::classof()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01818">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01703">computeExpandedLayoutMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00982">eraseStridedLayout()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00155">getCastCompatibleMemRefType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00659">mlir::bufferization::getMemRefType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01008">getStridedLinearLayoutMap()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00194">mlir::detail::Parser::parseMemRefType()</a>.</p>

</div>
</div>
<a id="abdc308b7190d3d087a4c12adb23b387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc308b7190d3d087a4c12adb23b387b">&#9670;&nbsp;</a></span>mapLoopToProcessorIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::mapLoopToProcessorIds </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>processorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>numProcessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>. </p>
<p>This is achieved by embedding the SSA values corresponding to <code>processorIds</code> and <code>numProcessors</code> into the bounds and step of the <code>forOp</code>. No check is performed on the legality of the rewrite, it is the caller's responsibility to ensure legality.</p>
<p>Requires that <code>processorIds</code> and <code>numProcessors</code> have the same size and that for each idx, <code>processorIds</code>[idx] takes, at runtime, all values between 0 and <code>numProcessors</code>[idx] - 1. This corresponds to traditional use cases for:</p><ol type="1">
<li>GPU (threadIdx, get_local_id(), ...)</li>
<li>MPI (MPI_Comm_rank)</li>
<li>OpenMP (omp_get_thread_num)</li>
</ol>
<p>Example: Assuming a 2-d grid with processorIds = [blockIdx.x, threadIdx.x] and numProcessors = [gridDim.x, blockDim.x], the loop:</p>
<div class="fragment"><div class="line">scf.for %i = %lb to %ub step %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>is rewritten into a version resembling the following pseudo-IR:</p>
<div class="fragment"><div class="line">scf.for %i = %lb + %step * (threadIdx.x + blockIdx.x * blockDim.x)</div><div class="line">   to %ub step %gridDim.x * blockDim.x * %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01834">1834</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00448">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00031">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="ac7736bcb70dbd9f242cd5182dd443031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7736bcb70dbd9f242cd5182dd443031">&#9670;&nbsp;</a></span>matchConstantIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; <a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html">arith::ConstantIndexOp</a> &gt; mlir::matchConstantIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a ConstantIndexOp. </p>
<p>TODO: This should probably just be a general matcher that uses matchConstant and checks the operation for an index type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html#l00022">22</a> of file <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a1fe80a8d036b62be279ebe10c18dc953">canonicalizeSubViewPart()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00333">333</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00797">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00183">mlir::arith::ConstantIndexOp::classof()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00453">extractVectorElementType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00566">genVectorMask()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">getAsOpFoldResult()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01277">getBoolAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">getConstantIntValue()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00908">getF64Values()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00199">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">getSinglyExecutedRegionsToSink()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00152">mlir::ValueShapeRange::getValueAsShape()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00113">mlir::OperationFolder::insertKnownConstant()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00186">integerConstants()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00373">isDefinedOutsideOrConstant()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00047">isEmptyInit()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00194">isInBounds()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00063">isLikelyAnIndexComputation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00068">isOpLoopInvariant()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00385">isValidSymbol()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00324">mlir::linalg::makeComposedPadHighOp()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00196">ConstantTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00259">NoOpOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00292">AddZeroOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00651">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01429">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00050">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00168">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00310">signedCeilNonnegInputs()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00681">simplifyConstSwitchValue()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="Builders_8cpp_source.html#l00398">mlir::OpBuilder::tryFold()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00342">342</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00042">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::match()</a>.</p>

</div>
</div>
<a id="a0319d523385e6e3a03e2c9ff83a4750a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0319d523385e6e3a03e2c9ff83a4750a">&#9670;&nbsp;</a></span>matchReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::matchReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td>
          <td class="paramname"><em>iterCarriedArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>redPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>combinerOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to match a generic reduction given a list of iteration-carried arguments, <code>iterCarriedArgs</code> and the position of the potential reduction argument within the list, <code>redPos</code>. </p>
<p>If a reduction is matched, returns the reduced value and the topologically-sorted list of combiner operations involved in the reduction. Otherwise, returns a null value.</p>
<p>The matching algorithm relies on the following invariants, which are subject to change:</p><ol type="1">
<li>The first combiner operation must be a binary operation with the iteration-carried value and the reduced value as operands.</li>
<li>The iteration-carried value and combiner operations must be side effect-free, have single result and a single use.</li>
<li>Combiner operations must be immediately nested in the region op performing the reduction.</li>
<li>Reduction def-use chain must end in a terminator op that yields the next iteration/output values in the same order as the iteration-carried values in <code>iterCarriedArgs</code>.</li>
<li><code>iterCarriedArgs</code> must contain all the iteration-carried/output values of the region op performing the reduction.</li>
</ol>
<p>This utility is generic enough to detect reductions involving multiple combiner operations (disabled for now) across multiple dialects, including Linalg, Affine and SCF. For the sake of genericity, it does not return specific enum values for the combiner operations since its goal is also matching reductions without pre-defined semantics in core MLIR. It's up to each client to make sense out of the list of combiner operations. It's also up to each client to check for additional invariants on the expected reductions not covered by this generic matching. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00270">270</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00219">dependsOnCarriedVals()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00273">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00172">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00645">mlir::Operation::getUsers()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00621">mlir::Operation::hasOneUse()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00531">mlir::Operation::mightHaveTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00144">matchLinalgReduction()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00036">matchSimpleReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01423">vectorizeAffineYieldOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00344">vectorizeOneOp()</a>.</p>

</div>
</div>
<a id="af3ad163144fafb93cf9814b2235ccf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ad163144fafb93cf9814b2235ccf59">&#9670;&nbsp;</a></span>MlirLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-lsp-server</code>. </p>
<ul>
<li>registry should contain all the dialects that can be parsed in source IR passed to the server. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirLspServerMain_8cpp_source.html#l00021">21</a> of file <a class="el" href="MlirLspServerMain_8cpp_source.html">MlirLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00203">mlir::lsp::LSPServer::run()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="a12e665be5c248a4929119ca802c7e488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e665be5c248a4929119ca802c7e488">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;&#160;</td>
          <td class="paramname"><em>passPipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitInputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyDiagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyPasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnregisteredDialects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preloadDialectsInContext</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the core processing behind <code>mlir-opt</code>: </p>
<ul>
<li>outputStream is the stream where the resulting IR is printed.</li>
<li>buffer is the in-memory file to parser and process.</li>
<li>passPipeline is the specification of the pipeline that will be applied.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>splitInputFile will look for a "-----" marker in the input file, and load each chunk in an individual ModuleOp processed separately.</li>
<li>verifyDiagnostics enables a verification mode where comments starting with "expected-(error|note|remark|warning)" are parsed in the input and matched against emitted diagnostics.</li>
<li>verifyPasses enables the IR verifier in-between each pass in the pipeline.</li>
<li>allowUnregisteredDialects allows to parse and create operation without registering the <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.</li>
<li>preloadDialectsInContext will trigger the upfront loading of all dialects from the global registry in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. This option is deprecated and will be removed soon. </li>
</ul>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00092">processBuffer()</a>.</p>

</div>
</div>
<a id="a8ae6077c691513a852d0f978191f2d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae6077c691513a852d0f978191f2d24">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aa22124ccf5219095aee552486366ccc0">PassPipelineFn</a>&#160;</td>
          <td class="paramname"><em>passManagerSetupFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitInputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyDiagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyPasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnregisteredDialects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preloadDialectsInContext</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support a callback to setup the pass manager. </p>
<ul>
<li>passManagerSetupFn is the callback invoked to setup the pass manager to apply on the loaded IR. </li>
</ul>

</div>
</div>
<a id="a97aa62850bedfdb7b95db9d097579763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97aa62850bedfdb7b95db9d097579763">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preloadDialectsInContext</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-opt</code>. </p>
<ul>
<li>toolName is used for the header displayed by <code>--help</code>.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>preloadDialectsInContext will trigger the upfront loading of all dialects from the global registry in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. This option is deprecated and will be removed soon. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00194">194</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00156">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="namespacemlir.html#a12e665be5c248a4929119ca802c7e488">MlirOptMain()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00167">registerAsmPrinterCLOptions()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00107">mlir::DebugCounter::registerCLOptions()</a>, <a class="el" href="Timing_8cpp_source.html#l00556">registerDefaultTimingManagerCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00086">registerMLIRContextCLOptions()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00128">registerPassManagerCLOptions()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="afcf1fa346908020b9dbc2009bb3630ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1fa346908020b9dbc2009bb3630ce">&#9670;&nbsp;</a></span>MlirPdllLspServerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirPdllLspServerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-pdll-lsp-server</code>. </p>

<p class="definition">Definition at line <a class="el" href="MlirPdllLspServerMain_8cpp_source.html#l00020">20</a> of file <a class="el" href="MlirPdllLspServerMain_8cpp_source.html">MlirPdllLspServerMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581aa603905470e2a5b8c13e96b579ef0dba">mlir::lsp::Logger::Debug</a>, <a class="el" href="Transport_8h_source.html#l00043">mlir::lsp::Delimited</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a902b0d55fddef6f8d651fe1035b7d4bd">mlir::lsp::Logger::Error</a>, <a class="el" href="classmlir_1_1lsp_1_1Logger.html#a2c49a7e9f2cb27c007ec6857bd85a581a4059b0251f66a18cb56f544728796875">mlir::lsp::Logger::Info</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00255">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="Logging_8cpp_source.html#l00017">mlir::lsp::Logger::setLogLevel()</a>, and <a class="el" href="Transport_8h_source.html#l00041">mlir::lsp::Standard</a>.</p>

</div>
</div>
<a id="ab515fd3b6aebea7df681f094b42d9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515fd3b6aebea7df681f094b42d9e71">&#9670;&nbsp;</a></span>mlirReduceMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::mlirReduceMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">41</a> of file <a class="el" href="MlirReduceMain_8cpp_source.html">MlirReduceMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00915">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00049">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00031">loadModule()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00657">mlir::PassManager::run()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ab673e648679ec83d87417b04baf281dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab673e648679ec83d87417b04baf281dd">&#9670;&nbsp;</a></span>mlirTranslateMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::mlirTranslateMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate to/from an MLIR module from/to an external representation (e.g. </p>
<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, SPIRV binary, ...). This is the entry point for the implementation of tools like <code>mlir-translate</code>. The translation to perform is parsed from the command line. The <code>toolName</code> argument is used for the header displayed by <code>--help</code>. </p>

</div>
</div>
<a id="afca33cad5b0cd935568ea0fc0a439abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca33cad5b0cd935568ea0fc0a439abd">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::mod </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns MLIR's mod operation on constants. </p>
<p>MLIR's mod operation yields the remainder of the Euclidean division of 'lhs' by 'rhs', and is therefore not C's % operator. The RHS is always expected to be positive, and the result is always non-negative. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00045">45</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00260">mlir::presburger::LexSimplexBase::addCut()</a>, <a class="el" href="AllocLikeConversion_8cpp_source.html#l00014">mlir::AllocLikeOpLLVMLowering::createAligned()</a>, <a class="el" href="IRModule_8h_source.html#l00920">mlir::python::PyAffineExpr::get()</a>, <a class="el" href="Simplex_8cpp_source.html#l00351">isRangeDivisibleBy()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00219">parseScheduleClause()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01093">prepareLLVMModule()</a>, and <a class="el" href="OpenMPDialect_8cpp_source.html#l00179">verifyScheduleModifiers()</a>.</p>

</div>
</div>
<a id="a7770d05a67ea19ac133fde220298b3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7770d05a67ea19ac133fde220298b3c7">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isDefinedOutsideRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>shouldMoveOutOfRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>moveOutOfRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of regions, perform loop-invariant code motion. </p>
<p>An operation is loop-invariant if it depends only of values defined outside of the loop. LICM moves these operations out of the loop body so that they are not computed more than once.</p>
<p>Example:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div><div class="line">  affine.for %arg1 = 0 to 10 {</div><div class="line">    %v0 = arith.addi %arg0, %arg0 : i32</div><div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>After LICM:</p>
<div class="fragment"><div class="line">affine.for %arg0 = 0 to 10 {</div><div class="line">  %v0 = arith.addi %arg0, %arg0 : i32</div><div class="line">  affine.for %arg1 = 0 to 10 {</div><div class="line">    %v1 = arith.addi %v0, %arg1 : i32</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Users must supply three callbacks.</p>
<ul>
<li><code>isDefinedOutsideRegion</code> returns true if the given value is invariant with respect to the given region. A common implementation might be: <code>value.getParentRegion()-&gt;isProperAncestor(region)</code>.</li>
<li><code>shouldMoveOutOfRegion</code> returns true if the provided operation can be moved of the given region, e.g. if it is side-effect free.</li>
<li><code>moveOutOfRegion</code> moves the operation out of the given region. A common implementation might be: <code>op-&gt;moveBefore(region-&gt;getParentOp())</code>.</li>
</ul>
<p>An operation is moved if all of its operands satisfy <code>isDefinedOutsideRegion</code> and it satisfies <code>shouldMoveOutOfRegion</code>.</p>
<p>Returns the number of operations moved. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00050">50</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00028">canBeHoisted()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00168">mlir::Operation::getParentRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00645">mlir::Operation::getUsers()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00395">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00096">moveLoopInvariantCode()</a>.</p>

</div>
</div>
<a id="a56b9f2d2e0330c53880b673633907ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b9f2d2e0330c53880b673633907ac6">&#9670;&nbsp;</a></span>moveLoopInvariantCode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLike</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move side-effect free loop invariant code out of a loop-like op using methods provided by the interface. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00096">96</a> of file <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html">LoopInvariantCodeMotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectUtils_8cpp_source.html#l00015">isSideEffectFree()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00050">moveLoopInvariantCode()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a8e15aec55d8f7275d4f2f770e26f9041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e15aec55d8f7275d4f2f770e26f9041">&#9670;&nbsp;</a></span>normalizeAffineFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::normalizeAffineFor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize an affine.for op. </p>
<p>Normalizes affine.for ops.</p>
<p>If the affine.for op has only a single iteration only then it is simply promoted, else it is normalized in the traditional way, by converting the lower bound to zero and loop step to one. The upper bound is set to the trip count of the loop. Original loops must have a lower bound with only a single result. There is no such restriction on upper bounds. Returns success if the loop has been normalized (or is already in the normal form).</p>
<p>If the affine.for op has only a single iteration only then it is simply promoted, else it is normalized in the traditional way, by converting the lower bound to zero and loop step to one. The upper bound is set to the trip count of the loop. For now, original loops must have lower bound with a single result only. There is no such restriction on upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">556</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">canonicalizeMapAndOperands()</a>, <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00299">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00452">mlir::AffineBound::getMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00454">mlir::AffineBound::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8h_source.html#l00455">mlir::AffineBound::getOperand()</a>, <a class="el" href="AffineOps_8h_source.html#l00462">mlir::AffineBound::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00330">mlir::Operation::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">promoteIfSingleIteration()</a>, <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ac0a1fe4deb3e0ecb3d92460a0ffec72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a1fe4deb3e0ecb3d92460a0ffec72e">&#9670;&nbsp;</a></span>normalizeAffineParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::normalizeAffineParallel </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a affine.parallel op so that lower bounds are 0 and steps are 1. </p>
<p>As currently implemented, this transformation cannot fail and will return early if the op is already in a normalized form. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00485">485</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00209">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00809">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00293">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00069">mlir::AffineValueMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00070">mlir::AffineValueMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00067">mlir::AffineValueMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, and <a class="el" href="Value_8cpp_source.html#l00061">mlir::Value::replaceAllUsesExcept()</a>.</p>

</div>
</div>
<a id="a33df4a5521b82b16cc2530426e2aa724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33df4a5521b82b16cc2530426e2aa724">&#9670;&nbsp;</a></span>normalizeMemRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::normalizeMemRef </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses. </p>
<p>Returns failure if any of its uses escape (while leaving the IR in a valid state). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">1677</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01627">createNewDynamicSizes()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01453">getTileSizePos()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00213">mlir::Value::getUsers()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">normalizeMemRefType()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01254">replaceAllMemRefUsesWith()</a>, <a class="el" href="Value_8h_source.html#l00162">mlir::Value::replaceAllUsesWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>.</p>

</div>
</div>
<a id="ad139b18a8e4fed885a7c7040ac8c9a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139b18a8e4fed885a7c7040ac8c9a42">&#9670;&nbsp;</a></span>normalizeMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::normalizeMemRefType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbolicOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the old memref type map layout and computes the new memref type to have a new shape and a layout map, where the old layout map has been normalized to an identity layout map. </p>
<p>It returns the old memref in case no normalization was needed or a failure occurs while transforming the old map layout to an identity layout map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">1735</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">mlir::FlatAffineValueConstraints::composeMatchingMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01515">mlir::presburger::IntegerRelation::getConstantBound()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00308">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01453">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01552">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::LB</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01377">mlir::FlatAffineValueConstraints::projectOut()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00186">mlir::MemRefType::Builder::setLayout()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00176">mlir::MemRefType::Builder::setShape()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::UB</a>.</p>

<p class="reference">Referenced by <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">&#9670;&nbsp;</a></span>openInputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::MemoryBuffer&gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="CompilationDatabase_8cpp_source.html#l00058">mlir::lsp::CompilationDatabase::getFileInfo()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, and <a class="el" href="JitRunner_8cpp_source.html#l00110">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="a4c8c9750d9c8efdbcc7542f3b1564d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">&#9670;&nbsp;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::ToolOutputFile&gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00083">mlir::SimpleObjectCache::dumpToObjectFile()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00409">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00064">generateLocationsFromIR()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, and <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">mlirReduceMain()</a>.</p>

</div>
</div>
<a id="aab45d6414e128b6ce12252cac519bbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab45d6414e128b6ce12252cac519bbac">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowAnalysis_8h_source.html#l00049">49</a> of file <a class="el" href="DataFlowAnalysis_8h_source.html">DataFlowAnalysis.h</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00222">222</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a8db56ba5c170b04848e194937be59a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db56ba5c170b04848e194937be59a56">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00927">927</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReductionNode_8h_source.html#l00080">mlir::ReductionNode::getVariants()</a>.</p>

</div>
</div>
<a id="a6bb385e3105982b905c5ef4db9f9f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb385e3105982b905c5ef4db9f9f21b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00933">933</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a48146d74baebce1c83140c378053f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48146d74baebce1c83140c378053f3c2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00939">939</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a4bfbb1c5941d2cc005eb3f483e881202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfbb1c5941d2cc005eb3f483e881202">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00943">943</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00245">245</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReductionNode_8h_source.html#l00080">mlir::ReductionNode::getVariants()</a>, and <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00244">244</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00246">246</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00045">getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="ac7e879c874e4fdc6aaf9d4742abdb876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e879c874e4fdc6aaf9d4742abdb876">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02392">2392</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8h_source.html#l00027">mlir::Range::offset</a>, <a class="el" href="ViewLikeInterface_8h_source.html#l00028">mlir::Range::size</a>, and <a class="el" href="ViewLikeInterface_8h_source.html#l00029">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="af8130946445de43cbbe975607457e51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8130946445de43cbbe975607457e51c">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AliasResult.html">AliasResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00078">78</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00030">mlir::AliasResult::print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolTable_8h_source.html#l00171">mlir::SymbolTable::UseRange::empty()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00276">shouldPrintElementsAttrWithHex()</a>.</p>

</div>
</div>
<a id="a40e22b31f6f0d59955e0e73f0d387613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e22b31f6f0d59955e0e73f0d387613">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a type range to the given output stream. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00087">87</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="ab097ddf5971ea2a3956fc814005f459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097ddf5971ea2a3956fc814005f459f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00090">90</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00074">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a5e8f0e932c305de3ac1584560d1b03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f0e932c305de3ac1584560d1b03d0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00104">104</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02994">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="ae72e36349258a6b2baeae78188a74550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e36349258a6b2baeae78188a74550">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00145">145</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00057">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="a0e8ea3e011d372d1f5b3bc1fb34e1286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ea3e011d372d1f5b3bc1fb34e1286">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ModRefResult.html">ModRefResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AliasAnalysis_8h_source.html#l00165">165</a> of file <a class="el" href="AliasAnalysis_8h_source.html">AliasAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00051">mlir::ModRefResult::print()</a>.</p>

</div>
</div>
<a id="acd5bfd80339235fbb32a685ff75f4e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bfd80339235fbb32a685ff75f4e16">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00185">185</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03003">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="a45dade5c2740697bc36ceb8d6554ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dade5c2740697bc36ceb8d6554ee00">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00223">223</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00051">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a8c357b30f2e56803678fe5f7b75e80a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c357b30f2e56803678fe5f7b75e80a1">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[10/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00237">237</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="SPIRVDialect_8cpp_source.html#l00771">print()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a78425f2c879f5b708f5c58af03931e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78425f2c879f5b708f5c58af03931e9f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[11/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8">SymbolTable::Visibility</a>&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00381">381</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a13c479c348969ab459513a4bfd559bb9">mlir::SymbolTable::Nested</a>, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a47f9082fc380ca62d531096aa1d110f1">mlir::SymbolTable::Private</a>, and <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a3d067bedfe2f4677470dd6ccf64d05ed">mlir::SymbolTable::Public</a>.</p>

</div>
</div>
<a id="a3df16c49c963cdc57cf6f9e7c3e9f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df16c49c963cdc57cf6f9e7c3e9f822">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[12/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00240">240</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03044">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="af07e7b01e09b3da975cc984b4e1c506d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07e7b01e09b3da975cc984b4e1c506d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[13/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00246">246</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::OpTrait::impl::foldIdempotent()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00682">mlir::OpTrait::impl::foldInvolution()</a>, <a class="el" href="OpDefinition_8h_source.html#l00097">mlir::OpState::print()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00713">mlir::OpTrait::impl::verifyAtLeastNOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00801">mlir::OpTrait::impl::verifyAtLeastNRegions()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00827">mlir::OpTrait::impl::verifyAtLeastNResults()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00962">mlir::OpTrait::impl::verifyAtLeastNSuccessors()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01057">mlir::OpTrait::impl::verifyElementwise()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00734">mlir::OpTrait::impl::verifyIsIdempotent()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00742">mlir::OpTrait::impl::verifyIsInvolution()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01100">mlir::OpTrait::impl::verifyIsIsolatedFromAbove()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00920">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00704">mlir::OpTrait::impl::verifyNOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01042">mlir::OpTrait::impl::verifyNoRegionArguments()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00794">mlir::OpTrait::impl::verifyNRegions()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00820">mlir::OpTrait::impl::verifyNResults()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00953">mlir::OpTrait::impl::verifyNSuccessors()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00698">mlir::OpTrait::impl::verifyOneOperand()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00788">mlir::OpTrait::impl::verifyOneRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00814">mlir::OpTrait::impl::verifyOneResult()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00946">mlir::OpTrait::impl::verifyOneSuccessor()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00760">mlir::OpTrait::impl::verifyOperandsAreFloatLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00751">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01032">mlir::OpTrait::impl::verifyOperandSizeAttr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00972">mlir::OpTrait::impl::verifyResultsAreBoolLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00983">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00992">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01037">mlir::OpTrait::impl::verifyResultSizeAttr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00874">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00845">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00860">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00835">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00769">mlir::OpTrait::impl::verifySameTypeOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00999">mlir::OpTrait::impl::verifyValueSizeAttr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00692">mlir::OpTrait::impl::verifyZeroOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00782">mlir::OpTrait::impl::verifyZeroRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00808">mlir::OpTrait::impl::verifyZeroResult()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00938">mlir::OpTrait::impl::verifyZeroSuccessor()</a>.</p>

</div>
</div>
<a id="ae69078b1d3f3263a1769df2e0f1730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69078b1d3f3263a1769df2e0f1730df">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[14/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00882">882</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03019">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="a85b9a8e647d5e73b7e107b0669ec9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9a8e647d5e73b7e107b0669ec9e29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[15/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00299">299</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00155">mlir::Diagnostic::print()</a>.</p>

</div>
</div>
<a id="acabdc4e9d44aae13942c9ea9b41b9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdc4e9d44aae13942c9ea9b41b9a33">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[16/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00337">337</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a58c02ebe7d299d1683ae658ea4e9352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c02ebe7d299d1683ae658ea4e9352c">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[17/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00346">346</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00261">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="ad554d3204bdbdc4a87d291ed94c1e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554d3204bdbdc4a87d291ed94c1e575">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[18/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00351">351</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a922b7c99e121802c2e58a80f964b8561">mlir::OpAsmPrinter::printSuccessor()</a>.</p>

</div>
</div>
<a id="a6f93a44db5e2d93372201d5a594e51cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f93a44db5e2d93372201d5a594e51cd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[19/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00567">567</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03032">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="acee66a47ca548fabe02261ad8b96eea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee66a47ca548fabe02261ad8b96eea5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[20/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00710">710</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00102">mlir::PDLValue::print()</a>.</p>

</div>
</div>
<a id="a778366ed204055f8c0ae4e113220a5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778366ed204055f8c0ae4e113220a5bd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[21/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PDLValue.html#aa5a98d42f4638805a23d5390ddb28ac0">PDLValue::Kind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00715">715</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ab0dd71f700f3e4336e89a94f69ff28de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dd71f700f3e4336e89a94f69ff28de">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[22/32]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l00799">799</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l03087">mlir::Operation::print()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00223">mlir::OpPrintingFlags::useLocalScope()</a>.</p>

</div>
</div>
<a id="a97986a4859106d3c96b089e726e26c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97986a4859106d3c96b089e726e26c7c">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[23/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00150">150</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a627aa7e5b958743b9a67a4ccbe1418c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627aa7e5b958743b9a67a4ccbe1418c9">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[24/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00205">205</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a26ecef972faf3b5c78d8415d69a86728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ecef972faf3b5c78d8415d69a86728">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[25/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ValueRangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00212">212</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a424d21ac06bbb37dee5c29f22e9d261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d21ac06bbb37dee5c29f22e9d261a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[26/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00166">166</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad013c3d87cad19d6a7fa6ce16eb6bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad013c3d87cad19d6a7fa6ce16eb6bd58">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[27/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00179">179</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a4d69cef9b50344549afeaaa734f8172d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d69cef9b50344549afeaaa734f8172d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[28/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00219">219</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a6d315bdf3396a4c2cac6ead94cfc0e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d315bdf3396a4c2cac6ead94cfc0e26">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[29/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename ElementT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; ElementT &gt;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00226">226</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ac31efc2a6e3489b511bf1640b6e3b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31efc2a6e3489b511bf1640b6e3b9eb">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[30/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00173">173</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a462d4f34f404bcc705506899944185f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d4f34f404bcc705506899944185f6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[31/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT , typename T , typename std::enable_if&lt;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, bool, float, double &gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00197">197</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ab69273e2629a0b7e18af99582f687692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69273e2629a0b7e18af99582f687692">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[32/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsmPrinterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1AsmPrinter.html">AsmPrinter</a>, AsmPrinterT&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, AsmPrinterT &amp;&gt; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">AsmPrinterT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00158">158</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a8fc3d1f66f267d9111234fac1effdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3d1f66f267d9111234fac1effdfce">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00173">173</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00219">219</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a543c4328a4fa5ed530aa88a9d7d158a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543c4328a4fa5ed530aa88a9d7d158a9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define comparisons for StringAttr against nullptr and itself to avoid the StringRef overloads from being chosen when not desirable. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00926">926</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReductionNode_8h_source.html#l00080">mlir::ReductionNode::getVariants()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00077">mlir::AffineExpr::operator!=()</a>, <a class="el" href="IRModule_8h_source.html#l00916">mlir::python::PyAffineExpr::PyAffineExpr()</a>, <a class="el" href="IRModule_8h_source.html#l00943">mlir::python::PyAffineMap::PyAffineMap()</a>, <a class="el" href="IRModule_8h_source.html#l00791">mlir::python::PyAttribute::PyAttribute()</a>, <a class="el" href="IRModule_8h_source.html#l00964">mlir::python::PyIntegerSet::PyIntegerSet()</a>, and <a class="el" href="IRModule_8h_source.html#l00721">mlir::python::PyType::PyType()</a>.</p>

</div>
</div>
<a id="a40ce38cb70a016263f28574d4982475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ce38cb70a016263f28574d4982475b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00930">930</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a075d7bf5dfe5d33c409763bc28330180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d7bf5dfe5d33c409763bc28330180">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow direct comparison with StringRef. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00936">936</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a50c46bfb0a0fbbe700ef6c07a611dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c46bfb0a0fbbe700ef6c07a611dbf8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00940">940</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a609ab9ceb7a2ad554864c86fc7ece4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609ab9ceb7a2ad554864c86fc7ece4fd">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> mlir::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowAnalysis_8h_source.html#l00042">42</a> of file <a class="el" href="DataFlowAnalysis_8h_source.html">DataFlowAnalysis.h</a>.</p>

</div>
</div>
<a id="a001ec055bf293748f02c00aff842dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ec055bf293748f02c00aff842dc38">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&amp; mlir::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a2c02a386e5ba59c4c88f83ac471f999d">ChangeResult</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlowAnalysis_8h_source.html#l00045">45</a> of file <a class="el" href="DataFlowAnalysis_8h_source.html">DataFlowAnalysis.h</a>.</p>

</div>
</div>
<a id="a10aad3624e000c0585087c96357ea857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aad3624e000c0585087c96357ea857">&#9670;&nbsp;</a></span>outlineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::outlineIfOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>thenFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>thenFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">func::FuncOp *&#160;</td>
          <td class="paramname"><em>elseFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>elseFnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the then and/or else regions of <code>ifOp</code> as follows: </p>
<ul>
<li>if <code>thenFn</code> is not null, <code>thenFnName</code> must be specified and the <code>then</code> region is inlined into a new FuncOp that is captured by the pointer.</li>
<li>if <code>elseFn</code> is not null, <code>elseFnName</code> must be specified and the <code>else</code> region is inlined into a new FuncOp that is captured by the pointer. Creates new FuncOps and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>thenFnName</code>/<code>elseFnName</code> that will not collide with another FuncOp name. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00203">203</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">outlineSingleBlockRegion()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ae9152a09d079148a1a2f40d4946f7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9152a09d079148a1a2f40d4946f7c17">&#9670;&nbsp;</a></span>outlineKernelFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gpu::GPUFuncOp mlir::outlineKernelFunc </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>kernelFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>. </p>
<p>The region of the <code>launchOp</code> can use values from above. These need to be captured and passed as arguments to the generated gpu.func. The generated function has arguments</p><ul>
<li>corresponding to the values passed in as <code>operands</code>, in that order.</li>
<li>any additional values that might be used within the region of the <code>launchOp</code> and defined above it. These captured values are appended to the <code>operands</code> list. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00205">205</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00146">outlineKernelFuncImpl()</a>.</p>

</div>
</div>
<a id="a135bdb9acf35637041fa45613a4121b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135bdb9acf35637041fa45613a4121b4">&#9670;&nbsp;</a></span>outlineSingleBlockRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; func::FuncOp &gt; mlir::outlineSingleBlockRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>funcName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline a region with a single block into a new FuncOp. </p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type. ">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. Creates a new FuncOp and thus cannot be used in a FuncOp pass. The client is responsible for providing a unique <code>funcName</code> that will not collide with another FuncOp name.</p>
<p>Assumes the FuncOp result types is the type of the yielded operands of the single block. This constraint makes it easy to determine the result. This method also clones the <code><a class="el" href="classmlir_1_1arith_1_1ConstantIndexOp.html" title="Specialization of arith.constant op that returns an integer of index type. ">arith::ConstantIndexOp</a></code> at the start of <code>outlinedFuncBody</code> to alloc simple canonicalizations. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">101</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00468">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00353">mlir::OpBuilder::createBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Region_8h_source.html#l00081">mlir::Region::getArguments()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00320">mlir::Operation::getOperandTypes()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00330">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::getResultTypes()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00059">getUsedValuesDefinedAbove()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00277">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="Value_8cpp_source.html#l00082">mlir::Value::replaceUsesWithIf()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00367">mlir::OpBuilder::setInsertionPointToEnd()</a>, <a class="el" href="Builders_8h_source.html#l00362">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00203">outlineIfOp()</a>.</p>

</div>
</div>
<a id="a7acf0c58d63da562112dd8f6a81b49e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acf0c58d63da562112dd8f6a81b49e3">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00122">122</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Threading_8h_source.html#l00135">parallelForEach()</a>, and <a class="el" href="Threading_8h_source.html#l00146">parallelForEachN()</a>.</p>

</div>
</div>
<a id="af1232c5821e793866aa3cf2234e1ba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1232c5821e793866aa3cf2234e1ba93">&#9670;&nbsp;</a></span>parallelForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements in the provided range asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within the range. If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00135">135</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00122">parallelForEach()</a>.</p>

</div>
</div>
<a id="a2c4dba1fa6bb63b3b3fbdb5127f9d21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4dba1fa6bb63b3b3fbdb5127f9d21b">&#9670;&nbsp;</a></span>parallelForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::parallelForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the given function on the elements between [begin, end) asynchronously. </p>
<p>Diagnostics emitted during processing are ordered relative to the element's position within [begin, end). If the provided context does not have multi-threading enabled, this function always processes elements sequentially. </p>

<p class="definition">Definition at line <a class="el" href="Threading_8h_source.html#l00146">146</a> of file <a class="el" href="Threading_8h_source.html">Threading.h</a>.</p>

<p class="reference">References <a class="el" href="Threading_8h_source.html#l00122">parallelForEach()</a>.</p>

</div>
</div>
<a id="af1aa182f707b3cb6a071cf1a9937578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aa182f707b3cb6a071cf1a9937578d">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. If the passed <code>attrStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="MLIRGen_8cpp_source.html#l00200">checkAndNestUnderRewriteOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00222">convertToLaunchFuncOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00643">mlir::AsmParser::getChecked()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="IR_8cpp_source.html#l00742">mlirAttributeParseGet()</a>, <a class="el" href="OpImplementation_8h_source.html#l00664">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00311">parseSymbol()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01045">parseTargetEnvAttr()</a>, and <a class="el" href="DLTI_8cpp_source.html#l00301">mlir::DataLayoutSpecAttr::print()</a>.</p>

</div>
</div>
<a id="ae34310a5d6e4690062af470064089068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34310a5d6e4690062af470064089068">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bd19a863e2bf8969c4bae3ecaa84a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. The number of characters of <code>attrStr</code> parsed in the process is returned in <code>numRead</code>. </p>

</div>
</div>
<a id="ae61d149703ad4537629141fab7417075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61d149703ad4537629141fab7417075">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">parseSourceString()</a>.</p>

</div>
</div>
<a id="adc3d0c425094498fc25bf4856eb029c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d0c425094498fc25bf4856eb029c8">&#9670;&nbsp;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses dimension and symbol list. </p>
<p>Parses dimension and symbol list and returns true if parsing failed.</p>
<p><code>numDims</code> is set to the number of dimensions in the list parsed. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00447">447</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00048">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bae4e85fd5ca8927b9be287e34162aab21">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01341">parseBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, and <a class="el" href="AffineOps_8h_source.html#l00333">mlir::AffineDmaWaitOp::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a4cdbef9427aac1eeac4dbf017bae583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdbef9427aac1eeac4dbf017bae583b">&#9670;&nbsp;</a></span>parseEnumKeywordAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumClass , typename ParserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseEnumKeywordAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserType &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>. </p>

<p class="definition">Definition at line <a class="el" href="ParserUtils_8h_source.html#l00027">27</a> of file <a class="el" href="ParserUtils_8h_source.html">ParserUtils.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00229">parseControlAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00323">parseCooperativeMatrixType()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l00214">parseEnumKeywordAttr()</a>.</p>

</div>
</div>
<a id="a85903e615943c997c10e210bc3d5efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85903e615943c997c10e210bc3d5efb1">&#9670;&nbsp;</a></span>parseIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::parseIntegerSet </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printDiagnosticInfo</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single MemoryBuffer wrapping <code>str</code>. If the passed <code>str</code> has additional tokens that were not part of the <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>, a failure is returned. Diagnostics are printed on failure if <code>printDiagnosticInfo</code> is true. </p>

<p class="reference">Referenced by <a class="el" href="AffineParser_8cpp_source.html#l00716">mlir::detail::Parser::parseAffineExprOfSSAIds()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">parseSourceString()</a>.</p>

</div>
</div>
<a id="af94cc8a71386c0f81c3e657a6f78ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94cc8a71386c0f81c3e657a6f78ef26">&#9670;&nbsp;</a></span>parseOperandsOrIntegersOffsetsOrStridesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseOperandsOrIntegersOffsetsOrStridesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr &amp;&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pasrer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. for use in in assemblyFormat. Parse a mixed list with either (1) static integer values or (2) SSA values. Fill <code>integers</code> with the integer ArrayAttr, where ShapedType::kDynamicStrideOrOffset encodes the position of SSA values. Add the parsed SSA values to <code>values</code> in-order. E.g. after parsing "[%arg0, 7, 42, %arg42]":</p><ol type="1">
<li><code>result</code> is filled with the i64 ArrayAttr "[`dynVal`, 7, 42, `dynVal`]"</li>
<li><code>ssa</code> is filled with "[%arg0, %arg1]". </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00145">145</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a5431766655470cf319cac81fb638e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5431766655470cf319cac81fb638e5e7">&#9670;&nbsp;</a></span>parseOperandsOrIntegersSizesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseOperandsOrIntegersSizesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr &amp;&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pasrer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;OperandsOrIntegersSizesList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. for use in in assemblyFormat. Parse a mixed list with either (1) static integer values or (2) SSA values. Fill <code>integers</code> with the integer ArrayAttr, where ShapedType::kDynamicSize encodes the position of SSA values. Add the parsed SSA values to <code>values</code> in-order. E.g. after parsing "[%arg0, 7, 42, %arg42]":</p><ol type="1">
<li><code>result</code> is filled with the i64 ArrayAttr "[`dynVal`, 7, 42, `dynVal`]"</li>
<li><code>ssa</code> is filled with "[%arg0, %arg1]". </li>
</ol>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00153">153</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the textual representation of a pass pipeline, adding the result to 'pm' on success. </p>
<p>Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00672">672</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00074">mlirParsePassPipeline()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00686">parsePassPipeline()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00186">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="aef5abaea7950d9dc385a018dbbb40d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5abaea7950d9dc385a018dbbb40d0b">&#9670;&nbsp;</a></span>parsePassPipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given textual representation of a pass pipeline, and return the parsed pipeline on success. </p>
<p>The given pipeline string should be wrapped with the desired type of operation to root the created operation, i.e. <code>builtin.module(cse)</code> over <code>cse</code>. Returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00686">686</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00672">parsePassPipeline()</a>.</p>

</div>
</div>
<a id="a79c5d880e7caad7aa65e3946d395ec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c5d880e7caad7aa65e3946d395ec1c">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *&#160;</td>
          <td class="paramname"><em>asmState</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. If <code>asmState</code> is non-null, it is populated with detailed information about the parsed IR (including exact locations for SSA uses and definitions). <code>asmState</code> should only be provided if this detailed information is desired. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l02145">2145</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRServer_8cpp_source.html#l00179">getLspDiagnoticFromDiag()</a>.</p>

</div>
</div>
<a id="a1795d3dff83a21eba1ca1fc638b5154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1795d3dff83a21eba1ca1fc638b5154b">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l02161">2161</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>.</p>

</div>
</div>
<a id="ae8316c9bcfd2fc6ba5b3d0adcd3522e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8316c9bcfd2fc6ba5b3d0adcd3522e2">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParserState.html">AsmParserState</a> *&#160;</td>
          <td class="paramname"><em>asmState</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. If <code>asmState</code> is non-null, it is populated with detailed information about the parsed IR (including exact locations for SSA uses and definitions). <code>asmState</code> should only be provided if this detailed information is desired. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l02168">2168</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="aceb9923f4483d3d4bfbba1cc6b3403b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb9923f4483d3d4bfbba1cc6b3403b2">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00139">139</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">parseSourceFile()</a>.</p>

</div>
</div>
<a id="a53fad28df0c39bfb6bbfc87671696a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fad28df0c39bfb6bbfc87671696a2c">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00157">157</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">parseSourceFile()</a>.</p>

</div>
</div>
<a id="a610850e1634d4778915b85040a9a31f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610850e1634d4778915b85040a9a31f0">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">176</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00039">mlir::detail::constructContainerOpForParserIfNecessary()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00139">parseSourceFile()</a>.</p>

</div>
</div>
<a id="aca40e833eb161d3044d41db30225fb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca40e833eb161d3044d41db30225fb47">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the IR string and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l02188">2188</a> of file <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html">Parser.cpp</a>.</p>

</div>
</div>
<a id="a4d8d85f887b1cf46b129114282993b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8d85f887b1cf46b129114282993b3c">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the provided string containing MLIR. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">197</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="namespacemlir.html#ae61d149703ad4537629141fab7417075">parseAttribute()</a>, <a class="el" href="namespacemlir.html#a85903e615943c997c10e210bc3d5efb1">parseIntegerSet()</a>, and <a class="el" href="namespacemlir.html#afafaf30c94bd5327a769f9fd691cd42a">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00039">mlir::detail::constructContainerOpForParserIfNecessary()</a>.</p>

</div>
</div>
<a id="ac5ffe10560be9caf3b9e8de592c20e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ffe10560be9caf3b9e8de592c20e93">&#9670;&nbsp;</a></span>parseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. If the passed <code>typeStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="MLIRGen_8cpp_source.html#l00200">checkAndNestUnderRewriteOp()</a>, <a class="el" href="IR_8cpp_source.html#l00715">mlirTypeParseGet()</a>, <a class="el" href="OpImplementation_8h_source.html#l00926">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00237">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00978">mlir::AsmParser::parseKeywordType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00311">parseSymbol()</a>, <a class="el" href="OpImplementation_8h_source.html#l00845">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpImplementation_8h_source.html#l00876">mlir::AsmParser::parseType()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00931">mlir::AsmParser::parseTypeList()</a>.</p>

</div>
</div>
<a id="afafaf30c94bd5327a769f9fd691cd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafaf30c94bd5327a769f9fd691cd42a">&#9670;&nbsp;</a></span>parseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. The number of characters of <code>typeStr</code> parsed in the process is returned in <code>numRead</code>. </p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">parseSourceString()</a>.</p>

</div>
</div>
<a id="a48413a8aa4dcee8ffa93b222cbedfd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48413a8aa4dcee8ffa93b222cbedfd1b">&#9670;&nbsp;</a></span>permuteLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::permuteLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>inputNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>permMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ... </p>
<p>are from the outermost position to inner. Returns the position in <code>inputNest</code> of the AffineForOp that becomes the new outermost loop of this nest. This method always succeeds, asserts out on invalid input / specifications. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01492">1492</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01470">isPerfectlyNested()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01562">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="aee7856a3b7ff811204524bbc9959c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7856a3b7ff811204524bbc9959c8c9">&#9670;&nbsp;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00521">521</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00539">populateAffineToVectorConversionPatterns()</a>.</p>

</div>
</div>
<a id="ad6a984b6da6b0bf690f727bd2e20dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a984b6da6b0bf690f727bd2e20dd31">&#9670;&nbsp;</a></span>populateAffineToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00539">539</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00521">populateAffineToStdConversionPatterns()</a>.</p>

</div>
</div>
<a id="a996cc8b761f1373132a5d77b16d2076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996cc8b761f1373132a5d77b16d2076a">&#9670;&nbsp;</a></span>populateAMXLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAMXLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower AMX ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00214">214</a> of file <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a6f862550b655bdc6a10caa74ce4ae0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f862550b655bdc6a10caa74ce4ae0af">&#9670;&nbsp;</a></span>populateArmSVELegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmSVELegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower ArmSVE ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from ArmSVE to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>

<p class="definition">Definition at line <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00070">70</a> of file <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00132">mlir::Pattern::getContext()</a>.</p>

</div>
</div>
<a id="a9659670212051d0795efd99cf38772ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9659670212051d0795efd99cf38772ed">&#9670;&nbsp;</a></span>populateAsyncStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAsyncStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for async structural type conversions. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is async.execute &ndash; the async.execute op and the corresponding async.yield ops need to update their types accordingly to the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class. ">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l01117">1117</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00115">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3df32552b0e40b3e55a3a098fb0f8f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df32552b0e40b3e55a3a098fb0f8f52">&#9670;&nbsp;</a></span>populateBranchOpInterfaceTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBranchOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(BranchOpInterface branchOp, int idx)&gt;&#160;</td>
          <td class="paramname"><em>shouldConvertBranchOperand</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite branch operations to use operands that have been legalized by the conversion framework. </p>
<p>This can only be done if the branch operation implements the BranchOpInterface. Only needed for partial conversions.</p>
<p>If for some branch ops, we need to convert/legalize only a sub-set of the op's operands, such filtering behavior can be specified in shouldConvertBranchOperand. This callback should return true if branchOp's operand at index idx should be converted. </p>

<p class="reference">Referenced by <a class="el" href="FuncConversions_8cpp_source.html#l00041">populateCallOpTypeConversionPattern()</a>, and <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="acfbd8691a3dda5dad95817bf02cdd3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd8691a3dda5dad95817bf02cdd3cd">&#9670;&nbsp;</a></span>populateBufferizationToMemRefConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBufferizationToMemRefConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the Bufferization dialect to the MemRef dialect. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationToMemRef_8cpp_source.html#l00077">77</a> of file <a class="el" href="BufferizationToMemRef_8cpp_source.html">BufferizationToMemRef.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00811">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a3a9a918bfb0fc3727c4d2490164be0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a918bfb0fc3727c4d2490164be0c3">&#9670;&nbsp;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVConversion_8cpp_source.html#l00596">596</a> of file <a class="el" href="SPIRVConversion_8cpp_source.html">SPIRVConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00811">mlir::arith::populateArithmeticToSPIRVPatterns()</a>.</p>

</div>
</div>
<a id="a155010c68de4c682e3cb8890e9460283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155010c68de4c682e3cb8890e9460283">&#9670;&nbsp;</a></span>populateCallOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateCallOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00041">41</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00376">mlir::OperandRange::getBeginOperandIndex()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="namespacemlir.html#a3df32552b0e40b3e55a3a098fb0f8f52">populateBranchOpInterfaceTypeConversionPattern()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00499">mlir::RewriterBase::updateRootInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>.</p>

</div>
</div>
<a id="a75bf16b29d948811335c75976eb7b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bf16b29d948811335c75976eb7b876">&#9670;&nbsp;</a></span>populateComplexToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToLLVM_8cpp_source.html#l00302">302</a> of file <a class="el" href="ComplexToLLVM_8cpp_source.html">ComplexToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00811">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>.</p>

</div>
</div>
<a id="a09be0ab6e12c19fefea09a6cb423c54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be0ab6e12c19fefea09a6cb423c54d">&#9670;&nbsp;</a></span>populateComplexToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateComplexToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Complex to Standard. </p>

<p class="definition">Definition at line <a class="el" href="ComplexToStandard_8cpp_source.html#l00709">709</a> of file <a class="el" href="ComplexToStandard_8cpp_source.html">ComplexToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a45f6113274b77800e7c3b22dd83771e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6113274b77800e7c3b22dd83771e0">&#9670;&nbsp;</a></span>populateConvertArmNeon2dToIntrPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertArmNeon2dToIntrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for the lowering of Arm NEON 2D ops to intrinsics. </p>
<p>See createConvertArmNeon2dToIntrPass. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeon2dToIntr_8cpp_source.html#l00065">65</a> of file <a class="el" href="ArmNeon2dToIntr_8cpp_source.html">ArmNeon2dToIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae6e66615eb7e50976ed8c89b2bb05adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e66615eb7e50976ed8c89b2bb05adc">&#9670;&nbsp;</a></span>populateConvertShapeConstraintsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertShapeConstraintsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00039">39</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a65ee5fd8a8bcd80a922acd227a213e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ee5fd8a8bcd80a922acd227a213e2e">&#9670;&nbsp;</a></span>populateDecomposeCallGraphTypesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateDecomposeCallGraphTypesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;&#160;</td>
          <td class="paramname"><em>decomposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00190">190</a> of file <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html">DecomposeCallGraphTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeCallGraphTypes_8h_source.html#l00057">mlir::ValueDecomposer::addDecomposeValueConversion()</a>.</p>

</div>
</div>
<a id="a2fbc60c17752a76af9b0f28ffa36d4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc60c17752a76af9b0f28ffa36d4f9">&#9670;&nbsp;</a></span>populateExpandTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateExpandTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandTanh_8cpp_source.html#l00056">56</a> of file <a class="el" href="ExpandTanh_8cpp_source.html">ExpandTanh.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="ExpandTanh_8cpp_source.html#l00024">convertTanhOp()</a>.</p>

</div>
</div>
<a id="a12287a4adc9d89ce2ed49712b091c5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12287a4adc9d89ce2ed49712b091c5fa">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>functionLikeOpName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a FunctionOpInterface op with the given type converter. </p>
<p>This only supports ops which use FunctionType to represent their type. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03099">3099</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00483">mlir::OpInterfaceConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00503">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a1ab8b50117bb49a7ce3d85628dd374b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8b50117bb49a7ce3d85628dd374b8">&#9670;&nbsp;</a></span>populateFunctionOpInterfaceTypeConversionPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncOpT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFunctionOpInterfaceTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00503">503</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03099">populateFunctionOpInterfaceTypeConversionPattern()</a>.</p>

</div>
</div>
<a id="a6caa6cc89d0b3c43a871101ba9fe6216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caa6cc89d0b3c43a871101ba9fe6216">&#9670;&nbsp;</a></span>populateFuncToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the Func dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>The conversion patterns capture the <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect. ">LLVMTypeConverter</a> and the <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering. ">LowerToLLVMOptions</a> by reference meaning the references have to remain alive during the entire pattern lifetime. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">660</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LoweringOptions_8h_source.html#l00026">kDeriveIndexBitwidthFromDataLayout</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00261">mlir::arith::populateArithmeticToLLVMConversionPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00106">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00652">populateFuncToLLVMFuncOpConversionPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">populateOpenMPToLLVMConversionPatterns()</a>, and <a class="el" href="VectorToROCDL_8cpp_source.html#l00149">populateVectorToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="aefa6b16e02f4faa0e2d43ac82fca0185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa6b16e02f4faa0e2d43ac82fca0185">&#9670;&nbsp;</a></span>populateFuncToLLVMFuncOpConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToLLVMFuncOpConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>If <code>emitCWrappers</code> is set, the pattern will also produce functions that pass memref descriptors by pointer-to-structure in addition to the default unpacked form. </p>

<p class="definition">Definition at line <a class="el" href="FuncToLLVM_8cpp_source.html#l00652">652</a> of file <a class="el" href="FuncToLLVM_8cpp_source.html">FuncToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="TypeConverter_8h_source.html#l00081">mlir::LLVMTypeConverter::getOptions()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a6b9ec4369b7b5946147ad4545d22d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9ec4369b7b5946147ad4545d22d6c6">&#9670;&nbsp;</a></span>populateFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Func ops to SPIR-V ops. </p>
<p>Also adds the patterns to legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="FuncToSPIRV_8cpp_source.html#l00092">92</a> of file <a class="el" href="FuncToSPIRV_8cpp_source.html">FuncToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00811">mlir::arith::populateArithmeticToSPIRVPatterns()</a>.</p>

</div>
</div>
<a id="a9701a7692a76e65edd69bd6f22156776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701a7692a76e65edd69bd6f22156776">&#9670;&nbsp;</a></span>populateGpuAllReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuAllReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite all-reduce ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00410">410</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Passes_8h_source.html#l00046">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="a4ae1d309360c9e54edaa39ddb48d3ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae1d309360c9e54edaa39ddb48d3ea1">&#9670;&nbsp;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Passes_8h_source.html#l00046">46</a> of file <a class="el" href="Dialect_2GPU_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">References <a class="el" href="SerializeToBlob_8cpp_source.html#l00030">mlir::gpu::getDefaultGpuBinaryAnnotation()</a>, and <a class="el" href="AllReduceLowering_8cpp_source.html#l00410">populateGpuAllReducePatterns()</a>.</p>

</div>
</div>
<a id="acc2971eebb65dd07dfcb8318ede54f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2971eebb65dd07dfcb8318ede54f56">&#9670;&nbsp;</a></span>populateGpuToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>gpuBinaryAnnotation</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> and populate converter for gpu types. </p>

<p class="definition">Definition at line <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00880">880</a> of file <a class="el" href="GPUToLLVMConversion_8cpp_source.html">GPUToLLVMConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00115">mlir::TypeConverter::addConversion()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00173">mlir::LLVM::LLVMPointerType::get()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00164">mlir::LLVMTypeConverter::getContext()</a>.</p>

</div>
</div>
<a id="ac0cfe15e8fb355926517f8b4dc0d0c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cfe15e8fb355926517f8b4dc0d0c0a">&#9670;&nbsp;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00318">318</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00132">mlir::Pattern::getContext()</a>.</p>

</div>
</div>
<a id="ac6de97155f64d87208f5ce9e4041885a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6de97155f64d87208f5ce9e4041885a">&#9670;&nbsp;</a></span>populateGpuToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">gpu::amd::Runtime</a>&#160;</td>
          <td class="paramname"><em>runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>
<p>If <code>runtime</code> is Unknown, gpu.printf will not be lowered The resulting pattern set should be run over a gpu.module op </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00109">109</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00132">mlir::Pattern::getContext()</a>, <a class="el" href="Runtimes_8h_source.html#l00017">mlir::gpu::amd::HIP</a>, and <a class="el" href="Runtimes_8h_source.html#l00018">mlir::gpu::amd::OpenCL</a>.</p>

</div>
</div>
<a id="a822bcc3b680bed98c042cdabebc7f94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822bcc3b680bed98c042cdabebc7f94a">&#9670;&nbsp;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="GPUToSPIRV_8cpp_source.html#l00367">367</a> of file <a class="el" href="GPUToSPIRV_8cpp_source.html">GPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="abea1280606a190334088962debe41bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea1280606a190334088962debe41bf0">&#9670;&nbsp;</a></span>populateGpuWMMAToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuWMMAToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert WMMA ops from GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00371">371</a> of file <a class="el" href="WmmaOpsToNvvm_8cpp_source.html">WmmaOpsToNvvm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="a2f1602ebfb960be063051996895d9eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1602ebfb960be063051996895d9eae">&#9670;&nbsp;</a></span>populateLinalgToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00070">70</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a6131cb8a44ef9ffc0fc14b02e2c53365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6131cb8a44ef9ffc0fc14b02e2c53365">&#9670;&nbsp;</a></span>populateLinalgToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Linalg ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00208">208</a> of file <a class="el" href="LinalgToSPIRV_8cpp_source.html">LinalgToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a747b91bacc09bde115c3e891deb5ebe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b91bacc09bde115c3e891deb5ebe5">&#9670;&nbsp;</a></span>populateMathAlgebraicSimplificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathAlgebraicSimplificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AlgebraicSimplification_8cpp_source.html#l00117">117</a> of file <a class="el" href="AlgebraicSimplification_8cpp_source.html">AlgebraicSimplification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ada84ecb306c38b4e2a547962acc98dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada84ecb306c38b4e2a547962acc98dfd">&#9670;&nbsp;</a></span>populateMathPolynomialApproximationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathPolynomialApproximationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MathPolynomialApproximationOptions.html">MathPolynomialApproximationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PolynomialApproximation_8cpp_source.html#l01278">1278</a> of file <a class="el" href="PolynomialApproximation_8cpp_source.html">PolynomialApproximation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Math_2Transforms_2Passes_8h_source.html#l00022">mlir::MathPolynomialApproximationOptions::enableAvx2</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af9f399fbc6445ee4e3b3c7f261dcbefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f399fbc6445ee4e3b3c7f261dcbefc">&#9670;&nbsp;</a></span>populateMathToLibmConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToLibmConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Math to Libm calls. </p>

<p class="definition">Definition at line <a class="el" href="MathToLibm_8cpp_source.html#l00116">116</a> of file <a class="el" href="MathToLibm_8cpp_source.html">MathToLibm.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00811">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa792d9749fb9af6417bcc2b3662e5090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792d9749fb9af6417bcc2b3662e5090">&#9670;&nbsp;</a></span>populateMathToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathToLLVM_8cpp_source.html#l00265">265</a> of file <a class="el" href="MathToLLVM_8cpp_source.html">MathToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="ac7a0a3321fbef0b7dcd1fe6e0bfba227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a0a3321fbef0b7dcd1fe6e0bfba227">&#9670;&nbsp;</a></span>populateMathToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMathToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Math ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MathToSPIRV_8cpp_source.html#l00144">144</a> of file <a class="el" href="MathToSPIRV_8cpp_source.html">MathToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0e9890e0455cf09221d2ca1db8c19f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9890e0455cf09221d2ca1db8c19f2c">&#9670;&nbsp;</a></span>populateMemRefToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMemRefToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the MemRef dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">1923</a> of file <a class="el" href="MemRefToLLVM_8cpp_source.html">MemRefToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4ac6cc2ffb89010532e07c736361b52e95">mlir::LowerToLLVMOptions::AlignedAlloc</a>, <a class="el" href="LoweringOptions_8h_source.html#l00050">mlir::LowerToLLVMOptions::allocLowering</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="TypeConverter_8h_source.html#l00081">mlir::LLVMTypeConverter::getOptions()</a>, <a class="el" href="LoweringOptions_8h_source.html#l00026">kDeriveIndexBitwidthFromDataLayout</a>, <a class="el" href="classmlir_1_1LowerToLLVMOptions.html#a6845f4f8fe1f99c04c90cd621e87f4b4a1131a914388fac73e5f07b0ba0aad523">mlir::LowerToLLVMOptions::Malloc</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00070">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">populateOpenMPToLLVMConversionPatterns()</a>, and <a class="el" href="VectorToROCDL_8cpp_source.html#l00149">populateVectorToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="a95c0c6dd7df034b1f340ca9a14c9a0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c0c6dd7df034b1f340ca9a14c9a0a6">&#9670;&nbsp;</a></span>populateMemRefToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateMemRefToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating MemRef ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00548">548</a> of file <a class="el" href="MemRefToSPIRV_8cpp_source.html">MemRefToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a6a68bf61fe2cf12c77f265e4851897c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a68bf61fe2cf12c77f265e4851897c8">&#9670;&nbsp;</a></span>populateNVGPUToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateNVGPUToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00301">301</a> of file <a class="el" href="NVGPUToNVVM_8cpp_source.html">NVGPUToNVVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>.</p>

</div>
</div>
<a id="a075dcb844c996870c4c38bf277a4d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075dcb844c996870c4c38bf277a4d175">&#9670;&nbsp;</a></span>populateOpenACCToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenACCToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00140">140</a> of file <a class="el" href="OpenACCToLLVM_8cpp_source.html">OpenACCToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00040">mlir::DataDescriptor::isValid()</a>.</p>

</div>
</div>
<a id="a725b3caed685f9615fba2027124f359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b3caed685f9615fba2027124f359f">&#9670;&nbsp;</a></span>populateOpenACCToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenACCToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the OpenACC dialect to OpenACC with SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToSCF_8cpp_source.html#l00051">51</a> of file <a class="el" href="OpenACCToSCF_8cpp_source.html">OpenACCToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00707">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1111bfc29c10d7cd2ebba33996e38509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111bfc29c10d7cd2ebba33996e38509">&#9670;&nbsp;</a></span>populateOpenMPToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenMPToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00074">74</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00062">configureOpenMPToLLVMConversionLegality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00261">mlir::arith::populateArithmeticToLLVMConversionPatterns()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00106">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>, and <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a1727b1783cbf671c6ee60cc2a5c2f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727b1783cbf671c6ee60cc2a5c2f132">&#9670;&nbsp;</a></span>populateParallelLoopToGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateParallelLoopToGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00669">669</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af3bcc994390d4acdd8d8369854974a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bcc994390d4acdd8d8369854974a6c">&#9670;&nbsp;</a></span>populatePrepareVectorToMMAPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populatePrepareVectorToMMAPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to transform vector ops into a canonical form to convert to MMA matrix operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorToGPU_8cpp_source.html#l00512">512</a> of file <a class="el" href="VectorToGPU_8cpp_source.html">VectorToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00517">convertVectorToMMAOps()</a>.</p>

</div>
</div>
<a id="a7c65dfcafc10b8117f172e7c150ac1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65dfcafc10b8117f172e7c150ac1ad">&#9670;&nbsp;</a></span>populateReconcileUnrealizedCastsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateReconcileUnrealizedCastsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with rewrite patterns that eliminate noop <code>unrealized_conversion_cast</code> operation sequences. </p>

<p class="definition">Definition at line <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html#l00073">73</a> of file <a class="el" href="ReconcileUnrealizedCasts_8cpp_source.html">ReconcileUnrealizedCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac260b877914dd5ce7bf80eb50ff87a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac260b877914dd5ce7bf80eb50ff87a4b">&#9670;&nbsp;</a></span>populateRemoveShapeConstraintsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateRemoveShapeConstraintsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00058">58</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a2eb02814adc084d318ce037a93a326df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb02814adc084d318ce037a93a326df">&#9670;&nbsp;</a></span>populateReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite <code>return</code> ops to use operands that have been legalized by the conversion framework. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00135">135</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9fc663ae01ea2b6384c3f6ce299be3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc663ae01ea2b6384c3f6ce299be3b0">&#9670;&nbsp;</a></span>populateSCFToControlFlowConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToControlFlowConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert SCF operations to CFG branch-based operations within the ControlFlow dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToControlFlow_8cpp_source.html#l00615">615</a> of file <a class="el" href="SCFToControlFlow_8cpp_source.html">SCFToControlFlow.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00804">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00662">funcsToCoroutines()</a>.</p>

</div>
</div>
<a id="a3094753f32222ddd712d5b2321c38eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3094753f32222ddd712d5b2321c38eea">&#9670;&nbsp;</a></span>populateSCFToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scfToSPIRVContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRV_8cpp_source.html#l00429">429</a> of file <a class="el" href="SCFToSPIRV_8cpp_source.html">SCFToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="SCFToSPIRV_8h_source.html#l00029">mlir::ScfToSPIRVContext::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToSPIRV_8h_source.html#l00029">mlir::ScfToSPIRVContext::getImpl()</a>.</p>

</div>
</div>
<a id="a068b739b7424900d4d98c15c81e4609e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068b739b7424900d4d98c15c81e4609e">&#9670;&nbsp;</a></span>populateShapeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Shape dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00075">75</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a9d32c331310df6a35924ac128fa789f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32c331310df6a35924ac128fa789f3">&#9670;&nbsp;</a></span>populateShapeToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00685">685</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a7e144d2e73a085c2781475b2808bb059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e144d2e73a085c2781475b2808bb059">&#9670;&nbsp;</a></span>populateSparseTensorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparseTensorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1SparseTensorConversionOptions.html">SparseTensorConversionOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparse tensor conversion rules. </p>
<p>Populates the given patterns list with conversion rules required for the sparsification of linear algebra operations.</p>

<p class="definition">Definition at line <a class="el" href="SparseTensorConversion_8cpp_source.html#l00879">879</a> of file <a class="el" href="SparseTensorConversion_8cpp_source.html">SparseTensorConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="a86f7f8933f0baf6ebeddfdc698327c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f7f8933f0baf6ebeddfdc698327c31">&#9670;&nbsp;</a></span>populateSparsificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSparsificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1SparsificationOptions.html">SparsificationOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up sparsification rewriting rules with the given options. </p>
<p>Populates the given patterns list with rewriting rules required for the sparsification of linear algebra operations.</p>

<p class="definition">Definition at line <a class="el" href="Sparsification_8cpp_source.html#l01742">1742</a> of file <a class="el" href="Sparsification_8cpp_source.html">Sparsification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="aeb7de728c22748c6b736dd346296b69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7de728c22748c6b736dd346296b69f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01446">1446</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1eaf01d677b8c5bc75e77f5093d9ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaf01d677b8c5bc75e77f5093d9ca8f">&#9670;&nbsp;</a></span>populateSPIRVToLLVMFunctionConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMFunctionConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01561">1561</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aa1a0a0e3398946973ed32c1fb07d8936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a0a0e3398946973ed32c1fb07d8936">&#9670;&nbsp;</a></span>populateSPIRVToLLVMModuleConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMModuleConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01566">1566</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="aae66c52897a19a19fdec8d7022372b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae66c52897a19a19fdec8d7022372b7d">&#9670;&nbsp;</a></span>populateSPIRVToLLVMTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates type conversions with additional SPIR-V types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01431">1431</a> of file <a class="el" href="SPIRVToLLVM_8cpp_source.html">SPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00115">mlir::TypeConverter::addConversion()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00249">convertArrayType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00265">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00274">convertRuntimeArrayType()</a>, and <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>.</p>

</div>
</div>
<a id="abaf6b62cc455701b989bc81364a091f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf6b62cc455701b989bc81364a091f7">&#9670;&nbsp;</a></span>populateTensorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateTensorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>byteCountThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating tensor ops to SPIR-V ops. </p>
<p>Note: Normally tensors will be stored in buffers before converting to SPIR-V, given that is how a large amount of data is sent to the GPU. However, SPIR-V supports converting from tensors directly too. This is for the cases where the tensor just contains a small amount of elements and it makes sense to directly inline them as a small data array in the shader. To handle this, internally the conversion might create new local variables. SPIR-V consumers in GPU drivers may or may not optimize that away. So this has implications over register pressure. Therefore, a threshold is used to control when the patterns should kick in. </p>

<p class="definition">Definition at line <a class="el" href="TensorToSPIRV_8cpp_source.html#l00102">102</a> of file <a class="el" href="TensorToSPIRV_8cpp_source.html">TensorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a75a70c08f12898f5942f022ea27ba371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a70c08f12898f5942f022ea27ba371">&#9670;&nbsp;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reassociateFPReductions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force32BitVectorIndices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01195">1195</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="TypeConverter_8h_source.html#l00079">mlir::LLVMTypeConverter::getDialect()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00295">mlir::vector::populateVectorInsertExtractStridedSliceTransforms()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02703">mlir::vector::populateVectorTransferLoweringPatterns()</a>.</p>

</div>
</div>
<a id="a75cce579ffaa7f6e5b4da65897ae4e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cce579ffaa7f6e5b4da65897ae4e41">&#9670;&nbsp;</a></span>populateVectorToLLVMMatrixConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToLLVMMatrixConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> Matrix Intrinsics. </p>
<p>To lower to assembly, the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> flag -lower-matrix-intrinsics will be needed when invoking <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01222">1222</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="affd8b33175a786207a6ab4213f9b25a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd8b33175a786207a6ab4213f9b25a1">&#9670;&nbsp;</a></span>populateVectorToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="VectorToROCDL_8cpp_source.html#l00149">149</a> of file <a class="el" href="VectorToROCDL_8cpp_source.html">VectorToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00776">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03264">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>, and <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a96c6c9c53e199da9b2def6f5e62eec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6c9c53e199da9b2def6f5e62eec02">&#9670;&nbsp;</a></span>populateVectorToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + func. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l01262">1262</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="VectorToSCF_8h_source.html#l00057">mlir::VectorTransferToSCFOptions::lowerPermutationMaps</a>, <a class="el" href="VectorToSCF_8h_source.html#l00064">mlir::VectorTransferToSCFOptions::lowerTensors</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00275">mlir::vector::populateVectorTransferPermutationMapLoweringPatterns()</a>, <a class="el" href="VectorToSCF_8h_source.html#l00051">mlir::VectorTransferToSCFOptions::targetRank</a>, and <a class="el" href="VectorToSCF_8h_source.html#l00070">mlir::VectorTransferToSCFOptions::unroll</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8h_source.html#l00071">mlir::VectorTransferToSCFOptions::enableFullUnroll()</a>.</p>

</div>
</div>
<a id="a32404bdce26e3b9e768fa1e790e77a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32404bdce26e3b9e768fa1e790e77a44">&#9670;&nbsp;</a></span>populateVectorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00374">374</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01383">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ac1ec093f212c96c69468a9e7df149fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec093f212c96c69468a9e7df149fb5">&#9670;&nbsp;</a></span>populateX86VectorLegalizeForLLVMExportPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateX86VectorLegalizeForLLVMExportPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower X86Vector ops to ops that map to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> intrinsics. </p>
<p>Populate the given list with patterns that convert from X86Vector to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>

<p class="definition">Definition at line <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00161">161</a> of file <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html">LegalizeForLLVMExport.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2X86Vector_2Transforms_8h_source.html#l00162">mlir::x86vector::avx2::LoweringOptions::setTransposeOptions()</a>.</p>

</div>
</div>
<a id="a2cf47b41fcadeb8f453dae11fa9f93c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf47b41fcadeb8f453dae11fa9f93c6">&#9670;&nbsp;</a></span>printOperandsOrIntegersOffsetsOrStridesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printOperandsOrIntegersOffsetsOrStridesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. for use in in assemblyFormat. Prints a list with either (1) the static integer value in <code>integers</code> if the value is ShapedType::kDynamicStrideOrOffset or (2) the next value otherwise. This allows idiomatic printing of mixed value and integer attributes in a list. E.g. <code>[arg0, 7, 42, arg42]</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00092">92</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ac8bc42c73fba28565d395032d99a7fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bc42c73fba28565d395032d99a7fc7">&#9670;&nbsp;</a></span>printOperandsOrIntegersSizesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printOperandsOrIntegersSizesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Printer hook for custom directive in assemblyFormat. </p>
<p>custom&lt;OperandsOrIntegersSizesList&gt;($values, $integers)</p>
<p>where <code>values</code> is of ODS type <code>Variadic&lt;Index&gt;</code> and <code>integers</code> is of ODS type <code>I64ArrayAttr</code>. for use in in assemblyFormat. Prints a list with either (1) the static integer value in <code>integers</code> if the value is ShapedType::kDynamicSize or (2) the next value otherwise. This allows idiomatic printing of mixed value and integer attributes in a list. E.g. <code>[arg0, 7, 42, arg42]</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00100">100</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a9f574bfd0dab3a0967cf1e3c77780fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">&#9670;&nbsp;</a></span>promoteIfSingleIteration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp was known to have a single iteration.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00131">131</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00304">mlir::Builder::getDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00209">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00114">replaceIterArgsAndYieldResults()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00091">createAffineDataCopyGenerationPass()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00432">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00181">generateShiftedLoop()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00975">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>.</p>

</div>
</div>
<a id="ab5e4727751a2af7968a7f722b77620ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e4727751a2af7968a7f722b77620ff">&#9670;&nbsp;</a></span>promoteIfSingleIteration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a scf::ForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp it can be determined that the loop has a single iteration.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00295">295</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00279">replaceIterArgsAndYieldResults()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="Arithmetic_8h_source.html#l00086">mlir::arith::ConstantIndexOp::value()</a>.</p>

</div>
</div>
<a id="aac04a5178397b80a50634b35e015183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac04a5178397b80a50634b35e015183a">&#9670;&nbsp;</a></span>promoteSingleIterationLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::promoteSingleIterationLoops </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>. </p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&nbsp;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

<p class="reference">Referenced by <a class="el" href="MemoryPromotion_8cpp_source.html#l00122">insertCopies()</a>.</p>

</div>
</div>
<a id="afe55df95d48191f0fa2c5ab8f4e81e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe55df95d48191f0fa2c5ab8f4e81e34">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all the MLIR dialects to the provided registry. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00067">67</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>, <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00750">mlir::tensor::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00526">mlir::scf::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Shape_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00169">mlir::shape::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00123">mlir::vector::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Arithmetic_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00176">mlir::arith::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00478">mlir::linalg::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00542">mlir::bufferization::func_ext::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00206">mlir::tensor::registerInferTypeOpInterfaceExternalModels()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00284">mlir::tensor::registerTilingOpInterfaceExternalModels()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l00195">mlir::linalg::registerTransformDialectExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Registration_8cpp_source.html#l00016">mlirRegisterAllDialects()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00123">registerAllDialects()</a>.</p>

</div>
</div>
<a id="a5fcd07e2ad26a58627d961ce8e544f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcd07e2ad26a58627d961ce8e544f1b">&#9670;&nbsp;</a></span>registerAllDialects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all the MLIR dialects to the registry contained in the given context. </p>

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00123">123</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="InitAllDialects_8h_source.html#l00067">registerAllDialects()</a>.</p>

</div>
</div>
<a id="afb552a159c6c887b98b3583dfd5cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb552a159c6c887b98b3583dfd5cbe5d">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00049">49</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

<p class="reference">References <a class="el" href="SerializeToCubin_8cpp_source.html#l00147">registerGpuSerializeToCubinPass()</a>, <a class="el" href="SerializeToHsaco_8cpp_source.html#l00492">registerGpuSerializeToHsacoPass()</a>, and <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00060">mlir::sparse_tensor::registerSparseTensorPipelines()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Registration_8cpp_source.html#l00026">mlirRegisterAllPasses()</a>.</p>

</div>
</div>
<a id="ad1e68be8ebf61b3be9572769e19bc467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e68be8ebf61b3be9572769e19bc467">&#9670;&nbsp;</a></span>registerAllToLLVMIRTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::registerAllToLLVMIRTranslations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all dialects that can be translated to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR and the corresponding translation interfaces. </p>

<p class="definition">Definition at line <a class="el" href="All_8h_source.html#l00032">32</a> of file <a class="el" href="All_8h_source.html">All.h</a>.</p>

<p class="reference">References <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>, <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>, <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00505">registerLLVMDialectTranslation()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00142">registerNVVMDialectTranslation()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00534">registerOpenACCDialectTranslation()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01400">registerOpenMPDialectTranslation()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00108">registerROCDLDialectTranslation()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>.</p>

</div>
</div>
<a id="a8d16808b31b66905b067720d428adf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16808b31b66905b067720d428adf61">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00028">28</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01175">registerFromLLVMIRTranslation()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00068">registerFromSPIRVTranslation()</a>, <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00029">registerToCppTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, and <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00108">registerToSPIRVTranslation()</a>.</p>

</div>
</div>
<a id="a0465249a74e23df5fdc548001933239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0465249a74e23df5fdc548001933239c">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="aa4a637ec7428727c66f27117b9892f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a637ec7428727c66f27117b9892f1e">&#9670;&nbsp;</a></span>registerAMXDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAMXDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the AMX dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html">AMXToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="AMXToLLVMIRTranslation_8cpp_source.html#l00045">registerAMXDialectTranslation()</a>.</p>

</div>
</div>
<a id="ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfe4c9ed6ee3105af1b2d4d4b7c2ad">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a559f20bb41c97729f2d089e6f7a72e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559f20bb41c97729f2d089e6f7a72e4e">&#9670;&nbsp;</a></span>registerArmNeonDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmNeonDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmNeon dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html">ArmNeonToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmNeonToLLVMIRTranslation_8cpp_source.html#l00046">registerArmNeonDialectTranslation()</a>.</p>

</div>
</div>
<a id="a53be2d34e1d4e96ea100bbf93af35a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53be2d34e1d4e96ea100bbf93af35a2c">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">45</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="afc9c160fac7074517c6f013864acee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c160fac7074517c6f013864acee68">&#9670;&nbsp;</a></span>registerArmSVEDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSVEDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the ArmSVE dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00052">52</a> of file <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html">ArmSVEToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ArmSVEToLLVMIRTranslation_8cpp_source.html#l00045">registerArmSVEDialectTranslation()</a>.</p>

</div>
</div>
<a id="a894a08aa6ed051f55e57bc35859a379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a08aa6ed051f55e57bc35859a379f">&#9670;&nbsp;</a></span>registerAsmPrinterCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsmPrinterCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1AsmPrinter.html" title="This base class exposes generic asm printer hooks, usable across the various derived printers...">AsmPrinter</a>. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l00167">167</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00163">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmState_8h_source.html#l00055">mlir::AsmState::getImpl()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a1da5a75b8bc3193908b0e222a6da1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5a75b8bc3193908b0e222a6da1d85">&#9670;&nbsp;</a></span>registerDefaultTimingManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerDefaultTimingManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream. ">DefaultTimingManager</a></code>. </p>
<p>The values of these options can be applied via the <code>applyDefaultTimingManagerCLOptions</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Timing_8cpp_source.html#l00556">556</a> of file <a class="el" href="Timing_8cpp_source.html">Timing.cpp</a>.</p>

<p class="reference">References <a class="el" href="Timing_8cpp_source.html#l00554">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>.</p>

</div>
</div>
<a id="accfff33b4e364b14e039f109ea3d9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfff33b4e364b14e039f109ea3d9669">&#9670;&nbsp;</a></span>registerDialect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteDialect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerDialect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a267e7e7ec38e0a09285a20831414d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a267e7e7ec38e0a09285a20831414d3">&#9670;&nbsp;</a></span>registerFromLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01175">1175</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01158">translateLLVMIRToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a51ef91a9901d4d87a042990ccb79f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef91a9901d4d87a042990ccb79f2be">&#9670;&nbsp;</a></span>registerFromSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00068">68</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a408ccd7b20bede5af6274d2243aaf4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ccd7b20bede5af6274d2243aaf4ce">&#9670;&nbsp;</a></span>registerGpuSerializeToCubinPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuSerializeToCubinPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register pass to serialize GPU kernel functions to a CUBIN binary annotation. </p>

<p class="definition">Definition at line <a class="el" href="SerializeToCubin_8cpp_source.html#l00147">147</a> of file <a class="el" href="SerializeToCubin_8cpp_source.html">SerializeToCubin.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00049">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a309cdd85b1689eff02c2259ef8d0bb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309cdd85b1689eff02c2259ef8d0bb6c">&#9670;&nbsp;</a></span>registerGpuSerializeToHsacoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerGpuSerializeToHsacoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register pass to serialize GPU kernel functions to a HSAco binary annotation. </p>

<p class="definition">Definition at line <a class="el" href="SerializeToHsaco_8cpp_source.html#l00492">492</a> of file <a class="el" href="SerializeToHsaco_8cpp_source.html">SerializeToHsaco.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllPasses_8h_source.html#l00049">registerAllPasses()</a>.</p>

</div>
</div>
<a id="a8b9759ca57d83ec47b341d58d966b9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9759ca57d83ec47b341d58d966b9e8">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00505">505</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SerializeToBlob_8cpp_source.html#l00108">mlir::gpu::SerializeToBlobPass::getDependentDialects()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00021">mlirExecutionEngineCreate()</a>, <a class="el" href="Registration_8cpp_source.html#l00022">mlirRegisterAllLLVMTranslations()</a>, <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00512">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a74024a3b8ec9af8d50db598772774a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74024a3b8ec9af8d50db598772774a96">&#9670;&nbsp;</a></span>registerLLVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerLLVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00512">512</a> of file <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html">LLVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00505">registerLLVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5254079fbbd31a78a3430bff18df2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254079fbbd31a78a3430bff18df2d7c">&#9670;&nbsp;</a></span>registerMLIRContextCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMLIRContextCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. </p>
<p>These flags are used when constructing an MLIR context for initialization. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00086">86</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00073">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRContext_8h_source.html#l00188">mlir::MLIRContext::getImpl()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a2989267e0da323d644b3316b85b3942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989267e0da323d644b3316b85b3942f">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00142">142</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00149">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="a00d03cc4e706acdb35969f4d4e78142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d03cc4e706acdb35969f4d4e78142a">&#9670;&nbsp;</a></span>registerNVVMDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerNVVMDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00149">149</a> of file <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html">NVVMToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00142">registerNVVMDialectTranslation()</a>.</p>

</div>
</div>
<a id="ae9bc345c5d25bda3847f7ddf6cebe9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bc345c5d25bda3847f7ddf6cebe9bc">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00534">534</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00541">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a889d8518a5c67b981e76d27c9a256d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d8518a5c67b981e76d27c9a256d86">&#9670;&nbsp;</a></span>registerOpenACCDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenACCDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenACC dialect and the translation in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00541">541</a> of file <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html">OpenACCToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00534">registerOpenACCDialectTranslation()</a>.</p>

</div>
</div>
<a id="a6ea20d97a32efd36c02468e54db4b2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea20d97a32efd36c02468e54db4b2e7">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01400">1400</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01407">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="aaa35b353841b70d090e1ead360536308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa35b353841b70d090e1ead360536308">&#9670;&nbsp;</a></span>registerOpenMPDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerOpenMPDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the OpenMP dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01407">1407</a> of file <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html">OpenMPToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01400">registerOpenMPDialectTranslation()</a>.</p>

</div>
</div>
<a id="a5a4626059212aef6f3aa5fa7088ce667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4626059212aef6f3aa5fa7088ce667">&#9670;&nbsp;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00113">113</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00024">passRegistry</a>, and <a class="el" href="PassRegistry_8cpp_source.html#l00028">passRegistryTypeIDs</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&nbsp;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00128">128</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00292">mlir::PassManager::IRPrinterConfig::getOpPrintingFlags()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a83965c855ad737422194336251348893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83965c855ad737422194336251348893">&#9670;&nbsp;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>optHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8cpp_source.html#l00078">mlir::PassRegistryEntry::getOptionWidth()</a>, <a class="el" href="PassRegistry_8h_source.html#l00164">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00186">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="ab895c88d57833ccee805eb3233c04ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab895c88d57833ccee805eb3233c04ca6">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00108">108</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00115">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a4e522221c6652cb1450a6a3803125534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e522221c6652cb1450a6a3803125534">&#9670;&nbsp;</a></span>registerROCDLDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerROCDLDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00115">115</a> of file <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html">ROCDLToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00108">registerROCDLDialectTranslation()</a>.</p>

</div>
</div>
<a id="a9ed913befc935e3b4b3e622838655b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed913befc935e3b4b3e622838655b30">&#9670;&nbsp;</a></span>registerTestRoundtripDebugSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripDebugSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00174">174</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>.</p>

</div>
</div>
<a id="a2b336390b16983a364b2d95bd2a64a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b336390b16983a364b2d95bd2a64a2f">&#9670;&nbsp;</a></span>registerTestRoundtripSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00163">163</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>.</p>

</div>
</div>
<a id="a520bc0aa5f34c15a39f2202fdf521382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520bc0aa5f34c15a39f2202fdf521382">&#9670;&nbsp;</a></span>registerToCppTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToCppTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html#l00029">29</a> of file <a class="el" href="Cpp_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateToCpp_8cpp_source.html#l01039">mlir::emitc::translateToCpp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a003d72c96a8bffacc207ba165212e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d72c96a8bffacc207ba165212e2db">&#9670;&nbsp;</a></span>registerToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">25</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="namespacemlir.html#adc149979459c3123124db882fb765dba">translateModuleToLLVMIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="af7f5d34c37689ae9b05537a040d9e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5d34c37689ae9b05537a040d9e0a0">&#9670;&nbsp;</a></span>registerToSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00108">108</a> of file <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00083">serializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00028">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a06a06304b237de21b74a8c5b3251ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a06304b237de21b74a8c5b3251ac35">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR in the given registry;. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">46</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="All_8h_source.html#l00032">registerAllToLLVMIRTranslations()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a087d9cf09c9d93a0bf0f287509afc5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087d9cf09c9d93a0bf0f287509afc5b4">&#9670;&nbsp;</a></span>registerX86VectorDialectTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerX86VectorDialectTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the X86Vector dialect and the translation from it in the registry associated with the given context. </p>

<p class="definition">Definition at line <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00054">54</a> of file <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html">X86VectorToLLVMIRTranslation.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00357">mlir::MLIRContext::appendDialectRegistry()</a>, and <a class="el" href="X86VectorToLLVMIRTranslation_8cpp_source.html#l00046">registerX86VectorDialectTranslation()</a>.</p>

</div>
</div>
<a id="a1fa0a7e84eb2af3d70c98d59fc9ccbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">&#9670;&nbsp;</a></span>removeDuplicateExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::removeDuplicateExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00649">649</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01631">canonicalizeLoopBounds()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02633">createCanonicalizedAffineForOp()</a>, and <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>.</p>

</div>
</div>
<a id="a1ecf0a02c37964d01f1a90ca6cccffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecf0a02c37964d01f1a90ca6cccffec">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>domOpFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>postDomOpFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceInDeallocOp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>. </p>
<p>The new memref could be of a different shape or rank. <code>extraIndices</code> provides any additional access indices to be added to the start.</p>
<p><code>indexRemap</code> remaps indices of the old memref access to a new set of indices that are used to index the memref. Additional input operands to indexRemap can be optionally provided in <code>extraOperands</code>, and they occupy the start of its input list. <code>indexRemap</code>'s dimensional inputs are expected to correspond to memref's indices, and its symbolic inputs if any should be provided in <code>symbolOperands</code>.</p>
<p><code>domOpFilter</code>, if non-null, restricts the replacement to only those operations that are dominated by the former; similarly, <code>postDomOpFilter</code> restricts replacement to only those operations that are postdominated by it.</p>
<p>'allowNonDereferencingOps', if set, allows replacement of non-dereferencing uses of a memref without any requirement for access index rewrites as long as the user operation has the MemRefsNormalizable trait. The default value of this flag is false.</p>
<p>'replaceInDeallocOp', if set, lets DeallocOp, a non-dereferencing user, to also be a candidate for replacement. The default value of this flag is false.</p>
<p>Returns true on success and false if the replacement is not possible, whenever a memref is used as an operand in a non-dereferencing context and 'allowNonDereferencingOps' is false, except for dealloc's on the memref which are left untouched. See comments at function definition for an example. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01254">1254</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00687">getElementType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00175">mlir::Operation::getParentOfType()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00213">mlir::Value::getUsers()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00066">doubleBuffer()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a9e5a7944174565a109d7a5efe97cd62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5a7944174565a109d7a5efe97cd62e">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">1076</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">canonicalizeMapAndOperands()</a>, <a class="el" href="Attributes_8h_source.html#l00130">mlir::Attribute::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00362">mlir::Operation::getAttrs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00687">getElementType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00308">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Attributes_8cpp_source.html#l00032">mlir::NamedAttribute::getName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="Attributes_8h_source.html#l00158">mlir::NamedAttribute::getValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00259">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00356">isValidSymbol()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00297">mlir::Operation::operand_begin()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00298">mlir::Operation::operand_end()</a>, <a class="el" href="OperationSupport_8h_source.html#l00609">mlir::OperationState::operands</a>, <a class="el" href="IR_2Operation_8h_source.html#l00209">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00274">mlir::Operation::setOperand()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">simplifyAffineMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&nbsp;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <code>orig</code> within the given region with <code>replacement</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00024">24</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00197">mlir::Value::getUses()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>, <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00572">coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00628">collapseParallelLoops()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00110">sinkOperationsIntoLaunchOp()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00795">stripmineSink()</a>.</p>

</div>
</div>
<a id="a61278b37497f27fa382bcabb5cd043b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61278b37497f27fa382bcabb5cd043b8">&#9670;&nbsp;</a></span>replaceForOpWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::replaceForOpWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newYieldedValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceLoopResults</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace <code>loop</code> with a new loop where <code>newIterOperands</code> are appended with new initialization values and <code>newYieldedValues</code> are added as new yielded values. </p>
<p>The returned ForOp has <code>newYieldedValues.size()</code> new result values. Additionally, if <code>replaceLoopResults</code> is true, all uses of <code>loop.getResults()</code> are replaced with the first <code>loop.getNumResults()</code> return values of the original loop respectively. The original loop is deleted and the new loop returned. Prerequisite: <code>newIterOperands.size() == newYieldedValues.size()</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02048">2048</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8h_source.html#l00643">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00194">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00202">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00633">mlir::OperationState::addTypes()</a>, <a class="el" href="OpImplementation_8h_source.html#l00985">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="OperationSupport_8h_source.html#l00612">mlir::OperationState::attributes</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">canonicalizeSetAndOperands()</a>, <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00265">mlir::RewriterBase::eraseBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00489">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00297">mlir::Builder::getEmptyAffineMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00048">mlir::Builder::getIndexType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00659">mlir::bufferization::getMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00308">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00017">mlir::IntegerSet::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l01163">mlir::ValueRange::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00607">mlir::OperationState::location</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00298">mlir::RewriterBase::mergeBlockBefore()</a>, <a class="el" href="OperationSupport_8h_source.html#l00609">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a55ebc9079a03a42c71c883b21e733dfa">mlir::OpAsmParser::parseAffineMapOfSSAIds()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00447">parseDimAndSymbolList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac8dd551c69e3209e1d5ca180c4778362">mlir::AsmParser::parseOptionalArrowTypeList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">mlir::OpAsmParser::parseRegion()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00771">print()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00437">printDimAndSymbolList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00099">mlir::AsmPrinter::printOptionalArrowTypeList()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#aca2979fa160a91a41e9aae802edcb7d1">mlir::OpAsmPrinter::printRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::push_back()</a>, <a class="el" href="OperationSupport_8h_source.html#l00616">mlir::OperationState::regions</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="PatternMatch_8h_source.html#l00484">mlir::RewriterBase::startRootUpdate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, <a class="el" href="OperationSupport_8h_source.html#l00611">mlir::OperationState::types</a>, <a class="el" href="Verifier_8cpp_source.html#l00372">verify()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a64a364dd32a6190474be758d1a6b9d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a364dd32a6190474be758d1a6b9d5f">&#9670;&nbsp;</a></span>reshapeLikeShapesAreCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::reshapeLikeShapesAreCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>collapsedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociationMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpandingReshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that shapes of the reshaped types using following rules 1) if a dimension in the collapsed type is static, then the corresponding dimensions in the expanded shape should be a) static b) the product should be same as the collaped shape. </p>
<p>2) if a dimension in the collaped type is dynamic, one and only one of the corresponding dimensions in the expanded type should be dynamic. This rule is only needed with reshape operations that are expanding. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">226</a> of file <a class="el" href="ReshapeOpsUtils_8cpp_source.html">ReshapeOpsUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00156">verifyReshapeLikeShapes()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">verifyReshapeLikeTypes()</a>.</p>

</div>
</div>
<a id="a9eb183dcb73d44f0e0aedb09b73c7fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb183dcb73d44f0e0aedb09b73c7fd7">&#9670;&nbsp;</a></span>runRegionDCE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::runRegionDCE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns success if any operations or arguments were deleted, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00366">366</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::cast()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00625">mlir::OperationEquivalence::computeHash()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00309">deleteDeadness()</a>, <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Block_8cpp_source.html#l00137">mlir::Block::getArgumentTypes()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Block_8h_source.html#l00225">mlir::Block::getPredecessors()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l01204">mlir::OperationEquivalence::ignoreHashValue()</a>, <a class="el" href="OperationSupport_8h_source.html#l01186">mlir::OperationEquivalence::IgnoreLocations</a>, <a class="el" href="OperationSupport_8h_source.html#l01222">mlir::OperationEquivalence::ignoreValueEquivalence()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00705">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00259">propagateLiveness()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00730">simplifyRegions()</a>.</p>

</div>
</div>
<a id="a3e58dea8a192531cbf60dd5238c0ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58dea8a192531cbf60dd5238c0ba8a">&#9670;&nbsp;</a></span>separateFullTiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::separateFullTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>fullTileNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp. </p>
<p>The original loop nest is replaced by this guarded two version form.</p>
<p>affine.if (cond) // full_tile else // partial tile </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02790">2790</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02655">createSeparationCondition()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a3741dc3ccffcfafa71e4540ba59f08c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3741dc3ccffcfafa71e4540ba59f08c0">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>superShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>subShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>. </p>
<p>This is calculated by performing a traversal from minor to major dimensions (i.e. in reverse shape order). If integral division is not possible, returns None. The ArrayRefs are assumed (and enforced) to only contain &gt; 1 values. This constraint comes from the fact that they are meant to be used with VectorTypes, for which the property holds by construction.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 4, 5, 8}, {2, 5, 2}) returns {3, 2, 1, 4}</li>
<li>shapeRatio({3, 4, 4, 8}, {2, 5, 2}) returns None</li>
<li>shapeRatio({1, 2, 10, 32}, {2, 5, 2}) returns {1, 1, 2, 16} </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00127">127</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00065">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00244">getEnclosingforOps()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00163">shapeRatio()</a>.</p>

</div>
</div>
<a id="a937430eb9b6e13bfb05e6ecc5649a816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937430eb9b6e13bfb05e6ecc5649a816">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>superVectorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>subVectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>. </p>
<p>If integral division is not possible, returns None. Assumes and enforces that the VectorTypes have the same elemental type. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00163">163</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00127">shapeRatio()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&nbsp;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. When <code>expr</code> is semi-affine, a simplified semi-affine expression is constructed in the sorted order of dimension and symbol positions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">1390</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00023">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00935">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00187">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00270">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00255">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00439">simplifySemiAffine()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00074">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00907">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">mlir::AffineExpr::cast()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00889">createPrivateMemRef()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00736">detectAsMod()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00974">getConstDifference()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">mlir::FlatAffineValueConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00945">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00753">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&nbsp;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">639</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00253">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01240">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01953">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00497">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00056">getCleanupLoopLowerBound()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00340">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>.</p>

</div>
</div>
<a id="a1cab5a79af53f1bc236af0c5ba5e7b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cab5a79af53f1bc236af0c5ba5e7b54">&#9670;&nbsp;</a></span>simplifyIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::simplifyIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference. </p>
<p>Also, drop any duplicate constraints. Returns the simplified integer set. This method runs in time linear in the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01358">1358</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01484">mlir::FlatAffineValueConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00504">mlir::presburger::IntegerRelation::isEmpty()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l01565">mlir::presburger::IntegerRelation::removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="a50c016066a116564e82772ece3edd84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c016066a116564e82772ece3edd84c">&#9670;&nbsp;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. The provided rewriter is used to notify callers of operation and block deletion.</p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00730">730</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00079">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00652">mergeIdenticalBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00366">runRegionDCE()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="aa6e007ae66428f560626d4ba3c58dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e007ae66428f560626d4ba3c58dfe2">&#9670;&nbsp;</a></span>sinkOperationsIntoLaunchOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::sinkOperationsIntoLaunchOp </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>isSinkingBeneficiary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00110">110</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00468">mlir::OpBuilder::clone()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00079">extractBeneficiaryOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00059">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00024">replaceAllUsesInRegionWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="ad4e57efabe41ec9f1d263ed7a42c7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e57efabe41ec9f1d263ed7a42c7f15">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01562">1562</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01422">checkLoopInterchangeDependences()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00668">getDependenceComponents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00946">getPerfectlyNestedLoops()</a>, <a class="el" href="namespacemlir_1_1matcher.html#add2d6ea67e8745edd1987358b954a5e6">mlir::matcher::isParallelLoop()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00143">mlir::DependenceComponent::lb</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01492">permuteLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00145">mlir::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01088">isFusionProfitable()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00863">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a856cbb46a654a0b0402a4624edd911f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856cbb46a654a0b0402a4624edd911f3">&#9670;&nbsp;</a></span>sparseParallelizationStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832">SparseParallelizationStrategy</a> mlir::sparseParallelizationStrategy </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts command-line parallelization flag to the strategy enum. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00137">137</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a3b1257bf6747bc07f90c215e9aafd4a7">kAnyStorageAnyLoop</a>, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832afe3590ad05890d8754eef93504f9b7af">kAnyStorageOuterLoop</a>, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a0d7778373362fd80feddcb9b38a354b8">kDenseAnyLoop</a>, <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a09e4a3d1c3e70c9426528f102480e6e7">kDenseOuterLoop</a>, and <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">kNone</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SparseTensor_2Pipelines_2Passes_8h_source.html#l00049">mlir::sparse_tensor::SparseCompilerOptions::sparsificationOptions()</a>.</p>

</div>
</div>
<a id="a3aa1a4192d65a00261a1f969b16c3e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa1a4192d65a00261a1f969b16c3e8a">&#9670;&nbsp;</a></span>sparseToSparseConversionStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36ca">SparseToSparseConversionStrategy</a> mlir::sparseToSparseConversionStrategy </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts command-line sparse2sparse flag to the strategy enum. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00164">164</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa8c857c2f1b000c92f9794ebf53888d7">kAuto</a>, <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caaa9a2bb1cd77c7a81a96b73f10722040e">kDirect</a>, and <a class="el" href="namespacemlir.html#ad6dfcab9b0dbfb18cf218eef50ba36caad0d3b7e52553c0a403cfe727b3ce47b3">kViaCOO</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SparseTensor_2Pipelines_2Passes_8h_source.html#l00062">mlir::sparse_tensor::SparseCompilerOptions::sparseTensorConversionOptions()</a>.</p>

</div>
</div>
<a id="a1a09e3695ba40c8c2a2669d62ba540a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a09e3695ba40c8c2a2669d62ba540a8">&#9670;&nbsp;</a></span>sparseVectorizationStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2">SparseVectorizationStrategy</a> mlir::sparseVectorizationStrategy </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts command-line vectorization flag to the strategy enum. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00152">152</a> of file <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html">SparseTensorPasses.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2a3bd27e991efaf1f1fad03867e363b410">kAnyStorageInnerLoop</a>, <a class="el" href="namespacemlir.html#a89ff3aa7fac07fd569937d78a0046fe2a580289a4bc04d1b8340b94829df37fbb">kDenseInnerLoop</a>, and <a class="el" href="namespacemlir.html#a781474aef998ccce168b69ae973cd832a35c3ace1970663a16e5c65baa5941b13">kNone</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SparseTensor_2Pipelines_2Passes_8h_source.html#l00049">mlir::sparse_tensor::SparseCompilerOptions::sparsificationOptions()</a>.</p>

</div>
</div>
<a id="a2320d5e3423bb76edf4048a5674f8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2320d5e3423bb76edf4048a5674f8f8e">&#9670;&nbsp;</a></span>splitAndProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>originalBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a>&#160;</td>
          <td class="paramname"><em>processChunkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. </p>

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8cpp_source.html#l00022">22</a> of file <a class="el" href="ToolUtilities_8cpp_source.html">ToolUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00092">processBuffer()</a>.</p>

</div>
</div>
<a id="a6f16fcf3a83d26d5a59da3bf0138ca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f16fcf3a83d26d5a59da3bf0138ca24">&#9670;&nbsp;</a></span>structFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>Give structFuncArgTypeConverter access to memref-specific functions.</p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00533">533</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a14aa9eab34d9d03045c1ce109f34bb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14aa9eab34d9d03045c1ce109f34bb34">&#9670;&nbsp;</a></span>substWithMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::substWithMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positivePath</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse <code>e</code> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> where all occurrences of <code>dim</code> have been replaced by either: </p>
<ul>
<li><code>min</code> if <code>positivePath</code> is true when we reach an occurrence of <code>dim</code></li>
<li><code>max</code> if <code>positivePath</code> is true when we reach an occurrence of <code>dim</code> <code>positivePath</code> is negated each time we hit a multiplicative or divisive binary op with a constant negative coefficient. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00459">459</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00186">min()</a>.</p>

</div>
</div>
<a id="a57a1cb2e1046f84d6328600b92c99e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1cb2e1046f84d6328600b92c99e52">&#9670;&nbsp;</a></span>succeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::succeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a> corresponds to a success value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00068">68</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00041">mlir::LogicalResult::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00794">areValidCastInputsAndOutputs()</a>, <a class="el" href="PatternMatch_8h_source.html#l01091">mlir::detail::pdl_function_builder::assertArgs()</a>, <a class="el" href="OpDefinition_8h_source.html#l01685">mlir::Op&lt; AffineDmaWaitOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResult, OpTrait::OpInvariants, AffineMapAccessInterface::Trait &gt;::attachInterface()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03288">canonicalizeLoopBounds()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00538">mlir::presburger::SetCoalescer::coalesce()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00625">collectSymbolScopes()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01818">computeCollapsedLayoutMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00265">convertScalarType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00298">convertVectorType()</a>, <a class="el" href="Builders_8h_source.html#l00451">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00889">createPrivateMemRef()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00309">deleteDeadness()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00241">mlir::detail::DiagnosticEngineImpl::emit()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00703">extractStrides()</a>, <a class="el" href="LogicalResult_8h_source.html#l00044">mlir::LogicalResult::failed()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00228">mlir::detail::PassCrashReproducerGenerator::finalize()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00496">mlir::Operation::fold()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01357">foldExtractAfterInsertSlice()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01456">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00132">mlir::tensor::foldTensorCast()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="OpDefinition_8h_source.html#l01538">mlir::op_definition_impl::foldTraits()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01676">mlir::presburger::IntegerRelation::fourierMotzkinEliminate()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00043">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="LoopUnroll_8cpp_source.html#l00074">gatherInnermostLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00181">generateShiftedLoop()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00451">getAllocationTypeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00716">getLoadStoreElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02970">getOption()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00068">mlir::ConvertToLLVMPattern::getStridedElementPtr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01782">hasTrivialZeroTripCount()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02302">haveCompatibleOffsets()</a>, <a class="el" href="IR_8cpp_source.html#l00284">inferOperationTypes()</a>, <a class="el" href="ByteCode_8cpp_source.html#l01035">mlir::detail::PDLByteCode::initializeMutableState()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00108">isFusionLegal()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00115">mlir::vector::isLastMemrefDimUnitStride()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="Matchers_8h_source.html#l00075">mlir::detail::constant_op_binder&lt; AttrT &gt;::match()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00126">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00262">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00340">mlir::detail::OpOrInterfaceRewritePatternBase&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01689">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01405">mlir::vector::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00860">mlir::linalg::GeneralizePadOpPattern::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00652">mergeIdenticalBlocks()</a>, <a class="el" href="IR_8cpp_source.html#l00485">mlirOperationVerify()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01465">mlir::detail::ConversionPatternRewriterImpl::notifyRegionWasClonedBefore()</a>, <a class="el" href="DLTI_8cpp_source.html#l00280">mlir::DataLayoutSpecAttr::parse()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00123">parseAnyType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00282">parseAsyncDependencies()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00866">parseAttributions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01341">parseBound()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00124">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00229">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00102">parseCreateOperationOpResults()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00539">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00845">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00902">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00876">parseKeywordList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00141">parseLinearClause()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00056">parseOperandList()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00108">parseOperandsOrIntegersImpl()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00144">parseOperationOpAttributes()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00217">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00816">mlir::AsmParser::parseOptionalAttribute()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01757">parseOptionalKeywordAlternative()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00290">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeywordOrString()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01785">parseOptionalLLVMKeyword()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00100">parseOptionalOperand()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00129">parseOptionalOperandAndType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00302">parseReductionVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00154">parserOptionalOperandAndTypeWithPrefix()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00219">parseScheduleClause()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00025">parseStorageType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00564">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00628">parseStructType()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00480">parseSwitchOpCases()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00381">parseSynchronizationHint()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01045">parseTargetEnvAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00931">mlir::AsmParser::parseTypeList()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00197">parseUniformType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00600">parseVariableDecorations()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00520">parseWsLoopControl()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00313">peelLoop()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01725">mlir::AsmPrinter::Impl::printAlias()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01733">mlir::AsmPrinter::Impl::printAttribute()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00369">printInitializationList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00067">mlir::AsmPrinter::printStrippedAttrOrType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02025">mlir::AsmPrinter::Impl::printType()</a>, <a class="el" href="Transport_8cpp_source.html#l00265">readLine()</a>, <a class="el" href="Transport_8cpp_source.html#l00196">mlir::lsp::JSONTransport::run()</a>, <a class="el" href="Serializer_8cpp_source.html#l00273">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="DebugAction_8h_source.html#l00110">mlir::DebugActionManager::shouldExecute()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00702">simplifyPassThroughSwitch()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00730">simplifyRegions()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="TypeFromLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00758">tryIsolateBands()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01656">vectorizeLoops()</a>, <a class="el" href="PatternMatch_8h_source.html#l01069">mlir::detail::pdl_function_builder::verifyAsArgs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01174">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="OpDefinition_8h_source.html#l01600">mlir::op_definition_impl::verifyRegionTraits()</a>, <a class="el" href="OpDefinition_8h_source.html#l01577">mlir::op_definition_impl::verifyTraits()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00054">walkReferenceCountedValues()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a5f55c06c7c4aeace3f6824dd68f8b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">&#9670;&nbsp;</a></span>success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::success </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSuccess</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="This class represents an efficient way to signal success or failure. ">LogicalResult</a>. </p>
<p>If isSuccess is true a <code>success</code> result is generated, otherwise a 'failure' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00056">56</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00030">mlir::LogicalResult::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00570">ableToUpdatePredOperands()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00027">acceptBitWidth()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00587">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00375">mlir::gpu::addAsyncDependency()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00639">mlir::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="LinalgDialect_8cpp_source.html#l00097">addNamedOpBuilders()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00407">mlir::linalg::LinalgTransformationFilter::addOpFilter()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00412">mlir::linalg::LinalgTransformationFilter::addOpNameFilter()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00625">addRuntimePreemptionSpecifier()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">mlir::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00915">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="OpImplementation_8h_source.html#l00993">mlir::AsmParser::addTypesToList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00985">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02374">affineDataCopyGenerate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00236">affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00348">affineParallelize()</a>, <a class="el" href="LLVMTranslationInterface_8h_source.html#l00055">mlir::LLVMTranslationDialectInterface::amendOperation()</a>, <a class="el" href="LLVMTranslationInterface_8h_source.html#l00081">mlir::LLVMTranslationInterface::amendOperation()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00880">mlir::bufferization::analyzeOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00650">analyzeProfitability()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00378">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00743">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00059">applyTilingToAll()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00124">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00400">areAllLLVMTypes()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00834">assertDestinationPassingStyle()</a>, <a class="el" href="OpDefinition_8h_source.html#l01685">mlir::Op&lt; AffineDmaWaitOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResult, OpTrait::OpInvariants, AffineMapAccessInterface::Trait &gt;::attachInterface()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00562">barePtrFuncArgTypeConverter()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00652">bufferizableInPlaceAnalysisImpl()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00222">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00403">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">mlir::bufferization::bufferizeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02107">buildLLVMFunctionType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00441">buildUnresolvedTargetMaterialization()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03277">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01631">canonicalizeLoopBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">canonicalizeSetAndOperands()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00145">castBoolToIntN()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00115">castDataPtr()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00133">checkAffineLoopNestMappable()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00107">checkAffineLoopNestMappableImpl()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00770">checkAliasInfoConsistency()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">mlir::linalg::LinalgTransformationFilter::checkAndNotify()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00071">checkAndUpdateCapabilityRequirements()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00043">checkAndUpdateExtensionRequirements()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00067">checkCapabilityRequirements()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00273">checkCompatibleReturnType&lt; float &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00253">checkCompatibleReturnType&lt; int32_t &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00263">checkCompatibleReturnType&lt; int64_t &gt;()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00184">checkDoubleConsume()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00039">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00442">checkIfHyperRectangular()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00299">checkTensorElementType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00437">checkTilingLegality()</a>, <a class="el" href="PDLTypes_8cpp_source.html#l00060">mlir::pdl::PDLType::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00384">mlir::BoolAttr::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01238">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00538">mlir::presburger::SetCoalescer::coalesce()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01720">coalesceLoops()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00098">collapseBranch()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00101">mlir::spirv::Deserializer::collect()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00039">collectValidReferencesFor()</a>, <a class="el" href="DLTI_8cpp_source.html#l00192">combineOneSpec()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00147">compileAndExecute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">mlir::FlatAffineValueConstraints::composeMatchingMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00033">computeConversionSet()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01408">computeLocalVars()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00042">computeReshapeOutput()</a>, <a class="el" href="Simplex_8cpp_source.html#l00507">mlir::presburger::SymbolicLexSimplex::computeSymbolicIntegerLexMin()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04365">concatElemAndIndices()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00331">mlir::AffineMap::constantFold()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01297">mlir::presburger::IntegerRelation::constantFoldId()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00283">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00567">mlir::LLVM::ModuleTranslation::convertBlock()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03051">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00159">convertCmpPredicate()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00279">convertDataOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01370">mlir::detail::ConversionPatternRewriterImpl::convertNonEntryRegionTypes()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01111">convertOmpAtomicCapture()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00983">convertOmpAtomicRead()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01040">convertOmpAtomicUpdate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01006">convertOmpAtomicWrite()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00337">convertOmpCritical()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00310">convertOmpMaster()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00533">convertOmpOrdered()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00563">convertOmpOrderedRegion()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00252">convertOmpParallel()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01208">convertOmpReductionOp()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00596">convertOmpSections()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00888">convertOmpSimdLoop()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00664">convertOmpSingle()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01255">convertOmpThreadprivate()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00682">convertOmpWsLoop()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00256">convertOperationImpl()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03018">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03033">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00431">convertStandaloneDataOp()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>, <a class="el" href="ExpandTanh_8cpp_source.html#l00024">convertTanhOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00222">convertToLaunchFuncOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02995">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00227">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="AllocLikeConversion_8cpp_source.html#l00014">mlir::AllocLikeOpLLVMLowering::createAligned()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00538">mlir::bufferization::createAllocDeallocOps()</a>, <a class="el" href="Arithmetic_2Transforms_2ExpandOps_8cpp_source.html#l00018">createConst()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00438">mlir::bufferization::createDealloc()</a>, <a class="el" href="ROCDLToLLVMIRTranslation_8cpp_source.html#l00031">createDeviceFunctionCall()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00527">mlir::bufferization::createMemCpy()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00655">mlir::bufferization::deallocateBuffers()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Promotion_8cpp_source.html#l00106">defaultDeallocBufferCallBack()</a>, <a class="el" href="VectorRewritePatterns_8h_source.html#l00368">mlir::vector::ContractionOpToMatmulOpLowering::defaultFilter()</a>, <a class="el" href="VectorRewritePatterns_8h_source.html#l00410">mlir::vector::ContractionOpToOuterProductOpLowering::defaultFilter()</a>, <a class="el" href="VectorRewritePatterns_8h_source.html#l00455">mlir::vector::ContractionOpToDotLowering::defaultFilter()</a>, <a class="el" href="VectorRewritePatterns_8h_source.html#l00495">mlir::vector::ContractionOpLowering::defaultFilter()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00309">deleteDeadness()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00062">mlir::spirv::Deserializer::deserialize()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00405">mlir::spirv::Deserializer::processOp&lt; spirv::ControlBarrierOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00501">mlir::spirv::Deserializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00329">mlir::spirv::Deserializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00372">mlir::spirv::Deserializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00434">mlir::spirv::Deserializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00476">mlir::spirv::Deserializer::processOp&lt; spirv::MemoryBarrierOp &gt;()</a>, <a class="el" href="Verifier_8cpp_source.html#l00274">diagnoseInvalidOperandDominance()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00649">doSequentialDispatch()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00035">dropRefIfNoUses()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00625">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Transport_8cpp_source.html#l00137">encodeError()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00079">eraseUnreachableBlocks()</a>, <a class="el" href="OperationSupport_8h_source.html#l01227">mlir::OperationEquivalence::exactValueMatch()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="DeserializeOps_8cpp_source.html#l00032">extractOpcode()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00703">extractStrides()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00133">extractValueFromConstOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="Threading_8h_source.html#l00036">failableParallelForEach()</a>, <a class="el" href="LogicalResult_8h_source.html#l00036">mlir::LogicalResult::failure()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00260">mlir::bufferization::finalizeBuffers()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00180">mlir::detail::OpPassManagerImpl::finalizePassList()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00116">findDuplicateElement()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02855">findLiveUserOfReplaced()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00079">findOptimal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">mlir::FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01231">mlir::AffineDmaWaitOp::fold()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00496">mlir::Operation::fold()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01153">mlir::impl::foldCastInterfaceOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01084">foldExtractOpFromExtractChain()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01456">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01335">foldIdentityOffsetSizeAndStrideOpInterface()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01585">foldLoopBounds()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00089">mlir::memref::foldMemRefCast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00981">foldMemRefCast()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00132">mlir::tensor::foldTensorCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02968">foldTensorCast()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="OpDefinition_8h_source.html#l01501">mlir::op_definition_impl::foldTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01538">mlir::op_definition_impl::foldTraits()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00773">forwardPassthroughAttributes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00662">funcsToCoroutines()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00354">fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00517">mlir::presburger::IntegerRelation::gaussianEliminateId()</a>, <a class="el" href="Generalization_8cpp_source.html#l00032">generalizeNamedOpPrecondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02573">generateCopyForMemRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01508">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00064">generateLocationsFromIR()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00956">mlir::LLVM::ModuleTranslation::getAccessGroup()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00213">getAllocEffectFor()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00119">getAssumedUniqueReturnOp()</a>, <a class="el" href="SplitPadding_8cpp_source.html#l00036">getAsValue()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00153">getBlockIt()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00387">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00242">getDefaultABIAttrs()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00090">getDivRepr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00972">getElementPtrType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00908">getF64Values()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00032">getFirstIntValue()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00140">mlir::FloatType::getFPMantissaWidth()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00044">mlir::transform::TransformState::getHandleForPayloadOp()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00097">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">getIndexSet()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01360">getInsertExtractValueElementType()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00071">getInterfaceVariables()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00104">getKernelGlobalVariables()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00068">getLdMatrixIntrinsicId()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00699">getLLVMAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00716">getLoadStoreElementType()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00081">getMemRefAlignment()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">getMemRefSizeInBytes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00333">mlir::OpPassManager::getNesting()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00704">getNumElements()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00199">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00110">getPermutationMapAttr()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00049">getPtrToElementType()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00465">getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">getRelationFromMap()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01583">mlir::ConversionPatternRewriter::getRemappedValues()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00048">mlir::shape::getShapeVec()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00028">getSrcVectorElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00747">getStridesAndOffset()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01453">getTileSizePos()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00449">mlir::vector::getVectorReductionOp()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00081">mlir::LLVM::detail::handleMultidimensionalVectors()</a>, <a class="el" href="BufferOptimizations_8cpp_source.html#l00075">hasAllocationScope()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00984">hasAtMostSingleNonScalar()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01782">hasTrivialZeroTripCount()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00408">hoistAffineIfOp()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00587">mlir::bufferization::hoistBufferAllocations()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00168">HoistingAnalysis::HoistingAnalysis()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00716">hoistOpsBetween()</a>, <a class="el" href="OperationSupport_8h_source.html#l01222">mlir::OperationEquivalence::ignoreValueEquivalence()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00048">mlir::ComplexStructBuilder::imaginary()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00100">inferDynamicDimsForConv()</a>, <a class="el" href="IR_8cpp_source.html#l00284">inferOperationTypes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00179">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02356">inferStridedSliceOpResultType()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00038">mlir::ReductionNode::initialize()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00120">mlir::ExternalPass::initialize()</a>, <a class="el" href="include_2mlir_2Pass_2Pass_8h_source.html#l00184">mlir::Pass::initialize()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00332">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00433">inlineCallsInSCC()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00418">inlineConvertOmpRegions()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00042">inlineWhileCase()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00685">inPlaceAnalysis()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Interchange_8cpp_source.html#l00037">interchangeGenericOpPrecondition()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00040">interleaveWithError()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00070">invertPredicate()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00370">mlir::ExecutionEngine::invokePacked()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00411">isAsyncWithOneDependency()</a>, <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00270">isBoolScalarOrVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00541">isDefinedByCallTo()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00453">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00563">isGenericOpExpandable()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00505">isGpuAsyncTokenType()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00194">isInBounds()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02076">isIntegerArrayAttrConfinedToRange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02096">isIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02061">isIntegerArrayAttrSmallerThanShape()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="Simplex_8cpp_source.html#l00351">isRangeDivisibleBy()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02119">isSumOfIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00081">isSumOfMul()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00047">isValidQuantizationSpec()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01872">isZeroAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02696">legalizeUnresolvedMaterialization()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00031">loadModule()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00325">lookupSymbolInImpl()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01632">lookupSymbolInModule()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00378">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00975">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01203">loopUnrollJamByFactor()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">lowerAffineLowerBound()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02141">makeI64ArrayAttr()</a>, <a class="el" href="OptUtils_8cpp_source.html#l00026">mapToLevel()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00030">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00017">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00026">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="IndexIntrinsicsOpLowering_8h_source.html#l00035">mlir::GPUIndexIntrinsicOpLowering&lt; Op, XOp, YOp, ZOp &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00097">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00039">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00040">InnerOuterDimReductionConversion::matchAndRewrite()</a>, <a class="el" href="Dialect_2Arithmetic_2Utils_2Utils_8h_source.html#l00044">mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder&lt; OpType, ResultTypeFunc, CastOpFunc &gt;::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00165">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00126">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00060">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00284">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00074">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00100">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00112">ReduceMultiDimReductionRank::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00116">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00125">ReshapeReshapeOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00148">TransferWritePermutationLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00156">SingleBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00169">mlir::ConvertOpToLLVMPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00173">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00196">ConstantTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00203">Convert1DExtractStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00208">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00223">TwoDimMultiReductionToElementWise::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00229">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00259">NoOpOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00262">TwoDimMultiReductionToReduction::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00262">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00276">ConvertVariable::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00288">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00289">ConvertAddressOf::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00292">AddZeroOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00300">OneDimMultiReductionToTwoDim::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00305">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00340">mlir::detail::OpOrInterfaceRewritePatternBase&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00353">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00355">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00360">ConvertLoad::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00378">MaterializePadValue::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00387">ConvertStore::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01405">mlir::vector::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00425">MaxPool2dIsNoOp::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00438">mlir::OpConversionPattern&lt; cf::AssertOp &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00460">ClampIsNoOp::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00483">mlir::OpInterfaceConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00528">ClampClampOptimization::matchAndRewrite()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00534">YieldOpLowering::matchAndRewrite()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00578">AssertOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00651">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00800">VectorizePadOpUserPattern&lt; vector::TransferWriteOp &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00918">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01105">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00781">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00860">mlir::linalg::GeneralizePadOpPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01257">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00922">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01688">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01703">SelectI1Simplify::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01796">TransferReadToVectorLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01882">VectorLoadToMemrefLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01900">VectorStoreToMemrefStoreLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01937">TransferWriteToVectorStoreLowering::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02004">BubbleDownVectorBitCastForExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02078">BubbleDownBitCastForStridedSliceExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02157">BubbleUpBitCastForStridedSliceInsert::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02276">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02329">VectorCreateMaskOpConversion::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02649">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02691">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02830">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00221">mlir::TypeConverter::materializeTargetConversion()</a>, <a class="el" href="Verifier_8cpp_source.html#l00099">mayBeValidWithoutTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00652">mergeIdenticalBlocks()</a>, <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00070">mlirExecutionEngineInvokePacked()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00194">MlirOptMain()</a>, <a class="el" href="MlirReduceMain_8cpp_source.html#l00041">mlirReduceMain()</a>, <a class="el" href="Simplex_8cpp_source.html#l00744">mlir::presburger::LexSimplexBase::moveRowUnknownToColumn()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00081">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00235">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00902">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01481">NAryInferReturnTypes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00556">normalizeAffineFor()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01677">normalizeMemRef()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00310">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="LogicalResult_8h_source.html#l00093">mlir::FailureOr&lt; T &gt;::operator LogicalResult()</a>, <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00049">GpuAsyncRegionPass::ThreadTokenCallback::operator()()</a>, <a class="el" href="SerializeToBlob_8cpp_source.html#l00101">mlir::gpu::SerializeToBlobPass::optimizeLlvm()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00241">outlineExecuteOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00203">outlineIfOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00857">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="Threading_8h_source.html#l00122">parallelForEach()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00115">mlir::FieldParser&lt; ContainerT, std::enable_if_t&lt; std::is_member_function_pointer&lt; decltype(&amp;ContainerT::push_back)&gt;::value, ContainerT &gt; &gt;::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00269">mlir::DynamicAttr::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01043">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00156">mlir::DynamicType::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01188">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00684">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00072">parseAllocateAndAllocator()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00353">parseAllReduceOperation()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00457">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseArrowTypeList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00638">parseAtomicReductionRegion()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00044">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00351">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00664">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00264">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00866">parseAttributions()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00289">parseAwaitResultType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01341">parseBound()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00115">parseClauseAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00953">mlir::AsmParser::parseColonType()</a>, <a class="el" href="PassOptions_8h_source.html#l00038">mlir::detail::pass_options::parseCommaSeparatedList()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00124">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00229">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00067">parseCreateOperationOpAttributes()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00102">parseCreateOperationOpResults()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00358">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseCustomAttributeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l00728">mlir::AsmParser::parseCustomAttributeWithFallback()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00370">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseCustomTypeWithFallback()</a>, <a class="el" href="OpImplementation_8h_source.html#l00905">mlir::AsmParser::parseCustomTypeWithFallback()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00538">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00421">parseElementAttrHexValues()</a>, <a class="el" href="ParserUtils_8h_source.html#l00027">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00214">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseEnumStrAttr()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00301">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseFloat()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00266">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00164">mlir::function_interface_impl::parseFunctionOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00083">parseFunctionResultList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00065">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00116">mlir::function_interface_impl::parseFunctionSignature()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00539">parseGEPIndices()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00367">parseImageOperands()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00559">mlir::detail::Parser::parseIntegerInDimensionList()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00693">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="OpImplementation_8h_source.html#l00485">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00876">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00513">mlir::AsmParser::parseKeywordOrString()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00764">parseLaunchFuncOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00141">parseLinearClause()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00147">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00250">parseMemoryAccessAttributes()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00194">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00201">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00175">parseNamedStructuredOpRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00194">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00094">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00067">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00115">parseOperandAndType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00056">parseOperandList()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00108">parseOperandsOrIntegersImpl()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00144">parseOperationOpAttributes()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00255">parseOptionalArrayStride()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00075">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalArrow()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00465">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalArrowTypeList()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00393">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDict()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00401">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalAttrDictWithKeyword()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00217">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00105">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalColon()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00487">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalColonTypeList()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00115">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalComma()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00480">mlir::ExtensibleDialect::parseOptionalDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00458">mlir::ExtensibleDialect::parseOptionalDynamicType()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00120">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalEllipsis()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00130">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalEqual()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00150">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalGreater()</a>, <a class="el" href="OpImplementation_8h_source.html#l00567">mlir::AsmParser::parseOptionalInteger()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00252">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00290">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalKeywordOrString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00085">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLBrace()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00140">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLess()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01785">parseOptionalLLVMKeyword()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00160">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLParen()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00180">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalLSquare()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00100">parseOptionalOperand()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00220">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalPlus()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00200">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalQuestion()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00095">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRBrace()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00170">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRParen()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00190">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalRSquare()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00210">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalStar()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00235">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalString()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00423">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalSymbolName()</a>, <a class="el" href="AsmParserImpl_8h_source.html#l00230">mlir::detail::AsmParserImpl&lt; BaseT &gt;::parseOptionalVerticalBar()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01094">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00672">parsePassPipeline()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00057">mlir::detail::Parser::parsePrettyDialectSymbolName()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04322">parsePtrAccessChainOpImpl()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00165">parseQuantParams()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00302">parseReductionVarList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00040">parseRegions()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00412">parseResultsValueType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00219">parseScheduleClause()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00536">parseSizeAssignment()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00281">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00066">parseStorageRange()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00153">mlir::detail::Parser::parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00603">mlir::detail::Parser::parseStrideList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00474">mlir::AsmParser::parseString()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00564">parseStructMemberDecorations()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00480">parseSwitchOpCases()</a>, <a class="el" href="OpImplementation_8h_source.html#l00845">mlir::AsmParser::parseSymbolName()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00381">parseSynchronizationHint()</a>, <a class="el" href="OpImplementation_8h_source.html#l01143">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00876">mlir::AsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00931">mlir::AsmParser::parseTypeList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00081">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00096">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00600">parseVariableDecorations()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00487">mlir::detail::Parser::parseVectorDimensionList()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00970">parseVerCapExtAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00587">mlir::detail::Parser::parseXInDimensionList()</a>, <a class="el" href="PassRegistry_8h_source.html#l00164">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00186">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00111">peelForLoop()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00047">performActions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, <a class="el" href="Simplex_8cpp_source.html#l00918">mlir::presburger::SimplexBase::pivot()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01543">poolingInferReturnTypes()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00079">mlir::bufferization::populateBufferizeMaterializationLegality()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00041">populateCallOpTypeConversionPattern()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01598">populateFromInt64AttrArray()</a>, <a class="el" href="DLTI_8cpp_source.html#l00301">mlir::DataLayoutSpecAttr::print()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01172">print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01725">mlir::AsmPrinter::Impl::printAlias()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00298">printAsyncDependencies()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">printAtomicReductionRegion()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00947">printAttributions()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00301">printAwaitResultType()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00185">printConstantOp()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00122">printCreateOperationOpResults()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00563">printGEPIndices()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00493">mlir::ExtensibleDialect::printIfDynamicAttr()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00471">mlir::ExtensibleDialect::printIfDynamicType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00369">printInitializationList()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00043">printNVVMIntrinsicOp()</a>, <a class="el" href="TranslateToCpp_8cpp_source.html#l00249">printOperation()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00423">printResultsValueType()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00532">printSwitchOpCases()</a>, <a class="el" href="Serializer_8cpp_source.html#l00135">mlir::spirv::Serializer::printValueIDMap()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">printWsLoopControl()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00197">processDataOperands()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00126">processOperands()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00295">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>, <a class="el" href="Promotion_8cpp_source.html#l00359">mlir::linalg::promoteSubviewsPrecondition()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Lexer_8cpp_source.html#l00107">mlir::pdll::Lexer::pushInclude()</a>, <a class="el" href="Transport_8cpp_source.html#l00265">readLine()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01410">ReduceInferReturnTypes()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00580">reductionPreconditions()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00438">mlir::DiagnosticEngine::registerHandler()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, <a class="el" href="Translation_8cpp_source.html#l00057">registerTranslateToMLIRFunction()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00152">ReifyExpandOrCollapseShapeOp&lt; OpTy &gt;::reifyResultShapes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01255">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00882">replaceAllSymbolUsesImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00594">replaceDimOrSym()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00031">replaceTransferOpWithMubuf()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="SCCP_8cpp_source.html#l00170">replaceWithConstant()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00074">reshapeLowerToHigher()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01445">resolveBroadcastShape()</a>, <a class="el" href="OpImplementation_8h_source.html#l01158">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00044">resolveSourceIndices()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00151">rewriteAffineOpAfterPeeling()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00839">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00901">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01055">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="mlir-lsp-server_2LSPServer_8cpp_source.html#l00203">mlir::lsp::LSPServer::run()</a>, <a class="el" href="Transport_8cpp_source.html#l00196">mlir::lsp::JSONTransport::run()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00938">mlir::bufferization::runOneShotBufferize()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00418">mlir::bufferization::runOneShotModuleBufferize()</a>, <a class="el" href="mlir-pdll-lsp-server_2LSPServer_8cpp_source.html#l00255">mlir::lsp::runPdllLSPServer()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00366">runRegionDCE()</a>, <a class="el" href="Inliner_8cpp_source.html#l00287">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02790">separateFullTiles()</a>, <a class="el" href="Serializer_8cpp_source.html#l00086">mlir::spirv::Serializer::serialize()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00083">serializeModule()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00570">mlir::spirv::Serializer::processOp&lt; spirv::ControlBarrierOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00666">mlir::spirv::Serializer::processOp&lt; spirv::CopyMemoryOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00536">mlir::spirv::Serializer::processOp&lt; spirv::EntryPointOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00591">mlir::spirv::Serializer::processOp&lt; spirv::ExecutionModeOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00639">mlir::spirv::Serializer::processOp&lt; spirv::FunctionCallOp &gt;()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00620">mlir::spirv::Serializer::processOp&lt; spirv::MemoryBarrierOp &gt;()</a>, <a class="el" href="Serializer_8cpp_source.html#l00263">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::ArrayType &gt;()</a>, <a class="el" href="Serializer_8cpp_source.html#l00273">mlir::spirv::Serializer::processTypeDecoration&lt; spirv::RuntimeArrayType &gt;()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00978">mlir::LLVM::ModuleTranslation::setAccessGroupsMetadata()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00043">mlir::gpu::setMappingAttr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00067">mlir::DataDescriptor::setSize()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00276">shouldPrintElementsAttrWithHex()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00144">simplifyBrToBlockWithSinglePred()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00681">simplifyConstSwitchValue()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00702">simplifyPassThroughSwitch()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00730">simplifyRegions()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00826">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00775">simplifySwitchFromSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00604">simplifySwitchWithOnlyDefault()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00110">sinkOperationsIntoLaunchOp()</a>, <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00492">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00035">splatZero()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00022">splitAndProcessBuffer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00519">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00127">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00533">structFuncArgTypeConverter()</a>, <a class="el" href="Tiling_8cpp_source.html#l00284">tilePadOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00860">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00904">tilePerfectlyNestedParametric()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00398">mlir::OpBuilder::tryFold()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00758">tryIsolateBands()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00070">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00721">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00025">typeOrAttrParser()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00051">updateSymbolAndAllUses()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00473">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00653">mlir::linalg::vectorizeCopy()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01530">vectorizeLoopNest()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00595">vectorizeStaticLinalgOpPrecondition()</a>, <a class="el" href="VectorRewritePatterns_8h_source.html#l00330">mlir::vector::VectorTransferFullPartialRewriter::VectorTransferFullPartialRewriter()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00032">mlir::quant::QuantizedType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00166">mlir::spirv::InterfaceVarABIAttr::verify()</a>, <a class="el" href="DLTI_8cpp_source.html#l00146">mlir::DataLayoutSpecAttr::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00059">mlir::LLVM::LLVMArrayType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00262">mlir::spirv::VerCapExtAttr::verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00067">mlir::gpu::MMAMatrixType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00142">mlir::LLVM::LLVMFunctionType::verify()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00344">mlir::spirv::TargetEnvAttr::verify()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00179">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::verify()</a>, <a class="el" href="OpDefinition_8h_source.html#l00188">mlir::OpState::verify()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00218">mlir::LLVM::LLVMPointerType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00235">mlir::quant::AnyQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00732">mlir::spirv::SampledImageType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00270">mlir::quant::UniformQuantizedType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00323">mlir::quant::UniformQuantizedPerAxisType::verify()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00435">mlir::LLVM::LLVMStructType::verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00383">mlir::quant::CalibratedQuantizedType::verify()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01096">mlir::spirv::MatrixType::verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01087">verifyAccessChain()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00081">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02573">verifyAffineMinMaxOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00902">mlir::detail::pdl_function_builder::ProcessPDLValueBasedOn&lt; T, Type &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00915">mlir::detail::pdl_function_builder::ProcessBuiltinPDLValue&lt; Value &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00937">mlir::detail::pdl_function_builder::ProcessDerivedPDLValue&lt; T, Type &gt;::verifyAsArg()</a>, <a class="el" href="PatternMatch_8h_source.html#l01069">mlir::detail::pdl_function_builder::verifyAsArgs()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00713">mlir::OpTrait::impl::verifyAtLeastNOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00801">mlir::OpTrait::impl::verifyAtLeastNRegions()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00827">mlir::OpTrait::impl::verifyAtLeastNResults()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01174">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00822">verifyAtomicUpdateOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00588">verifyBlockReadWritePtrAndValTypes()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00061">mlir::detail::verifyBranchSuccessorOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01170">mlir::impl::verifyCastInterfaceOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00418">verifyCastOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01610">verifyCollapsedShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00103">verifyCompatibleDims()</a>, <a class="el" href="Traits_8cpp_source.html#l00231">mlir::OpTrait::impl::verifyCompatibleOperandBroadcast()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00057">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00094">verifyCompatibleShapes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00676">verifyConvOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03767">verifyCoopMatrixMulAdd()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00311">mlir::detail::verifyDataLayoutOp()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00474">mlir::detail::verifyDataLayoutSpec()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00094">verifyDependencies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01057">mlir::OpTrait::impl::verifyElementwise()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00330">mlir::LLVM::LLVMPointerType::verifyEntries()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00562">mlir::LLVM::LLVMStructType::verifyEntries()</a>, <a class="el" href="DataLayoutInterfaces_8h_source.html#l00103">mlir::DataLayoutDialectInterface::verifyEntry()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00805">verifyExtOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02758">verifyFuncOpInterfaceStructAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00898">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00049">verifyHasBindingUse()</a>, <a class="el" href="DLTI_2Traits_8cpp_source.html#l00015">mlir::impl::verifyHasDefaultDLTIDataLayoutTrait()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00391">verifyImageOperands()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00206">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01116">mlir::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01218">mlir::AffineDmaWaitOp::verifyInvariantsImpl()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00734">mlir::OpTrait::impl::verifyIsIdempotent()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00742">mlir::OpTrait::impl::verifyIsInvolution()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01100">mlir::OpTrait::impl::verifyIsIsolatedFromAbove()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00920">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">verifyListOfOperandsOrIntegers()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00573">verifyLoadStorePtrAndValTypes()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01771">verifyLoopNesting()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00465">verifyMemoryAccessAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00667">verifyMemoryOpMetadata()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00549">verifyMemorySemantics()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00704">mlir::OpTrait::impl::verifyNOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01042">mlir::OpTrait::impl::verifyNoRegionArguments()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00794">mlir::OpTrait::impl::verifyNRegions()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00820">mlir::OpTrait::impl::verifyNResults()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00341">verifyNumBlockArgs()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">mlir::detail::verifyOffsetSizeAndStrideOp()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00698">mlir::OpTrait::impl::verifyOneOperand()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00788">mlir::OpTrait::impl::verifyOneRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00814">mlir::OpTrait::impl::verifyOneResult()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01310">verifyOpAndAdjustFlags()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00251">verifyOpaquePtr()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00760">mlir::OpTrait::impl::verifyOperandsAreFloatLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00751">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00150">mlir::Dialect::verifyOperationAttribute()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00653">verifyOpMetadata()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02710">verifyPermutationMap()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03698">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00217">mlir::transform::detail::verifyPossibleTopLevelTransformOpTrait()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00332">verifyReductionVarList()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00042">mlir::Dialect::verifyRegionArgAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01238">verifyRegionAttribute()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00051">mlir::Dialect::verifyRegionResultAttribute()</a>, <a class="el" href="OpDefinition_8h_source.html#l00189">mlir::OpState::verifyRegions()</a>, <a class="el" href="OpDefinition_8h_source.html#l00902">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::verifyRegionTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01593">mlir::op_definition_impl::verifyRegionTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01600">mlir::op_definition_impl::verifyRegionTraits()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">verifyReshapeLikeTypes()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00972">mlir::OpTrait::impl::verifyResultsAreBoolLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00983">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00992">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00180">verifyResultTypesAreInferrable()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00874">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00845">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00860">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00835">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00769">mlir::OpTrait::impl::verifySameTypeOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00179">verifyScheduleModifiers()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00083">verifyShapeOrExtentTensorOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00936">verifyShiftOp()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00071">verifySizeOrIndexOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00509">verifySourceMemoryAccessAttribute()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00595">mlir::linalg::detail::verifyStructuredOpInterface()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00032">verifySwitchOp()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00439">mlir::detail::verifySymbol()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00617">verifySymbolAttribute()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00076">verifySymbolAttrUse()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00398">mlir::detail::verifySymbolTable()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00440">verifySynchronizationHint()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00928">verifyTerminatorSuccessors()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00031">verifyTileSize()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00266">mlir::OpTrait::ReturnLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00806">mlir::OpTrait::SingleBlock&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01181">mlir::OpTrait::ConstantLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01213">mlir::OpTrait::AffineScope&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01229">mlir::OpTrait::AutomaticAllocationScope&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01243">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;::Impl&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01374">mlir::OpTrait::Scalarizable&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01394">mlir::OpTrait::Vectorizable&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01435">mlir::OpTrait::Tensorizable&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01571">mlir::op_definition_impl::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01577">mlir::op_definition_impl::verifyTraits()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02739">verifyTransferOp()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00818">verifyTruncateOp()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00094">verifyTypesAlongAllEdges()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00999">mlir::OpTrait::impl::verifyValueSizeAttr()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00599">verifyVectorConstructionInvariants()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03714">verifyVectorMemoryOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01386">verifyYield()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00692">mlir::OpTrait::impl::verifyZeroOperands()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00782">mlir::OpTrait::impl::verifyZeroRegion()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00808">mlir::OpTrait::impl::verifyZeroResult()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00938">mlir::OpTrait::impl::verifyZeroSuccessor()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00062">visit()</a>, <a class="el" href="SerializeOps_8cpp_source.html#l00042">visitInPrettyBlockOrder()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00538">HasAffineDimExprVisitor::visitSymbolExpr()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00054">walkReferenceCountedValues()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00067">walkReturnOperations()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="ab15bd4c107bb9ea52b7fcc11c283c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bd4c107bb9ea52b7fcc11c283c129">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00845">845</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a623f987acfe618f9aa4823d6c7aec9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623f987acfe618f9aa4823d6c7aec9d6">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01697">1697</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00885">extractFixedOuterLoops()</a>, <a class="el" href="CodegenStrategy_8h_source.html#l00216">mlir::linalg::CodegenStrategy::tileIf()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00868">tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="adb3ac25a4d763e0e5234f6b347c7f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ac25a4d763e0e5234f6b347c7f17a">&#9670;&nbsp;</a></span>tile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00858">858</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a8605009295454f6ebebbbaed546f7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8605009295454f6ebebbbaed546f7963">&#9670;&nbsp;</a></span>tile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01709">1709</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="affb0191e64550dc17ce5ec5e35b74882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb0191e64550dc17ce5ec5e35b74882">&#9670;&nbsp;</a></span>tilePerfectlyNested() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00860">860</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00774">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00509">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01959">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a76588ffa46e04caaa584360fa5cdde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76588ffa46e04caaa584360fa5cdde4c">&#9670;&nbsp;</a></span>tilePerfectlyNested() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00868">868</a> of file <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00780">getPerfectlyNestedLoopsImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01697">tile()</a>.</p>

</div>
</div>
<a id="a7722fac9c5c7f3625d6a6fe1e2fbd52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7722fac9c5c7f3625d6a6fe1e2fbd52d">&#9670;&nbsp;</a></span>tilePerfectlyNestedParametric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tilePerfectlyNestedParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00904">904</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00746">constructParametricallyTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00509">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01959">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

</div>
</div>
<a id="a206ff895887c175c8c4408399856d3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206ff895887c175c8c4408399856d3e5">&#9670;&nbsp;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a637916a3aeba97d795fa40975fbd7bd6">SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>toSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-root DAG topological sort. </p>
<p>Performs a topological sort of the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> in the <code>toSort</code> SetVector. Returns a topologically sorted SetVector. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00195">195</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00172">dfsPostorder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00206">getOpToConvert()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00133">getSlice()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00369">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="ae1515f52892c837f5105efe3f5c5c060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1515f52892c837f5105efe3f5c5c060">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00128">128</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00080">getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">getReductionIteratorTypeName()</a>, <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131">Parallel</a>, and <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a">Reduction</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transport_8cpp_source.html#l00137">encodeError()</a>, <a class="el" href="MLIRServer_8cpp_source.html#l00021">getLocationFromLoc()</a>, <a class="el" href="PDLLServer_8cpp_source.html#l00035">getURIFromLoc()</a>, and <a class="el" href="Transport_8cpp_source.html#l00196">mlir::lsp::JSONTransport::run()</a>.</p>

</div>
</div>
<a id="a2f93379e5dbb5551bbe57170230a1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f93379e5dbb5551bbe57170230a1d92">&#9670;&nbsp;</a></span>translateDataLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutSpecInterface mlir::translateDataLayout </td>
          <td>(</td>
          <td class="paramtype">const llvm::DataLayout &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout into an MLIR equivalent using the DLTI dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00094">94</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l01093">prepareLLVMModule()</a>, and <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01127">translateLLVMIRToModule()</a>.</p>

</div>
</div>
<a id="afc1f3b8cc0f16fa8f9165cce0e5a875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1f3b8cc0f16fa8f9165cce0e5a875b">&#9670;&nbsp;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>llvmModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>The <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context is extracted from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>{}</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01127">1127</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="MLIRContext_8h_source.html#l00102">mlir::MLIRContext::loadDialect()</a>, and <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00094">translateDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l01158">translateLLVMIRToModule()</a>.</p>

</div>
</div>
<a id="adc149979459c3123124db882fb765dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc149979459c3123124db882fb765dba">&#9670;&nbsp;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate operation that satisfies <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect module requirements into an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR module living in the given context. </p>
<p>This translates operations from any dilalect that has a registered implementation of <a class="el" href="classmlir_1_1LLVMTranslationDialectInterface.html" title="Base class for dialect interfaces providing translation to LLVM IR. ">LLVMTranslationDialectInterface</a>. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00235">mlir::ExecutionEngine::create()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l01093">prepareLLVMModule()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00025">registerToLLVMIRTranslation()</a>, and <a class="el" href="SerializeToBlob_8cpp_source.html#l00135">mlir::gpu::SerializeToBlobPass::translateToLLVMIR()</a>.</p>

</div>
</div>
<a id="ae4d7280c80aed8b236533289e9d327be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d7280c80aed8b236533289e9d327be">&#9670;&nbsp;</a></span>vectorizeAffineLoopNest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vectorizeAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest. ">VectorizationStrategy</a> definition). </p>
<p>Loops are provided in a 2D vector container. The first dimension represents the nesting level relative to the loops to be vectorized. The second dimension contains the loops. This means that: a) every loop in 'loops[i]' must have a parent loop in 'loops[i-1]', b) a loop in 'loops[i]' may or may not have a child loop in 'loops[i+1]'.</p>
<p>For example, for the following loop nest:</p>
<p>func (in0: memref&lt;64x128x512xf32&gt;, in1: memref&lt;64x128x128xf32&gt;, out0: memref&lt;64x128x512xf32&gt;, out1: memref&lt;64x128x128xf32&gt;) { affine.for i0 = 0 to 64 { affine.for i1 = 0 to 128 { affine.for i2 = 0 to 512 { ld = affine.load in0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; affine.store ld, out0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; } affine.for i3 = 0 to 128 { ld = affine.load in1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; affine.store ld, out1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; } } } return }</p>
<p>loops = {{i0}, {i2, i3}}, to vectorize the outermost and the two innermost loops; loops = {{i1}, {i2, i3}}, to vectorize the middle and the two innermost loops; loops = {{i2}}, to vectorize only the first innermost loop; loops = {{i3}}, to vectorize only the second innermost loop; loops = {{i1}}, to vectorize only the middle loop. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01858">1858</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01530">vectorizeLoopNest()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01771">verifyLoopNesting()</a>.</p>

</div>
</div>
<a id="a010e3124b85c19918a82d5d6ae922f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010e3124b85c19918a82d5d6ae922f48">&#9670;&nbsp;</a></span>vectorizeAffineLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vectorizeAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="namespacemlir.html#a8c18458e843e6fbd7837dec1b0be4cd5">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fastestVaryingPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a> &amp;&#160;</td>
          <td class="paramname"><em>reductionLoops</em> = <code><a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. If <code>reductionLoops</code> is not empty, the given reduction loops may be vectorized along the reduction dimension. TODO: Vectorizing reductions is supported only for 1-D vectorization. </p>

</div>
</div>
<a id="a0d12621b13993f83de878d26d2d7ef8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d12621b13993f83de878d26d2d7ef8b">&#9670;&nbsp;</a></span>vectorizeAffineLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vectorizeAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fastestVaryingPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a49c23a0a994193842991e0c87709e067">ReductionLoopMap</a> &amp;&#160;</td>
          <td class="paramname"><em>reductionLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External utility to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. If <code>reductionLoops</code> is not empty, the given reduction loops may be vectorized along the reduction dimension. TODO: Vectorizing reductions is supported only for 1-D vectorization. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01812">1812</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01656">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="ae4b1ba650fd43b50351e92bbb75bd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1ba650fd43b50351e92bbb75bd4c0">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyRecursively</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> and returns failure. If <code>verifyRecursively</code> is false, this assumes that nested operations have already been properly verified, and does not recursively invoke the verifier on nested operations. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00372">372</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorDialect_8cpp_source.html#l00027">acceptBitWidth()</a>, <a class="el" href="OpDefinition_8h_source.html#l01685">mlir::Op&lt; AffineDmaWaitOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResult, OpTrait::OpInvariants, AffineMapAccessInterface::Trait &gt;::attachInterface()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l02107">buildLLVMFunctionType()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00184">checkDoubleConsume()</a>, <a class="el" href="PDLTypes_8cpp_source.html#l00060">mlir::pdl::PDLType::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00384">mlir::BoolAttr::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01238">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="MLIRGen_8cpp_source.html#l00599">mlir::pdll::codegenPDLLToMLIR()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01895">computeCollapsedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01743">computeExpandedType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l04365">concatElemAndIndices()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00116">findDuplicateElement()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01217">foldMemRefCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00157">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00908">getF64Values()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00140">mlir::FloatType::getFPMantissaWidth()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00234">getGetValueTypeOpValueType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01360">getInsertExtractValueElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00716">getLoadStoreElementType()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00333">mlir::OpPassManager::getNesting()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00704">getNumElements()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00984">hasAtMostSingleNonScalar()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">hasOneBranchOpTo()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02356">inferStridedSliceOpResultType()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l00070">invertPredicate()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="Tester_8cpp_source.html#l00027">mlir::Tester::isInteresting()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01125">isLastMemrefDimUnitStride()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00204">isMatchingWidth()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00307">mlir::TensorType::isValidElementType()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00047">isValidQuantizationSpec()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01872">isZeroAttribute()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01632">lookupSymbolInModule()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02141">makeI64ArrayAttr()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00651">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00918">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="IR_8cpp_source.html#l00485">mlirOperationVerify()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00167">mlir::LLVM::LLVMFunctionType::params()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01543">poolingInferReturnTypes()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01598">populateFromInt64AttrArray()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00645">printAtomicReductionRegion()</a>, <a class="el" href="Dialect_2Async_2IR_2Async_8cpp_source.html#l00301">printAwaitResultType()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00122">printCreateOperationOpResults()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00563">printGEPIndices()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00043">printNVVMIntrinsicOp()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00423">printResultsValueType()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00532">printSwitchOpCases()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02825">printTransferAttrs()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00554">printWsLoopControl()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01035">produceSliceErrorMsg()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02340">produceSubViewErrorMsg()</a>, <a class="el" href="Translation_8cpp_source.html#l00057">registerTranslateToMLIRFunction()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">replaceForOpWithNewYields()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="SPIRV_2TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00373">mlir::DynamicOpDefinition::setVerifyFn()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00380">mlir::DynamicOpDefinition::setVerifyRegionFn()</a>, <a class="el" href="Translation_8cpp_source.html#l00091">mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration()</a>, <a class="el" href="RunnerUtils_8h_source.html#l00280">impl::MemRefDataVerifier&lt; T &gt;::verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01087">verifyAccessChain()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01174">verifyAtomicCompareExchangeImpl()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00676">verifyConvOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03767">verifyCoopMatrixMulAdd()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00470">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01442">verifyInsertSliceOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00667">verifyMemoryOpMetadata()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l00341">verifyNumBlockArgs()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01310">verifyOpAndAdjustFlags()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00251">verifyOpaquePtr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03698">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00180">verifyResultTypesAreInferrable()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00032">verifySwitchOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00440">verifySynchronizationHint()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03714">verifyVectorMemoryOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01386">verifyYield()</a>, and <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00062">visit()</a>.</p>

</div>
</div>
<a id="a961cf9926486f7d6e7160efa8f846d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961cf9926486f7d6e7160efa8f846d64">&#9670;&nbsp;</a></span>verifyCompatibleDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensions are compatible if all non-dynamic dims are equal. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00103">103</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeUtilities_8cpp_source.html#l00119">verifyCompatibleShapes()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00057">57</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00132">mlir::tensor::foldTensorCast()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00076">verifyCompatibleShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00094">verifyCompatibleShapes()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00898">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00076">76</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00057">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a2801a1733326688cf0c9bee8d633f234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801a1733326688cf0c9bee8d633f234">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two arrays have the same number of elements and each pair wise entries have compatible shape. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00094">94</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00057">verifyCompatibleShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticOps_8cpp_source.html#l00794">areValidCastInputsAndOutputs()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01057">mlir::OpTrait::impl::verifyElementwise()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00845">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00835">mlir::OpTrait::impl::verifySameOperandsShape()</a>.</p>

</div>
</div>
<a id="a132fff065736d8e977fe8179f2e7086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132fff065736d8e977fe8179f2e7086c">&#9670;&nbsp;</a></span>verifyCompatibleShapes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if all given types have compatible shapes. </p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. The element type does not matter.</p>
<p>That is, they are all scalars (not shaped), or they are all shaped types and any ranked shapes have compatible dimensions. Dimensions are compatible if all non-dynamic dims are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00119">119</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00103">verifyCompatibleDims()</a>.</p>

</div>
</div>
<a id="a42b025daa91f0ef533bd16102dabbe10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b025daa91f0ef533bd16102dabbe10">&#9670;&nbsp;</a></span>verifyListOfOperandsOrIntegers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyListOfOperandsOrIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>expectedNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(int64_t)&gt;&#160;</td>
          <td class="paramname"><em>isDynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a the <code>values</code> has as many elements as the number of entries in <code>attr</code> for which <code>isDynamic</code> evaluates to true. </p>
<p>Include the definitions of the loop-like interfaces.</p>
<p>Check static and dynamic offsets/sizes/strides does not overflow type. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">20</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">mlir::detail::verifyOffsetSizeAndStrideOp()</a>.</p>

</div>
</div>
<a id="ad29ab36fc05840316f3a7e56271818a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29ab36fc05840316f3a7e56271818a6">&#9670;&nbsp;</a></span>verifyReshapeLikeShapes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyReshapeLikeShapes </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>collapsedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpandingReshape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00156">156</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00268">hasNonIdentityLayout()</a>, and <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">reshapeLikeShapesAreCompatible()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">verifyReshapeLikeTypes()</a>.</p>

</div>
</div>
<a id="a59e37ef38e035b072204c4cc6f2bc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e37ef38e035b072204c4cc6f2bc6a5">&#9670;&nbsp;</a></span>verifyReshapeLikeTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyReshapeLikeTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html">Op</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>expandedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>collapsedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExpansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common verifier for reshape-like types. </p>
<p>Fills <code>expandedType</code> and <code>collapsedType</code> with the proper <code>src</code> or <code>result</code> type. </p>

<p class="definition">Definition at line <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">103</a> of file <a class="el" href="ReshapeOpsUtils_8h_source.html">ReshapeOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00648">mlir::OpState::emitOpError()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00196">isReassociationValid()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">reshapeLikeShapesAreCompatible()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">success()</a>, and <a class="el" href="ReshapeOpsUtils_8h_source.html#l00156">verifyReshapeLikeShapes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00306">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00279">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00024">areValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00059">getUsedValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00053">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00053">53</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00032">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a655db45ed8c23d04d5ed5ee0abe041ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655db45ed8c23d04d5ed5ee0abe041ad">&#9670;&nbsp;</a></span>wouldOpBeTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::wouldOpBeTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing. </p>
<p>This is equivalent to checking <code>isOpTriviallyDead</code> if <code>op</code> was unused. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00093">93</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00531">mlir::Operation::mightHaveTrait()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00040">wouldOpBeTriviallyDeadImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">isOpTriviallyDead()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00237">propagateLiveness()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2887883f00b094c5ca61c631d7b093a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887883f00b094c5ca61c631d7b093a0">&#9670;&nbsp;</a></span>kDeriveIndexBitwidthFromDataLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::kDeriveIndexBitwidthFromDataLayout = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout. </p>

<p class="definition">Definition at line <a class="el" href="LoweringOptions_8h_source.html#l00026">26</a> of file <a class="el" href="LoweringOptions_8h_source.html">LoweringOptions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00159">convertCmpPredicate()</a>, <a class="el" href="ControlFlowToLLVM_8cpp_source.html#l00106">mlir::cf::populateControlFlowToLLVMConversionPatterns()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00660">populateFuncToLLVMConversionPatterns()</a>, and <a class="el" href="MemRefToLLVM_8cpp_source.html#l01923">populateMemRefToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a89827c63faec642164c91b4f8eb0bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89827c63faec642164c91b4f8eb0bbbb">&#9670;&nbsp;</a></span>kPtrBasePosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::kPtrBasePosInDataDescriptor = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00021">21</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00040">mlir::DataDescriptor::isValid()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00126">processOperands()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00056">mlir::DataDescriptor::setBasePointer()</a>.</p>

</div>
</div>
<a id="a5b10e5f178951c728a16e10de4d038c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b10e5f178951c728a16e10de4d038c0">&#9670;&nbsp;</a></span>kPtrPosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::kPtrPosInDataDescriptor = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00022">22</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00040">mlir::DataDescriptor::isValid()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00126">processOperands()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00062">mlir::DataDescriptor::setPointer()</a>.</p>

</div>
</div>
<a id="a17d7fcc466ac5f8bdada62aa526a821e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d7fcc466ac5f8bdada62aa526a821e">&#9670;&nbsp;</a></span>kSizePosInDataDescriptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::kSizePosInDataDescriptor = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertOpenACCToLLVM_8h_source.html#l00023">23</a> of file <a class="el" href="ConvertOpenACCToLLVM_8h_source.html">ConvertOpenACCToLLVM.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00040">mlir::DataDescriptor::isValid()</a>, <a class="el" href="OpenACCToLLVMIRTranslation_8cpp_source.html#l00126">processOperands()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00067">mlir::DataDescriptor::setSize()</a>.</p>

</div>
</div>
<a id="aafef60380fb7774fcdb69f86f7b0bbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafef60380fb7774fcdb69f86f7b0bbb2">&#9670;&nbsp;</a></span>makeOptimizingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; Error(Module *)&gt; mlir::makeOptimizingTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8h_source.html#l00034">34</a> of file <a class="el" href="OptUtils_8h_source.html">OptUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00314">JitRunnerMain()</a>, <a class="el" href="OptUtils_8cpp_source.html#l00026">mapToLevel()</a>, and <a class="el" href="CAPI_2ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00021">mlirExecutionEngineCreate()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:03 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
