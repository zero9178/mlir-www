<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::TypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1TypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::TypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  
 <a href="classmlir_1_1TypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::TypeConverter:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1TypeConverter__inherit__graph.png" border="0" usemap="#mlir_1_1TypeConverter_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1TypeConverter_inherit__map" id="mlir_1_1TypeConverter_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con..." alt="" coords="206,5,389,47"/>
<area shape="rect" id="node3" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect. " alt="" coords="206,71,389,98"/>
<area shape="rect" id="node4" href="classmlir_1_1SPIRVTypeConverter.html" title="Type conversion from builtin types to SPIR&#45;V types for shader interface. " alt="" coords="204,122,391,149"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides all of the information necessary to convert a type signature.  <a href="classmlir_1_1TypeConverter_1_1SignatureConversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3db00a47b187ad5846fea3362969a913">addArgumentMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3db00a47b187ad5846fea3362969a913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a materialization function, which must be convertible to the following form: <code>Optional&lt;<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> &amp;, T, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values. ">ValueRange</a>, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a>)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="#a3db00a47b187ad5846fea3362969a913">More...</a><br /></td></tr>
<tr class="separator:a3db00a47b187ad5846fea3362969a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">addSourceMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting a legal type to an illegal source type.  <a href="#aaf35c0b4faa6fa6d8eda987ad71393e9">More...</a><br /></td></tr>
<tr class="separator:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">addTargetMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting type from an illegal, or source, type to a legal type.  <a href="#acfe54f9a4348e1d8aa30535f53ddaf37">More...</a><br /></td></tr>
<tr class="separator:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c3e12662d60542476df0feddcd9fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a98c3e12662d60542476df0feddcd9fff">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a98c3e12662d60542476df0feddcd9fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="#a98c3e12662d60542476df0feddcd9fff">More...</a><br /></td></tr>
<tr class="separator:a98c3e12662d60542476df0feddcd9fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b17254bd638b2e408c7d5f972ced99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a82b17254bd638b2e408c7d5f972ced99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="#a82b17254bd638b2e408c7d5f972ced99">More...</a><br /></td></tr>
<tr class="separator:a82b17254bd638b2e408c7d5f972ced99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4e8bb70bde7031736a7092c001c4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a5c4e8bb70bde7031736a7092c001c4ba">convertTypes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a5c4e8bb70bde7031736a7092c001c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="#a5c4e8bb70bde7031736a7092c001c4ba">More...</a><br /></td></tr>
<tr class="separator:a5c4e8bb70bde7031736a7092c001c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851e966212a7ca7d0f6ba4217cc94555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a851e966212a7ca7d0f6ba4217cc94555">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a851e966212a7ca7d0f6ba4217cc94555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="#a851e966212a7ca7d0f6ba4217cc94555">More...</a><br /></td></tr>
<tr class="separator:a851e966212a7ca7d0f6ba4217cc94555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0564be6da3bb990712f30fee9a71dedf"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a0564be6da3bb990712f30fee9a71dedf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a0564be6da3bb990712f30fee9a71dedf">isLegal</a> (RangeT &amp;&amp;range)</td></tr>
<tr class="memdesc:a0564be6da3bb990712f30fee9a71dedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the given types are legal for this type converter.  <a href="#a0564be6da3bb990712f30fee9a71dedf">More...</a><br /></td></tr>
<tr class="separator:a0564be6da3bb990712f30fee9a71dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad883e7fdaecf9928ec69b04af4f95c37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad883e7fdaecf9928ec69b04af4f95c37">isLegal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad883e7fdaecf9928ec69b04af4f95c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation has legal operand and result types.  <a href="#ad883e7fdaecf9928ec69b04af4f95c37">More...</a><br /></td></tr>
<tr class="separator:ad883e7fdaecf9928ec69b04af4f95c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a4f962742b7455a70218227b7201d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a4c4a4f962742b7455a70218227b7201d">isLegal</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a4c4a4f962742b7455a70218227b7201d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the types of block arguments within the region are legal.  <a href="#a4c4a4f962742b7455a70218227b7201d">More...</a><br /></td></tr>
<tr class="separator:a4c4a4f962742b7455a70218227b7201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e6b3ab7ac3d67208f429fbf15fade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a2c3e6b3ab7ac3d67208f429fbf15fade">isSignatureLegal</a> (FunctionType ty)</td></tr>
<tr class="memdesc:a2c3e6b3ab7ac3d67208f429fbf15fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="#a2c3e6b3ab7ac3d67208f429fbf15fade">More...</a><br /></td></tr>
<tr class="separator:a2c3e6b3ab7ac3d67208f429fbf15fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d8fb83971ae60f79e79bca268547a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3a8d8fb83971ae60f79e79bca268547a">convertSignatureArg</a> (<a class="el" href="classunsigned.html">unsigned</a> inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result)</td></tr>
<tr class="memdesc:a3a8d8fb83971ae60f79e79bca268547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows for converting a specific argument of a signature.  <a href="#a3a8d8fb83971ae60f79e79bca268547a">More...</a><br /></td></tr>
<tr class="separator:a3a8d8fb83971ae60f79e79bca268547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642cd6e09a55f7d5ca4d99bb31d643cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a642cd6e09a55f7d5ca4d99bb31d643cf">convertSignatureArgs</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result, <a class="el" href="classunsigned.html">unsigned</a> origInputOffset=0)</td></tr>
<tr class="separator:a642cd6e09a55f7d5ca4d99bb31d643cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a9a0d70ed6d97cbb8da4ba4a6e46a475e">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="#a9a0d70ed6d97cbb8da4ba4a6e46a475e">More...</a><br /></td></tr>
<tr class="separator:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf86f32f772b0c88c285052599b1b5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf86f32f772b0c88c285052599b1b5e6">materializeArgumentConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="memdesc:aaf86f32f772b0c88c285052599b1b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind.  <a href="#aaf86f32f772b0c88c285052599b1b5e6">More...</a><br /></td></tr>
<tr class="separator:aaf86f32f772b0c88c285052599b1b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09f0ebddc61145342e5f9f8b19a12a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad09f0ebddc61145342e5f9f8b19a12a1">materializeSourceConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="separator:ad09f0ebddc61145342e5f9f8b19a12a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e4c78aeadbd4d8e6bc2eb0548fad68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae9e4c78aeadbd4d8e6bc2eb0548fad68">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs)</td></tr>
<tr class="separator:ae9e4c78aeadbd4d8e6bc2eb0548fad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class. </p>
<p>Specific conversions and materializations can be registered using addConversion and addMaterialization, respectively. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00036">36</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3db00a47b187ad5846fea3362969a913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db00a47b187ad5846fea3362969a913">&#9670;&nbsp;</a></span>addArgumentMaterialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::TypeConverter::addArgumentMaterialization </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a materialization function, which must be convertible to the following form: <code>Optional&lt;<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> &amp;, T, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values. ">ValueRange</a>, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a>)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>. </p>
<p>This function is responsible for creating an operation, using the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> and <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> provided, that "casts" a range of values into a single value of the given type <code>T</code>. It must return a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> of the converted type on success, an <code>llvm::None</code> if it failed but other materialization can be attempted, and <code>nullptr</code> on unrecoverable failure. It will only be called for (sub)types of <code>T</code>. Materialization functions must be provided when a type conversion may persist after the conversion has finished.</p>
<p>This method registers a materialization that will be called when converting an illegal block argument type, to a legal type. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00135">135</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a272bc4144b1ac5a3f7f1ad25c0e39e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bc4144b1ac5a3f7f1ad25c0e39e03">&#9670;&nbsp;</a></span>addConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::TypeConverter::addConversion </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a conversion function. </p>
<p>A conversion function must be convertible to any of the following forms(where <code>T</code> is a class derived from <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>:</p><ul>
<li>Optional&lt;Type&gt;(T)<ul>
<li>This form represents a 1-1 type conversion. It should return nullptr or <code>llvm::None</code> to signify failure. If <code>llvm::None</code> is returned, the converter is allowed to try another conversion function to perform the conversion.</li>
</ul>
</li>
<li>Optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;)<ul>
<li>This form represents a 1-N type conversion. It should return <code>failure</code> or <code>llvm::None</code> to signify a failed conversion. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. If <code>llvm::None</code> is returned, the converter is allowed to try another conversion function to perform the conversion.</li>
</ul>
</li>
<li>Optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;, ArrayRef&lt;Type&gt;)<ul>
<li>This form represents a 1-N type conversion supporting recursive types. The first two arguments and the return value are the same as for the regular 1-N form. The third argument is contains is the "call stack" of the recursive conversion: it contains the list of types currently being converted, with the current type being the last one. If it is present more than once in the list, the conversion concerns a recursive type. Note: When attempting to convert a type, e.g. via 'convertType', the mostly recently added conversions will be invoked first. </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00115">115</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01117">mlir::populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00880">mlir::populateGpuToLLVMConversionPatterns()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01431">mlir::populateSPIRVToLLVMTypeConversion()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l00492">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>.</p>

</div>
</div>
<a id="aaf35c0b4faa6fa6d8eda987ad71393e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf35c0b4faa6fa6d8eda987ad71393e9">&#9670;&nbsp;</a></span>addSourceMaterialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::TypeConverter::addSourceMaterialization </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method registers a materialization that will be called when converting a legal type to an illegal source type. </p>
<p>This is used when conversions to an illegal type must persist beyond the main conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00144">144</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, and <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>.</p>

</div>
</div>
<a id="acfe54f9a4348e1d8aa30535f53ddaf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe54f9a4348e1d8aa30535f53ddaf37">&#9670;&nbsp;</a></span>addTargetMaterialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::TypeConverter::addTargetMaterialization </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method registers a materialization that will be called when converting type from an illegal, or source, type to a legal type. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00152">152</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02947">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02995">convertTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03003">isLegal()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a9a0d70ed6d97cbb8da4ba4a6e46a475e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0d70ed6d97cbb8da4ba4a6e46a475e">&#9670;&nbsp;</a></span>convertBlockSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto TypeConverter::convertBlockSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument. </p>
<p>This function should return a valid conversion for the signature on success, None otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03051">3051</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01550">mlir::ConversionPatternRewriter::convertRegionTypes()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Block_8cpp_source.html#l00137">mlir::Block::getArgumentTypes()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00499">mlir::RewriterBase::updateRootInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l00441">buildUnresolvedTargetMaterialization()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00180">isLegal()</a>.</p>

</div>
</div>
<a id="a3a8d8fb83971ae60f79e79bca268547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8d8fb83971ae60f79e79bca268547a">&#9670;&nbsp;</a></span>convertSignatureArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertSignatureArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>inputNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows for converting a specific argument of a signature. </p>
<p>It takes as inputs the original argument input number, type. On success, it populates 'result' with any new mappings. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03018">3018</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02918">mlir::TypeConverter::SignatureConversion::addInputs()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00180">isLegal()</a>.</p>

</div>
</div>
<a id="a642cd6e09a55f7d5ca4d99bb31d643cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642cd6e09a55f7d5ca4d99bb31d643cf">&#9670;&nbsp;</a></span>convertSignatureArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertSignatureArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>origInputOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03033">3033</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00180">isLegal()</a>.</p>

</div>
</div>
<a id="a98c3e12662d60542476df0feddcd9fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c3e12662d60542476df0feddcd9fff">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02947">2947</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="DialectConversion_8h_source.html#l00152">addTargetMaterialization()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00061">adjustAccessChainForBitwidth()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00139">broadcast()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00441">buildUnresolvedTargetMaterialization()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00372">mlir::LLVMTypeConverter::canConvertToBarePtr()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00249">convertArrayType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00431">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00240">mlir::LLVMTypeConverter::convertFunctionTypeCWrapper()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00265">convertPointerType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00274">convertRuntimeArrayType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00201">convertStructTypePacked()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00187">convertStructTypeWithOffset()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00227">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00199">mlir::ConvertToLLVMPattern::createMemRefDescriptor()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00019">mlir::LLVM::detail::extractNDVectorTypeInfo()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00065">extractOne()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00043">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00113">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="BufferUtils_8cpp_source.html#l00149">mlir::bufferization::getGlobalFor()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00081">getMemRefAlignment()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00172">mlir::LLVMTypeConverter::getPointerBitwidth()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00049">getPtrToElementType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00171">mlir::ConvertToLLVMPattern::getSizeInBytes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00356">mlir::LLVMTypeConverter::getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00047">insertOne()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00106">mlir::ConvertToLLVMPattern::isConvertibleAndHasIdentityMaps()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00183">lowerAsEntryFunction()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00017">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00026">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00165">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00284">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00310">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00207">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00313">mlir::UnrankedMemRefDescriptor::pack()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01117">mlir::populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00067">mlir::DataDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00460">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00533">mlir::structFuncArgTypeConverter()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a82b17254bd638b2e408c7d5f972ced99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b17254bd638b2e408c7d5f972ced99">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02985">2985</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>.</p>

</div>
</div>
<a id="a5c4e8bb70bde7031736a7092c001c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4e8bb70bde7031736a7092c001c4ba">&#9670;&nbsp;</a></span>convertTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given set of types, filling 'results' as necessary. </p>
<p>This returns failure if the conversion of any of the types fails, success otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02995">2995</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00152">addTargetMaterialization()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a851e966212a7ca7d0f6ba4217cc94555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851e966212a7ca7d0f6ba4217cc94555">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given type is legal for this type converter, i.e. </p>
<p>the type converts to itself. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03003">3003</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00816">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00152">addTargetMaterialization()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00062">mlir::configureOpenMPToLLVMConversionLegality()</a>, <a class="el" href="DialectConversion_8h_source.html#l00180">isLegal()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00119">mlir::isLegalForBranchOpInterfaceTypeConversionPattern()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00140">mlir::isLegalForReturnOpTypeConversionPattern()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns()</a>, and <a class="el" href="Detensorize_8cpp_source.html#l00025">sourceMaterializationCallback()</a>.</p>

</div>
</div>
<a id="a0564be6da3bb990712f30fee9a71dedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0564be6da3bb990712f30fee9a71dedf">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp; !std::is_convertible&lt;RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool&gt; mlir::TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of the given types are legal for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00180">180</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03051">convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03018">convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03033">convertSignatureArgs()</a>, <a class="el" href="DialectConversion_8h_source.html#l00048">mlir::TypeConverter::SignatureConversion::InputMapping::inputNo</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03003">isLegal()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03014">isSignatureLegal()</a>.</p>

</div>
</div>
<a id="ad883e7fdaecf9928ec69b04af4f95c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad883e7fdaecf9928ec69b04af4f95c37">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation has legal operand and result types. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03004">3004</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00320">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::getResultTypes()</a>.</p>

</div>
</div>
<a id="a4c4a4f962742b7455a70218227b7201d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4a4f962742b7455a70218227b7201d">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the types of block arguments within the region are legal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03008">3008</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00137">mlir::Block::getArgumentTypes()</a>.</p>

</div>
</div>
<a id="a2c3e6b3ab7ac3d67208f429fbf15fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3e6b3ab7ac3d67208f429fbf15fade">&#9670;&nbsp;</a></span>isSignatureLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isSignatureLegal </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the inputs and outputs of the given function type are legal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03014">3014</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00180">isLegal()</a>.</p>

</div>
</div>
<a id="aaf86f32f772b0c88c285052599b1b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf86f32f772b0c88c285052599b1b5e6">&#9670;&nbsp;</a></span>materializeArgumentConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::TypeConverter::materializeArgumentConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind. </p>
<p>See the respective <code>add*Materialization</code> for more information on the context for these methods. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00211">211</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02696">legalizeUnresolvedMaterialization()</a>.</p>

</div>
</div>
<a id="ad09f0ebddc61145342e5f9f8b19a12a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09f0ebddc61145342e5f9f8b19a12a1">&#9670;&nbsp;</a></span>materializeSourceConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::TypeConverter::materializeSourceConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00216">216</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02855">findLiveUserOfReplaced()</a>.</p>

</div>
</div>
<a id="ae9e4c78aeadbd4d8e6bc2eb0548fad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e4c78aeadbd4d8e6bc2eb0548fad68">&#9670;&nbsp;</a></span>materializeTargetConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::TypeConverter::materializeTargetConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00221">221</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02696">legalizeUnresolvedMaterialization()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Transforms/<a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a></li>
<li>lib/Transforms/Utils/<a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:04 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
