<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1analysis__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1analysis__impl.html">analysis_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1pass__options"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pass__options.html">pass_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1pdl__function__builder"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pdl__function__builder.html">pdl_function_builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1storage__user__base__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1storage__user__base__impl.html">storage_user_base_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AbstractLatticeElement.html">AbstractLatticeElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an abstract lattice.  <a href="classmlir_1_1detail_1_1AbstractLatticeElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html">AffineBinaryOpExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary operation appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineConstantExprStorage.html">AffineConstantExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="structmlir_1_1detail_1_1AffineConstantExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineDimExprStorage.html">AffineDimExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional or symbolic identifier appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineDimExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineExprStorage.html">AffineExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapAccessInterfaceInterfaceTraits.html">AffineMapAccessInterfaceInterfaceTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapAccessInterfaceTrait.html">AffineMapAccessInterfaceTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">AffineMapStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineReadOpInterfaceInterfaceTraits.html">AffineReadOpInterfaceInterfaceTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineReadOpInterfaceTrait.html">AffineReadOpInterfaceTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineWriteOpInterfaceInterfaceTraits.html">AffineWriteOpInterfaceInterfaceTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineWriteOpInterfaceTrait.html">AffineWriteOpInterfaceTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AliasAnalysisTraits.html">AliasAnalysisTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains various internal trait classes used by the main <a class="el" href="classmlir_1_1AliasAnalysis.html" title="This class represents the main alias analysis interface in MLIR. ">AliasAnalysis</a> class below.  <a href="structmlir_1_1detail_1_1AliasAnalysisTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisConcept.html">AnalysisConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract polymorphic base class representing an analysis.  <a href="structmlir_1_1detail_1_1AnalysisConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AnalysisMap.html">AnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a cache of analyses for a single operation.  <a href="classmlir_1_1detail_1_1AnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisModel.html">AnalysisModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived analysis model used to hold a specific analysis object.  <a href="structmlir_1_1detail_1_1AnalysisModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html">AnyCapturedValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyValueMatcher.html">AnyValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmParserImpl.html">AsmParserImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation of the generic parser methods within <a class="el" href="classmlir_1_1AsmParser.html" title="This base class exposes generic asm parser hooks, usable across the various derived parsers...">AsmParser</a>.  <a href="classmlir_1_1detail_1_1AsmParserImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmStateImpl.html">AsmStateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1attr__value__binder.html">attr_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> and binds the value inside the <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="structmlir_1_1detail_1_1attr__value__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttributeUniquer.html">AttributeUniquer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1BlockArgumentImpl.html">BlockArgumentImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a>.  <a href="classmlir_1_1detail_1_1BlockArgumentImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1CallbackOstream.html">CallbackOstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple raw ostream subclass that forwards write_impl calls to the user-supplied callback together with opaque user-supplied data.  <a href="classmlir_1_1detail_1_1CallbackOstream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__op__binder.html">constant_float_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat float operation and binds the constant float value.  <a href="structmlir_1_1detail_1_1constant__float__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">constant_float_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat float value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">constant_int_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat integer operation and binds the constant integer value.  <a href="structmlir_1_1detail_1_1constant__int__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">constant_int_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat integer value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">constant_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait, and binds the folded attribute value.  <a href="structmlir_1_1detail_1_1constant__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">constant_op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait.  <a href="structmlir_1_1detail_1_1constant__op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl.html">ConversionPatternRewriterImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template utility that computes the number of elements within <code>T</code> that satisfy the given predicate.  <a href="structmlir_1_1detail_1_1count__if__t__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl_3_01Pred_00_01N_00_01T_00_01Us_8_8_8_01_4.html">count_if_t_impl&lt; Pred, N, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html">DefaultTimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream. ">DefaultTimingManager</a></code>.  <a href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html">DenseElementIndexedIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl iterator for indexed <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object. ">DenseElementsAttr</a> iterators that records a data pointer and data index that is adjusted for the case of a splat attribute.  <a href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html">DenseElementsAttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html">DenseIntOrFPElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html">DenseStringElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object containing strings.  <a href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DiagnosticEngineImpl.html">DiagnosticEngineImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html">DialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class used for all derived interface types.  <a href="classmlir_1_1detail_1_1DialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html">DialectInterfaceCollectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base class for a collection of instances for a specific interface kind.  <a href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DominanceInfoBase.html">DominanceInfoBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicAttrStorage.html">DynamicAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicAttr.html" title="A dynamic attribute instance. ">DynamicAttr</a>.  <a href="structmlir_1_1detail_1_1DynamicAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicTypeStorage.html">DynamicTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicType.html" title="A dynamic type instance. ">DynamicType</a>.  <a href="structmlir_1_1detail_1_1DynamicTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ElementsAttrIndexer.html">ElementsAttrIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for indexing into the element range of an ElementsAttr.  <a href="structmlir_1_1detail_1_1ElementsAttrIndexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrIterator.html">ElementsAttrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a generic iterator for ElementsAttr.  <a href="classmlir_1_1detail_1_1ElementsAttrIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">ElementsAttrRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iterator utilities for an ElementsAttr range.  <a href="classmlir_1_1detail_1_1ElementsAttrRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ExpectedDiag.html">ExpectedDiag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html">FallbackTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a fallback for resolving TypeIDs.  <a href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ForwardDataFlowAnalysisBase.html">ForwardDataFlowAnalysisBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the non-templated virtual base class for the <a class="el" href="classmlir_1_1ForwardDataFlowAnalysis.html" title="This class provides a general forward dataflow analysis driver utilizing the lattice classes defined ...">ForwardDataFlowAnalysis</a>.  <a href="classmlir_1_1detail_1_1ForwardDataFlowAnalysisBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FunctionTypeStorage.html">FunctionTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1FunctionTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineOpResult.html">InlineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index can be represented "inline" in the underlying <a class="el" href="classmlir_1_1detail_1_1ValueImpl.html" title="The base class for all derived Value classes. ">ValueImpl</a>.  <a href="structmlir_1_1detail_1_1InlineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html">InlineTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for resolving the <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a> of a class that provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a> <a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#a94343b857aec8e86b6000bbd453f786b">resolveTypeID()</a></code> method.  <a href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerSetStorage.html">IntegerSetStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerTypeStorage.html">IntegerTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1IntegerTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an abstract interface.  <a href="classmlir_1_1detail_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">InterfaceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient mapping between a given <code><a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface. ">Interface</a></code> type, and a particular implementation of its concept.  <a href="classmlir_1_1detail_1_1InterfaceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1IROperandBase.html">IROperandBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base for <a class="el" href="classmlir_1_1IROperand.html" title="A reference to a value, suitable for use as an operand of an operation. ">IROperand</a>, and provides all of the non-templated facilities for operand use management.  <a href="classmlir_1_1detail_1_1IROperandBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">is_complex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait detector that checks if a given type T is a complex type.  <a href="structmlir_1_1detail_1_1is__complex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t_3_01std_1_1complex_3_01T_01_4_01_4.html">is_complex_t&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NestedAnalysisMap.html">NestedAnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis map that contains a map for the current operation, and a set of maps for any child operations.  <a href="structmlir_1_1detail_1_1NestedAnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__filter__iterator.html">op_filter_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out operations that are not 'OpT'.  <a href="classmlir_1_1detail_1_1op__filter__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__iterator.html">op_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iteration over the held operations of a block for a specific operation type.  <a href="classmlir_1_1detail_1_1op__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of op.  <a href="structmlir_1_1detail_1_1op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OperandStorage.html">OperandStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles the management of operation operands.  <a href="classmlir_1_1detail_1_1OperandStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html">OpOrInterfaceRewritePatternBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html" title="OpOrInterfaceRewritePatternBase is a wrapper around RewritePattern that allows for matching and rewri...">OpOrInterfaceRewritePatternBase</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class or <a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface. ">Interface</a>.  <a href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpPassManagerImpl.html">OpPassManagerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpResultImpl.html">OpResultImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result.  <a href="classmlir_1_1detail_1_1OpResultImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html">OpToOpPassAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor pass used to run operation passes over nested operations.  <a href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OutOfLineOpResult.html">OutOfLineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index cannot be represented "inline", and thus requires an additional index field.  <a href="classmlir_1_1detail_1_1OutOfLineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParallelDiagnosticHandlerImpl.html">ParallelDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implement support for parsing global entities like attributes and types.  <a href="classmlir_1_1detail_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class refers to all of the state maintained globally by the parser, such as the current lexer position etc.  <a href="structmlir_1_1detail_1_1ParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassCrashReproducerGenerator.html">PassCrashReproducerGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassExecutionState.html">PassExecutionState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state for a single execution of a pass.  <a href="structmlir_1_1detail_1_1PassExecutionState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassInstrumentorImpl.html">PassInstrumentorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassOptions.html">PassOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container class and manager for all pass options.  <a href="classmlir_1_1detail_1_1PassOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassPipelineCLParserImpl.html">PassPipelineCLParserImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PatternMatcherValue.html">PatternMatcherValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds to a specific value and matches it.  <a href="structmlir_1_1detail_1_1PatternMatcherValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCode.html">PDLByteCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bytecode class is also the interpreter.  <a href="classmlir_1_1detail_1_1PDLByteCode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html">PDLByteCodeMutableState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the mutable state of a bytecode instance.  <a href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodePattern.html">PDLByteCodePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of the data pertaining to a specific pattern within the bytecode.  <a href="classmlir_1_1detail_1_1PDLByteCodePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PreservedAnalyses.html">PreservedAnalyses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to represent the analyses that are known to be preserved.  <a href="classmlir_1_1detail_1_1PreservedAnalyses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecoveryReproducerContext.html">RecoveryReproducerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the context for generating a recovery reproducer.  <a href="structmlir_1_1detail_1_1RecoveryReproducerContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html">RecursivePatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html" title="RecursivePatternMatcher that composes. ">RecursivePatternMatcher</a> that composes.  <a href="structmlir_1_1detail_1_1RecursivePatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticHandlerImpl.html">SourceMgrDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticVerifierHandlerImpl.html">SourceMgrDiagnosticVerifierHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StorageUniquerImpl.html">StorageUniquerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;. ">StorageUniquer</a> class.  <a href="structmlir_1_1detail_1_1StorageUniquerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing users of storage classes uniqued by a <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;. ">StorageUniquer</a>.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserTraitBase.html">StorageUserTraitBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits for storage classes.  <a href="classmlir_1_1detail_1_1StorageUserTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StringAttrStorage.html">StringAttrStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SymbolState.html">SymbolState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains record of any parsed top-level symbols.  <a href="structmlir_1_1detail_1_1SymbolState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TimingManagerImpl.html">TimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details of the <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time. ">TimingManager</a></code>.  <a href="classmlir_1_1detail_1_1TimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TupleTypeStorage.html">TupleTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a collection of other types.  <a href="structmlir_1_1detail_1_1TupleTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver.html">TypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T.  <a href="classmlir_1_1detail_1_1TypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html">TypeIDResolver&lt; T, std::enable_if_t&lt; InlineTypeIDResolver::has_resolve_typeid&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T, when the class provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a> <a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#a44f66ca9f3d85b18a223313feb90f7e7">resolveTypeID()</a></code> method.  <a href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">TypeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get, or create, unique instances of types within an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.  <a href="structmlir_1_1detail_1_1TypeUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ValueImpl.html">ValueImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all derived <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> classes.  <a href="classmlir_1_1detail_1_1ValueImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D.html">Vector1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01false_01_4.html">Vector1D&lt; T, Dim, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01true_01_4.html">Vector1D&lt; T, Dim, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">DenseIterPtrAndSplat</a> = std::pair&lt; const char *, bool &gt;</td></tr>
<tr class="memdesc:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of raw pointer and a boolean flag of whether the pointer holds a splat,.  <a href="#a912e3cd5feea0574a2f3fce7c34dcefd">More...</a><br /></td></tr>
<tr class="separator:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d607e4b534651dbd796b895db9e07b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OperationOrValue &gt; </td></tr>
<tr class="memitem:a0d607e4b534651dbd796b895db9e07b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">has_operation_or_value_matcher_t</a> = decltype(std::declval&lt; T &gt;().match(std::declval&lt; OperationOrValue &gt;()))</td></tr>
<tr class="memdesc:a0d607e4b534651dbd796b895db9e07b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check whether T provides a 'match' method with type <code>OperationOrValue</code>.  <a href="#a0d607e4b534651dbd796b895db9e07b3">More...</a><br /></td></tr>
<tr class="separator:a0d607e4b534651dbd796b895db9e07b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">first_argument</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'.  <a href="#ae2b75c9bae3caf1909b6d6277fb6ea61">More...</a><br /></td></tr>
<tr class="separator:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplParams" colspan="2">template&lt;typename FnT &gt; </td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">walkResultType</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a66816d8124426b5976554a8448b1fd08">walk</a>(nullptr, std::declval&lt; FnT &gt;()))</td></tr>
<tr class="memdesc:a5258e43cc82e8e9a4c2c605f10a16461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to provide the return type of a templated walk method.  <a href="#a5258e43cc82e8e9a4c2c605f10a16461">More...</a><br /></td></tr>
<tr class="separator:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">count_if_t</a> = <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt; Pred, 0, Ts... &gt;</td></tr>
<tr class="separator:aabbea31f5f9034714e29d3a49cae75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename... Args&gt; </td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">has_impltype_getkey_t</a> = decltype(ImplTy::getKey(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a1be2dcfec91412eb27290aab9294b4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'getKey' method with types 'Args'.  <a href="#a1be2dcfec91412eb27290aab9294b4cc">More...</a><br /></td></tr>
<tr class="separator:a1be2dcfec91412eb27290aab9294b4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename T &gt; </td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">has_impltype_hash_t</a> = decltype(ImplTy::hashKey(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:afb2713c77027515db7c2d5f698d0f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'hashKey' method for 'T'.  <a href="#afb2713c77027515db7c2d5f698d0f33c">More...</a><br /></td></tr>
<tr class="separator:afb2713c77027515db7c2d5f698d0f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab5ac2de9a9d0eebfe67eb5e4db2084f1">ByteCodeField</a> = uint16_t</td></tr>
<tr class="memdesc:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use generic bytecode types.  <a href="#ab5ac2de9a9d0eebfe67eb5e4db2084f1">More...</a><br /></td></tr>
<tr class="separator:ab5ac2de9a9d0eebfe67eb5e4db2084f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ab167043a2e4cd4d0e666853d6170"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1d9ab167043a2e4cd4d0e666853d6170">ByteCodeAddr</a> = uint32_t</td></tr>
<tr class="separator:a1d9ab167043a2e4cd4d0e666853d6170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34799170e951dbbdab0628a01e97344"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af34799170e951dbbdab0628a01e97344">OwningOpRange</a> = llvm::OwningArrayRef&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td></tr>
<tr class="separator:af34799170e951dbbdab0628a01e97344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1e92b3730d5a0d2e1c4f704cb4674d1e">isPowerOf2</a> (int n)</td></tr>
<tr class="separator:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a50c1b52f8e20f12e77716d79a5868"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a69a50c1b52f8e20f12e77716d79a5868">nextPowerOf2</a> (int n)</td></tr>
<tr class="separator:a69a50c1b52f8e20f12e77716d79a5868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; int64_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab48e4040142437e45b8fe0f83b837ad9">makeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:ab48e4040142437e45b8fe0f83b837ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension.  <a href="#ab48e4040142437e45b8fe0f83b837ad9">More...</a><br /></td></tr>
<tr class="separator:ab48e4040142437e45b8fe0f83b837ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N &gt;=1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, N &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada8eaeb3d7b3be7839ef146f1f82a313">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc)</td></tr>
<tr class="memdesc:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI.  <a href="#ada8eaeb3d7b3be7839ef146f1f82a313">More...</a><br /></td></tr>
<tr class="separator:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N==0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, 0 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1a76d14b47a24b32bcb01c58dced65f8">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc={})</td></tr>
<tr class="memdesc:a1a76d14b47a24b32bcb01c58dced65f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI.  <a href="#a1a76d14b47a24b32bcb01c58dced65f8">More...</a><br /></td></tr>
<tr class="separator:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842827e09218842d20c6be75a6fb6ff0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a842827e09218842d20c6be75a6fb6ff0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a842827e09218842d20c6be75a6fb6ff0">allocAligned</a> (size_t nElements, <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> allocFun=&amp;::malloc, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; uint64_t &gt; alignment=<a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; uint64_t &gt;())</td></tr>
<tr class="memdesc:a842827e09218842d20c6be75a6fb6ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>nElements</code> of type T with an optional <code>alignment</code>.  <a href="#a842827e09218842d20c6be75a6fb6ff0">More...</a><br /></td></tr>
<tr class="separator:a842827e09218842d20c6be75a6fb6ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8938e103917c859d7c6c021d7a2f3d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a8938e103917c859d7c6c021d7a2f3d0a">getBranchSuccessorArgument</a> (const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands, <a class="el" href="classunsigned.html">unsigned</a> operandIndex, <a class="el" href="classmlir_1_1Block.html">Block</a> *successor)</td></tr>
<tr class="memdesc:a8938e103917c859d7c6c021d7a2f3d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or None if <code>operandIndex</code> isn't a successor operand index.  <a href="#a8938e103917c859d7c6c021d7a2f3d0a">More...</a><br /></td></tr>
<tr class="separator:a8938e103917c859d7c6c021d7a2f3d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2e2f4d4cb24fe5f60b359e5962ad5498">verifyBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> succNo, const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands)</td></tr>
<tr class="memdesc:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the given operands match those of the given successor block.  <a href="#a2e2f4d4cb24fe5f60b359e5962ad5498">More...</a><br /></td></tr>
<tr class="separator:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4afbba3aecdff992f5fb31b086f9c12">verifyTypesAlongControlFlowEdges</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae4afbba3aecdff992f5fb31b086f9c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that types match along control flow edges described the given op.  <a href="#ae4afbba3aecdff992f5fb31b086f9c12">More...</a><br /></td></tr>
<tr class="separator:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f192c53dfd75f982a0f688bb068021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4f192c53dfd75f982a0f688bb068021">getDefaultTypeSize</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:ae4f192c53dfd75f982a0f688bb068021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size request.  <a href="#ae4f192c53dfd75f982a0f688bb068021">More...</a><br /></td></tr>
<tr class="separator:ae4f192c53dfd75f982a0f688bb068021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f7d3f6449026adc3574694e6ebf14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac25f7d3f6449026adc3574694e6ebf14">getDefaultTypeSizeInBits</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:ac25f7d3f6449026adc3574694e6ebf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size in bits request.  <a href="#ac25f7d3f6449026adc3574694e6ebf14">More...</a><br /></td></tr>
<tr class="separator:ac25f7d3f6449026adc3574694e6ebf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b80c166d5e934716eab0cc1dde085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2d7b80c166d5e934716eab0cc1dde085">getDefaultABIAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a2d7b80c166d5e934716eab0cc1dde085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the required alignemnt request.  <a href="#a2d7b80c166d5e934716eab0cc1dde085">More...</a><br /></td></tr>
<tr class="separator:a2d7b80c166d5e934716eab0cc1dde085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f841e410185c44a1c45a10e3838c9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0f841e410185c44a1c45a10e3838c9ca">getDefaultPreferredAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a0f841e410185c44a1c45a10e3838c9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the preferred alignemnt request.  <a href="#a0f841e410185c44a1c45a10e3838c9ca">More...</a><br /></td></tr>
<tr class="separator:a0f841e410185c44a1c45a10e3838c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a31d3a751d105f957d43b5ee8ad6ab047">filterEntriesForType</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID)</td></tr>
<tr class="memdesc:a31d3a751d105f957d43b5ee8ad6ab047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e.  <a href="#a31d3a751d105f957d43b5ee8ad6ab047">More...</a><br /></td></tr>
<tr class="separator:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memItemLeft" align="right" valign="top">DataLayoutEntryInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af7ddc54fc9b6e82cf3b6a797a6bfefca">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <a href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">More...</a><br /></td></tr>
<tr class="separator:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aee3b9d7e0a9cd00a32827f48d4536850">verifyDataLayoutOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aee3b9d7e0a9cd00a32827f48d4536850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the operation implementing the data layout interface, or a module operation, is valid.  <a href="#aee3b9d7e0a9cd00a32827f48d4536850">More...</a><br /></td></tr>
<tr class="separator:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a791a52efb3f0b9d61ca353b635e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af3a791a52efb3f0b9d61ca353b635e95">verifyDataLayoutSpec</a> (DataLayoutSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:af3a791a52efb3f0b9d61ca353b635e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a data layout spec is valid.  <a href="#af3a791a52efb3f0b9d61ca353b635e95">More...</a><br /></td></tr>
<tr class="separator:af3a791a52efb3f0b9d61ca353b635e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011f880d1be7381fc63c707c3577d42b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a011f880d1be7381fc63c707c3577d42b">inferReturnTensorTypes</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; &amp;retComponents)&gt; componentTypeFn, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;inferredReturnTypes)</td></tr>
<tr class="separator:a011f880d1be7381fc63c707c3577d42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad276c5acc7f5d475d0e1987a456a59e0">verifyInferredResultTypes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad276c5acc7f5d475d0e1987a456a59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the inferred result types match the actual result types for the op.  <a href="#ad276c5acc7f5d475d0e1987a456a59e0">More...</a><br /></td></tr>
<tr class="separator:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb54d50bfcc329f59aee2490b27c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afebb54d50bfcc329f59aee2490b27c07">verifyOffsetSizeAndStrideOp</a> (OffsetSizeAndStrideOpInterface op)</td></tr>
<tr class="separator:afebb54d50bfcc329f59aee2490b27c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caa43784c57086534e1833f66eaecfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0caa43784c57086534e1833f66eaecfc">sameOffsetsSizesAndStrides</a> (OffsetSizeAndStrideOpInterface a, OffsetSizeAndStrideOpInterface b, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt; cmp)</td></tr>
<tr class="separator:a0caa43784c57086534e1833f66eaecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad693ba34552063984c6685f93500c79f">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:ad693ba34552063984c6685f93500c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#adc67b3a3dac2996cc431f90b8658f6e6">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addb63088be1c8bff57b28cc3be96701b">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:addb63088be1c8bff57b28cc3be96701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2b0f1dec3bae54bd6eecd9e5abb59e4c">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3315ae7edc12bed53da6a26424d047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada3315ae7edc12bed53da6a26424d047">verifyAffineMapAsLayout</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> m, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:ada3315ae7edc12bed53da6a26424d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41576f3aecc8ed8c3cb2da13e5fe161"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac41576f3aecc8ed8c3cb2da13e5fe161">isConstantLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac41576f3aecc8ed8c3cb2da13e5fe161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the specified operation is ConstantLike.  <a href="#ac41576f3aecc8ed8c3cb2da13e5fe161">More...</a><br /></td></tr>
<tr class="separator:ac41576f3aecc8ed8c3cb2da13e5fe161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d56b4a0735c0f5cb8275a7d526f92ed"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:a1d56b4a0735c0f5cb8275a7d526f92ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1d56b4a0735c0f5cb8275a7d526f92ed">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:a1d56b4a0735c0f5cb8275a7d526f92ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher.  <a href="#a1d56b4a0735c0f5cb8275a7d526f92ed">More...</a><br /></td></tr>
<tr class="separator:a1d56b4a0735c0f5cb8275a7d526f92ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80234cf144582369aedd31ad010918d1"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:a80234cf144582369aedd31ad010918d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a80234cf144582369aedd31ad010918d1">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:a80234cf144582369aedd31ad010918d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> matcher.  <a href="#a80234cf144582369aedd31ad010918d1">More...</a><br /></td></tr>
<tr class="separator:a80234cf144582369aedd31ad010918d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplParams" colspan="2">template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7baf9bf03348723f8d037a39800d69a7">enumerateImpl</a> (TupleT &amp;&amp;tuple, CallbackT &amp;&amp;callback, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a7baf9bf03348723f8d037a39800d69a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplParams" colspan="2">template&lt;typename... Tys, typename CallbackT &gt; </td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">enumerate</a> (std::tuple&lt; Tys... &gt; &amp;tuple, CallbackT &amp;&amp;callback)</td></tr>
<tr class="separator:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">getDefaultDiagnosticEmitFn</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object.  <a href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">More...</a><br /></td></tr>
<tr class="separator:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3379fc459c08af37eb4a514b0eadef2d"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3379fc459c08af37eb4a514b0eadef2d">getDefaultDiagnosticEmitFn</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:a3379fc459c08af37eb4a514b0eadef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aea9f7283021fca39df8cf99bbd90cf4a">verifySymbolTable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e42f84b57ed10b489c12a7236bb356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae8e42f84b57ed10b489c12a7236bb356">verifySymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae8e42f84b57ed10b489c12a7236bb356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a> (Ret(*)(Arg, Rest...))</td></tr>
<tr class="memdesc:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper templates to deduce the first argument of a callback parameter.  <a href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">More...</a><br /></td></tr>
<tr class="separator:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4b5b18be8ea226e9d3606f21c1a7a7e">first_argument_type</a> (Ret(F::*)(Arg, Rest...))</td></tr>
<tr class="separator:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66816d8124426b5976554a8448b1fd08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a66816d8124426b5976554a8448b1fd08">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a66816d8124426b5976554a8448b1fd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="#a66816d8124426b5976554a8448b1fd08">More...</a><br /></td></tr>
<tr class="separator:a66816d8124426b5976554a8448b1fd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba96390004d8e5a82ed7ebf5ab76ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7ba96390004d8e5a82ed7ebf5ab76ad3">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a7ba96390004d8e5a82ed7ebf5ab76ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93da801717c53254b945c15507edb905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a93da801717c53254b945c15507edb905">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a93da801717c53254b945c15507edb905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432863430e989902ec199eaf994a0c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a432863430e989902ec199eaf994a0c84">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a432863430e989902ec199eaf994a0c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="#a432863430e989902ec199eaf994a0c84">More...</a><br /></td></tr>
<tr class="separator:a432863430e989902ec199eaf994a0c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d9b9ba40e66e24ece3092c1424e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a983d9b9ba40e66e24ece3092c1424e42">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a983d9b9ba40e66e24ece3092c1424e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c935888be3c9860dcfe9a25830b9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab5c935888be3c9860dcfe9a25830b9fd">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:ab5c935888be3c9860dcfe9a25830b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac359fcabc6011f1190c112e5721a1f95"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:ac359fcabc6011f1190c112e5721a1f95"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac359fcabc6011f1190c112e5721a1f95">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac359fcabc6011f1190c112e5721a1f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="#ac359fcabc6011f1190c112e5721a1f95">More...</a><br /></td></tr>
<tr class="separator:ac359fcabc6011f1190c112e5721a1f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8c8c7e2547537b23b03ebc549b5188"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a3d8c8c7e2547537b23b03ebc549b5188"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3d8c8c7e2547537b23b03ebc549b5188">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3d8c8c7e2547537b23b03ebc549b5188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="#a3d8c8c7e2547537b23b03ebc549b5188">More...</a><br /></td></tr>
<tr class="separator:a3d8c8c7e2547537b23b03ebc549b5188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89561dcc4552722f19805a977fbb86d0"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a89561dcc4552722f19805a977fbb86d0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a89561dcc4552722f19805a977fbb86d0">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a89561dcc4552722f19805a977fbb86d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="#a89561dcc4552722f19805a977fbb86d0">More...</a><br /></td></tr>
<tr class="separator:a89561dcc4552722f19805a977fbb86d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626abe27e64a0a166feedf7e829c968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7626abe27e64a0a166feedf7e829c968">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:a7626abe27e64a0a166feedf7e829c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walkers with stage aware callbacks.  <a href="#a7626abe27e64a0a166feedf7e829c968">More...</a><br /></td></tr>
<tr class="separator:a7626abe27e64a0a166feedf7e829c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aa2adf6127282c5d8cd497d1eff1013c1">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:aa2adf6127282c5d8cd497d1eff1013c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation.  <a href="#aa2adf6127282c5d8cd497d1eff1013c1">More...</a><br /></td></tr>
<tr class="separator:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f8b1397d79506b79dda1c6672b68b3"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a26f8b1397d79506b79dda1c6672b68b3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a26f8b1397d79506b79dda1c6672b68b3">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a26f8b1397d79506b79dda1c6672b68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations nested under and including the given operation.  <a href="#a26f8b1397d79506b79dda1c6672b68b3">More...</a><br /></td></tr>
<tr class="separator:a26f8b1397d79506b79dda1c6672b68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f528aa32da80acdb6358d90d9804e93"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a8f528aa32da80acdb6358d90d9804e93"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a8f528aa32da80acdb6358d90d9804e93">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a8f528aa32da80acdb6358d90d9804e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="#a8f528aa32da80acdb6358d90d9804e93">More...</a><br /></td></tr>
<tr class="separator:a8f528aa32da80acdb6358d90d9804e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad27d69a99e3c3071714ffa42b3f7f41"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:aad27d69a99e3c3071714ffa42b3f7f41"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aad27d69a99e3c3071714ffa42b3f7f41">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:aad27d69a99e3c3071714ffa42b3f7f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="#aad27d69a99e3c3071714ffa42b3f7f41">More...</a><br /></td></tr>
<tr class="separator:aad27d69a99e3c3071714ffa42b3f7f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0c95cf9bfd21b06e858fb98892946015">constructContainerOpForParserIfNecessary</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *parsedBlock, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Location.html">Location</a> sourceFileLoc)</td></tr>
<tr class="memdesc:a0c95cf9bfd21b06e858fb98892946015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it.  <a href="#a0c95cf9bfd21b06e858fb98892946015">More...</a><br /></td></tr>
<tr class="separator:a0c95cf9bfd21b06e858fb98892946015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d7a8089745af25248145b612493b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a930d7a8089745af25248145b612493b4">getDenseElementBitWidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> eltType)</td></tr>
<tr class="memdesc:a930d7a8089745af25248145b612493b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object. ">DenseElementsAttr</a> should use for this type.  <a href="#a930d7a8089745af25248145b612493b4">More...</a><br /></td></tr>
<tr class="separator:a930d7a8089745af25248145b612493b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aae4714fdeb9f7fa11cf2bd472a5ab6d3">isSupportedMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> type.  <a href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">More...</a><br /></td></tr>
<tr class="separator:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f32721e9d15092545cf9ea586d6d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a37f32721e9d15092545cf9ea586d6d7e">wrapIntegerMemorySpace</a> (<a class="el" href="classunsigned.html">unsigned</a> memorySpace, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a37f32721e9d15092545cf9ea586d6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> form.  <a href="#a37f32721e9d15092545cf9ea586d6d7e">More...</a><br /></td></tr>
<tr class="separator:a37f32721e9d15092545cf9ea586d6d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38aedb222d8f61891a51c10805e286c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab38aedb222d8f61891a51c10805e286c">skipDefaultMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:ab38aedb222d8f61891a51c10805e286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="#ab38aedb222d8f61891a51c10805e286c">More...</a><br /></td></tr>
<tr class="separator:ab38aedb222d8f61891a51c10805e286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec833993e8780c005c1c18d054273b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3ec833993e8780c005c1c18d054273b4">getMemorySpaceAsInt</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:a3ec833993e8780c005c1c18d054273b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[deprecated] Returns the memory space in old raw integer representation.  <a href="#a3ec833993e8780c005c1c18d054273b4">More...</a><br /></td></tr>
<tr class="separator:a3ec833993e8780c005c1c18d054273b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplItemLeft" align="right" valign="top">decltype(first_argument_type(&amp;F::operator()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a> (F)</td></tr>
<tr class="separator:a63c39ecb3618964551c0b29bc356b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1d9ab167043a2e4cd4d0e666853d6170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ab167043a2e4cd4d0e666853d6170">&#9670;&nbsp;</a></span>ByteCodeAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a1d9ab167043a2e4cd4d0e666853d6170">mlir::detail::ByteCodeAddr</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00030">30</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="ab5ac2de9a9d0eebfe67eb5e4db2084f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ac2de9a9d0eebfe67eb5e4db2084f1">&#9670;&nbsp;</a></span>ByteCodeField</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ab5ac2de9a9d0eebfe67eb5e4db2084f1">mlir::detail::ByteCodeField</a> = typedef uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use generic bytecode types. </p>
<p>ByteCodeField refers to the actual bytecode entries. ByteCodeAddr refers to size of indices into the bytecode. </p>

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00029">29</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="aabbea31f5f9034714e29d3a49cae75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbea31f5f9034714e29d3a49cae75a4">&#9670;&nbsp;</a></span>count_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">mlir::detail::count_if_t</a> = typedef <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt;Pred, 0, Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00138">138</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a912e3cd5feea0574a2f3fce7c34dcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e3cd5feea0574a2f3fce7c34dcefd">&#9670;&nbsp;</a></span>DenseIterPtrAndSplat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">mlir::detail::DenseIterPtrAndSplat</a> = typedef std::pair&lt;const char *, bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of raw pointer and a boolean flag of whether the pointer holds a splat,. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00036">36</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ae2b75c9bae3caf1909b6d6277fb6ea61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b75c9bae3caf1909b6d6277fb6ea61">&#9670;&nbsp;</a></span>first_argument</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">mlir::detail::first_argument</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00112">112</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a1be2dcfec91412eb27290aab9294b4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be2dcfec91412eb27290aab9294b4cc">&#9670;&nbsp;</a></span>has_impltype_getkey_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">mlir::detail::has_impltype_getkey_t</a> = typedef decltype(ImplTy::getKey(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'getKey' method with types 'Args'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00026">26</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="afb2713c77027515db7c2d5f698d0f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2713c77027515db7c2d5f698d0f33c">&#9670;&nbsp;</a></span>has_impltype_hash_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">mlir::detail::has_impltype_hash_t</a> = typedef decltype(ImplTy::hashKey(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'hashKey' method for 'T'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00030">30</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a0d607e4b534651dbd796b895db9e07b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d607e4b534651dbd796b895db9e07b3">&#9670;&nbsp;</a></span>has_operation_or_value_matcher_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OperationOrValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">mlir::detail::has_operation_or_value_matcher_t</a> = typedef decltype(std::declval&lt;T&gt;().match(std::declval&lt;OperationOrValue&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check whether T provides a 'match' method with type <code>OperationOrValue</code>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00178">178</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="af34799170e951dbbdab0628a01e97344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34799170e951dbbdab0628a01e97344">&#9670;&nbsp;</a></span>OwningOpRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#af34799170e951dbbdab0628a01e97344">mlir::detail::OwningOpRange</a> = typedef llvm::OwningArrayRef&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteCode_8h_source.html#l00031">31</a> of file <a class="el" href="ByteCode_8h_source.html">ByteCode.h</a>.</p>

</div>
</div>
<a id="a5258e43cc82e8e9a4c2c605f10a16461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5258e43cc82e8e9a4c2c605f10a16461">&#9670;&nbsp;</a></span>walkResultType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">mlir::detail::walkResultType</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a66816d8124426b5976554a8448b1fd08">walk</a>(nullptr, std::declval&lt;FnT&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to provide the return type of a templated walk method. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00319">319</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a842827e09218842d20c6be75a6fb6ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842827e09218842d20c6be75a6fb6ff0">&#9670;&nbsp;</a></span>allocAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T *, T *&gt; mlir::detail::allocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a>&#160;</td>
          <td class="paramname"><em>allocFun</em> = <code>&amp;::malloc</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt;uint64_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>nElements</code> of type T with an optional <code>alignment</code>. </p>
<p>This replaces a portable <code>posix_memalign</code>. <code>alignment</code> must be a power of 2 and greater than the size of T. By default the alignment is sizeof(T). </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00102">102</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00048">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="ad693ba34552063984c6685f93500c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693ba34552063984c6685f93500c79f">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00307">307</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00310">bindDims()</a>.</p>

</div>
</div>
<a id="adc67b3a3dac2996cc431f90b8658f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67b3a3dac2996cc431f90b8658f6e6">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00310">310</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00307">bindDims()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="addb63088be1c8bff57b28cc3be96701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb63088be1c8bff57b28cc3be96701b">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00316">316</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00319">bindSymbols()</a>.</p>

</div>
</div>
<a id="a2b0f1dec3bae54bd6eecd9e5abb59e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f1dec3bae54bd6eecd9e5abb59e4c">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00319">319</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00316">bindSymbols()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="a0c95cf9bfd21b06e858fb98892946015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c95cf9bfd21b06e858fb98892946015">&#9670;&nbsp;</a></span>constructContainerOpForParserIfNecessary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::detail::constructContainerOpForParserIfNecessary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>parsedBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it. </p>
<p>If the block does not contain just that operation, create a new operation instance of <code>ContainerOpT</code> and move all of the operations within <code>parsedBlock</code> into the first block of the first region. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00039">39</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::front()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">mlir::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00197">mlir::parseSourceString()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a7146031ab7f6bb4cdacc53c4f1e96aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7146031ab7f6bb4cdacc53c4f1e96aac">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys, typename CallbackT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvoid.html">void</a> mlir::detail::enumerate </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Tys... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00234">234</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00225">enumerateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00570">ableToUpdatePredOperands()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00055">adjustIter()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">mlir::alignAffineMapWithValues()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00052">mlir::PatternApplicator::applyCostModel()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00037">applyPatterns()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00038">mlir::applyPermutationToVector()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00124">mlir::transform::TransformState::applyTransform()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00222">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00403">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00400">buildCostGraph()</a>, <a class="el" href="IRCore_8cpp_source.html#l01259">mlir::python::PyOpView::buildGeneric()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00590">buildPredicateList()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00637">composeAffineMapAndOperands()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00484">mlir::LLVM::detail::connectPHINodes()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00458">convertForOp()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00209">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00048">convertIntrinsicResult()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00256">convertOperationImpl()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00482">convertYieldOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00199">mlir::ConvertToLLVMPattern::createMemRefDescriptor()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00039">mlir::tensor::createPadHighOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Promotion_8cpp_source.html#l00080">defaultAllocBufferCallBack()</a>, <a class="el" href="Verifier_8cpp_source.html#l00274">diagnoseInvalidOperandDominance()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00448">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00066">doubleBuffer()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00625">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00126">mlir::ComputationSliceState::dump()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00660">foldSwitch()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="Fusion_8cpp_source.html#l00193">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00742">fuseOperations()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01291">generateCollapsedIndexingRegion()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00451">getAllocationTypeAndShape()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00078">getBackwardSliceImpl()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00153">getBlockIt()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02433">getCanonicalSubViewResultType()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01005">getCollapsableIterationSpaceDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00822">getDimMap()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00169">mlir::linalg::getDynOperands()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00022">getExpandedDimToCollapsedDimMap()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00074">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="MLIRServer_8cpp_source.html#l00179">getLspDiagnoticFromDiag()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00433">getPHISourceValue()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00465">getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00935">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="Fusion_8cpp_source.html#l00068">getShapeDefiningLoopRange()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00135">mlir::getSinglyExecutedRegionsToSink()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00038">getTiledSliceDims()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00109">getTreePredicates()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00192">getTypeNumBytes()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00081">mlir::LLVM::detail::handleMultidimensionalVectors()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00089">handleMultidimensionalVectors()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00077">hasSameBitwidthScalarType()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00343">mlir::linalg::hoistRedundantVectorTransfersOnTensor()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02631">inferTransposeResultType()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00043">injectGpuIndexOperations()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00144">inlineRegionImpl()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00031">insertCopyLoops()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00658">mlir::inversePermutation()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00171">isConstantOne()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00541">isDefinedByCallTo()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00917">isDimSequencePreserved()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00453">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00117">mlir::AffineMap::isMinorIdentityWithBroadcasting()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00349">mlir::isOpwiseShiftValid()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00157">mlir::AffineMap::isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00196">mlir::isReassociationValid()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="DependenceAnalysis_8cpp_source.html#l00103">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraph()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00767">mlir::spirv::linearizeIndex()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00092">logFailure()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00183">lowerAsEntryFunction()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00282">mlir::linalg::makeComposedExtractSliceOp()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00017">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00112">ReduceMultiDimReductionRank::matchAndRewrite()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00249">TransposeOpLowering::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00918">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00146">outlineKernelFuncImpl()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00154">packFunctionArguments()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00169">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01757">parseOptionalKeywordAlternative()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01492">mlir::permuteLoops()</a>, <a class="el" href="TosaOps_8cpp_source.html#l01543">poolingInferReturnTypes()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02453">mlir::AsmPrinter::Impl::printIntegerSet()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00060">printResultsAsList()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00532">printSwitchOpCases()</a>, <a class="el" href="Promotion_8cpp_source.html#l00213">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00466">pruneReductionDimsFromMap()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01255">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01076">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00226">mlir::reshapeLikeShapesAreCompatible()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00508">mlir::linalg::LinalgPaddingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00255">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00826">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00041">sliceTransferIndices()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l00492">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00035">splatZero()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, <a class="el" href="Tiling_8cpp_source.html#l00099">tileLinalgOpImpl()</a>, <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00053">mlir::scf::tileParallelLoop()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00275">mlir::linalg::TileLoopNest::tileRootOp()</a>, <a class="el" href="Tiling_8cpp_source.html#l00072">mlir::linalg::transformIndexOps()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00021">updateFuncOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00249">vectorizeLinalgYield()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00992">verifyAttributions()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01610">verifyCollapsedShape()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00103">mlir::verifyReshapeLikeTypes()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00180">verifyResultTypesAreInferrable()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00094">verifyTypesAlongAllEdges()</a>, <a class="el" href="AsyncRuntimeRefCounting_8cpp_source.html#l00054">walkReferenceCountedValues()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00126">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a7baf9bf03348723f8d037a39800d69a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf9bf03348723f8d037a39800d69a7">&#9670;&nbsp;</a></span>enumerateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvoid.html">void</a> mlir::detail::enumerateImpl </td>
          <td>(</td>
          <td class="paramtype">TupleT &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00225">225</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00234">enumerate()</a>.</p>

</div>
</div>
<a id="a31d3a751d105f957d43b5ee8ad6ab047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d3a751d105f957d43b5ee8ad6ab047">&#9670;&nbsp;</a></span>filterEntriesForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> mlir::detail::filterEntriesForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>typeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e. </p>
<p>belonging to the same type class. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00217">217</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00108">mlir::Type::getTypeID()</a>.</p>

</div>
</div>
<a id="af7ddc54fc9b6e82cf3b6a797a6bfefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">&#9670;&nbsp;</a></span>filterEntryForIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutEntryInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00227">227</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a6f65c29b00af55fbdff5cf2a1bfbbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper templates to deduce the first argument of a callback parameter. </p>

</div>
</div>
<a id="ae4b5b18be8ea226e9d3606f21c1a7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b5b18be8ea226e9d3606f21c1a7a7e">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(F::*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="Visitors_8h_source.html#l00092">mlir::WalkStage::getNextRegion()</a>.</p>

</div>
</div>
<a id="a8938e103917c859d7c6c021d7a2f3d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8938e103917c859d7c6c021d7a2f3d0a">&#9670;&nbsp;</a></span>getBranchSuccessorArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; mlir::detail::getBranchSuccessorArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>operandIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>successor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or None if <code>operandIndex</code> isn't a successor operand index. </p>
<p>Returns the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if 'operandIndex' is within the range of 'operands', or None if <code>operandIndex</code> isn't a successor operand index.</p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00040">40</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00120">mlir::Block::getArgument()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00376">mlir::OperandRange::getBeginOperandIndex()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00083">mlir::SuccessorOperands::getForwardedOperands()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00065">mlir::SuccessorOperands::getProducedOperandCount()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8h_source.html#l00107">mlir::SuccessorOperands::getOperandIndex()</a>.</p>

</div>
</div>
<a id="a2d7b80c166d5e934716eab0cc1dde085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7b80c166d5e934716eab0cc1dde085">&#9670;&nbsp;</a></span>getDefaultABIAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getDefaultABIAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the required alignemnt request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00133">133</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00124">getFloatTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00112">getIntegerTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00435">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00411">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00435">mlir::DataLayout::getTypeABIAlignment()</a>.</p>

</div>
</div>
<a id="ac9dddc7a1f6dc8aa95eaa5b7910c76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object. </p>
<p>This is defined out-of-line to avoid the need to include <a class="el" href="Location_8h.html">Location.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01027">1027</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00128">mlir::DynamicType::get()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00149">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a3379fc459c08af37eb4a514b0eadef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3379fc459c08af37eb4a514b0eadef2d">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01031">1031</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>.</p>

</div>
</div>
<a id="a0f841e410185c44a1c45a10e3838c9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f841e410185c44a1c45a10e3838c9ca">&#9670;&nbsp;</a></span>getDefaultPreferredAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getDefaultPreferredAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the preferred alignemnt request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">186</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00177">getFloatTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00167">getIntegerTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00435">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00447">mlir::DataLayout::getTypePreferredAlignment()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">getDefaultTypeSizeInBits()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00447">mlir::DataLayout::getTypePreferredAlignment()</a>.</p>

</div>
</div>
<a id="ae4f192c53dfd75f982a0f688bb068021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f192c53dfd75f982a0f688bb068021">&#9670;&nbsp;</a></span>getDefaultTypeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getDefaultTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">45</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">getDefaultTypeSizeInBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00411">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="ac25f7d3f6449026adc3574694e6ebf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f7d3f6449026adc3574694e6ebf14">&#9670;&nbsp;</a></span>getDefaultTypeSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getDefaultTypeSizeInBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size in bits request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00051">51</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00186">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00091">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00411">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00423">mlir::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00423">mlir::DataLayout::getTypeSizeInBits()</a>.</p>

</div>
</div>
<a id="a930d7a8089745af25248145b612493b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d7a8089745af25248145b612493b4">&#9670;&nbsp;</a></span>getDenseElementBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::detail::getDenseElementBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>eltType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object. ">DenseElementsAttr</a> should use for this type. </p>

<p class="definition">Definition at line <a class="el" href="AttributeDetail_8h_source.html#l00034">34</a> of file <a class="el" href="AttributeDetail_8h_source.html">AttributeDetail.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00091">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00986">mlir::DenseElementsAttr::bitcast()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00676">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00423">getDenseElementStorageWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00100">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00824">isValidIntOrFloat()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01169">mappingHelper()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00627">mlir::DenseElementsAttr::BoolElementIterator::operator*()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00640">mlir::DenseElementsAttr::IntElementIterator::operator*()</a>.</p>

</div>
</div>
<a id="a3ec833993e8780c005c1c18d054273b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec833993e8780c005c1c18d054273b4">&#9670;&nbsp;</a></span>getMemorySpaceAsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getMemorySpaceAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[deprecated] Returns the memory space in old raw integer representation. </p>
<p>New <code><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> getMemorySpace()</code> method should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00505">505</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00130">mlir::Attribute::cast()</a>, and <a class="el" href="Attributes_8h_source.html#l00109">mlir::Attribute::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00150">mlir::AffineDmaStartOp::getDstMemorySpace()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00396">mlir::BaseMemRefType::getMemorySpaceAsInt()</a>, <a class="el" href="AffineOps_8h_source.html#l00129">mlir::AffineDmaStartOp::getSrcMemorySpace()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>.</p>

</div>
</div>
<a id="a011f880d1be7381fc63c707c3577d42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011f880d1be7381fc63c707c3577d42b">&#9670;&nbsp;</a></span>inferReturnTensorTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::inferReturnTensorTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; location, <a class="el" href="classmlir_1_1ValueShapeRange.html">ValueShapeRange</a> operands, DictionaryAttr attributes, <a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a> regions, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; &amp;retComponents)&gt;&#160;</td>
          <td class="paramname"><em>componentTypeFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryAttr&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a>&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inferredReturnTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00179">179</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferTypeOpInterface_8h_source.html#l00205">mlir::ValueShapeRange::getValues()</a>, and <a class="el" href="InferTypeOpInterface_8h_source.html#l00275">mlir::OpTrait::InferTensorType&lt; ConcreteType &gt;::inferReturnTypes()</a>.</p>

</div>
</div>
<a id="ac41576f3aecc8ed8c3cb2da13e5fe161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41576f3aecc8ed8c3cb2da13e5fe161">&#9670;&nbsp;</a></span>isConstantLike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::detail::isConstantLike </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if the specified operation is ConstantLike. </p>
<p>This includes some quick filters to avoid a semi-expensive test in the common case. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00053">53</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00269">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00524">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00060">mlir::detail::constant_op_matcher::match()</a>, and <a class="el" href="Matchers_8h_source.html#l00075">mlir::detail::constant_op_binder&lt; AttrT &gt;::match()</a>.</p>

</div>
</div>
<a id="a1e92b3730d5a0d2e1c4f704cb4674d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92b3730d5a0d2e1c4f704cb4674d1e">&#9670;&nbsp;</a></span>isPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::detail::isPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00046">46</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CRunnerUtils_8h_source.html#l00048">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="aae4714fdeb9f7fa11cf2bd472a5ab6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">&#9670;&nbsp;</a></span>isSupportedMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::isSupportedMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00473">473</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00072">mlir::Attribute::getDialect()</a>, and <a class="el" href="Attributes_8h_source.html#l00109">mlir::Attribute::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>.</p>

</div>
</div>
<a id="ada8eaeb3d7b3be7839ef146f1f82a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8eaeb3d7b3be7839ef146f1f82a313">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N &gt;= 1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, N&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00064">64</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00131">StridedMemRefType&lt; T, N &gt;::basePtr</a>, and <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00065">copy()</a>.</p>

</div>
</div>
<a id="a1a76d14b47a24b32bcb01c58dced65f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a76d14b47a24b32bcb01c58dced65f8">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N == 0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, 0&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00085">85</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00192">StridedMemRefType&lt; T, 0 &gt;::basePtr</a>.</p>

</div>
</div>
<a id="ab48e4040142437e45b8fe0f83b837ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48e4040142437e45b8fe0f83b837ad9">&#9670;&nbsp;</a></span>makeStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int64_t, N&gt; mlir::detail::makeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension. </p>
<p>e.g. shape[3, 4, 5] -&gt; strides[20, 5, 1] </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00045">45</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a1d56b4a0735c0f5cb8275a7d526f92ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d56b4a0735c0f5cb8275a7d526f92ed">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00186">186</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00273">mlir::Operation::getOperand()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="a80234cf144582369aedd31ad010918d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80234cf144582369aedd31ad010918d1">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#a0d607e4b534651dbd796b895db9e07b3">detail::has_operation_or_value_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00196">196</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00273">mlir::Operation::getOperand()</a>.</p>

</div>
</div>
<a id="a69a50c1b52f8e20f12e77716d79a5868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a50c1b52f8e20f12e77716d79a5868">&#9670;&nbsp;</a></span>nextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::detail::nextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00048">48</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00046">isPowerOf2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00102">allocAligned()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00078">mlir::detail::Vector1D&lt; T, Dim, false &gt;::operator[]()</a>, <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00145">mlir::OwningMemRef&lt; T, Rank &gt;::OwningMemRef()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00057">mlir::detail::Vector1D&lt; T, Dim, true &gt;::Vector1D()</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00072">mlir::detail::Vector1D&lt; T, Dim, false &gt;::Vector1D()</a>.</p>

</div>
</div>
<a id="a0caa43784c57086534e1833f66eaecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caa43784c57086534e1833f66eaecfc">&#9670;&nbsp;</a></span>sameOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::sameOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00161">161</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Value_8h_source.html#l00121">mlir::Value::getContext()</a>, and <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ab38aedb222d8f61891a51c10805e286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38aedb222d8f61891a51c10805e286c">&#9670;&nbsp;</a></span>skipDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::skipDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00497">497</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast_or_null()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>.</p>

</div>
</div>
<a id="ada3315ae7edc12bed53da6a26424d047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3315ae7edc12bed53da6a26424d047">&#9670;&nbsp;</a></span>verifyAffineMapAsLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyAffineMapAsLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00081">81</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00250">mlir::detail::ElementsAttrRange&lt; IteratorT &gt;::size()</a>.</p>

</div>
</div>
<a id="a2e2f4d4cb24fe5f60b359e5962ad5498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f4d4cb24fe5f60b359e5962ad5498">&#9670;&nbsp;</a></span>verifyBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>succNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the given operands match those of the given successor block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00061">61</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="Block_8h_source.html#l00120">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00065">mlir::SuccessorOperands::getProducedOperandCount()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00505">mlir::Operation::getSuccessor()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00056">mlir::SuccessorOperands::size()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8h_source.html#l00107">mlir::SuccessorOperands::getOperandIndex()</a>.</p>

</div>
</div>
<a id="aee3b9d7e0a9cd00a32827f48d4536850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3b9d7e0a9cd00a32827f48d4536850">&#9670;&nbsp;</a></span>verifyDataLayoutOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyDataLayoutOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the operation implementing the data layout interface, or a module operation, is valid. </p>
<p>This calls the verifier of the spec attribute and checks if the layout is compatible with specs attached to the enclosing operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00311">311</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00345">mlir::InFlightDiagnostic::attachNote()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00250">collectParentLayouts()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00046">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00281">getCombinedDataLayout()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00237">getSpec()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_8cpp_source.html#l00301">mlir::DataLayoutSpecAttr::print()</a>.</p>

</div>
</div>
<a id="af3a791a52efb3f0b9d61ca353b635e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a791a52efb3f0b9d61ca353b635e95">&#9670;&nbsp;</a></span>verifyDataLayoutSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyDataLayoutSpec </td>
          <td>(</td>
          <td class="paramtype">DataLayoutSpecInterface&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a data layout spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant type and dialect interfaces for type and identifier keys respectively. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00474">474</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

</div>
</div>
<a id="ad276c5acc7f5d475d0e1987a456a59e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276c5acc7f5d475d0e1987a456a59e0">&#9670;&nbsp;</a></span>verifyInferredResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyInferredResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the inferred result types match the actual result types for the op. </p>
<p>Precondition: op implements InferTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00206">206</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00518">mlir::Operation::emitOpError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00365">mlir::Operation::getAttrDictionary()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00301">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::getResultTypes()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferTypeOpInterface_8h_source.html#l00205">mlir::ValueShapeRange::getValues()</a>.</p>

</div>
</div>
<a id="afebb54d50bfcc329f59aee2490b27c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebb54d50bfcc329f59aee2490b27c07">&#9670;&nbsp;</a></span>verifyOffsetSizeAndStrideOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyOffsetSizeAndStrideOp </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">38</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">mlir::verifyListOfOperandsOrIntegers()</a>.</p>

</div>
</div>
<a id="ae8e42f84b57ed10b489c12a7236bb356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e42f84b57ed10b489c12a7236bb356">&#9670;&nbsp;</a></span>verifySymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifySymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00439">439</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00518">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00377">mlir::Operation::getAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00381">mlir::Operation::getAttrOfType()</a>, <a class="el" href="SymbolTable_8h_source.html#l00055">mlir::SymbolTable::getSymbolAttrName()</a>, <a class="el" href="SymbolTable_8h_source.html#l00061">mlir::SymbolTable::getVisibilityAttrName()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolTable_8h_source.html#l00305">mlir::SymbolUserMap::useEmpty()</a>.</p>

</div>
</div>
<a id="aea9f7283021fca39df8cf99bbd90cf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f7283021fca39df8cf99bbd90cf4a">&#9670;&nbsp;</a></span>verifySymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifySymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00398">398</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00334">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00518">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00381">mlir::Operation::getAttrOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00474">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00483">mlir::Operation::getRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="SymbolTable_8h_source.html#l00055">mlir::SymbolTable::getSymbolAttrName()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00080">walkSymbolTable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolTable_8h_source.html#l00305">mlir::SymbolUserMap::useEmpty()</a>, and <a class="el" href="SymbolTable_8h_source.html#l00340">mlir::OpTrait::SymbolTable&lt; ConcreteType &gt;::verifyRegionTrait()</a>.</p>

</div>
</div>
<a id="ae4afbba3aecdff992f5fb31b086f9c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4afbba3aecdff992f5fb31b086f9c12">&#9670;&nbsp;</a></span>verifyTypesAlongControlFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::detail::verifyTypesAlongControlFlowEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that types match along control flow edges described the given op. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00159">159</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00474">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::getResultTypes()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00094">verifyTypesAlongAllEdges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowInterfaces_8h_source.html#l00107">mlir::SuccessorOperands::getOperandIndex()</a>.</p>

</div>
</div>
<a id="a66816d8124426b5976554a8448b1fd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66816d8124426b5976554a8448b1fd08">&#9670;&nbsp;</a></span>walk() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>Walk all of the regions/blocks/operations nested under and including the given operation.</p>
<p>Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. These methods are invoked for void-returning callbacks. A callback on a block or operation is allowed to erase that block or operation only if the walk is in post-order. See non-void method for pre-order erasure. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00024">24</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, and <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>.</p>

<p class="reference">Referenced by <a class="el" href="PatternApplicator_8h_source.html#l00059">mlir::PatternApplicator::applyDefaultCostModel()</a>, <a class="el" href="Nodes_8h_source.html#l00129">mlir::pdll::ast::Node::getLoc()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00097">isMemRefNormalizable()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00082">mlir::AffineExpr::operator!()</a>, <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00293">GpuAsyncRegionPass::SingleTokenUseCallback::operator()()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01821">verifyConstantType()</a>, <a class="el" href="Nodes_8h_source.html#l00139">mlir::pdll::ast::Node::walk()</a>, <a class="el" href="Visitors_8h_source.html#l00169">walk()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00597">mlir::Operation::walk()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01182">JamBlockGatherer::walk()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00113">mlir::PatternApplicator::walkAllPatterns()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00563">walkSymbolUses()</a>.</p>

</div>
</div>
<a id="a7ba96390004d8e5a82ed7ebf5ab76ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba96390004d8e5a82ed7ebf5ab76ad3">&#9670;&nbsp;</a></span>walk() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00040">40</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="a93da801717c53254b945c15507edb905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93da801717c53254b945c15507edb905">&#9670;&nbsp;</a></span>walk() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00055">55</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00090">mlir::WalkStage::advance()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="a432863430e989902ec199eaf994a0c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432863430e989902ec199eaf994a0c84">&#9670;&nbsp;</a></span>walk() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>Walk all of the regions/blocks/operations nested under and including the given operation.</p>
<p>Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. This method is invoked for skippable or interruptible callbacks. A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure.</li>
</ul>
<p>These functions walk operations until an interrupt result is returned by the callback. Walks on regions, blocks and operations may also be skipped if the callback returns a skip result. Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00102">102</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="Visitors_8h_source.html#l00058">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="a983d9b9ba40e66e24ece3092c1424e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983d9b9ba40e66e24ece3092c1424e42">&#9670;&nbsp;</a></span>walk() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00129">129</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="Visitors_8h_source.html#l00058">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="ab5c935888be3c9860dcfe9a25830b9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c935888be3c9860dcfe9a25830b9fd">&#9670;&nbsp;</a></span>walk() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8cpp_source.html#l00155">155</a> of file <a class="el" href="Visitors_8cpp_source.html">Visitors.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="Visitors_8h_source.html#l00090">mlir::WalkStage::advance()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00477">mlir::Operation::getRegions()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="Visitors_8h_source.html#l00058">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="ac359fcabc6011f1190c112e5721a1f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac359fcabc6011f1190c112e5721a1f95">&#9670;&nbsp;</a></span>walk() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. This method is selected for callbacks that operate on Region*, Block*, and Operation*.</li>
</ul>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to...">Region</a> *r) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> *b) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> *op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00169">169</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="a3d8c8c7e2547537b23b03ebc549b5188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8c8c7e2547537b23b03ebc549b5188">&#9670;&nbsp;</a></span>walk() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classvoid.html">void</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order' (post-order by default). This method is selected for void-returning callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation only if the walk is in post-order. See non-void method for pre-order erasure.</p>
<p>Example: op-&gt;walk([](ReturnOp op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00192">192</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="a89561dcc4552722f19805a977fbb86d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89561dcc4552722f19805a977fbb86d0">&#9670;&nbsp;</a></span>walk() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>Regions, blocks and operations at the same nesting level are visited in lexicographical order. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). This method is selected for WalkReturn returning skippable or interruptible callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure.</li>
</ul>
<p>Example: op-&gt;walk([](ReturnOp op) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#a693d2ecca6f15d4d492c6ff2bea148d0">WalkResult::skip()</a>; if (another_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00227">227</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>, and <a class="el" href="Visitors_8h_source.html#l00038">mlir::WalkResult::WalkResult()</a>.</p>

</div>
</div>
<a id="a7626abe27e64a0a166feedf7e829c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626abe27e64a0a166feedf7e829c968">&#9670;&nbsp;</a></span>walk() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic walkers with stage aware callbacks. </p>
<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for void returning callbacks. </p>

</div>
</div>
<a id="aa2adf6127282c5d8cd497d1eff1013c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2adf6127282c5d8cd497d1eff1013c1">&#9670;&nbsp;</a></span>walk() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. </p>
<p>The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for skippable or interruptible callbacks. </p>

</div>
</div>
<a id="a26f8b1397d79506b79dda1c6672b68b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f8b1397d79506b79dda1c6672b68b3">&#9670;&nbsp;</a></span>walk() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations nested under and including the given operation. </p>
<p>This method is selected for stage-aware callbacks that operate on Operation*.</p>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> *op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers. ">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00265">265</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="a8f528aa32da80acdb6358d90d9804e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f528aa32da80acdb6358d90d9804e93">&#9670;&nbsp;</a></span>walk() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classvoid.html">void</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for void returning callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk([](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers. ">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00282">282</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

</div>
</div>
<a id="aad27d69a99e3c3071714ffa42b3f7f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad27d69a99e3c3071714ffa42b3f7f41">&#9670;&nbsp;</a></span>walk() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, RetT&gt;::type mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for WalkReturn returning interruptible callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk(op, [](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers. ">WalkStage</a> &amp;stage) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00307">307</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, and <a class="el" href="Visitors_8cpp_source.html#l00024">walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Visitors_8h_source.html#l00227">walk()</a>.</p>

</div>
</div>
<a id="a37f32721e9d15092545cf9ea586d6d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f32721e9d15092545cf9ea586d6d7e">&#9670;&nbsp;</a></span>wrapIntegerMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::wrapIntegerMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> form. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00489">489</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00516">mlir::MemRefType::Builder::setMemorySpace()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a63c39ecb3618964551c0b29bc356b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c39ecb3618964551c0b29bc356b675">&#9670;&nbsp;</a></span>first_argument_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(first_argument_type(&amp;F::operator())) mlir::detail::first_argument_type(F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00108">108</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:04 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
