<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineValueConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1FlatAffineValueConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineValueConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each identifier can hav...">FlatAffineValueConstraints</a> represents an extension of IntegerPolyhedron where each identifier can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it.  
 <a href="classmlir_1_1FlatAffineValueConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__inherit__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_inherit__map" id="mlir_1_1FlatAffineValueConstraints_inherit__map">
<area shape="rect" id="node4" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain &#45;&gt; range) where &quot;domain&quot; and &quot;range&quot; a..." alt="" coords="34,259,205,285"/>
<area shape="rect" id="node2" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html" title="An IntegerPolyhedron represents the set of points from a PresburgerSpace that satisfy a list of affin..." alt="" coords="29,95,209,136"/>
<area shape="rect" id="node3" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ..." alt="" coords="29,5,209,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__coll__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_coll__map" id="mlir_1_1FlatAffineValueConstraints_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html" title="An IntegerPolyhedron represents the set of points from a PresburgerSpace that satisfy a list of affin..." alt="" coords="753,57,933,98"/>
<area shape="rect" id="node3" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ..." alt="" coords="372,57,552,98"/>
<area shape="rect" id="node4" href="classmlir_1_1presburger_1_1Matrix.html" title="This is a class to represent a resizable matrix. " alt="" coords="20,5,195,32"/>
<area shape="rect" id="node5" href="classmlir_1_1presburger_1_1PresburgerSpace.html" title="PresburgerSpace is the space of all possible values of a tuple of integer valued variables/identifier..." alt="" coords="5,57,209,98"/>
<area shape="rect" id="node6" href="classunsigned.html" title="unsigned" alt="" coords="67,123,148,149"/>
<area shape="rect" id="node7" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l llvm::Optional\&lt; mlir\l::Value \&gt;, 8 \&gt;" alt="" coords="764,123,923,179"/>
<area shape="rect" id="node8" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l T, N \&gt;" alt="" coords="388,130,536,171"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aaec51cfb6129c7a10dbf24740897cf1b">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:aaec51cfb6129c7a10dbf24740897cf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="#aaec51cfb6129c7a10dbf24740897cf1b">More...</a><br /></td></tr>
<tr class="separator:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a8ba51af6e35a94b11d73b5215a35ff7a">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims=0, <a class="el" href="classunsigned.html">unsigned</a> numSymbols=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="#a8ba51af6e35a94b11d73b5215a35ff7a">More...</a><br /></td></tr>
<tr class="separator:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a72f6f50a3c14fb9b64ff67fd3dfdc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1a72f6f50a3c14fb9b64ff67fd3dfdc1">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> &amp;fac, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="separator:a1a72f6f50a3c14fb9b64ff67fd3dfdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af048f5fb19968688b331c7bb0f8d9a4d">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="memdesc:af048f5fb19968688b331c7bb0f8d9a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these.  <a href="#af048f5fb19968688b331c7bb0f8d9a4d">More...</a><br /></td></tr>
<tr class="separator:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa32c847534d57cff25fdfa654778e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0aa32c847534d57cff25fdfa654778e0">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef)</td></tr>
<tr class="separator:a0aa32c847534d57cff25fdfa654778e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa812729dd90454f1c10517520dde9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3fa812729dd90454f1c10517520dde9a">FlatAffineValueConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a3fa812729dd90454f1c10517520dde9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="#a3fa812729dd90454f1c10517520dde9a">More...</a><br /></td></tr>
<tr class="separator:a3fa812729dd90454f1c10517520dde9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a948d12b8760154eed1281249b0f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4c5a948d12b8760154eed1281249b0f7">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:a4c5a948d12b8760154eed1281249b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">getKind</a> () const override</td></tr>
<tr class="memdesc:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of this FlatAffineConstraints.  <a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">More...</a><br /></td></tr>
<tr class="separator:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf03e7c9ae234b714e008160e7d3fba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aadf03e7c9ae234b714e008160e7d3fba">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:aadf03e7c9ae234b714e008160e7d3fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any existing data and reserves memory for the specified constraints.  <a href="#aadf03e7c9ae234b714e008160e7d3fba">More...</a><br /></td></tr>
<tr class="separator:aadf03e7c9ae234b714e008160e7d3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96f71bbc66b10ee4e5286483b7b141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad96f71bbc66b10ee4e5286483b7b141f">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims=0, <a class="el" href="classunsigned.html">unsigned</a> numSymbols=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="separator:ad96f71bbc66b10ee4e5286483b7b141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00fa2f257f1bd2c8ab11369207198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a58e00fa2f257f1bd2c8ab11369207198">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:a58e00fa2f257f1bd2c8ab11369207198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a94ce5a825b81e5767fef38db2329a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae3a94ce5a825b81e5767fef38db2329a">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:ae3a94ce5a825b81e5767fef38db2329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592860df144ae17907bccf79792e3f90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a592860df144ae17907bccf79792e3f90">clone</a> () const</td></tr>
<tr class="memdesc:a592860df144ae17907bccf79792e3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this object.  <a href="#a592860df144ae17907bccf79792e3f90">More...</a><br /></td></tr>
<tr class="separator:a592860df144ae17907bccf79792e3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85192d2ad28e90993950ec5c2598a3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a85192d2ad28e90993950ec5c2598a3e7">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a85192d2ad28e90993950ec5c2598a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps.  <a href="#a85192d2ad28e90993950ec5c2598a3e7">More...</a><br /></td></tr>
<tr class="separator:a85192d2ad28e90993950ec5c2598a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287995c9f074be38e7e1d76b39d93f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4287995c9f074be38e7e1d76b39d93f8">addDomainFromSliceMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a4287995c9f074be38e7e1d76b39d93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice.  <a href="#a4287995c9f074be38e7e1d76b39d93f8">More...</a><br /></td></tr>
<tr class="separator:a4287995c9f074be38e7e1d76b39d93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1b74b3973d5329fe7ec99a7d2f8ed31f">addAffineIfOpDomain</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints imposed by the <code>affine.if</code> operation.  <a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">More...</a><br /></td></tr>
<tr class="separator:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c982da57d4288f8cbe655848ecd204c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9c982da57d4288f8cbe655848ecd204c">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap)</td></tr>
<tr class="memdesc:a9c982da57d4288f8cbe655848ecd204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map.  <a href="#a9c982da57d4288f8cbe655848ecd204c">More...</a><br /></td></tr>
<tr class="separator:a9c982da57d4288f8cbe655848ecd204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae0266a236d1adc4c4a08e4d68b741e38">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae0266a236d1adc4c4a08e4d68b741e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands.  <a href="#ae0266a236d1adc4c4a08e4d68b741e38">More...</a><br /></td></tr>
<tr class="separator:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210341fc77fde46aedce6d2609f26738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a210341fc77fde46aedce6d2609f26738">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a210341fc77fde46aedce6d2609f26738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a210341fc77fde46aedce6d2609f26738">More...</a><br /></td></tr>
<tr class="separator:a210341fc77fde46aedce6d2609f26738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714f817973fece68d8223bf3d8d598de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a714f817973fece68d8223bf3d8d598de">getAsIntegerSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:a714f817973fece68d8223bf3d8d598de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint system as an integer set.  <a href="#a714f817973fece68d8223bf3d8d598de">More...</a><br /></td></tr>
<tr class="separator:a714f817973fece68d8223bf3d8d598de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad748b8fbd8eea446a0c378ca1cc65781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad748b8fbd8eea446a0c378ca1cc65781">getSliceBounds</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="memdesc:ad748b8fbd8eea446a0c378ca1cc65781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic).  <a href="#ad748b8fbd8eea446a0c378ca1cc65781">More...</a><br /></td></tr>
<tr class="separator:ad748b8fbd8eea446a0c378ca1cc65781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae5e83c0b271e4aff69e15b7bd96a1c4b">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this FlatAffineConstraints.  <a href="#ae5e83c0b271e4aff69e15b7bd96a1c4b">More...</a><br /></td></tr>
<tr class="separator:ae5e83c0b271e4aff69e15b7bd96a1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77763faa50eb0b78f95f0c195fe4bc49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a77763faa50eb0b78f95f0c195fe4bc49">getLowerAndUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:a77763faa50eb0b78f95f0c195fe4bc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num).  <a href="#a77763faa50eb0b78f95f0c195fe4bc49">More...</a><br /></td></tr>
<tr class="separator:a77763faa50eb0b78f95f0c195fe4bc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dbadcb953c32567a17ab1b662505e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac0dbadcb953c32567a17ab1b662505e0">getIneqAsAffineValueMap</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> ineqPos, <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;vmap, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ac0dbadcb953c32567a17ab1b662505e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands).  <a href="#ac0dbadcb953c32567a17ab1b662505e0">More...</a><br /></td></tr>
<tr class="separator:ac0dbadcb953c32567a17ab1b662505e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad38a7dd065a6c286b7ac84f0d1712c23">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>.  <a href="#ad38a7dd065a6c286b7ac84f0d1712c23">More...</a><br /></td></tr>
<tr class="separator:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab578264c931fe0f78eb0397943d032c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab578264c931fe0f78eb0397943d032c1">findId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classunsigned.html">unsigned</a> *pos) const</td></tr>
<tr class="memdesc:ab578264c931fe0f78eb0397943d032c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#ab578264c931fe0f78eb0397943d032c1">More...</a><br /></td></tr>
<tr class="separator:ab578264c931fe0f78eb0397943d032c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9d547b7f44aaa82af5d5ab1aeb74a42a">containsId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val) const</td></tr>
<tr class="memdesc:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise.  <a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">More...</a><br /></td></tr>
<tr class="separator:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda87dfc4340eb857e9bc9ab05141b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acda87dfc4340eb857e9bc9ab05141b16">swapId</a> (<a class="el" href="classunsigned.html">unsigned</a> posA, <a class="el" href="classunsigned.html">unsigned</a> posB) override</td></tr>
<tr class="memdesc:acda87dfc4340eb857e9bc9ab05141b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the posA^th identifier with the posB^th identifier.  <a href="#acda87dfc4340eb857e9bc9ab05141b16">More...</a><br /></td></tr>
<tr class="separator:acda87dfc4340eb857e9bc9ab05141b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7f6c30bd586070d7de8a397723f6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1b7f6c30bd586070d7de8a397723f6d6">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a1b7f6c30bd586070d7de8a397723f6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert identifiers of the specified kind at position <code>pos</code>.  <a href="#a1b7f6c30bd586070d7de8a397723f6d6">More...</a><br /></td></tr>
<tr class="separator:a1b7f6c30bd586070d7de8a397723f6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f0f181d5ce35bc7ca1ca687e6152f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1c9f0f181d5ce35bc7ca1ca687e6152f">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a1c9f0f181d5ce35bc7ca1ca687e6152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7a47c183d1fb0a0cf7cb26f8c9364d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#abe7a47c183d1fb0a0cf7cb26f8c9364d">insertLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:abe7a47c183d1fb0a0cf7cb26f8c9364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37618dd64a6fe91226805818e4139fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a37618dd64a6fe91226805818e4139fb9">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a37618dd64a6fe91226805818e4139fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c6ee75c0627beaeb455d0428636849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a99c6ee75c0627beaeb455d0428636849">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a99c6ee75c0627beaeb455d0428636849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd4c76f84cac8a1ca39fc04e1fa405f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3dd4c76f84cac8a1ca39fc04e1fa405f">insertId</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1) override</td></tr>
<tr class="memdesc:a3dd4c76f84cac8a1ca39fc04e1fa405f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>.  <a href="#a3dd4c76f84cac8a1ca39fc04e1fa405f">More...</a><br /></td></tr>
<tr class="separator:a3dd4c76f84cac8a1ca39fc04e1fa405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758f6a5c517265cf9a526012199bbeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad758f6a5c517265cf9a526012199bbeb">insertId</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:ad758f6a5c517265cf9a526012199bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a18111fe7ef555fcb69a9d6a175ea8cd8">appendDimId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append identifiers of the specified kind after the last identifier of that kind.  <a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">More...</a><br /></td></tr>
<tr class="separator:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a6f8c373783c6b808038d8c07e796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2c2a6f8c373783c6b808038d8c07e796">appendSymbolId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a2c2a6f8c373783c6b808038d8c07e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b30867dd5b0a1e96d796d6614cd14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a8f7b30867dd5b0a1e96d796d6614cd14">appendDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a8f7b30867dd5b0a1e96d796d6614cd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad400686ca3654177ac70e93e2f1b0a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad400686ca3654177ac70e93e2f1b0a45">appendSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:ad400686ca3654177ac70e93e2f1b0a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b41c2975c4022edde6450d7533fbabb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5b41c2975c4022edde6450d7533fbabb">appendLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a5b41c2975c4022edde6450d7533fbabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb732ee1febb93fddd889edbd75603c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1cb732ee1febb93fddd889edbd75603c">removeIdRange</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit) override</td></tr>
<tr class="memdesc:a1cb732ee1febb93fddd889edbd75603c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="#a1cb732ee1febb93fddd889edbd75603c">More...</a><br /></td></tr>
<tr class="separator:a1cb732ee1febb93fddd889edbd75603c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150883739ccac33efedf30dd36decfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1150883739ccac33efedf30dd36decfb">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a1150883739ccac33efedf30dd36decfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system.  <a href="#a1150883739ccac33efedf30dd36decfb">More...</a><br /></td></tr>
<tr class="separator:a1150883739ccac33efedf30dd36decfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1918c91299c463de63c843ee1f7628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5f1918c91299c463de63c843ee1f7628">computeAlignedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands) const</td></tr>
<tr class="memdesc:a5f1918c91299c463de63c843ee1f7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>map</code> with this constraint system based on <code>operands</code>.  <a href="#a5f1918c91299c463de63c843ee1f7628">More...</a><br /></td></tr>
<tr class="separator:a5f1918c91299c463de63c843ee1f7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad4dd23a785eb9a02c7f2ba43fa1aa7db">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="memdesc:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map.  <a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">More...</a><br /></td></tr>
<tr class="separator:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a79575e2c2693576f2c5a4accf0dcdab6">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a79575e2c2693576f2c5a4accf0dcdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a79575e2c2693576f2c5a4accf0dcdab6">More...</a><br /></td></tr>
<tr class="separator:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b004fb4978436d8c8cd8976803468c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a38b004fb4978436d8c8cd8976803468c">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a38b004fb4978436d8c8cd8976803468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol identifiers which are loop IVs to dim identifiers.  <a href="#a38b004fb4978436d8c8cd8976803468c">More...</a><br /></td></tr>
<tr class="separator:a38b004fb4978436d8c8cd8976803468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af0c35f1d2d81adf4ba06b84df578cd78">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:af0c35f1d2d81adf4ba06b84df578cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="#af0c35f1d2d81adf4ba06b84df578cd78">More...</a><br /></td></tr>
<tr class="separator:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad2eed02898a13f56e0bc2a470c2f89af">mergeAndAlignIdsWithOther</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *other)</td></tr>
<tr class="memdesc:ad2eed02898a13f56e0bc2a470c2f89af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>.  <a href="#ad2eed02898a13f56e0bc2a470c2f89af">More...</a><br /></td></tr>
<tr class="separator:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4fb1fae3bb100c4a3391e523712d2dba">areIdsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a4fb1fae3bb100c4a3391e523712d2dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order.  <a href="#a4fb1fae3bb100c4a3391e523712d2dba">More...</a><br /></td></tr>
<tr class="separator:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003266c0f9665b8b6dabd3df392cb6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a003266c0f9665b8b6dabd3df392cb6c1">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) override</td></tr>
<tr class="memdesc:a003266c0f9665b8b6dabd3df392cb6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each identifier can hav...">FlatAffineValueConstraints</a> with <code>other</code>.  <a href="#a003266c0f9665b8b6dabd3df392cb6c1">More...</a><br /></td></tr>
<tr class="separator:a003266c0f9665b8b6dabd3df392cb6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3896e7ab007a7bd1e8d1fb1fb098bdea">getValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">More...</a><br /></td></tr>
<tr class="separator:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39afc73e0776e068eb7331bcb349c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5e39afc73e0776e068eb7331bcb349c7">hasValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a5e39afc73e0776e068eb7331bcb349c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a5e39afc73e0776e068eb7331bcb349c7">More...</a><br /></td></tr>
<tr class="separator:a5e39afc73e0776e068eb7331bcb349c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a6a4ea45324a6c969a5b5062ec932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a321a6a4ea45324a6c969a5b5062ec932">hasValues</a> () const</td></tr>
<tr class="memdesc:a321a6a4ea45324a6c969a5b5062ec932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a321a6a4ea45324a6c969a5b5062ec932">More...</a><br /></td></tr>
<tr class="separator:a321a6a4ea45324a6c969a5b5062ec932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc790e216f3bbf7416308c04045094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9ccc790e216f3bbf7416308c04045094">getValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="memdesc:a9ccc790e216f3bbf7416308c04045094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Values associated with identifiers in range [start, end).  <a href="#a9ccc790e216f3bbf7416308c04045094">More...</a><br /></td></tr>
<tr class="separator:a9ccc790e216f3bbf7416308c04045094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5177b199aa494103835274f72907a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af5177b199aa494103835274f72907a8b">getAllValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="separator:af5177b199aa494103835274f72907a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7998d8323c934c13a86769ca8fad877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad7998d8323c934c13a86769ca8fad877">getMaybeValues</a> () const</td></tr>
<tr class="separator:ad7998d8323c934c13a86769ca8fad877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1e61e7f65a2ddd3fb4dc389d1fcd4467">getMaybeDimValues</a> () const</td></tr>
<tr class="separator:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464901024f611db773f2def48443b8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a464901024f611db773f2def48443b8f8">getMaybeSymbolValues</a> () const</td></tr>
<tr class="separator:a464901024f611db773f2def48443b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d108d7e10610afd56b9bc03598741f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0d108d7e10610afd56b9bc03598741f9">getMaybeDimAndSymbolValues</a> () const</td></tr>
<tr class="separator:a0d108d7e10610afd56b9bc03598741f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5eccad1d331cf5cfb78bf1f08fda7224">setValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a5eccad1d331cf5cfb78bf1f08fda7224">More...</a><br /></td></tr>
<tr class="separator:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c65d604a6089bb16894e4a9ee33bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a320c65d604a6089bb16894e4a9ee33bf">setValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>)</td></tr>
<tr class="memdesc:a320c65d604a6089bb16894e4a9ee33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Values associated with the identifiers in the range [start, end).  <a href="#a320c65d604a6089bb16894e4a9ee33bf">More...</a><br /></td></tr>
<tr class="separator:a320c65d604a6089bb16894e4a9ee33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5333879b7e111caf2c3371c0d0745296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5333879b7e111caf2c3371c0d0745296">mergeSymbolIds</a> (<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a5333879b7e111caf2c3371c0d0745296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique.  <a href="#a5333879b7e111caf2c3371c0d0745296">More...</a><br /></td></tr>
<tr class="separator:a5333879b7e111caf2c3371c0d0745296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">mlir::presburger::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a set reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">More...</a><br /></td></tr>
<tr class="separator:ac39dd991a3d29265b2f1d70390091139 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abc78cf32669bb6400f29c987a787f478">IntegerPolyhedron</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation with the specified number of dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#abc78cf32669bb6400f29c987a787f478">More...</a><br /></td></tr>
<tr class="separator:abc78cf32669bb6400f29c987a787f478 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ae519080bf303b244bde7d9d3b57ee13c">clone</a> () const</td></tr>
<tr class="separator:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3425db4a298e5d0f47f0a57f03e42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1presburger_1_1SymbolicLexMin.html">SymbolicLexMin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a54b3425db4a298e5d0f47f0a57f03e42">findSymbolicIntegerLexMin</a> () const</td></tr>
<tr class="memdesc:a54b3425db4a298e5d0f47f0a57f03e42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the symbolic integer lexmin of the polyhedron.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a54b3425db4a298e5d0f47f0a57f03e42">More...</a><br /></td></tr>
<tr class="separator:a54b3425db4a298e5d0f47f0a57f03e42 inherit pub_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">More...</a><br /></td></tr>
<tr class="separator:a720bc08a94b0b8e26ffffedebf24fc1c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abdf1aa5c32a8def0e57d15969aa912b0">IntegerRelation</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a relation with the specified number of dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abdf1aa5c32a8def0e57d15969aa912b0">More...</a><br /></td></tr>
<tr class="separator:abdf1aa5c32a8def0e57d15969aa912b0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25ac9112420b4edf3e954ba3e338b19 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae25ac9112420b4edf3e954ba3e338b19">~IntegerRelation</a> ()=default</td></tr>
<tr class="separator:ae25ac9112420b4edf3e954ba3e338b19 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0403155cdedc9be79ce9bb2ffecc24d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af0403155cdedc9be79ce9bb2ffecc24d">clone</a> () const</td></tr>
<tr class="separator:af0403155cdedc9be79ce9bb2ffecc24d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af1f51851031d9519a61befb0ed874f74">getSpace</a> () const</td></tr>
<tr class="memdesc:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying space.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af1f51851031d9519a61befb0ed874f74">More...</a><br /></td></tr>
<tr class="separator:af1f51851031d9519a61befb0ed874f74 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a171247eae0b907aa93572dbf3a95c2cb">getSpaceWithoutLocals</a> () const</td></tr>
<tr class="memdesc:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the space without locals.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a171247eae0b907aa93572dbf3a95c2cb">More...</a><br /></td></tr>
<tr class="separator:a171247eae0b907aa93572dbf3a95c2cb inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9025608bad072a18f4db2f1fa1b32786">append</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from <code>other</code> into <code>this</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9025608bad072a18f4db2f1fa1b32786">More...</a><br /></td></tr>
<tr class="separator:a9025608bad072a18f4db2f1fa1b32786 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7fa9f3b109d62586e5a968f80a2a6c1a">intersect</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> other) const</td></tr>
<tr class="memdesc:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the intersection of the two sets.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7fa9f3b109d62586e5a968f80a2a6c1a">More...</a><br /></td></tr>
<tr class="separator:a7fa9f3b109d62586e5a968f80a2a6c1a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a99ebeb474504c3a8dc714b1fc655c1f3">isEqual</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) const</td></tr>
<tr class="memdesc:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether <code>this</code> and <code>other</code> are equal.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a99ebeb474504c3a8dc714b1fc655c1f3">More...</a><br /></td></tr>
<tr class="separator:a99ebeb474504c3a8dc714b1fc655c1f3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aef11443a1bca6b41093edf742ebb53ab">isSubsetOf</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other) const</td></tr>
<tr class="memdesc:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this is a subset of the given <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aef11443a1bca6b41093edf742ebb53ab">More...</a><br /></td></tr>
<tr class="separator:aef11443a1bca6b41093edf742ebb53ab inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c45a382314df12c0a142473d0d0b90 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a70c45a382314df12c0a142473d0d0b90">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a70c45a382314df12c0a142473d0d0b90 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a70c45a382314df12c0a142473d0d0b90">More...</a><br /></td></tr>
<tr class="separator:a70c45a382314df12c0a142473d0d0b90 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd92326b96e637b6160e6172d5321df inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8cd92326b96e637b6160e6172d5321df">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a8cd92326b96e637b6160e6172d5321df inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d81c1d12f2b28501dfef7cd40172768 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2d81c1d12f2b28501dfef7cd40172768">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a2d81c1d12f2b28501dfef7cd40172768 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified inequality row and column.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a2d81c1d12f2b28501dfef7cd40172768">More...</a><br /></td></tr>
<tr class="separator:a2d81c1d12f2b28501dfef7cd40172768 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd705d472624dd3a370344d16e94fd8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6cd705d472624dd3a370344d16e94fd8">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a6cd705d472624dd3a370344d16e94fd8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1256e59f9472125b55ecf1af2b7c3d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae1256e59f9472125b55ecf1af2b7c3d1">getNumConstraints</a> () const</td></tr>
<tr class="separator:ae1256e59f9472125b55ecf1af2b7c3d1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8256d78b1e5d72024cbc77541649dc0d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8256d78b1e5d72024cbc77541649dc0d">getNumDomainIds</a> () const</td></tr>
<tr class="separator:a8256d78b1e5d72024cbc77541649dc0d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecddea9682bc6b50e894ff16df26a110 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aecddea9682bc6b50e894ff16df26a110">getNumRangeIds</a> () const</td></tr>
<tr class="separator:aecddea9682bc6b50e894ff16df26a110 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eb5b1fb749daba9b9af014d238dbed inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af6eb5b1fb749daba9b9af014d238dbed">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:af6eb5b1fb749daba9b9af014d238dbed inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b401e1a3010dfd70b4a01b37c6865 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2d2b401e1a3010dfd70b4a01b37c6865">getNumLocalIds</a> () const</td></tr>
<tr class="separator:a2d2b401e1a3010dfd70b4a01b37c6865 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f88b07d402e392ad0a84f64a00bf9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7e9f88b07d402e392ad0a84f64a00bf9">getNumDimIds</a> () const</td></tr>
<tr class="separator:a7e9f88b07d402e392ad0a84f64a00bf9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c705aee81797b4a3a7c394185655b5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af9c705aee81797b4a3a7c394185655b5">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:af9c705aee81797b4a3a7c394185655b5 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae28179f2dc89292ca7cc1fc29b628f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afae28179f2dc89292ca7cc1fc29b628f">getNumIds</a> () const</td></tr>
<tr class="separator:afae28179f2dc89292ca7cc1fc29b628f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abddc32ead0b239d7759bf9383bdbf114">getNumCols</a> () const</td></tr>
<tr class="memdesc:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abddc32ead0b239d7759bf9383bdbf114">More...</a><br /></td></tr>
<tr class="separator:abddc32ead0b239d7759bf9383bdbf114 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740f656b16fb2c3484898e46cb85785 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af740f656b16fb2c3484898e46cb85785">getNumEqualities</a> () const</td></tr>
<tr class="separator:af740f656b16fb2c3484898e46cb85785 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae878c389a2b7a93f7609c0818630efa4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae878c389a2b7a93f7609c0818630efa4">getNumInequalities</a> () const</td></tr>
<tr class="separator:ae878c389a2b7a93f7609c0818630efa4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228f32becb1c08c0b89bbec7ccf55ac4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a228f32becb1c08c0b89bbec7ccf55ac4">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:a228f32becb1c08c0b89bbec7ccf55ac4 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d483e98eff17961ab5e094eae7169 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa07d483e98eff17961ab5e094eae7169">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:aa07d483e98eff17961ab5e094eae7169 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bbacff8cfcd646992cba1270adcc3f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a59bbacff8cfcd646992cba1270adcc3f">getEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a59bbacff8cfcd646992cba1270adcc3f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71100dc37e6e03af0b74e2562be4d3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a5b71100dc37e6e03af0b74e2562be4d3">getInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a5b71100dc37e6e03af0b74e2562be4d3 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c1bb3a10376e058a380eea894715db inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a27c1bb3a10376e058a380eea894715db">getNumIdKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a27c1bb3a10376e058a380eea894715db inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ids of the specified kind.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a27c1bb3a10376e058a380eea894715db">More...</a><br /></td></tr>
<tr class="separator:a27c1bb3a10376e058a380eea894715db inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b94b57ec4d11e035d7d9659020314c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a54b94b57ec4d11e035d7d9659020314c">getIdKindOffset</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a54b94b57ec4d11e035d7d9659020314c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at which the specified kind of id starts.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a54b94b57ec4d11e035d7d9659020314c">More...</a><br /></td></tr>
<tr class="separator:a54b94b57ec4d11e035d7d9659020314c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148a660a6241c25e98cf64fdbf19eaf1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a148a660a6241c25e98cf64fdbf19eaf1">getIdKindEnd</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a148a660a6241c25e98cf64fdbf19eaf1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at Which the specified kind of id ends.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a148a660a6241c25e98cf64fdbf19eaf1">More...</a><br /></td></tr>
<tr class="separator:a148a660a6241c25e98cf64fdbf19eaf1 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58305607df576b183597c33213b8211 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa58305607df576b183597c33213b8211">getIdKindOverlap</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit) const</td></tr>
<tr class="memdesc:aa58305607df576b183597c33213b8211 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements of the specified kind in the range [idStart, idLimit).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa58305607df576b183597c33213b8211">More...</a><br /></td></tr>
<tr class="separator:aa58305607df576b183597c33213b8211 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3527cff7aa8eb32f69dc107ab23423e8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3527cff7aa8eb32f69dc107ab23423e8">getIdKindAt</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a3527cff7aa8eb32f69dc107ab23423e8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IdKind of the id at the specified position.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a3527cff7aa8eb32f69dc107ab23423e8">More...</a><br /></td></tr>
<tr class="separator:a3527cff7aa8eb32f69dc107ab23423e8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f431396270ed25e2ee49ed9cd32661 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a32f431396270ed25e2ee49ed9cd32661">getCounts</a> () const</td></tr>
<tr class="separator:a32f431396270ed25e2ee49ed9cd32661 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8498e71a2011cbb2f451e77a3673d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2ec8498e71a2011cbb2f451e77a3673d">truncate</a> (const <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a> &amp;counts)</td></tr>
<tr class="separator:a2ec8498e71a2011cbb2f451e77a3673d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddcee35d48242e722097f702465ec93 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#acddcee35d48242e722097f702465ec93">appendId</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:acddcee35d48242e722097f702465ec93 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <code>num</code> identifiers of the specified kind after the last identifier.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#acddcee35d48242e722097f702465ec93">More...</a><br /></td></tr>
<tr class="separator:acddcee35d48242e722097f702465ec93 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8f2f4187978c1f6ea96658645c2ade inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6e8f2f4187978c1f6ea96658645c2ade">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="memdesc:a6e8f2f4187978c1f6ea96658645c2ade inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a6e8f2f4187978c1f6ea96658645c2ade">More...</a><br /></td></tr>
<tr class="separator:a6e8f2f4187978c1f6ea96658645c2ade inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b0b41437c2cb642b13a40548242c7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac74b0b41437c2cb642b13a40548242c7">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="memdesc:ac74b0b41437c2cb642b13a40548242c7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an equality from the coefficients specified in <code>eq</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ac74b0b41437c2cb642b13a40548242c7">More...</a><br /></td></tr>
<tr class="separator:ac74b0b41437c2cb642b13a40548242c7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dcec7e3e9d7001c6b64907b0ba2e3e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a74dcec7e3e9d7001c6b64907b0ba2e3e">eliminateRedundantLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> posA, <a class="el" href="classunsigned.html">unsigned</a> posB)</td></tr>
<tr class="memdesc:a74dcec7e3e9d7001c6b64907b0ba2e3e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate the <code>posB^th</code> local identifier, replacing every instance of it with the <code>posA^th</code> local identifier.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a74dcec7e3e9d7001c6b64907b0ba2e3e">More...</a><br /></td></tr>
<tr class="separator:a74dcec7e3e9d7001c6b64907b0ba2e3e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfb71c6ec28ce064fef3b45122217c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a44cfb71c6ec28ce064fef3b45122217c">removeId</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a44cfb71c6ec28ce064fef3b45122217c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers of the specified kind with the specified pos (or within the specified range) from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a44cfb71c6ec28ce064fef3b45122217c">More...</a><br /></td></tr>
<tr class="separator:a44cfb71c6ec28ce064fef3b45122217c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2685c95eebb167d9f50e7386158ff96 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2685c95eebb167d9f50e7386158ff96">removeId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:aa2685c95eebb167d9f50e7386158ff96 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified identifier from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2685c95eebb167d9f50e7386158ff96">More...</a><br /></td></tr>
<tr class="separator:aa2685c95eebb167d9f50e7386158ff96 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee8ece23dbafb7d8589b5c276f6050e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3ee8ece23dbafb7d8589b5c276f6050e">removeEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a3ee8ece23dbafb7d8589b5c276f6050e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8131b65d378ed96aa21caddb24ea794 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac8131b65d378ed96aa21caddb24ea794">removeInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:ac8131b65d378ed96aa21caddb24ea794 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a366deee545d5b19e6c58720758316a09">removeEqualityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="memdesc:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the (in)equalities at positions [start, end).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a366deee545d5b19e6c58720758316a09">More...</a><br /></td></tr>
<tr class="separator:a366deee545d5b19e6c58720758316a09 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27195ff4c05a11fcbe8c2414737c5757 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a27195ff4c05a11fcbe8c2414737c5757">removeInequalityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="separator:a27195ff4c05a11fcbe8c2414737c5757 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MaybeOptimum.html">MaybeOptimum</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae2de214b91887bc196761e5882616171">findRationalLexMin</a> () const</td></tr>
<tr class="memdesc:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lexicographically minimum rational point satisfying the constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae2de214b91887bc196761e5882616171">More...</a><br /></td></tr>
<tr class="separator:ae2de214b91887bc196761e5882616171 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98759926cab73ace9e8be06e25999d4b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1MaybeOptimum.html">MaybeOptimum</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a98759926cab73ace9e8be06e25999d4b">findIntegerLexMin</a> () const</td></tr>
<tr class="memdesc:a98759926cab73ace9e8be06e25999d4b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but returns lexicographically minimal integer point.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a98759926cab73ace9e8be06e25999d4b">More...</a><br /></td></tr>
<tr class="separator:a98759926cab73ace9e8be06e25999d4b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7a1032a361b5d13e18746696b7f1af41">clearConstraints</a> ()</td></tr>
<tr class="memdesc:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all equalities and inequalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7a1032a361b5d13e18746696b7f1af41">More...</a><br /></td></tr>
<tr class="separator:a7a1032a361b5d13e18746696b7f1af41 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79ca05cec0a10c86f7426f6ee80296d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa79ca05cec0a10c86f7426f6ee80296d">setAndEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:aa79ca05cec0a10c86f7426f6ee80296d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>values.size()</code> identifiers starting at <code>po</code>s to the specified values and removes them.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa79ca05cec0a10c86f7426f6ee80296d">More...</a><br /></td></tr>
<tr class="separator:aa79ca05cec0a10c86f7426f6ee80296d inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ada75d3d4cb6bc695ad94626853e4b43e">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a> with <code>other</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ada75d3d4cb6bc695ad94626853e4b43e">More...</a><br /></td></tr>
<tr class="separator:ada75d3d4cb6bc695ad94626853e4b43e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abe4ff7884644e641bc5affa78ce467d8">getLowerAndUpperBoundIndices</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *lbIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *ubIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *eqIndices=nullptr, <a class="el" href="classunsigned.html">unsigned</a> offset=0, <a class="el" href="classunsigned.html">unsigned</a> num=0) const</td></tr>
<tr class="memdesc:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather positions of all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abe4ff7884644e641bc5affa78ce467d8">More...</a><br /></td></tr>
<tr class="separator:abe4ff7884644e641bc5affa78ce467d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abc9cb516db541340c61ca0ec56050220">isEmpty</a> () const</td></tr>
<tr class="memdesc:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for emptiness by performing variable elimination on all identifiers, running the GCD test on each equality constraint, and checking for invalid constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abc9cb516db541340c61ca0ec56050220">More...</a><br /></td></tr>
<tr class="separator:abc9cb516db541340c61ca0ec56050220 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a468688279f14239bf08f335ad4d962be">isEmptyByGCDTest</a> () const</td></tr>
<tr class="memdesc:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the GCD test on all equality constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a468688279f14239bf08f335ad4d962be">More...</a><br /></td></tr>
<tr class="separator:a468688279f14239bf08f335ad4d962be inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a5e4dc5a7b42cac79a365bbe7ef8851d0">isIntegerEmpty</a> () const</td></tr>
<tr class="memdesc:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of constraints is found to have no solution, false if a solution exists.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a5e4dc5a7b42cac79a365bbe7ef8851d0">More...</a><br /></td></tr>
<tr class="separator:a5e4dc5a7b42cac79a365bbe7ef8851d0 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ed78b98159cc85380412dd4c7f0eb31">getBoundedDirections</a> () const</td></tr>
<tr class="memdesc:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix where each row is a vector along which the polytope is bounded.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ed78b98159cc85380412dd4c7f0eb31">More...</a><br /></td></tr>
<tr class="separator:a7ed78b98159cc85380412dd4c7f0eb31 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c47be74b62b0c228993d20eee71191b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c47be74b62b0c228993d20eee71191b">findIntegerSample</a> () const</td></tr>
<tr class="memdesc:a1c47be74b62b0c228993d20eee71191b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1presburger_1_1Simplex.html" title="The Simplex class uses the Normal pivot rule and supports integer emptiness checks as well as detecti...">Simplex</a> for unbounded sets.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c47be74b62b0c228993d20eee71191b">More...</a><br /></td></tr>
<tr class="separator:a1c47be74b62b0c228993d20eee71191b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce0387bb7fafade89296ba7003481a9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1ce0387bb7fafade89296ba7003481a9">computeVolume</a> () const</td></tr>
<tr class="memdesc:a1ce0387bb7fafade89296ba7003481a9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an overapproximation of the number of integer points in the relation.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a1ce0387bb7fafade89296ba7003481a9">More...</a><br /></td></tr>
<tr class="separator:a1ce0387bb7fafade89296ba7003481a9 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109fc888484d9e1916d9fa64e035ff45 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a109fc888484d9e1916d9fa64e035ff45">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="memdesc:a109fc888484d9e1916d9fa64e035ff45 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point satisfies the constraints, or false otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a109fc888484d9e1916d9fa64e035ff45">More...</a><br /></td></tr>
<tr class="separator:a109fc888484d9e1916d9fa64e035ff45 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38130ad728d0ad6b0988a82ff6f9bce8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a38130ad728d0ad6b0988a82ff6f9bce8">containsPointNoLocal</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="memdesc:a38130ad728d0ad6b0988a82ff6f9bce8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the values of non-local ids, return a satisfying assignment to the local if one exists, or an empty optional otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a38130ad728d0ad6b0988a82ff6f9bce8">More...</a><br /></td></tr>
<tr class="separator:a38130ad728d0ad6b0988a82ff6f9bce8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac004c211419251119dad440e81efd7d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ac004c211419251119dad440e81efd7d8">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators, std::vector&lt; <a class="el" href="structmlir_1_1presburger_1_1MaybeLocalRepr.html">MaybeLocalRepr</a> &gt; &amp;repr) const</td></tr>
<tr class="memdesc:ac004c211419251119dad440e81efd7d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find equality and pairs of inequality contraints identified by their position indices, using which an explicit representation for each local variable can be computed.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ac004c211419251119dad440e81efd7d8">More...</a><br /></td></tr>
<tr class="separator:ac004c211419251119dad440e81efd7d8 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3da9fb643b0bdfcab27b9163077834 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7c3da9fb643b0bdfcab27b9163077834">getLocalReprs</a> (std::vector&lt; <a class="el" href="structmlir_1_1presburger_1_1MaybeLocalRepr.html">MaybeLocalRepr</a> &gt; &amp;repr) const</td></tr>
<tr class="separator:a7c3da9fb643b0bdfcab27b9163077834 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efa59e4c3c0d8758f27c78cde99cb88 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0efa59e4c3c0d8758f27c78cde99cb88">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators) const</td></tr>
<tr class="separator:a0efa59e4c3c0d8758f27c78cde99cb88 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9747540e54eecf066947bdd8a47af165 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9747540e54eecf066947bdd8a47af165">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a9747540e54eecf066947bdd8a47af165 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified identifier.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9747540e54eecf066947bdd8a47af165">More...</a><br /></td></tr>
<tr class="separator:a9747540e54eecf066947bdd8a47af165 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60380cc138dca812196f2abd8d1a740b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a60380cc138dca812196f2abd8d1a740b">addBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a60380cc138dca812196f2abd8d1a740b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified expression.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a60380cc138dca812196f2abd8d1a740b">More...</a><br /></td></tr>
<tr class="separator:a60380cc138dca812196f2abd8d1a740b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8e2a91e9e4f2a441251b19504d58e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8aa8e2a91e9e4f2a441251b19504d58e">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="memdesc:a8aa8e2a91e9e4f2a441251b19504d58e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8aa8e2a91e9e4f2a441251b19504d58e">More...</a><br /></td></tr>
<tr class="separator:a8aa8e2a91e9e4f2a441251b19504d58e inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#adabbad10f2e180e48ad4e83b0ccf7b2f">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#adabbad10f2e180e48ad4e83b0ccf7b2f">More...</a><br /></td></tr>
<tr class="separator:adabbad10f2e180e48ad4e83b0ccf7b2f inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdfc93dbe7dc28f69e638426bb6d3b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6bdfc93dbe7dc28f69e638426bb6d3b6">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a6bdfc93dbe7dc28f69e638426bb6d3b6 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f82d26f8a1c0ff397f5c44365c8656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a25f82d26f8a1c0ff397f5c44365c8656">constantFoldId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a25f82d26f8a1c0ff397f5c44365c8656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a25f82d26f8a1c0ff397f5c44365c8656">More...</a><br /></td></tr>
<tr class="separator:a25f82d26f8a1c0ff397f5c44365c8656 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd234f5f99a14127ec7719e7254bcf1b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afd234f5f99a14127ec7719e7254bcf1b">constantFoldIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:afd234f5f99a14127ec7719e7254bcf1b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls <code>constantFoldId</code> for the specified range of identifiers, <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#afd234f5f99a14127ec7719e7254bcf1b">More...</a><br /></td></tr>
<tr class="separator:afd234f5f99a14127ec7719e7254bcf1b inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a719304f13882671a30b3cf814c11a157">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a719304f13882671a30b3cf814c11a157">More...</a><br /></td></tr>
<tr class="separator:a719304f13882671a30b3cf814c11a157 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff15778759dee3fa9ae9f75f839702a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a3ff15778759dee3fa9ae9f75f839702a">getConstantBoundOnDimSize</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minLbPos=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:a3ff15778759dee3fa9ae9f75f839702a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a3ff15778759dee3fa9ae9f75f839702a">More...</a><br /></td></tr>
<tr class="separator:a3ff15778759dee3fa9ae9f75f839702a inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0c87f8ea18f5827c6e66a30587e6cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b0c87f8ea18f5827c6e66a30587e6cf">getConstantBound</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a8b0c87f8ea18f5827c6e66a30587e6cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant bound for the pos^th identifier if there is one; None otherwise.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b0c87f8ea18f5827c6e66a30587e6cf">More...</a><br /></td></tr>
<tr class="separator:a8b0c87f8ea18f5827c6e66a30587e6cf inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a104c727179405d556154c39affb331b2">removeIndependentConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes constraints that are independent of (i.e., do not have a coefficient) identifiers in the range [pos, pos + num).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a104c727179405d556154c39affb331b2">More...</a><br /></td></tr>
<tr class="separator:a104c727179405d556154c39affb331b2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7330cb99e897efa1d60f9698a85e8837">isHyperRectangular</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num) const</td></tr>
<tr class="memdesc:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a7330cb99e897efa1d60f9698a85e8837">More...</a><br /></td></tr>
<tr class="separator:a7330cb99e897efa1d60f9698a85e8837 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c7092c24389f40c685372f3fa1e0edc">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a1c7092c24389f40c685372f3fa1e0edc">More...</a><br /></td></tr>
<tr class="separator:a1c7092c24389f40c685372f3fa1e0edc inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa7fccd1b94334c1054cfa10e920ee942">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa7fccd1b94334c1054cfa10e920ee942">More...</a><br /></td></tr>
<tr class="separator:aa7fccd1b94334c1054cfa10e920ee942 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2ddc803d4b5a2cad1ff6e117940cdf2">removeRedundantConstraints</a> ()</td></tr>
<tr class="memdesc:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant constraints using <a class="el" href="classmlir_1_1presburger_1_1Simplex.html" title="The Simplex class uses the Normal pivot rule and supports integer emptiness checks as well as detecti...">Simplex</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aa2ddc803d4b5a2cad1ff6e117940cdf2">More...</a><br /></td></tr>
<tr class="separator:aa2ddc803d4b5a2cad1ff6e117940cdf2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cffb0333901dbef827d4a550880177c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a4cffb0333901dbef827d4a550880177c">removeDuplicateDivs</a> ()</td></tr>
<tr class="separator:a4cffb0333901dbef827d4a550880177c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2efbdcf3d1c7aa4bb5da34fd13c48c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#adc2efbdcf3d1c7aa4bb5da34fd13c48c">convertIdKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> srcKind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit, <a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> dstKind)</td></tr>
<tr class="memdesc:adc2efbdcf3d1c7aa4bb5da34fd13c48c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts identifiers of kind srcKind in the range [idStart, idLimit) to variables of kind dstKind and placed after all the other variables of kind dstKind.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#adc2efbdcf3d1c7aa4bb5da34fd13c48c">More...</a><br /></td></tr>
<tr class="separator:adc2efbdcf3d1c7aa4bb5da34fd13c48c inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f71304c39ee39a9d6c645e37648424 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a58f71304c39ee39a9d6c645e37648424">convertToLocal</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="separator:a58f71304c39ee39a9d6c645e37648424 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641853649c409c4dbd362187f1f16e7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af641853649c409c4dbd362187f1f16e7">mergeLocalIds</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;other)</td></tr>
<tr class="memdesc:af641853649c409c4dbd362187f1f16e7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional local ids to the sets such that they both have the union of the local ids in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af641853649c409c4dbd362187f1f16e7">More...</a><br /></td></tr>
<tr class="separator:af641853649c409c4dbd362187f1f16e7 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9f8da36de3e0a65e95962f4be956c719">setDimSymbolSeparation</a> (<a class="el" href="classunsigned.html">unsigned</a> newSymbolCount)</td></tr>
<tr class="memdesc:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9f8da36de3e0a65e95962f4be956c719">More...</a><br /></td></tr>
<tr class="separator:a9f8da36de3e0a65e95962f4be956c719 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa3bb83ac8ceaee9d417b70d738e2c2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a5aa3bb83ac8ceaee9d417b70d738e2c2">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:a5aa3bb83ac8ceaee9d417b70d738e2c2 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea7be3fe92622dbf73699a113ea8a32 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a7ea7be3fe92622dbf73699a113ea8a32">dump</a> () const</td></tr>
<tr class="separator:a7ea7be3fe92622dbf73699a113ea8a32 inherit pub_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acfee23f39d31078e69df752b973f53b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acfee23f39d31078e69df752b973f53b6">getHyperrectangular</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs)</td></tr>
<tr class="separator:acfee23f39d31078e69df752b973f53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407729200db5589c49636b07bc2fd359"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a407729200db5589c49636b07bc2fd359">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a407729200db5589c49636b07bc2fd359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">mlir::presburger::IntegerPolyhedron</a></td></tr>
<tr class="memitem:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html">IntegerPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#af18fc68c685606bccf0edb704eeaa219">getUniverse</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#af18fc68c685606bccf0edb704eeaa219">More...</a><br /></td></tr>
<tr class="separator:af18fc68c685606bccf0edb704eeaa219 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f190eec942f4e6154a5be167baf6f42 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a3f190eec942f4e6154a5be167baf6f42">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a3f190eec942f4e6154a5be167baf6f42 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b410fc634df082bfe60882342a295f6">getUniverse</a> (const <a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a> &amp;<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a>)</td></tr>
<tr class="memdesc:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a8b410fc634df082bfe60882342a295f6">More...</a><br /></td></tr>
<tr class="separator:a8b410fc634df082bfe60882342a295f6 inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3b75527052c848183b6f0e6750bfd inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cf3b75527052c848183b6f0e6750bfd">classof</a> (const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> *cst)</td></tr>
<tr class="separator:a2cf3b75527052c848183b6f0e6750bfd inherit pub_static_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aea7189a24ab09944dbd4d5cc61bc795d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aea7189a24ab09944dbd4d5cc61bc795d">IdKind</a> = <a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a></td></tr>
<tr class="separator:aea7189a24ab09944dbd4d5cc61bc795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3202cddcf31d0798de72cac6742248b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">hasConsistentState</a> () const override</td></tr>
<tr class="memdesc:a3202cddcf31d0798de72cac6742248b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise.  <a href="#a3202cddcf31d0798de72cac6742248b0">More...</a><br /></td></tr>
<tr class="separator:a3202cddcf31d0798de72cac6742248b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33e9ae86390c8f29078675dd53870e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aec33e9ae86390c8f29078675dd53870e">flattenAlignedMapAndMergeLocals</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:aec33e9ae86390c8f29078675dd53870e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map that is aligned with this constraint system:  <a href="#aec33e9ae86390c8f29078675dd53870e">More...</a><br /></td></tr>
<tr class="separator:aec33e9ae86390c8f29078675dd53870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3ca6765edfa5677b1b23130e0187c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">fourierMotzkinEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, bool darkShadow=false, bool *isResultIntegerExact=nullptr) override</td></tr>
<tr class="memdesc:a30b3ca6765edfa5677b1b23130e0187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier.  <a href="#a30b3ca6765edfa5677b1b23130e0187c">More...</a><br /></td></tr>
<tr class="separator:a30b3ca6765edfa5677b1b23130e0187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab22f9e8a2b6d20dbe52378823edc5a9c">printSpace</a> (raw_ostream &amp;os) const override</td></tr>
<tr class="memdesc:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of constraints, dimensions, symbols and locals in the FlatAffineConstraints.  <a href="#ab22f9e8a2b6d20dbe52378823edc5a9c">More...</a><br /></td></tr>
<tr class="separator:ab22f9e8a2b6d20dbe52378823edc5a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a70fa88c51b843b4c4a1a72028172198e">hasInvalidConstraint</a> () const</td></tr>
<tr class="memdesc:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a70fa88c51b843b4c4a1a72028172198e">More...</a><br /></td></tr>
<tr class="separator:a70fa88c51b843b4c4a1a72028172198e inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6165f90789a6f7ea7bada6fc2ac906ba inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:a6165f90789a6f7ea7bada6fc2ac906ba inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a6165f90789a6f7ea7bada6fc2ac906ba">computeConstantLowerOrUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a6165f90789a6f7ea7bada6fc2ac906ba inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a6165f90789a6f7ea7bada6fc2ac906ba">More...</a><br /></td></tr>
<tr class="separator:a6165f90789a6f7ea7bada6fc2ac906ba inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6e602493042790ed536311fcdb5d62 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9d6e602493042790ed536311fcdb5d62">gaussianEliminateId</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="memdesc:a9d6e602493042790ed536311fcdb5d62 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates a single identifier at <code>position</code> from equality and inequality constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9d6e602493042790ed536311fcdb5d62">More...</a><br /></td></tr>
<tr class="separator:a9d6e602493042790ed536311fcdb5d62 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ade159612a3056ec58ea0940e116c9bfb">removeRedundantLocalVars</a> ()</td></tr>
<tr class="memdesc:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes local variables using equalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ade159612a3056ec58ea0940e116c9bfb">More...</a><br /></td></tr>
<tr class="separator:ade159612a3056ec58ea0940e116c9bfb inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b30de230109ef6200a7e05613d1b2b inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae9b30de230109ef6200a7e05613d1b2b">gaussianEliminateIds</a> (<a class="el" href="classunsigned.html">unsigned</a> posStart, <a class="el" href="classunsigned.html">unsigned</a> posLimit)</td></tr>
<tr class="memdesc:ae9b30de230109ef6200a7e05613d1b2b inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates identifiers from equality and inequality constraints in column range [posStart, posLimit).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae9b30de230109ef6200a7e05613d1b2b">More...</a><br /></td></tr>
<tr class="separator:ae9b30de230109ef6200a7e05613d1b2b inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#abea6bf84ef57c39c622dad8439c1e3fc">gcdTightenInequalities</a> ()</td></tr>
<tr class="memdesc:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tightens inequalities given that we are dealing with integer spaces.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#abea6bf84ef57c39c622dad8439c1e3fc">More...</a><br /></td></tr>
<tr class="separator:abea6bf84ef57c39c622dad8439c1e3fc inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cbb719141f0ade802f8c5ddb4f081af">normalizeConstraintsByGCD</a> ()</td></tr>
<tr class="memdesc:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized each constraints by the GCD of its coefficients.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a2cbb719141f0ade802f8c5ddb4f081af">More...</a><br /></td></tr>
<tr class="separator:a2cbb719141f0ade802f8c5ddb4f081af inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aeb673542ed4e593652993f30164c3867">findConstraintWithNonZeroAt</a> (<a class="el" href="classunsigned.html">unsigned</a> colIdx, bool isEq, <a class="el" href="classunsigned.html">unsigned</a> *rowIdx) const</td></tr>
<tr class="memdesc:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a constraint with a non-zero coefficient at <code>colIdx</code> in equality (isEq=true) or inequality (isEq=false) constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#aeb673542ed4e593652993f30164c3867">More...</a><br /></td></tr>
<tr class="separator:aeb673542ed4e593652993f30164c3867 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#af7b048e5f43d1b7a764f296999befcd0">isColZero</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th column is all zero for both inequalities and equalities.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#af7b048e5f43d1b7a764f296999befcd0">More...</a><br /></td></tr>
<tr class="separator:af7b048e5f43d1b7a764f296999befcd0 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9f0b6fa8cdec9cd7fce252562ef6c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9e9f0b6fa8cdec9cd7fce252562ef6c6">removeIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="memdesc:a9e9f0b6fa8cdec9cd7fce252562ef6c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9e9f0b6fa8cdec9cd7fce252562ef6c6">More...</a><br /></td></tr>
<tr class="separator:a9e9f0b6fa8cdec9cd7fce252562ef6c6 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e94bf1fc913d3bbaec2ee31770510 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a0b8e94bf1fc913d3bbaec2ee31770510">truncateIdKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:a0b8e94bf1fc913d3bbaec2ee31770510 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the ids of the specified kind to the specified number by dropping some ids at the end.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a0b8e94bf1fc913d3bbaec2ee31770510">More...</a><br /></td></tr>
<tr class="separator:a0b8e94bf1fc913d3bbaec2ee31770510 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f38796e4e1d4f213cce0469a3cb47 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9a0f38796e4e1d4f213cce0469a3cb47">truncateIdKind</a> (<a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">IdKind</a> kind, const <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html">CountsSnapshot</a> &amp;counts)</td></tr>
<tr class="memdesc:a9a0f38796e4e1d4f213cce0469a3cb47 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the ids to the number in the space of the specified <a class="el" href="structmlir_1_1presburger_1_1IntegerRelation_1_1CountsSnapshot.html" title="The struct CountsSnapshot stores the count of each IdKind, and also of each constraint type...">CountsSnapshot</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a9a0f38796e4e1d4f213cce0469a3cb47">More...</a><br /></td></tr>
<tr class="separator:a9a0f38796e4e1d4f213cce0469a3cb47 inherit pro_methods_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2662045a8d845c7cf9aa9516af6ea914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a></td></tr>
<tr class="memdesc:a2662045a8d845c7cf9aa9516af6ea914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns.  <a href="#a2662045a8d845c7cf9aa9516af6ea914">More...</a><br /></td></tr>
<tr class="separator:a2662045a8d845c7cf9aa9516af6ea914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a80fe301a2d8c1e77d84894aaaae00db8 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1PresburgerSpace.html">PresburgerSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a80fe301a2d8c1e77d84894aaaae00db8">space</a></td></tr>
<tr class="separator:a80fe301a2d8c1e77d84894aaaae00db8 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a20ca1194b199db265fd2d33fa19cdc65">equalities</a></td></tr>
<tr class="memdesc:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine equalities (in == 0 form).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a20ca1194b199db265fd2d33fa19cdc65">More...</a><br /></td></tr>
<tr class="separator:a20ca1194b199db265fd2d33fa19cdc65 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae4a45bb310b47515f4468e5aaee65516">inequalities</a></td></tr>
<tr class="memdesc:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine inequalities (in &gt;= 0 form).  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ae4a45bb310b47515f4468e5aaee65516">More...</a><br /></td></tr>
<tr class="separator:ae4a45bb310b47515f4468e5aaee65516 inherit pro_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a02a605e2b5fca97f0ea2af1f24a24703 inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a> { <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a5d3c39d196a997e225b4f3ee3e1da745">Kind::FlatAffineConstraints</a>, 
<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">Kind::FlatAffineValueConstraints</a>, 
<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a817d2f7f1430fc50808ae3809af385a3">Kind::IntegerRelation</a>, 
<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703aaaa02ac14b63aada677a5426f1782df9">Kind::IntegerPolyhedron</a>
 }<tr class="memdesc:a02a605e2b5fca97f0ea2af1f24a24703"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes of <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html" title="An IntegerRelation represents the set of points from a PresburgerSpace that satisfy a list of affine ...">IntegerRelation</a>.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a02a605e2b5fca97f0ea2af1f24a24703 inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad152d6d3a3f2c46a702bd1b59ecdaabc inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a> { <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabca77f105202929db0df2f3d3c1cb5e7f2a">EQ</a>, 
<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabcaa3e8dc9a8b5853177508d80ebf42d555">LB</a>, 
<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabcaa451545b93620cf26d5bdffb0939d3d0">UB</a>
 }<tr class="memdesc:ad152d6d3a3f2c46a702bd1b59ecdaabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of bound: equal, lower bound or upper bound.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad152d6d3a3f2c46a702bd1b59ecdaabc inherit pub_types_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">mlir::presburger::IntegerRelation</a></td></tr>
<tr class="memitem:a204f4a6defe5077b451f6975d7ccf8d6 inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a204f4a6defe5077b451f6975d7ccf8d6">kExplosionFactor</a> = 32</td></tr>
<tr class="memdesc:a204f4a6defe5077b451f6975d7ccf8d6 inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parameter that controls detection of an unrealistic number of constraints.  <a href="classmlir_1_1presburger_1_1IntegerRelation.html#a204f4a6defe5077b451f6975d7ccf8d6">More...</a><br /></td></tr>
<tr class="separator:a204f4a6defe5077b451f6975d7ccf8d6 inherit pro_static_attribs_classmlir_1_1presburger_1_1IntegerRelation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each identifier can hav...">FlatAffineValueConstraints</a> represents an extension of IntegerPolyhedron where each identifier can have an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00037">37</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aea7189a24ab09944dbd4d5cc61bc795d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7189a24ab09944dbd4d5cc61bc795d">&#9670;&nbsp;</a></span>IdKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">mlir::FlatAffineValueConstraints::IdKind</a> =  <a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00442">442</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaec51cfb6129c7a10dbf24740897cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec51cfb6129c7a10dbf24740897cf1b">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00041">41</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00074">mlir::presburger::PresburgerSpace::getSetSpace()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00630">mlir::presburger::IntegerPolyhedron::IntegerPolyhedron()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00491">mlir::FlatAffineRelation::FlatAffineRelation()</a>, <a class="el" href="AffineStructures_8h_source.html#l00061">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="a8ba51af6e35a94b11d73b5215a35ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba51af6e35a94b11d73b5215a35ff7a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00061">61</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="a1a72f6f50a3c14fb9b64ff67fd3dfdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a72f6f50a3c14fb9b64ff67fd3dfdc1">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ac39dd991a3d29265b2f1d70390091139">IntegerPolyhedron</a> &amp;&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00070">70</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00198">getHyperrectangular()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00630">mlir::presburger::IntegerPolyhedron::IntegerPolyhedron()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

</div>
</div>
<a id="af048f5fb19968688b331c7bb0f8d9a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af048f5fb19968688b331c7bb0f8d9a4d">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these. </p>
<p>The constructed system will only include equalities. </p>

</div>
</div>
<a id="a0aa32c847534d57cff25fdfa654778e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa32c847534d57cff25fdfa654778e0">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa812729dd90454f1c10517520dde9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa812729dd90454f1c10517520dde9a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00152">152</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00184">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00191">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00041">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00169">mlir::presburger::IntegerRelation::getNumIdKind()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a12e7fe91c72844f54ad9361f279ad2b3a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger::None</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

</div>
</div>
<a id="a4c5a948d12b8760154eed1281249b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a948d12b8760154eed1281249b0f7">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85192d2ad28e90993950ec5c2598a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85192d2ad28e90993950ec5c2598a3e7">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps. </p>
<p>The right identifier is first looked up using <code>forOp</code>'s <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new identifiers that are found in the bound operands of the 'affine.for' operation are added as trailing identifiers (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00587">587</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00184">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01243">mlir::presburger::IntegerRelation::addLocalFloorDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00639">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">addSliceBounds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1b74b3973d5329fe7ec99a7d2f8ed31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">&#9670;&nbsp;</a></span>addAffineIfOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addAffineIfOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints imposed by the <code>affine.if</code> operation. </p>
<p>These constraints are collected from the <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> attached to the given <code>affine.if</code> instance argument (<code>ifOp</code>). It is asserted that: 1) The <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> of the given <code>affine.if</code> instance should not contain semi-affine expressions, 2) The columns of the constraint system created from <code>ifOp</code> should match the columns in the current one regarding numbers and values. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00688">688</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00041">mlir::presburger::IntegerRelation::append()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00439">mergeAndAlignIdsWithOther()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>.</p>

</div>
</div>
<a id="a9c982da57d4288f8cbe655848ecd204c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c982da57d4288f8cbe655848ecd204c">&#9670;&nbsp;</a></span>addBound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. Note: The dimensions/symbols of this FlatAffineConstraints must match the dimensions/symbols of the affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01160">1160</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00184">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00191">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01240">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00639">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">addSliceBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">mlir::getMemRefSizeInBytes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">mlir::normalizeMemRefType()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00317">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="ae0266a236d1adc4c4a08e4d68b741e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0266a236d1adc4c4a08e4d68b741e38">&#9670;&nbsp;</a></span>addBound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01240">1240</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00873">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01208">computeAlignedMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">mlir::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">mlir::simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a210341fc77fde46aedce6d2609f26738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210341fc77fde46aedce6d2609f26738">&#9670;&nbsp;</a></span>addBound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ad152d6d3a3f2c46a702bd1b59ecdaabc">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01330">1330</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>.</p>

</div>
</div>
<a id="a4287995c9f074be38e7e1d76b39d93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287995c9f074be38e7e1d76b39d93f8">&#9670;&nbsp;</a></span>addDomainFromSliceMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addDomainFromSliceMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice. </p>
<p>Every pair (<code>lbMaps[i]</code>, <code>ubMaps[i]</code>) describes the bounds of a loop in the nest, sorted outer-to-inner. <code>operands</code> contains the bound operands for a single bound map. All the bound maps will use the same bound operands. Note that some loops described by a computation slice might not exist yet in the IR so the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to those dimension identifiers might be empty. For that reason, this method doesn't perform <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> look-ups to retrieve the dimension identifier positions. Instead, it assumes the position of the dim identifiers in the constraint system is the same as the position of the loop in the loop nest. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00639">639</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01946">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00312">mlir::AffineDimExpr::getPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1150883739ccac33efedf30dd36decfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150883739ccac33efedf30dd36decfb">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system. </p>
<p><code>val</code> has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The identifier is added to the end of the existing dims or symbols. Additional information on the identifier is extracted from the IR and added to the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00564">564</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00272">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00278">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01319">containsId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01946">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01940">mlir::isForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00229">mlir::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01240">addBound()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>.</p>

</div>
</div>
<a id="ad38a7dd065a6c286b7ac84f0d1712c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38a7dd065a6c286b7ac84f0d1712c23">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>. </p>
<p>Note that both lower/upper bounds share the same operand list <code>operands</code>. This function assumes <code>values.size</code> == <code>lbMaps.size</code> == <code>ubMaps.size</code>. Note that both lower/upper bounds use operands from <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01264">1264</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01946">mlir::getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="a18111fe7ef555fcb69a9d6a175ea8cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">&#9670;&nbsp;</a></span>appendDimId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append identifiers of the specified kind after the last identifier of that kind. </p>
<p>The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the position of the first added column.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00272">272</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00203">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">mlir::getRelationFromMap()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00317">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a8f7b30867dd5b0a1e96d796d6614cd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7b30867dd5b0a1e96d796d6614cd14">&#9670;&nbsp;</a></span>appendDimId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::appendDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00285">285</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00179">mlir::presburger::IntegerRelation::appendId()</a>.</p>

</div>
</div>
<a id="a5b41c2975c4022edde6450d7533fbabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b41c2975c4022edde6450d7533fbabb">&#9670;&nbsp;</a></span>appendLocalId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::appendLocalId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00291">291</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00179">mlir::presburger::IntegerRelation::appendId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00335">areIdsAlignedWithOther()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01351">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00445">composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01208">computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00551">convertLoopIVSymbolsToDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00058">mlir::presburger::IntegerRelation::IntegerRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00439">mergeAndAlignIdsWithOther()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01377">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00708">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01385">unionBoundingBox()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01136">flattenAlignedMapAndMergeLocals()</a>.</p>

</div>
</div>
<a id="a2c2a6f8c373783c6b808038d8c07e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a6f8c373783c6b808038d8c07e796">&#9670;&nbsp;</a></span>appendSymbolId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00278">278</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="ad400686ca3654177ac70e93e2f1b0a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad400686ca3654177ac70e93e2f1b0a45">&#9670;&nbsp;</a></span>appendSymbolId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::appendSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00288">288</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00179">mlir::presburger::IntegerRelation::appendId()</a>.</p>

</div>
</div>
<a id="a4fb1fae3bb100c4a3391e523712d2dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb1fae3bb100c4a3391e523712d2dba">&#9670;&nbsp;</a></span>areIdsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::areIdsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order. </p>
<p>Calls areIdsAligned to check if two constraint systems have the same set of identifiers in the same order.</p>
<p>Returns false otherwise.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00335">335</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00325">areIdsAligned()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a407729200db5589c49636b07bc2fd359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407729200db5589c49636b07bc2fd359">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::FlatAffineValueConstraints::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a720bc08a94b0b8e26ffffedebf24fc1c">IntegerRelation</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00108">108</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00688">addAffineIfOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00639">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">addSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00147">clone()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01319">containsId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::presburger::IntegerRelation::FlatAffineValueConstraints</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01484">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01438">getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00878">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00966">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01325">swapId()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

</div>
</div>
<a id="a003266c0f9665b8b6dabd3df392cb6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003266c0f9665b8b6dabd3df392cb6c1">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints represents an extension of IntegerPolyhedron where each identifier can hav...">FlatAffineValueConstraints</a> with <code>other</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01351">1351</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a12e7fe91c72844f54ad9361f279ad2b3a6adf97f83acf6453d4a6a4b1070f3754">mlir::presburger::None</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="a592860df144ae17907bccf79792e3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592860df144ae17907bccf79792e3f90">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt; FlatAffineValueConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this object. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00147">147</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>.</p>

</div>
</div>
<a id="ad4dd23a785eb9a02c7f2ba43fa1aa7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. </p>
<p>Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s are used to look up the right positions in the FlatAffineConstraints with which to associate. Every operand of vMap should have a matching dim/symbol column in this constraint system (with the same associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00445">445</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00453">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01208">computeAlignedMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="ae5e83c0b271e4aff69e15b7bd96a1c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e83c0b271e4aff69e15b7bd96a1c4b">&#9670;&nbsp;</a></span>composeMatchingMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMatchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this FlatAffineConstraints. </p>
<p>The results of the map <code>other</code> are added as the leading dimensions of this constraint system. Returns failure if <code>other</code> is a semi-affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00453">453</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00184">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01136">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00262">insertDimId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00445">composeMap()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a5f1918c91299c463de63c843ee1f7628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1918c91299c463de63c843ee1f7628">&#9670;&nbsp;</a></span>computeAlignedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> FlatAffineValueConstraints::computeAlignedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>map</code> with this constraint system based on <code>operands</code>. </p>
<p>Each operand must already have a corresponding dim/symbol in this constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01208">1208</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01537">mlir::alignAffineMapWithValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00177">mlir::presburger::IntegerRelation::getIdKindEnd()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00172">mlir::presburger::IntegerRelation::getIdKindOffset()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01240">addBound()</a>, <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00445">composeMap()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a9d547b7f44aaa82af5d5ab1aeb74a42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">&#9670;&nbsp;</a></span>containsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::containsId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01319">1319</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00564">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a38b004fb4978436d8c8cd8976803468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b004fb4978436d8c8cd8976803468c">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol identifiers which are loop IVs to dim identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00551">551</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01946">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00384">hasValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00502">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="ab578264c931fe0f78eb0397943d032c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab578264c931fe0f78eb0397943d032c1">&#9670;&nbsp;</a></span>findId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::findId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns true if found (false otherwise). <code>pos</code> is set to the (column) position of the identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01307">1307</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00587">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01330">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01264">addSliceBounds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01377">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00502">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="aec33e9ae86390c8f29078675dd53870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec33e9ae86390c8f29078675dd53870e">&#9670;&nbsp;</a></span>flattenAlignedMapAndMergeLocals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an affine map that is aligned with this constraint system: </p>
<ul>
<li>Flatten the map.</li>
<li>Add newly introduced local columns at the beginning of this constraint system (local column pos 0).</li>
<li>Add equalities that define the new local columns to this constraint system.</li>
<li>Return the flattened expressions via <code>flattenedExprs</code>.</li>
</ul>
<p>Note: This is a shared helper function of <code>addLowerOrUpperBound</code> and <code>composeMatchingMap</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01136">1136</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00041">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00268">insertLocalId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01160">addBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00453">composeMatchingMap()</a>.</p>

</div>
</div>
<a id="a30b3ca6765edfa5677b1b23130e0187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3ca6765edfa5677b1b23130e0187c">&#9670;&nbsp;</a></span>fourierMotzkinEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::fourierMotzkinEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>darkShadow</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isResultIntegerExact</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier. </p>
<p>If the result of the elimination is integer exact, <code>*isResultIntegerExact</code> is set to true. If <code>darkShadow</code> is set to true, a potential under approximation (subset) of the rational shadow / exact integer shadow is computed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#afd4a1e9844c11f13e2cc5bb1befea77c">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01364">1364</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01377">projectOut()</a>.</p>

</div>
</div>
<a id="af5177b199aa494103835274f72907a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5177b199aa494103835274f72907a8b">&#9670;&nbsp;</a></span>getAllValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getAllValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00400">400</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00391">getValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a714f817973fece68d8223bf3d8d598de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714f817973fece68d8223bf3d8d598de">&#9670;&nbsp;</a></span>getAsIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> FlatAffineValueConstraints::getAsIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constraint system as an integer set. </p>
<p>Returns a null integer set if the system has no constraints, or if an integer set couldn't be constructed as a result of a local variable's explicit representation not being known and such a local variable appearing in any of the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01484">1484</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01408">computeLocalVars()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02101">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01006">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00160">mlir::presburger::IntegerRelation::getEquality()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getInequality()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00128">mlir::presburger::IntegerRelation::getNumConstraints()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00146">mlir::presburger::IntegerRelation::getNumEqualities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00148">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l02024">mlir::presburger::IntegerRelation::isColZero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02655">createSeparationCondition()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01358">mlir::simplifyIntegerSet()</a>.</p>

</div>
</div>
<a id="acfee23f39d31078e69df752b973f53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee23f39d31078e69df752b973f53b6">&#9670;&nbsp;</a></span>getHyperrectangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> FlatAffineValueConstraints::getHyperrectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00198">198</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00070">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="ac0dbadcb953c32567a17ab1b662505e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dbadcb953c32567a17ab1b662505e0">&#9670;&nbsp;</a></span>getIneqAsAffineValueMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::getIneqAsAffineValueMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>ineqPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands). </p>
<p>The returned affine value map can either be a lower bound or an upper bound depending on the sign of atIneq(ineqPos, pos). Asserts if the row at <code>ineqPos</code> does not involve the <code>pos</code>th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01438">1438</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01408">computeLocalVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getInequality()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00148">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">getValues()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00019">mlir::AffineValueMap::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02735">createFullTiles()</a>.</p>

</div>
</div>
<a id="ac6234845a4fa3eb9444e56cab0fe5b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703">Kind</a> mlir::FlatAffineValueConstraints::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the kind of this FlatAffineConstraints. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#a895daf49eff151a9c2242a65c06e5c0a">mlir::presburger::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00106">106</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a02a605e2b5fca97f0ea2af1f24a24703a38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::presburger::IntegerRelation::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="a77763faa50eb0b78f95f0c195fe4bc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77763faa50eb0b78f95f0c195fe4bc49">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; FlatAffineValueConstraints::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>symStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num). </p>
<p>The multi-dimensional maps in the returned pair represent the max and min of potentially multiple affine expressions. The upper bound is exclusive. <code>localExprs</code> holds pre-computed <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s for all local identifiers in the system. </p>
<p>Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00878">878</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00160">mlir::presburger::IntegerRelation::getEquality()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getInequality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00297">mlir::presburger::IntegerRelation::getLowerAndUpperBoundIndices()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>.</p>

</div>
</div>
<a id="a0d108d7e10610afd56b9bc03598741f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d108d7e10610afd56b9bc03598741f9">&#9670;&nbsp;</a></span>getMaybeDimAndSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimAndSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00416">416</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>.</p>

</div>
</div>
<a id="a1e61e7f65a2ddd3fb4dc389d1fcd4467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61e7f65a2ddd3fb4dc389d1fcd4467">&#9670;&nbsp;</a></span>getMaybeDimValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00408">408</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>.</p>

</div>
</div>
<a id="a464901024f611db773f2def48443b8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464901024f611db773f2def48443b8f8">&#9670;&nbsp;</a></span>getMaybeSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00412">412</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00041">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="ad7998d8323c934c13a86769ca8fad877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7998d8323c934c13a86769ca8fad877">&#9670;&nbsp;</a></span>getMaybeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00404">404</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00325">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00342">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01385">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="ad748b8fbd8eea446a0c378ca1cc65781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad748b8fbd8eea446a0c378ca1cc65781">&#9670;&nbsp;</a></span>getSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::getSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubMaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic). </p>
<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as affine maps of the remaining identifiers (dimensional and symbolic identifiers).</p>
<p>This method is able to detect identifiers as floordiv's and mod's of affine expressions of other identifiers with respect to (positive) constants. Sets bound map to a null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> if such a bound can't be found (or yet unimplemented).</p>
<p>Local identifiers are themselves explicitly computed as affine functions of other identifiers in this process if needed. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00966">966</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00119">mlir::presburger::IntegerRelation::atEq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00847">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00736">detectAsMod()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03009">mlir::AffineMap::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02101">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00379">mlir::presburger::IntegerRelation::findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01515">mlir::presburger::IntegerRelation::getConstantBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00394">mlir::presburger::IntegerRelation::normalizeConstraintsByGCD()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">mlir::simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a3896e7ab007a7bd1e8d1fb1fb098bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineValueConstraints::getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> identifier was associated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00378">378</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00384">hasValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00551">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00307">getCommonBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00285">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a9ccc790e216f3bbf7416308c04045094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc790e216f3bbf7416308c04045094">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Values associated with identifiers in range [start, end). </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> was associated with one of these identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00391">391</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00378">getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02655">createSeparationCondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>, <a class="el" href="AffineStructures_8h_source.html#l00400">getAllValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01438">getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a3202cddcf31d0798de72cac6742248b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202cddcf31d0798de72cac6742248b0">&#9670;&nbsp;</a></span>hasConsistentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasConsistentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise. </p>
<p>This is meant to be used within an assert internally. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#ae3ea69dad17cc800b4325929ec3871d6">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00703">703</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

</div>
</div>
<a id="a5e39afc73e0776e068eb7331bcb349c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e39afc73e0776e068eb7331bcb349c7">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::FlatAffineValueConstraints::hasValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00384">384</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00317">hasValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00551">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">getValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01339">printSpace()</a>.</p>

</div>
</div>
<a id="a321a6a4ea45324a6c969a5b5062ec932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a6a4ea45324a6c969a5b5062ec932">&#9670;&nbsp;</a></span>hasValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00317">317</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00384">hasValue()</a>.</p>

</div>
</div>
<a id="a1b7f6c30bd586070d7de8a397723f6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7f6c30bd586070d7de8a397723f6d6">&#9670;&nbsp;</a></span>insertDimId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::insertDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert identifiers of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of identifier. The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the absolute column position (i.e., not relative to the kind of identifier) of the first added identifier.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00262">262</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01683">mlir::FlatAffineRelation::appendDomainId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01688">mlir::FlatAffineRelation::appendRangeId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00409">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01669">mlir::FlatAffineRelation::insertDomainId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00268">insertLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01676">mlir::FlatAffineRelation::insertRangeId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a37618dd64a6fe91226805818e4139fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37618dd64a6fe91226805818e4139fb9">&#9670;&nbsp;</a></span>insertDimId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00284">284</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

</div>
</div>
<a id="a3dd4c76f84cac8a1ca39fc04e1fa405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd4c76f84cac8a1ca39fc04e1fa405f">&#9670;&nbsp;</a></span>insertId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of identifier. Return the absolute column position (i.e., not relative to the kind of identifier) of the first added identifier. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html#ab574fc0b9921c7c9d0e41be673357c49">mlir::presburger::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00294">294</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00272">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00278">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00152">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00262">insertDimId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00268">insertLocalId()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00265">insertSymbolId()</a>.</p>

</div>
</div>
<a id="ad758f6a5c517265cf9a526012199bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad758f6a5c517265cf9a526012199bbeb">&#9670;&nbsp;</a></span>insertId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00302">302</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="abe7a47c183d1fb0a0cf7cb26f8c9364d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7a47c183d1fb0a0cf7cb26f8c9364d">&#9670;&nbsp;</a></span>insertLocalId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::insertLocalId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00268">268</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00262">insertDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00265">insertSymbolId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01136">flattenAlignedMapAndMergeLocals()</a>.</p>

</div>
</div>
<a id="a1c9f0f181d5ce35bc7ca1ca687e6152f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f0f181d5ce35bc7ca1ca687e6152f">&#9670;&nbsp;</a></span>insertSymbolId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineValueConstraints::insertSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00265">265</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00268">insertLocalId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a99c6ee75c0627beaeb455d0428636849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c6ee75c0627beaeb455d0428636849">&#9670;&nbsp;</a></span>insertSymbolId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00289">289</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00294">insertId()</a>.</p>

</div>
</div>
<a id="ad2eed02898a13f56e0bc2a470c2f89af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eed02898a13f56e0bc2a470c2f89af">&#9670;&nbsp;</a></span>mergeAndAlignIdsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeAndAlignIdsWithOther </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>. </p>
<p>Local identifiers in <code>other</code> that have the same division representation as local identifiers in <code>this</code> are merged into one. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00439">439</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00688">addAffineIfOpDomain()</a>, <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a5333879b7e111caf2c3371c0d0745296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5333879b7e111caf2c3371c0d0745296">&#9670;&nbsp;</a></span>mergeSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeSymbolIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique. </p>
<p>Symbols in <code>this</code> and <code>other</code> should be unique. Symbols with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> as <code>None</code> are considered to be inequal to all other symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00515">515</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00342">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">getValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00265">insertSymbolId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01325">swapId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00427">setValues()</a>.</p>

</div>
</div>
<a id="ab22f9e8a2b6d20dbe52378823edc5a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f9e8a2b6d20dbe52378823edc5a9c">&#9670;&nbsp;</a></span>printSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::printSpace </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the number of constraints, dimensions, symbols and locals in the FlatAffineConstraints. </p>
<p>Also, prints for each identifier whether there is an SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to it. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#a9c038eeeb326c7c2f6d990998f046f1e">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01339">1339</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00384">hasValue()</a>, and <a class="el" href="RunnerUtils_8h_source.html#l00088">impl::printSpace()</a>.</p>

</div>
</div>
<a id="a79575e2c2693576f2c5a4accf0dcdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79575e2c2693576f2c5a4accf0dcdab6">&#9670;&nbsp;</a></span>projectOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01377">1377</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01364">fourierMotzkinEliminate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00409">computeDirectionVector()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01735">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a1cb732ee1febb93fddd889edbd75603c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb732ee1febb93fddd889edbd75603c">&#9670;&nbsp;</a></span>removeIdRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::removeIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#af12c26b7067842b6f9fcc021f4fb5cae">presburger::IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aca2890cb0885f6f673f79801eca9e853">mlir::presburger::IntegerRelation</a>.</p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineRelation.html#ac737191bbf8011f3b86493eb06a5d7cc">mlir::FlatAffineRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00708">708</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00524">mlir::FlatAffineRelation::getNumRangeDims()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01654">mlir::FlatAffineRelation::inverse()</a>.</p>

</div>
</div>
<a id="aadf03e7c9ae234b714e008160e7d3fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf03e7c9ae234b714e008160e7d3fba">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears any existing data and reserves memory for the specified constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00228">228</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkTilingLegalityImpl()</a>, <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00072">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00118">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00241">reset()</a>.</p>

</div>
</div>
<a id="ad96f71bbc66b10ee4e5286483b7b141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96f71bbc66b10ee4e5286483b7b141f">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00241">241</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="a58e00fa2f257f1bd2c8ab11369207198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00fa2f257f1bd2c8ab11369207198">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00249">249</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="ae3a94ce5a825b81e5767fef38db2329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a94ce5a825b81e5767fef38db2329a">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00264">264</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00228">reset()</a>.</p>

</div>
</div>
<a id="a5eccad1d331cf5cfb78bf1f08fda7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccad1d331cf5cfb78bf1f08fda7224">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00421">421</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01754">mlir::getRelationFromMap()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00427">setValues()</a>.</p>

</div>
</div>
<a id="a320c65d604a6089bb16894e4a9ee33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c65d604a6089bb16894e4a9ee33bf">&#9670;&nbsp;</a></span>setValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Values associated with the identifiers in the range [start, end). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00427">427</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00421">setValue()</a>.</p>

</div>
</div>
<a id="acda87dfc4340eb857e9bc9ab05141b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda87dfc4340eb857e9bc9ab05141b16">&#9670;&nbsp;</a></span>swapId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::swapId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the posA^th identifier with the posB^th identifier. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html#aafd0dd2d2648d4a5e42c63ea9c5effad">mlir::presburger::IntegerRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01325">1325</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00481">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01654">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00515">mergeSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00502">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="af0c35f1d2d81adf4ba06b84df578cd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c35f1d2d81adf4ba06b84df578cd78">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. <code>other</code> is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>E.g.: 1) this = {0 &lt;= d0 &lt;= 127}, other = {16 &lt;= d0 &lt;= 192}, output = {0 &lt;= d0 &lt;= 192} 2) this = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, other = {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20} 3) this = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9} other = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15} </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01385">1385</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00325">areIdsAligned()</a>, <a class="el" href="AffineStructures_8h_source.html#l00404">getMaybeValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00135">mlir::presburger::IntegerRelation::getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00389">mergeAndAlignIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00291">appendLocalId()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2662045a8d845c7cf9aa9516af6ea914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2662045a8d845c7cf9aa9516af6ea914">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;, 8&gt; mlir::FlatAffineValueConstraints::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns. </p>
<p>Temporary ones or those that aren't associated with any <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> are set to None. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00481">481</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00108">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01351">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01597">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01208">computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01319">containsId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">findId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00041">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01364">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00703">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00317">hasValues()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01325">swapId()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:03 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
