<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/IR/OpDefinition.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_84ef7c054b4edc3447cfba80cee80f65.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpDefinition.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="IR_2Dialect_8h_source.html">mlir/IR/Dialect.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2Operation_8h_source.html">mlir/IR/Operation.h</a>&quot;</code><br />
<code>#include &quot;llvm/Support/PointerLikeTypeTraits.h&quot;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for OpDefinition.h:</div>
<div class="dyncontent">
<div class="center"><img src="OpDefinition_8h__incl.png" border="0" usemap="#include_2mlir_2IR_2OpDefinition_8h" alt=""/></div>
<map name="include_2mlir_2IR_2OpDefinition_8h" id="include_2mlir_2IR_2OpDefinition_8h">
<area shape="rect" id="node2" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="610,155,737,181"/>
<area shape="rect" id="node45" href="IR_2Operation_8h.html" title="mlir/IR/Operation.h" alt="" coords="1955,80,2101,107"/>
<area shape="rect" id="node3" href="DialectRegistry_8h.html" title="mlir/IR/DialectRegistry.h" alt="" coords="520,229,699,256"/>
<area shape="rect" id="node7" href="TypeID_8h.html" title="mlir/Support/TypeID.h" alt="" coords="423,692,585,719"/>
<area shape="rect" id="node21" href="OperationSupport_8h.html" title="mlir/IR/OperationSupport.h" alt="" coords="1527,229,1721,256"/>
<area shape="rect" id="node4" href="MLIRContext_8h.html" title="mlir/IR/MLIRContext.h" alt="" coords="1064,617,1227,644"/>
<area shape="rect" id="node5" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="785,774,935,801"/>
<area shape="rect" id="node22" href="BlockSupport_8h.html" title="mlir/IR/BlockSupport.h" alt="" coords="887,304,1054,331"/>
<area shape="rect" id="node23" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="1585,386,1703,413"/>
<area shape="rect" id="node24" href="IR_2Types_8h.html" title="mlir/IR/Types.h" alt="" coords="1442,468,1561,495"/>
<area shape="rect" id="node28" href="Location_8h.html" title="mlir/IR/Location.h" alt="" coords="1885,543,2021,569"/>
<area shape="rect" id="node34" href="IR_2BuiltinAttributes_8h.html" title="mlir/IR/BuiltinAttributes.h" alt="" coords="2267,304,2453,331"/>
<area shape="rect" id="node41" href="TypeRange_8h.html" title="mlir/IR/TypeRange.h" alt="" coords="1687,304,1839,331"/>
<area shape="rect" id="node42" href="InterfaceSupport_8h.html" title="mlir/Support/InterfaceSupport.h" alt="" coords="407,468,633,495"/>
<area shape="rect" id="node27" href="UseDefLists_8h.html" title="mlir/IR/UseDefLists.h" alt="" coords="1637,468,1795,495"/>
<area shape="rect" id="node25" href="TypeSupport_8h.html" title="mlir/IR/TypeSupport.h" alt="" coords="1327,543,1489,569"/>
<area shape="rect" id="node29" href="Attributes_8h.html" title="mlir/IR/Attributes.h" alt="" coords="2159,617,2305,644"/>
<area shape="rect" id="node35" href="BuiltinAttributeInterfaces_8h.html" title="mlir/IR/BuiltinAttribute\lInterfaces.h" alt="" coords="2535,379,2703,420"/>
<area shape="rect" id="node37" href="SubElementInterfaces_8h.html" title="mlir/IR/SubElementInterfaces.h" alt="" coords="2116,386,2340,413"/>
<area shape="rect" id="node46" href="Block_8h.html" title="mlir/IR/Block.h" alt="" coords="1064,229,1181,256"/>
<area shape="rect" id="node48" href="IR_2Diagnostics_8h.html" title="mlir/IR/Diagnostics.h" alt="" coords="1927,468,2084,495"/>
<area shape="rect" id="node49" href="IR_2Region_8h.html" title="mlir/IR/Region.h" alt="" coords="1524,155,1649,181"/>
<area shape="rect" id="node47" href="Visitors_8h.html" title="mlir/IR/Visitors.h" alt="" coords="253,692,384,719"/>
</map>
</div>
</div>
<p><a href="OpDefinition_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">mlir::OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for parsing-like operations that find it important to chain tog...">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">mlir::OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html">mlir::OpTrait::detail::MultiOperandTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple operands.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OpInvariants.html">mlir::OpTrait::OpInvariants&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>verifyInvariantsImpl</code> verifies the invariants like the types, attrs, .etc.  <a href="classmlir_1_1OpTrait_1_1OpInvariants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroOperands.html">mlir::OpTrait::ZeroOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have no SSA operand.  <a href="classmlir_1_1OpTrait_1_1ZeroOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneOperand.html">mlir::OpTrait::OneOperand&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have exactly one SSA operand.  <a href="classmlir_1_1OpTrait_1_1OneOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands.html">mlir::OpTrait::NOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1NOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands_1_1Impl.html">mlir::OpTrait::NOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a at least a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands_1_1Impl.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicOperands.html">mlir::OpTrait::VariadicOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of SSA operands.  <a href="classmlir_1_1OpTrait_1_1VariadicOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroRegion.html">mlir::OpTrait::ZeroRegion&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero regions.  <a href="classmlir_1_1OpTrait_1_1ZeroRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html">mlir::OpTrait::detail::MultiRegionTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple regions.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneRegion.html">mlir::OpTrait::OneRegion&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single region.  <a href="classmlir_1_1OpTrait_1_1OneRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions.html">mlir::OpTrait::NRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1NRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions_1_1Impl.html">mlir::OpTrait::NRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions_1_1Impl.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicRegions.html">mlir::OpTrait::VariadicRegions&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of regions.  <a href="classmlir_1_1OpTrait_1_1VariadicRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroResult.html">mlir::OpTrait::ZeroResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have zero results.  <a href="classmlir_1_1OpTrait_1_1ZeroResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html">mlir::OpTrait::detail::MultiResultTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple results.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneTypedResult.html">mlir::OpTrait::OneTypedResult&lt; ResultType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used for return value APIs for ops that are known to have a specific type other than <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1OpTrait_1_1OneTypedResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneTypedResult_1_1Impl.html">mlir::OpTrait::OneTypedResult&lt; ResultType &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneTypedResult_1_1Impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults.html">mlir::OpTrait::NResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of results.  <a href="classmlir_1_1OpTrait_1_1NResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults_1_1Impl.html">mlir::OpTrait::NResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have at least a specified number of results.  <a href="classmlir_1_1OpTrait_1_1AtLeastNResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults_1_1Impl.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicResults.html">mlir::OpTrait::VariadicResults&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of results.  <a href="classmlir_1_1OpTrait_1_1VariadicResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NoTerminator.html">mlir::OpTrait::NoTerminator&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class indicates that the regions associated with this op don't have terminators.  <a href="classmlir_1_1OpTrait_1_1NoTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsTerminator.html">mlir::OpTrait::IsTerminator&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be terminators.  <a href="classmlir_1_1OpTrait_1_1IsTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroSuccessor.html">mlir::OpTrait::ZeroSuccessor&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero successors.  <a href="classmlir_1_1OpTrait_1_1ZeroSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html">mlir::OpTrait::detail::MultiSuccessorTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple successors.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneSuccessor.html">mlir::OpTrait::OneSuccessor&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single successor.  <a href="classmlir_1_1OpTrait_1_1OneSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors.html">mlir::OpTrait::NSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1NSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors_1_1Impl.html">mlir::OpTrait::NSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors_1_1Impl.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html">mlir::OpTrait::VariadicSuccessors&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of successors.  <a href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlock.html">mlir::OpTrait::SingleBlock&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block.  <a href="structmlir_1_1OpTrait_1_1SingleBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block that must terminate with <code>TerminatorOpType</code>.  <a href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator_1_1Impl.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html">mlir::OpTrait::hasSingleBlockImplicitTerminator&lt; Op, hasTerminator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support to check if an operation has the <a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html" title="This class provides APIs and verifiers for ops with regions having a single block that must terminate...">SingleBlockImplicitTerminator</a> trait.  <a href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator_3_01Op_00_01false_01_4.html">mlir::OpTrait::hasSingleBlockImplicitTerminator&lt; Op, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsShape.html">mlir::OpTrait::SameOperandsShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand shape: all operands are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html">mlir::OpTrait::SameOperandsAndResultShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result shape: both are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html">mlir::OpTrait::SameOperandsElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html">mlir::OpTrait::SameOperandsAndResultElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html">mlir::OpTrait::SameOperandsAndResultType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result type.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html">mlir::OpTrait::ResultsAreBoolLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a boolean type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html">mlir::OpTrait::ResultsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a floating point type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html">mlir::OpTrait::ResultsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsCommutative.html">mlir::OpTrait::IsCommutative&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is commutative.  <a href="classmlir_1_1OpTrait_1_1IsCommutative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsInvolution.html">mlir::OpTrait::IsInvolution&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is an involution.  <a href="classmlir_1_1OpTrait_1_1IsInvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIdempotent.html">mlir::OpTrait::IsIdempotent&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is idempotent.  <a href="classmlir_1_1OpTrait_1_1IsIdempotent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html">mlir::OpTrait::OperandsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a float type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html">mlir::OpTrait::OperandsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameTypeOperands.html">mlir::OpTrait::SameTypeOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have the same type.  <a href="classmlir_1_1OpTrait_1_1SameTypeOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ConstantLike.html">mlir::OpTrait::ConstantLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for a sub-set of ops that are known to be constant-like.  <a href="classmlir_1_1OpTrait_1_1ConstantLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be isolated from above.  <a href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AffineScope.html">mlir::OpTrait::AffineScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that defines a new scope for polyhedral optimization purposes.  <a href="classmlir_1_1OpTrait_1_1AffineScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html">mlir::OpTrait::AutomaticAllocationScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that define a new scope for automatic allocations, i.e., allocations that are freed when control is transferred back from the operation's region.  <a href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1HasParent.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a verifier for ops that are expecting their parent to be one of the given parent ops.  <a href="structmlir_1_1OpTrait_1_1HasParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasParent_1_1Impl.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html">mlir::OpTrait::AttrSizedOperandSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for operations that have an attribute specifying operand segments.  <a href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html">mlir::OpTrait::AttrSizedResultSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html" title="A trait for operations that have an attribute specifying operand segments. ">AttrSizedOperandSegments</a> but used for results.  <a href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1NoRegionArguments.html">mlir::OpTrait::NoRegionArguments&lt; ConcrentType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait provides a verifier for ops that are expecting their regions to not have any arguments.  <a href="structmlir_1_1OpTrait_1_1NoRegionArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1MemRefsNormalizable.html">mlir::OpTrait::MemRefsNormalizable&lt; ConcrentType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html">mlir::OpTrait::Elementwise&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags element-wise ops on vectors or tensors.  <a href="structmlir_1_1OpTrait_1_1Elementwise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html">mlir::OpTrait::Scalarizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <code><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors. ">Elementwise</a></code> operatons that can be systematically scalarized.  <a href="structmlir_1_1OpTrait_1_1Scalarizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html">mlir::OpTrait::Vectorizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <code><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors. ">Elementwise</a></code> operatons that can be systematically vectorized.  <a href="structmlir_1_1OpTrait_1_1Vectorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html">mlir::OpTrait::Tensorizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <code><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors. ">Elementwise</a></code> operatons that can be systematically tensorized.  <a href="structmlir_1_1OpTrait_1_1Tensorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">mlir::OpInterface&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1DenseMapInfo_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01mlir_1_1Od37fd0551cf5866ed71417c08c0eda9a.html">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">mlir::impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">mlir::OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html">mlir::OpTrait::impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1detail.html">mlir::OpTrait::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">mlir::op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly register a set of "builtin" types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab00d842470c14be468290cbcc0576940"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab00d842470c14be468290cbcc0576940"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html#ab00d842470c14be468290cbcc0576940">mlir::OpTrait::has_implicit_terminator_t</a> = typename T::ImplicitTerminatorOpT</td></tr>
<tr class="memdesc:ab00d842470c14be468290cbcc0576940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check is an op defines the <code>ImplicitTerminatorOpT</code> member.  <a href="namespacemlir_1_1OpTrait.html#ab00d842470c14be468290cbcc0576940">More...</a><br /></td></tr>
<tr class="separator:ab00d842470c14be468290cbcc0576940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab8e1b916f30dd4d7d9ba1977d36dc013">mlir::op_definition_impl::has_single_result_fold_trait</a> = decltype(T::foldTrait(std::declval&lt; Operation * &gt;(), std::declval&lt; ArrayRef&lt; Attribute &gt; &gt;()))</td></tr>
<tr class="memdesc:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a 'foldTrait' method for single result operations.  <a href="namespacemlir_1_1op__definition__impl.html#ab8e1b916f30dd4d7d9ba1977d36dc013">More...</a><br /></td></tr>
<tr class="separator:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a6ddad3225ec31fadb0caf5a7f18c8919">mlir::op_definition_impl::detect_has_single_result_fold_trait</a> = llvm::is_detected&lt; has_single_result_fold_trait, T &gt;</td></tr>
<tr class="separator:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b98e8eb901a799fde18726456effcc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a52b98e8eb901a799fde18726456effcc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a52b98e8eb901a799fde18726456effcc">mlir::op_definition_impl::has_fold_trait</a> = decltype(T::foldTrait(std::declval&lt; Operation * &gt;(), std::declval&lt; ArrayRef&lt; Attribute &gt; &gt;(), std::declval&lt; SmallVectorImpl&lt; OpFoldResult &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a52b98e8eb901a799fde18726456effcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a general 'foldTrait' method.  <a href="namespacemlir_1_1op__definition__impl.html#a52b98e8eb901a799fde18726456effcc">More...</a><br /></td></tr>
<tr class="separator:a52b98e8eb901a799fde18726456effcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a141f18a84fcbbcd4be33c2ef7f85067b">mlir::op_definition_impl::detect_has_fold_trait</a> = llvm::is_detected&lt; has_fold_trait, T &gt;</td></tr>
<tr class="separator:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3cd51a531c501776224e11ba1f0cf6b7">mlir::op_definition_impl::detect_has_any_fold_trait</a> = std::conditional_t&lt; bool(detect_has_fold_trait&lt; T &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>), detect_has_fold_trait&lt; T &gt;, detect_has_single_result_fold_trait&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a3cd51a531c501776224e11ba1f0cf6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides any <code>foldTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a3cd51a531c501776224e11ba1f0cf6b7">More...</a><br /></td></tr>
<tr class="separator:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb84c922f7efa8ee20bd2165b97733"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a48fb84c922f7efa8ee20bd2165b97733"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a48fb84c922f7efa8ee20bd2165b97733">mlir::op_definition_impl::has_verify_trait</a> = decltype(T::verifyTrait(std::declval&lt; Operation * &gt;()))</td></tr>
<tr class="memdesc:a48fb84c922f7efa8ee20bd2165b97733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>verifyTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a48fb84c922f7efa8ee20bd2165b97733">More...</a><br /></td></tr>
<tr class="separator:a48fb84c922f7efa8ee20bd2165b97733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a1984f3eb75bc0cc029899eaeb9b1801a">mlir::op_definition_impl::detect_has_verify_trait</a> = llvm::is_detected&lt; has_verify_trait, T &gt;</td></tr>
<tr class="separator:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db9377b73432cdf6af480c0408a7350"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9db9377b73432cdf6af480c0408a7350"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a9db9377b73432cdf6af480c0408a7350">mlir::op_definition_impl::has_verify_region_trait</a> = decltype(T::verifyRegionTrait(std::declval&lt; Operation * &gt;()))</td></tr>
<tr class="memdesc:a9db9377b73432cdf6af480c0408a7350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>verifyTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a9db9377b73432cdf6af480c0408a7350">More...</a><br /></td></tr>
<tr class="separator:a9db9377b73432cdf6af480c0408a7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b286f7154404ca86adf28a33d65769"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38b286f7154404ca86adf28a33d65769"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a38b286f7154404ca86adf28a33d65769">mlir::op_definition_impl::detect_has_verify_region_trait</a> = llvm::is_detected&lt; has_verify_region_trait, T &gt;</td></tr>
<tr class="separator:a38b286f7154404ca86adf28a33d65769"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e7451c7364716df0ac50255d1bb0dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:a8e7451c7364716df0ac50255d1bb0dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an operation, generated by <code>buildTerminatorOp</code>, at the end of the region's only block if it does not have a terminator already.  <a href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">More...</a><br /></td></tr>
<tr class="separator:a8e7451c7364716df0ac50255d1bb0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89ade716be6ba0ebae6e192aa722859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:ad89ade716be6ba0ebae6e192aa722859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> and forward to the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> version of this function.  <a href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">More...</a><br /></td></tr>
<tr class="separator:ad89ade716be6ba0ebae6e192aa722859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">mlir::operator==</a> (OpState lhs, OpState rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">mlir::operator!=</a> (OpState lhs, OpState rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">mlir::operator&lt;&lt;</a> (raw_ostream &amp;os, OpFoldResult ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">More...</a><br /></td></tr>
<tr class="separator:a8c357b30f2e56803678fe5f7b75e80a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07e7b01e09b3da975cc984b4e1c506d"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">mlir::operator&lt;&lt;</a> (raw_ostream &amp;os, OpState op)</td></tr>
<tr class="memdesc:af07e7b01e09b3da975cc984b4e1c506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#af07e7b01e09b3da975cc984b4e1c506d">More...</a><br /></td></tr>
<tr class="separator:af07e7b01e09b3da975cc984b4e1c506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0132989f6240955f0653f9e2f544593e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a0132989f6240955f0653f9e2f544593e">mlir::OpTrait::impl::foldIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a0132989f6240955f0653f9e2f544593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adca9caae669acd6c6100fa24fe2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad8adca9caae669acd6c6100fa24fe2ca">mlir::OpTrait::impl::foldInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ad8adca9caae669acd6c6100fa24fe2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8e54e8c1d63dcd42fb7b3035d0cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a8dc8e54e8c1d63dcd42fb7b3035d0cdf">mlir::OpTrait::impl::verifyZeroOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a8dc8e54e8c1d63dcd42fb7b3035d0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa809f4f4d8b09d82d6a8fd16dd2c9710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aa809f4f4d8b09d82d6a8fd16dd2c9710">mlir::OpTrait::impl::verifyOneOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aa809f4f4d8b09d82d6a8fd16dd2c9710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d9ddc91b449aa789d17f9586507fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1e0d9ddc91b449aa789d17f9586507fe">mlir::OpTrait::impl::verifyNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a1e0d9ddc91b449aa789d17f9586507fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a23d65257edee446fa4d25c6d53bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a115a23d65257edee446fa4d25c6d53bf">mlir::OpTrait::impl::verifyIsIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a115a23d65257edee446fa4d25c6d53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d96b2cde016d241b493b4ad3a97b1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d96b2cde016d241b493b4ad3a97b1e8">mlir::OpTrait::impl::verifyIsInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a2d96b2cde016d241b493b4ad3a97b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889058045dff9baa6b2a4a9950abbc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a889058045dff9baa6b2a4a9950abbc7a">mlir::OpTrait::impl::verifyAtLeastNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a889058045dff9baa6b2a4a9950abbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cda488cf33c7043eb3a386c3cd4231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a34cda488cf33c7043eb3a386c3cd4231">mlir::OpTrait::impl::verifyOperandsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a34cda488cf33c7043eb3a386c3cd4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd39e6ccba62558b270c9dad614273a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1bd39e6ccba62558b270c9dad614273a">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a1bd39e6ccba62558b270c9dad614273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe4f6aa15d39476a2c01e85e7d52021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aefe4f6aa15d39476a2c01e85e7d52021">mlir::OpTrait::impl::verifySameTypeOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aefe4f6aa15d39476a2c01e85e7d52021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d0b57f4f04dc210475a73d9db6b7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a54d0b57f4f04dc210475a73d9db6b7d3">mlir::OpTrait::impl::verifyZeroRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a54d0b57f4f04dc210475a73d9db6b7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90522054e6b01d158e20f5a94e4b1aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a90522054e6b01d158e20f5a94e4b1aee">mlir::OpTrait::impl::verifyOneRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a90522054e6b01d158e20f5a94e4b1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e80ada4c0550c82e88f4e4d840f4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae3e80ada4c0550c82e88f4e4d840f4ad">mlir::OpTrait::impl::verifyNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="separator:ae3e80ada4c0550c82e88f4e4d840f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53730de6badc603ad6f726118d16f287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a53730de6badc603ad6f726118d16f287">mlir::OpTrait::impl::verifyAtLeastNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="separator:a53730de6badc603ad6f726118d16f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb1eef6f45f7ecb9ce52f5748ba942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a3edb1eef6f45f7ecb9ce52f5748ba942">mlir::OpTrait::impl::verifyZeroResult</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a3edb1eef6f45f7ecb9ce52f5748ba942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95e50903d49322f2b78695b60b6bcc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae95e50903d49322f2b78695b60b6bcc1">mlir::OpTrait::impl::verifyOneResult</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae95e50903d49322f2b78695b60b6bcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d5eefac26d790469de86a7f077421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d5eefac26d790469de86a7f077421">mlir::OpTrait::impl::verifyNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:add6d5eefac26d790469de86a7f077421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110f9468129a20d2293ae53d7fe2ef0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a110f9468129a20d2293ae53d7fe2ef0a">mlir::OpTrait::impl::verifyAtLeastNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a110f9468129a20d2293ae53d7fe2ef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e92618f861bedecfef4ad880f180081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e92618f861bedecfef4ad880f180081">mlir::OpTrait::impl::verifySameOperandsShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a5e92618f861bedecfef4ad880f180081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab88926993882bfc40c836a88e5fe66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#afab88926993882bfc40c836a88e5fe66">mlir::OpTrait::impl::verifySameOperandsAndResultShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:afab88926993882bfc40c836a88e5fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82438cfd273eb4a921e6e4bf7491daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac82438cfd273eb4a921e6e4bf7491daa">mlir::OpTrait::impl::verifySameOperandsElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ac82438cfd273eb4a921e6e4bf7491daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a11e847e87cb0d535a2d211df24088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad3a11e847e87cb0d535a2d211df24088">mlir::OpTrait::impl::verifySameOperandsAndResultElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ad3a11e847e87cb0d535a2d211df24088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e846953be56c5cd49c049e25d293d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e846953be56c5cd49c049e25d293d92">mlir::OpTrait::impl::verifySameOperandsAndResultType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a5e846953be56c5cd49c049e25d293d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d0fe5f6a3c7e9dcbef8c906538ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d0fe5f6a3c7e9dcbef8c906538ecf">mlir::OpTrait::impl::verifyResultsAreBoolLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:add6d0fe5f6a3c7e9dcbef8c906538ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078673dba11a98a41584775609a09e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a078673dba11a98a41584775609a09e85">mlir::OpTrait::impl::verifyResultsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a078673dba11a98a41584775609a09e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3ceabf6cb31385e6c2f43371b614d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d3ceabf6cb31385e6c2f43371b614d3">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a2d3ceabf6cb31385e6c2f43371b614d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4b2825599a0e6a222707b3b6b53f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a7d4b2825599a0e6a222707b3b6b53f75">mlir::OpTrait::impl::verifyIsTerminator</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a7d4b2825599a0e6a222707b3b6b53f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2711dea34b2a506e453a07200e93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a09b2711dea34b2a506e453a07200e93b">mlir::OpTrait::impl::verifyZeroSuccessor</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a09b2711dea34b2a506e453a07200e93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac938fc6e2ff3dc37694950498ae9dba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac938fc6e2ff3dc37694950498ae9dba6">mlir::OpTrait::impl::verifyOneSuccessor</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ac938fc6e2ff3dc37694950498ae9dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403585b9eec4de7bddd7f41981c34b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4403585b9eec4de7bddd7f41981c34b1">mlir::OpTrait::impl::verifyNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="separator:a4403585b9eec4de7bddd7f41981c34b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cceb3d69b10bcd82a82246f93b967a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a6cceb3d69b10bcd82a82246f93b967a4">mlir::OpTrait::impl::verifyAtLeastNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="separator:a6cceb3d69b10bcd82a82246f93b967a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b4da033b9e5d568efc60dc9c050430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a54b4da033b9e5d568efc60dc9c050430">mlir::OpTrait::impl::verifyValueSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef attrName, StringRef valueGroupName, size_t expectedCount)</td></tr>
<tr class="separator:a54b4da033b9e5d568efc60dc9c050430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbacb7693a2df8b34e96340ab89a94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4fbacb7693a2df8b34e96340ab89a94a">mlir::OpTrait::impl::verifyOperandSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="separator:a4fbacb7693a2df8b34e96340ab89a94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade217d2c5c5168f9b61dd5a7c6c812de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ade217d2c5c5168f9b61dd5a7c6c812de">mlir::OpTrait::impl::verifyResultSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="separator:ade217d2c5c5168f9b61dd5a7c6c812de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232a88a3d7d7399639ab0a50678c305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a232a88a3d7d7399639ab0a50678c305e">mlir::OpTrait::impl::verifyNoRegionArguments</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a232a88a3d7d7399639ab0a50678c305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea847862ff70619d3d9d187e4e01e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a8ea847862ff70619d3d9d187e4e01e76">mlir::OpTrait::impl::verifyElementwise</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a8ea847862ff70619d3d9d187e4e01e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bc911e10042037458d32a120a0d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ab15bc911e10042037458d32a120a0d9b">mlir::OpTrait::impl::verifyIsIsolatedFromAbove</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ab15bc911e10042037458d32a120a0d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for any values used by operations regions attached to the specified "IsIsolatedFromAbove" operation defined outside of it.  <a href="namespacemlir_1_1OpTrait_1_1impl.html#ab15bc911e10042037458d32a120a0d9b">More...</a><br /></td></tr>
<tr class="separator:ab15bc911e10042037458d32a120a0d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5480822c4898f287f588dfe98d1c85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html#a0c5480822c4898f287f588dfe98d1c85">mlir::OpTrait::hasElementwiseMappableTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a0c5480822c4898f287f588dfe98d1c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Together, <code><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors. ">Elementwise</a></code>, <code><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html" title="This trait tags Elementwise operatons that can be systematically scalarized. ">Scalarizable</a></code>, <code><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html" title="This trait tags Elementwise operatons that can be systematically vectorized. ">Vectorizable</a></code>, and <code><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html" title="This trait tags Elementwise operatons that can be systematically tensorized. ">Tensorizable</a></code> provide an easy way for scalar operations to conveniently generalize their behavior to vectors/tensors, and systematize conversion between these forms.  <a href="namespacemlir_1_1OpTrait.html#a0c5480822c4898f287f588dfe98d1c85">More...</a><br /></td></tr>
<tr class="separator:a0c5480822c4898f287f588dfe98d1c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a5c5901abcbc3fa45814cb4c4d0b27c28">mlir::op_definition_impl::hasTrait</a> (TypeID traitID)</td></tr>
<tr class="memdesc:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this given Trait ID matches the IDs of any of the provided trait types <code>Traits</code>.  <a href="namespacemlir_1_1op__definition__impl.html#a5c5901abcbc3fa45814cb4c4d0b27c28">More...</a><br /></td></tr>
<tr class="separator:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29daf4e8e7be567394da583d6fa7e35"><td class="memTemplParams" colspan="2">template&lt;typename Trait &gt; </td></tr>
<tr class="memitem:ab29daf4e8e7be567394da583d6fa7e35"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; detect_has_single_result_fold_trait&lt; Trait &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab29daf4e8e7be567394da583d6fa7e35">mlir::op_definition_impl::foldTrait</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:ab29daf4e8e7be567394da583d6fa7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a <code>foldTrait</code> function that is specialized for operations that have a single result.  <a href="namespacemlir_1_1op__definition__impl.html#ab29daf4e8e7be567394da583d6fa7e35">More...</a><br /></td></tr>
<tr class="separator:ab29daf4e8e7be567394da583d6fa7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c105b59443d003e7f7b6f898ae81c"><td class="memTemplParams" colspan="2">template&lt;typename Trait &gt; </td></tr>
<tr class="memitem:aab8c105b59443d003e7f7b6f898ae81c"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; detect_has_fold_trait&lt; Trait &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#aab8c105b59443d003e7f7b6f898ae81c">mlir::op_definition_impl::foldTrait</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:aab8c105b59443d003e7f7b6f898ae81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a generalized <code>foldTrait</code> function that is supports any operation type.  <a href="namespacemlir_1_1op__definition__impl.html#aab8c105b59443d003e7f7b6f898ae81c">More...</a><br /></td></tr>
<tr class="separator:aab8c105b59443d003e7f7b6f898ae81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86102e55170f09841069a60aac26f087"><td class="memTemplParams" colspan="2">template&lt;typename Trait &gt; </td></tr>
<tr class="memitem:a86102e55170f09841069a60aac26f087"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt;!detect_has_any_fold_trait&lt; Trait &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a86102e55170f09841069a60aac26f087">mlir::op_definition_impl::foldTrait</a> (Operation *, ArrayRef&lt; Attribute &gt;, SmallVectorImpl&lt; OpFoldResult &gt; &amp;)</td></tr>
<tr class="separator:a86102e55170f09841069a60aac26f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9f50d44f4d29093384d1517ee6bbc7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9f9f50d44f4d29093384d1517ee6bbc7"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a9f9f50d44f4d29093384d1517ee6bbc7">mlir::op_definition_impl::foldTraits</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:a9f9f50d44f4d29093384d1517ee6bbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple type containing a set of traits, return the result of folding the given operation.  <a href="namespacemlir_1_1op__definition__impl.html#a9f9f50d44f4d29093384d1517ee6bbc7">More...</a><br /></td></tr>
<tr class="separator:a9f9f50d44f4d29093384d1517ee6bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bbf485bc2550319055ebe8042c6dd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17bbf485bc2550319055ebe8042c6dd7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; detect_has_verify_trait&lt; T &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a17bbf485bc2550319055ebe8042c6dd7">mlir::op_definition_impl::verifyTrait</a> (Operation *op)</td></tr>
<tr class="memdesc:a17bbf485bc2550319055ebe8042c6dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the given trait if it provides a verifier.  <a href="namespacemlir_1_1op__definition__impl.html#a17bbf485bc2550319055ebe8042c6dd7">More...</a><br /></td></tr>
<tr class="separator:a17bbf485bc2550319055ebe8042c6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4861f14621261be57e1a6298fb7f638c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4861f14621261be57e1a6298fb7f638c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!detect_has_verify_trait&lt; T &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a4861f14621261be57e1a6298fb7f638c">mlir::op_definition_impl::verifyTrait</a> (Operation *)</td></tr>
<tr class="separator:a4861f14621261be57e1a6298fb7f638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1995dca865ae098afe18a3230bd428"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a3f1995dca865ae098afe18a3230bd428"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3f1995dca865ae098afe18a3230bd428">mlir::op_definition_impl::verifyTraits</a> (Operation *op)</td></tr>
<tr class="memdesc:a3f1995dca865ae098afe18a3230bd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of traits, return the result of verifying the given operation.  <a href="namespacemlir_1_1op__definition__impl.html#a3f1995dca865ae098afe18a3230bd428">More...</a><br /></td></tr>
<tr class="separator:a3f1995dca865ae098afe18a3230bd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7734f58488e199b85bd702b6ac64ab5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7734f58488e199b85bd702b6ac64ab5d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; detect_has_verify_region_trait&lt; T &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a7734f58488e199b85bd702b6ac64ab5d">mlir::op_definition_impl::verifyRegionTrait</a> (Operation *op)</td></tr>
<tr class="memdesc:a7734f58488e199b85bd702b6ac64ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the given trait if it provides a region verifier.  <a href="namespacemlir_1_1op__definition__impl.html#a7734f58488e199b85bd702b6ac64ab5d">More...</a><br /></td></tr>
<tr class="separator:a7734f58488e199b85bd702b6ac64ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41a2cfb3b1c73b7c6519f79e0c395e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe41a2cfb3b1c73b7c6519f79e0c395e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!detect_has_verify_region_trait&lt; T &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#abe41a2cfb3b1c73b7c6519f79e0c395e">mlir::op_definition_impl::verifyRegionTrait</a> (Operation *)</td></tr>
<tr class="separator:abe41a2cfb3b1c73b7c6519f79e0c395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab994d3a7ec910aba95d06ad4b413711d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab994d3a7ec910aba95d06ad4b413711d"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab994d3a7ec910aba95d06ad4b413711d">mlir::op_definition_impl::verifyRegionTraits</a> (Operation *op)</td></tr>
<tr class="memdesc:ab994d3a7ec910aba95d06ad4b413711d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of traits, return the result of verifying the regions of the given operation.  <a href="namespacemlir_1_1op__definition__impl.html#ab994d3a7ec910aba95d06ad4b413711d">More...</a><br /></td></tr>
<tr class="separator:ab994d3a7ec910aba95d06ad4b413711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dfb6c5c1746815939067b8aeb67cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a29dfb6c5c1746815939067b8aeb67cfb">mlir::impl::foldCastInterfaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; attrOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;foldResults)</td></tr>
<tr class="memdesc:a29dfb6c5c1746815939067b8aeb67cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to fold the given cast operation.  <a href="namespacemlir_1_1impl.html#a29dfb6c5c1746815939067b8aeb67cfb">More...</a><br /></td></tr>
<tr class="separator:a29dfb6c5c1746815939067b8aeb67cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c44a4e0ec8bccf0435bc3a37be108f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a6c44a4e0ec8bccf0435bc3a37be108f4">mlir::impl::verifyCastInterfaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>)&gt; areCastCompatible)</td></tr>
<tr class="memdesc:a6c44a4e0ec8bccf0435bc3a37be108f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to verify the given cast operation.  <a href="namespacemlir_1_1impl.html#a6c44a4e0ec8bccf0435bc3a37be108f4">More...</a><br /></td></tr>
<tr class="separator:a6c44a4e0ec8bccf0435bc3a37be108f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:01 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
