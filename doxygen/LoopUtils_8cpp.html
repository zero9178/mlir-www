<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/LoopUtils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LoopUtils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2SCF_8h_source.html">mlir/Dialect/SCF/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BlockAndValueMapping_8h_source.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MathExtras_8h_source.html">mlir/Support/MathExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegionUtils_8h_source.html">mlir/Transforms/RegionUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallPtrSet.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for LoopUtils.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="LoopUtils_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2Affine_2Utils_2LoopUtils_8cpp" alt=""/></div>
<map name="lib_2Dialect_2Affine_2Utils_2LoopUtils_8cpp" id="lib_2Dialect_2Affine_2Utils_2LoopUtils_8cpp">
<area shape="rect" id="node2" href="LoopUtils_8h.html" title="mlir/Dialect/Affine\l/LoopUtils.h" alt="" coords="44,363,184,404"/>
<area shape="rect" id="node8" href="SliceAnalysis_8h.html" title="mlir/Analysis/SliceAnalysis.h" alt="" coords="3048,459,3257,486"/>
<area shape="rect" id="node11" href="AffineAnalysis_8h.html" title="mlir/Dialect/Affine\l/Analysis/AffineAnalysis.h" alt="" coords="1105,184,1296,225"/>
<area shape="rect" id="node23" href="LoopAnalysis_8h.html" title="mlir/Dialect/Affine\l/Analysis/LoopAnalysis.h" alt="" coords="514,452,697,493"/>
<area shape="rect" id="node25" href="Dialect_2Affine_2Analysis_2Utils_8h.html" title="mlir/Dialect/Affine\l/Analysis/Utils.h" alt="" coords="773,363,913,404"/>
<area shape="rect" id="node28" href="AffineOps_8h.html" title="mlir/Dialect/Affine\l/IR/AffineOps.h" alt="" coords="1752,184,1892,225"/>
<area shape="rect" id="node34" href="AffineValueMap_8h.html" title="mlir/Dialect/Affine\l/IR/AffineValueMap.h" alt="" coords="989,363,1145,404"/>
<area shape="rect" id="node35" href="Dialect_2Affine_2Utils_8h.html" title="mlir/Dialect/Affine\l/Utils.h" alt="" coords="1106,95,1246,136"/>
<area shape="rect" id="node36" href="FuncOps_8h.html" title="mlir/Dialect/Func/IR\l/FuncOps.h" alt="" coords="2410,273,2558,315"/>
<area shape="rect" id="node40" href="MemRef_8h.html" title="mlir/Dialect/MemRef\l/IR/MemRef.h" alt="" coords="2231,273,2386,315"/>
<area shape="rect" id="node41" href="Dialect_2SCF_2SCF_8h.html" title="mlir/Dialect/SCF/SCF.h" alt="" coords="2784,281,2948,307"/>
<area shape="rect" id="node42" href="BlockAndValueMapping_8h.html" title="mlir/IR/BlockAndValueMapping.h" alt="" coords="258,191,492,218"/>
<area shape="rect" id="node43" href="IR_2IntegerSet_8h.html" title="mlir/IR/IntegerSet.h" alt="" coords="745,191,893,218"/>
<area shape="rect" id="node44" href="MathExtras_8h.html" title="mlir/Support/MathExtras.h" alt="" coords="2778,191,2969,218"/>
<area shape="rect" id="node45" href="GreedyPatternRewriteDriver_8h.html" title="mlir/Transforms/GreedyPattern\lRewriteDriver.h" alt="" coords="2119,95,2340,136"/>
<area shape="rect" id="node46" href="RegionUtils_8h.html" title="mlir/Transforms/RegionUtils.h" alt="" coords="1666,459,1881,486"/>
<area shape="rect" id="node3" href="Block_8h.html" title="mlir/IR/Block.h" alt="" coords="147,459,264,486"/>
<area shape="rect" id="node4" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="1113,616,1264,643"/>
<area shape="rect" id="node6" href="LogicalResult_8h.html" title="mlir/Support/LogicalResult.h" alt="" coords="44,541,248,568"/>
<area shape="rect" id="node12" href="Arithmetic_8h.html" title="mlir/Dialect/Arithmetic\l/IR/Arithmetic.h" alt="" coords="1556,273,1727,315"/>
<area shape="rect" id="node16" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="1276,541,1394,568"/>
<area shape="rect" id="node13" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="1576,370,1702,397"/>
<area shape="rect" id="node18" href="OpImplementation_8h.html" title="mlir/IR/OpImplementation.h" alt="" coords="1932,370,2135,397"/>
<area shape="rect" id="node20" href="InferTypeOpInterface_8h.html" title="mlir/Interfaces/InferType\lOpInterface.h" alt="" coords="1727,363,1908,404"/>
<area shape="rect" id="node14" href="OperationSupport_8h.html" title="mlir/IR/OperationSupport.h" alt="" coords="1095,459,1290,486"/>
<area shape="rect" id="node15" href="Location_8h.html" title="mlir/IR/Location.h" alt="" coords="1116,541,1252,568"/>
<area shape="rect" id="node19" href="IR_2BuiltinTypes_8h.html" title="mlir/IR/BuiltinTypes.h" alt="" coords="1956,459,2116,486"/>
<area shape="rect" id="node21" href="Builders_8h.html" title="mlir/IR/Builders.h" alt="" coords="2428,459,2562,486"/>
<area shape="rect" id="node26" href="AffineStructures_8h.html" title="mlir/Dialect/Affine\l/Analysis/AffineStructures.h" alt="" coords="289,452,490,493"/>
<area shape="rect" id="node27" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="924,459,1071,486"/>
<area shape="rect" id="node29" href="AffineMemoryOpInterfaces_8h.html" title="mlir/Dialect/Affine\l/IR/AffineMemoryOpInterfaces.h" alt="" coords="1322,363,1551,404"/>
<area shape="rect" id="node30" href="ControlFlowInterfaces_8h.html" title="mlir/Interfaces/ControlFlow\lInterfaces.h" alt="" coords="2209,363,2408,404"/>
<area shape="rect" id="node31" href="LoopLikeInterface_8h.html" title="mlir/Interfaces/LoopLike\lInterface.h" alt="" coords="3103,363,3282,404"/>
<area shape="rect" id="node37" href="FunctionInterfaces_8h.html" title="mlir/IR/FunctionInterfaces.h" alt="" coords="2532,370,2732,397"/>
<area shape="rect" id="node38" href="SymbolTable_8h.html" title="mlir/IR/SymbolTable.h" alt="" coords="2785,459,2949,486"/>
<area shape="rect" id="node39" href="CallInterfaces_8h.html" title="mlir/Interfaces/CallInterfaces.h" alt="" coords="2756,370,2978,397"/>
</map>
</div>
</div>
<p><a href="LoopUtils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structJamBlockGatherer.html">JamBlockGatherer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structStrideInfo.html">StrideInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;LoopUtils&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9f5fd0b12aa6c54ccac5e3b989058e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#ae9f5fd0b12aa6c54ccac5e3b989058e1">getCleanupLoopLowerBound</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> unrollFactor, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;cleanupLbMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;cleanupLbOperands)</td></tr>
<tr class="memdesc:ae9f5fd0b12aa6c54ccac5e3b989058e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop.  <a href="#ae9f5fd0b12aa6c54ccac5e3b989058e1">More...</a><br /></td></tr>
<tr class="separator:ae9f5fd0b12aa6c54ccac5e3b989058e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec6a79e25848be5701c5726d5c58c45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#afec6a79e25848be5701c5726d5c58c45">replaceIterArgsAndYieldResults</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:afec6a79e25848be5701c5726d5c58c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to replace uses of loop carried values (iter_args) and loop yield values while promoting single iteration affine.for ops.  <a href="#afec6a79e25848be5701c5726d5c58c45">More...</a><br /></td></tr>
<tr class="separator:afec6a79e25848be5701c5726d5c58c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d9620253cb64c4bf526fe054762b1a"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a29d9620253cb64c4bf526fe054762b1a">generateShiftedLoop</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap, const std::vector&lt; std::pair&lt; uint64_t, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt;&gt; &amp;opGroupQueue, <a class="el" href="classunsigned.html">unsigned</a> offset, AffineForOp srcForOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b)</td></tr>
<tr class="memdesc:a29d9620253cb64c4bf526fe054762b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an affine.for op with the specified lower and upper bounds while generating the right IV remappings to realize shifts for operations in its body.  <a href="#a29d9620253cb64c4bf526fe054762b1a">More...</a><br /></td></tr>
<tr class="separator:a29d9620253cb64c4bf526fe054762b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ff821b01ca66331f2750105cd29b1f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#ac3ff821b01ca66331f2750105cd29b1f">checkTilingLegalityImpl</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; mlir::AffineForOp &gt; origLoops)</td></tr>
<tr class="memdesc:ac3ff821b01ca66331f2750105cd29b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the legality of tiling of a hyper-rectangular loop nest by simply checking if there is a 'negative' dependence in the memrefs present in the loop nest.  <a href="#ac3ff821b01ca66331f2750105cd29b1f">More...</a><br /></td></tr>
<tr class="separator:ac3ff821b01ca66331f2750105cd29b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a7fa5d8b7559f948e7dfca7061c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#aec3a7fa5d8b7559f948e7dfca7061c9f">checkTilingLegality</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; mlir::AffineForOp &gt; origLoops)</td></tr>
<tr class="memdesc:aec3a7fa5d8b7559f948e7dfca7061c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether hyper-rectangular loop tiling of the nest represented by <code>origLoops</code> is valid.  <a href="#aec3a7fa5d8b7559f948e7dfca7061c9f">More...</a><br /></td></tr>
<tr class="separator:aec3a7fa5d8b7559f948e7dfca7061c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2d89ec54aa179df4b42431bacb288f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#aba2d89ec54aa179df4b42431bacb288f">checkIfHyperRectangular</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input)</td></tr>
<tr class="memdesc:aba2d89ec54aa179df4b42431bacb288f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a loop nest is hyper-rectangular or not.  <a href="#aba2d89ec54aa179df4b42431bacb288f">More...</a><br /></td></tr>
<tr class="separator:aba2d89ec54aa179df4b42431bacb288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b7a574e08b011e149e862de81bc39b"><td class="memTemplParams" colspan="2">template&lt;typename t &gt; </td></tr>
<tr class="memitem:ab9b7a574e08b011e149e862de81bc39b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#ab9b7a574e08b011e149e862de81bc39b">performPreTilingChecks</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; t &gt; tileSizes)</td></tr>
<tr class="memdesc:ab9b7a574e08b011e149e862de81bc39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the input nest is supported for tiling and whether tiling would be legal or not.  <a href="#ab9b7a574e08b011e149e862de81bc39b">More...</a><br /></td></tr>
<tr class="separator:ab9b7a574e08b011e149e862de81bc39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5924e91f0fcb574f01a0ef718fd0d38e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a5924e91f0fcb574f01a0ef718fd0d38e">moveLoopBodyImpl</a> (AffineForOp src, AffineForOp dest, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> loc)</td></tr>
<tr class="memdesc:a5924e91f0fcb574f01a0ef718fd0d38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the loop body of AffineForOp 'src' from 'src' into the specified location in destination's body, ignoring the terminator.  <a href="#a5924e91f0fcb574f01a0ef718fd0d38e">More...</a><br /></td></tr>
<tr class="separator:a5924e91f0fcb574f01a0ef718fd0d38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afe2b5dcbd5bf71e7f53551d5667543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a7afe2b5dcbd5bf71e7f53551d5667543">moveLoopBody</a> (AffineForOp src, AffineForOp dest)</td></tr>
<tr class="memdesc:a7afe2b5dcbd5bf71e7f53551d5667543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the loop body of AffineForOp 'src' from 'src' to the start of dest body.  <a href="#a7afe2b5dcbd5bf71e7f53551d5667543">More...</a><br /></td></tr>
<tr class="separator:a7afe2b5dcbd5bf71e7f53551d5667543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83637a522ca37f21ad29b95686634163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a83637a522ca37f21ad29b95686634163">constructTiledLoopNest</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, AffineForOp rootAffineForOp, <a class="el" href="classunsigned.html">unsigned</a> width, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; tiledLoops)</td></tr>
<tr class="memdesc:a83637a522ca37f21ad29b95686634163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs tiled loop nest, without setting the loop bounds and move the body of the original loop nest to the tiled loop nest.  <a href="#a83637a522ca37f21ad29b95686634163">More...</a><br /></td></tr>
<tr class="separator:a83637a522ca37f21ad29b95686634163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fecf5961f8da1b944c27825666cdf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a63fecf5961f8da1b944c27825666cdf6">setIntraTileBoundsParametric</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AffineForOp origLoop, AffineForOp newInterTileLoop, AffineForOp newIntraTileLoop, <a class="el" href="classmlir_1_1Value.html">Value</a> tileSize)</td></tr>
<tr class="memdesc:a63fecf5961f8da1b944c27825666cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower and upper bounds of intra-tile loops for parametric tiling.  <a href="#a63fecf5961f8da1b944c27825666cdf6">More...</a><br /></td></tr>
<tr class="separator:a63fecf5961f8da1b944c27825666cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d47dd5a912dd47b30a64a582d8ddb7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a61d47dd5a912dd47b30a64a582d8ddb7">setInterTileBoundsParametric</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AffineForOp origLoop, AffineForOp newLoop, <a class="el" href="classmlir_1_1Value.html">Value</a> tileSize)</td></tr>
<tr class="memdesc:a61d47dd5a912dd47b30a64a582d8ddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower and upper bounds of inter-tile loops for parametric tiling.  <a href="#a61d47dd5a912dd47b30a64a582d8ddb7">More...</a><br /></td></tr>
<tr class="separator:a61d47dd5a912dd47b30a64a582d8ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109bbddfb77b05a4f3e45beffe019a16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a109bbddfb77b05a4f3e45beffe019a16">constructParametricallyTiledIndexSetHyperRect</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; newLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a109bbddfb77b05a4f3e45beffe019a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions and tiling parameters are captured from SSA values.  <a href="#a109bbddfb77b05a4f3e45beffe019a16">More...</a><br /></td></tr>
<tr class="separator:a109bbddfb77b05a4f3e45beffe019a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f9e7796076ef4cea1254a2e0ba5041"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a97f9e7796076ef4cea1254a2e0ba5041">constructTiledIndexSetHyperRect</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; newLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a97f9e7796076ef4cea1254a2e0ba5041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions.  <a href="#a97f9e7796076ef4cea1254a2e0ba5041">More...</a><br /></td></tr>
<tr class="separator:a97f9e7796076ef4cea1254a2e0ba5041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3d5bafce05406f1c3de35328216d3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a6a3d5bafce05406f1c3de35328216d3f">generateUnrolledLoop</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *loopBodyBlock, <a class="el" href="classmlir_1_1Value.html">Value</a> forOpIV, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; ivRemapFn, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> yieldedValues)</td></tr>
<tr class="memdesc:a6a3d5bafce05406f1c3de35328216d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates unrolled copies of AffineForOp 'loopBodyBlock', with associated 'forOpIV' by 'unrollFactor', calling 'ivRemapFn' to remap 'forOpIV' for each unrolled body.  <a href="#a6a3d5bafce05406f1c3de35328216d3f">More...</a><br /></td></tr>
<tr class="separator:a6a3d5bafce05406f1c3de35328216d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38533a9233645094cbc0d835899e16b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#aa38533a9233645094cbc0d835899e16b">generateCleanupLoopForUnroll</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:aa38533a9233645094cbc0d835899e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to generate cleanup loop for unroll or unroll-and-jam when the trip count is not a multiple of <code>unrollFactor</code>.  <a href="#aa38533a9233645094cbc0d835899e16b">More...</a><br /></td></tr>
<tr class="separator:aa38533a9233645094cbc0d835899e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8682a13fef12f391f3d7ec0314776f2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#aa8682a13fef12f391f3d7ec0314776f2">areInnerBoundsInvariant</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:aa8682a13fef12f391f3d7ec0314776f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all control operands of all loops are defined outside of <code>forOp</code> and return false if not.  <a href="#aa8682a13fef12f391f3d7ec0314776f2">More...</a><br /></td></tr>
<tr class="separator:aa8682a13fef12f391f3d7ec0314776f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace165f719d896f578d05bfb00adce49"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#aace165f719d896f578d05bfb00adce49">checkLoopInterchangeDependences</a> (const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; &amp;depCompsVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; loopPermMap)</td></tr>
<tr class="separator:aace165f719d896f578d05bfb00adce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da35f76711087c102d41952e7be187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#af1da35f76711087c102d41952e7be187">augmentMapAndBounds</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; *operands, int64_t offset=0)</td></tr>
<tr class="separator:af1da35f76711087c102d41952e7be187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c23a22770f1ccbee4357e3dbddf42ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a3c23a22770f1ccbee4357e3dbddf42ce">stripmineSink</a> (AffineForOp forOp, uint64_t factor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="separator:a3c23a22770f1ccbee4357e3dbddf42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda437963a9fbf87b5b4ec7660ab18de"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:adda437963a9fbf87b5b4ec7660ab18de"><td class="memTemplItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#adda437963a9fbf87b5b4ec7660ab18de">stripmineSink</a> (AffineForOp forOp, SizeType factor, AffineForOp target)</td></tr>
<tr class="separator:adda437963a9fbf87b5b4ec7660ab18de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a140f24e42583fb80603e04bb3984"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a4a0a140f24e42583fb80603e04bb3984">findHighestBlockForPlacement</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;end, <a class="el" href="classmlir_1_1Block.html">Block</a> **copyPlacementBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *copyInPlacementStart, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *copyOutPlacementStart)</td></tr>
<tr class="memdesc:a4a0a140f24e42583fb80603e04bb3984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a memref region, determine the lowest depth at which transfers can be placed for it, and return the corresponding block, start and end positions in the block for placing incoming (read) and outgoing (write) copies respectively.  <a href="#a4a0a140f24e42583fb80603e04bb3984">More...</a><br /></td></tr>
<tr class="separator:a4a0a140f24e42583fb80603e04bb3984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809d332a4034932b525aab736987d9ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a809d332a4034932b525aab736987d9ff">getMultiLevelStrides</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; bufferShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structStrideInfo.html">StrideInfo</a> &gt; *strideInfos)</td></tr>
<tr class="memdesc:a809d332a4034932b525aab736987d9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns striding information for a copy/transfer of this region with potentially multiple striding levels from outermost to innermost.  <a href="#a809d332a4034932b525aab736987d9ff">More...</a><br /></td></tr>
<tr class="separator:a809d332a4034932b525aab736987d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9727db6fbdbf1f743563fd9b16a705c"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#af9727db6fbdbf1f743563fd9b16a705c">generatePointWiseCopy</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Value.html">Value</a> fastMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; lbOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; ubOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; fastBufOffsets, bool isCopyOut, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b)</td></tr>
<tr class="memdesc:af9727db6fbdbf1f743563fd9b16a705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a point-wise copy from/to `memref' to/from `fastMemRef' and returns the outermost AffineForOp of the copy loop nest.  <a href="#af9727db6fbdbf1f743563fd9b16a705c">More...</a><br /></td></tr>
<tr class="separator:af9727db6fbdbf1f743563fd9b16a705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de9f6a10e6dcb3328730888f1c28c94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a3de9f6a10e6dcb3328730888f1c28c94">emitRemarkForBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="separator:a3de9f6a10e6dcb3328730888f1c28c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c59d0854515c5c649f66bbd5d42aa0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a0c59d0854515c5c649f66bbd5d42aa0e">generateCopy</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, <a class="el" href="classmlir_1_1Block.html">Block</a> *copyPlacementBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> copyInPlacementStart, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> copyOutPlacementStart, <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> copyOptions, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;fastBufferMap, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests, uint64_t *sizeInBytes, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *nBegin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *nEnd)</td></tr>
<tr class="memdesc:a0c59d0854515c5c649f66bbd5d42aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer in the faster memory space for the specified memref region; generates a copy from the lower memory space to this one, and replaces all loads/stores in the block range [`begin', `end') of `block' to load/store from that buffer.  <a href="#a0c59d0854515c5c649f66bbd5d42aa0e">More...</a><br /></td></tr>
<tr class="separator:a0c59d0854515c5c649f66bbd5d42aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3841de62eb5a230cd65788335217c99c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a3841de62eb5a230cd65788335217c99c">getFullMemRefAsRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numParamLoopIVs, <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> *region)</td></tr>
<tr class="memdesc:a3841de62eb5a230cd65788335217c99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the memref region to just include the entire memref.  <a href="#a3841de62eb5a230cd65788335217c99c">More...</a><br /></td></tr>
<tr class="separator:a3841de62eb5a230cd65788335217c99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d53b2f12eaedf38a174cf512e6727b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a65d53b2f12eaedf38a174cf512e6727b">gatherLoopsInBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classunsigned.html">unsigned</a> currLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;depthToLoops)</td></tr>
<tr class="memdesc:a65d53b2f12eaedf38a174cf512e6727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all AffineForOps in 'block' at 'currLoopDepth' in 'depthToLoops'.  <a href="#a65d53b2f12eaedf38a174cf512e6727b">More...</a><br /></td></tr>
<tr class="separator:a65d53b2f12eaedf38a174cf512e6727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab281427ba40a98c3049b992b9ede579e"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#ab281427ba40a98c3049b992b9ede579e">createSeparationCondition</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b)</td></tr>
<tr class="memdesc:ab281427ba40a98c3049b992b9ede579e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AffineIfOp that encodes the conditional to choose between the constant trip count version and an unknown trip count version of this nest of loops.  <a href="#ab281427ba40a98c3049b992b9ede579e">More...</a><br /></td></tr>
<tr class="separator:ab281427ba40a98c3049b992b9ede579e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7251ea142ec1d74f6258afa49a410ce1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopUtils_8cpp.html#a7251ea142ec1d74f6258afa49a410ce1">createFullTiles</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;fullTileLoops, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b)</td></tr>
<tr class="memdesc:a7251ea142ec1d74f6258afa49a410ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the full tile loop nest (along with its body).  <a href="#a7251ea142ec1d74f6258afa49a410ce1">More...</a><br /></td></tr>
<tr class="separator:a7251ea142ec1d74f6258afa49a410ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;LoopUtils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00034">34</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa8682a13fef12f391f3d7ec0314776f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8682a13fef12f391f3d7ec0314776f2">&#9670;&nbsp;</a></span>areInnerBoundsInvariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool areInnerBoundsInvariant </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all control operands of all loops are defined outside of <code>forOp</code> and return false if not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01163">1163</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, and <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01203">mlir::loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="af1da35f76711087c102d41952e7be187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da35f76711087c102d41952e7be187">&#9670;&nbsp;</a></span>augmentMapAndBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> augmentMapAndBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01622">1622</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01642">stripmineSink()</a>.</p>

</div>
</div>
<a id="aba2d89ec54aa179df4b42431bacb288f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2d89ec54aa179df4b42431bacb288f">&#9670;&nbsp;</a></span>checkIfHyperRectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> checkIfHyperRectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a loop nest is hyper-rectangular or not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00442">442</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01535">mlir::presburger::IntegerRelation::isHyperRectangular()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>.</p>

</div>
</div>
<a id="aace165f719d896f578d05bfb00adce49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace165f719d896f578d05bfb00adce49">&#9670;&nbsp;</a></span>checkLoopInterchangeDependences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool checkLoopInterchangeDependences </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>depCompsVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01422">1422</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01456">mlir::isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01562">mlir::sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="aec3a7fa5d8b7559f948e7dfca7061c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a7fa5d8b7559f948e7dfca7061c9f">&#9670;&nbsp;</a></span>checkTilingLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> checkTilingLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; mlir::AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>origLoops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether hyper-rectangular loop tiling of the nest represented by <code>origLoops</code> is valid. </p>
<p>The validity condition is from Irigoin and Triolet, which states that two tiles cannot depend on each other. We simplify such condition to just checking whether there is any negative dependence direction, since we have the prior knowledge that the tiling results will be hyper-rectangles, which are scheduled in the lexicographically increasing order on the vector of loop indices. This function will return failure when any dependence component is negative along any of <code>origLoops</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00437">437</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkTilingLegalityImpl()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00463">performPreTilingChecks()</a>.</p>

</div>
</div>
<a id="ac3ff821b01ca66331f2750105cd29b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ff821b01ca66331f2750105cd29b1f">&#9670;&nbsp;</a></span>checkTilingLegalityImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool checkTilingLegalityImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; mlir::AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>origLoops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the legality of tiling of a hyper-rectangular loop nest by simply checking if there is a 'negative' dependence in the memrefs present in the loop nest. </p>
<p>If yes then tiling is invalid. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00368">368</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03123">mlir::Operation::dump()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00176">mlir::hasDependence()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00143">mlir::DependenceComponent::lb</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00082">mlir::MemRefAccess::opInst</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00228">mlir::FlatAffineValueConstraints::reset()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00145">mlir::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00437">checkTilingLegality()</a>.</p>

</div>
</div>
<a id="a109bbddfb77b05a4f3e45beffe019a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109bbddfb77b05a4f3e45beffe019a16">&#9670;&nbsp;</a></span>constructParametricallyTiledIndexSetHyperRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> constructParametricallyTiledIndexSetHyperRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>origLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>newLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions and tiling parameters are captured from SSA values. </p>
<p>Bounds of each dimension can thus be treated independently, and deriving the new bounds is much simpler and faster than for the case of tiling arbitrary polyhedral shapes. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00746">746</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00645">setInterTileBoundsParametric()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00550">setIntraTileBoundsParametric()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00904">mlir::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a97f9e7796076ef4cea1254a2e0ba5041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f9e7796076ef4cea1254a2e0ba5041">&#9670;&nbsp;</a></span>constructTiledIndexSetHyperRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> constructTiledIndexSetHyperRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>origLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>newLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions. </p>
<p>Bounds of each dimension can thus be treated independently, and deriving the new bounds is much simpler and faster than for the case of tiling arbitrary polyhedral shapes. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00774">774</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00083">mlir::getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00109">mlir::getLargestDivisorOfTripCount()</a>, <a class="el" href="AffineOps_8h_source.html#l00452">mlir::AffineBound::getMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00454">mlir::AffineBound::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8h_source.html#l00455">mlir::AffineBound::getOperand()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00860">mlir::tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="a83637a522ca37f21ad29b95686634163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83637a522ca37f21ad29b95686634163">&#9670;&nbsp;</a></span>constructTiledLoopNest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> constructTiledLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>origLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>rootAffineForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>tiledLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs tiled loop nest, without setting the loop bounds and move the body of the original loop nest to the tiled loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00509">509</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00503">moveLoopBody()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00860">mlir::tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00904">mlir::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a7251ea142ec1d74f6258afa49a410ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7251ea142ec1d74f6258afa49a410ce1">&#9670;&nbsp;</a></span>createFullTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> createFullTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>inputNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>fullTileLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the full tile loop nest (along with its body). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02735">2735</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00221">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="Builders_8cpp_source.html#l00468">mlir::OpBuilder::clone()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02633">mlir::createCanonicalizedAffineForOp()</a>, <a class="el" href="Matchers_8h_source.html#l00234">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01331">mlir::presburger::IntegerRelation::getConstantBoundOnDimSize()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01438">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00495">mlir::presburger::IntegerRelation::setDimSymbolSeparation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02790">mlir::separateFullTiles()</a>.</p>

</div>
</div>
<a id="ab281427ba40a98c3049b992b9ede579e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab281427ba40a98c3049b992b9ede579e">&#9670;&nbsp;</a></span>createSeparationCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineIfOp createSeparationCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an AffineIfOp that encodes the conditional to choose between the constant trip count version and an unknown trip count version of this nest of loops. </p>
<p>This is used to separate partial and full tiles if <code>loops</code> has the intra-tile loops. The affine.if op is inserted at the builder insertion point of <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02655">2655</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00123">mlir::presburger::IntegerRelation::atIneq()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">mlir::canonicalizeSetAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01484">mlir::FlatAffineValueConstraints::getAsIntegerSet()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01331">mlir::presburger::IntegerRelation::getConstantBoundOnDimSize()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00244">mlir::getIndexSet()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00164">mlir::presburger::IntegerRelation::getInequality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00297">mlir::presburger::IntegerRelation::getLowerAndUpperBoundIndices()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">mlir::FlatAffineValueConstraints::getValues()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00198">mlir::presburger::IntegerRelation::removeId()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02062">mlir::presburger::IntegerRelation::removeIndependentConstraints()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01565">mlir::presburger::IntegerRelation::removeTrivialRedundancy()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00495">mlir::presburger::IntegerRelation::setDimSymbolSeparation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02790">mlir::separateFullTiles()</a>.</p>

</div>
</div>
<a id="a3de9f6a10e6dcb3328730888f1c28c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de9f6a10e6dcb3328730888f1c28c94">&#9670;&nbsp;</a></span>emitRemarkForBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> LLVM_ATTRIBUTE_UNUSED emitRemarkForBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02025">2025</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00252">mlir::Operation::emitRemark()</a>, and <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>.</p>

</div>
</div>
<a id="a4a0a140f24e42583fb80603e04bb3984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a140f24e42583fb80603e04bb3984">&#9670;&nbsp;</a></span>findHighestBlockForPlacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> findHighestBlockForPlacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> **&#160;</td>
          <td class="paramname"><em>copyPlacementBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *&#160;</td>
          <td class="paramname"><em>copyInPlacementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *&#160;</td>
          <td class="paramname"><em>copyOutPlacementStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a memref region, determine the lowest depth at which transfers can be placed for it, and return the corresponding block, start and end positions in the block for placing incoming (read) and outgoing (write) copies respectively. </p>
<p>The lowest depth depends on whether the region being accessed is hoistable with respect to one or more immediately surrounding loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01873">1873</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00286">mlir::MemRefRegion::getConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">mlir::getLoopIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02374">mlir::affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a65d53b2f12eaedf38a174cf512e6727b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d53b2f12eaedf38a174cf512e6727b">&#9670;&nbsp;</a></span>gatherLoopsInBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> gatherLoopsInBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>currLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>depthToLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers all AffineForOps in 'block' at 'currLoopDepth' in 'depthToLoops'. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02601">2601</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02617">mlir::gatherLoops()</a>.</p>

</div>
</div>
<a id="aa38533a9233645094cbc0d835899e16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38533a9233645094cbc0d835899e16b">&#9670;&nbsp;</a></span>generateCleanupLoopForUnroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> generateCleanupLoopForUnroll </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to generate cleanup loop for unroll or unroll-and-jam when the trip count is not a multiple of <code>unrollFactor</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01057">1057</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00056">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">mlir::promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01092">mlir::loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01203">mlir::loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a0c59d0854515c5c649f66bbd5d42aa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c59d0854515c5c649f66bbd5d42aa0e">&#9670;&nbsp;</a></span>generateCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> generateCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>copyPlacementBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>copyInPlacementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>copyOutPlacementStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a>&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fastBufferMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *&#160;</td>
          <td class="paramname"><em>nBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *&#160;</td>
          <td class="paramname"><em>nEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a buffer in the faster memory space for the specified memref region; generates a copy from the lower memory space to this one, and replaces all loads/stores in the block range [`begin', `end') of `block' to load/store from that buffer. </p>
<p>Returns failure if copies could not be generated due to yet unimplemented cases. <code>copyInPlacementStart</code> and <code>copyOutPlacementStart</code> in copyPlacementBlock specify the insertion points where the incoming copies and outgoing copies, respectively, should be inserted (the insertion happens right before the insertion point). Since <code>begin</code> can itself be invalidated due to the memref rewriting done from this method, the output argument <code>nBegin</code> is set to its replacement (set to <code>begin</code> if no invalidation happens). Since outgoing copies could have been inserted at <code>end</code>, the output argument <code>nEnd</code> is set to the new end. <code>sizeInBytes</code> is set to the size of the fast buffer allocated. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02042">2042</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02025">emitRemarkForBlock()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LoopUtils_8h_source.html#l00164">mlir::AffineCopyOptions::fastMemorySpace</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="LoopUtils_8h_source.html#l00160">mlir::AffineCopyOptions::generateDma</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01953">generatePointWiseCopy()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00345">mlir::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00286">mlir::MemRefRegion::getConstraints()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00406">mlir::MemRefRegion::getLowerAndUpperBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00644">mlir::getMemRefSizeInBytes()</a>, <a class="el" href="Builders_8cpp_source.html#l00308">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01917">getMultiLevelStrides()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00144">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00141">mlir::presburger::IntegerRelation::getNumIds()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00134">mlir::presburger::IntegerRelation::getNumSymbolIds()</a>, <a class="el" href="OpDefinition_8h_source.html#l00091">mlir::OpState::getOperation()</a>, <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="AffineStructures_8h_source.html#l00391">mlir::FlatAffineValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00288">mlir::MemRefRegion::isWrite()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00340">mlir::MemRefRegion::loc</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00333">mlir::MemRefRegion::memref</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01254">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="LoopUtils_8h_source.html#l00166">mlir::AffineCopyOptions::tagMemorySpace</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02374">mlir::affineDataCopyGenerate()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02573">mlir::generateCopyForMemRegion()</a>.</p>

</div>
</div>
<a id="af9727db6fbdbf1f743563fd9b16a705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9727db6fbdbf1f743563fd9b16a705c">&#9670;&nbsp;</a></span>generatePointWiseCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp generatePointWiseCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>fastMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>lbOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>ubOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>fastBufOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCopyOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a point-wise copy from/to `memref' to/from `fastMemRef' and returns the outermost AffineForOp of the copy loop nest. </p>
<p><code>lbMaps</code> and <code>ubMaps</code> along with <code>lbOperands</code> and <code>ubOperands</code> hold the lower and upper bound information for the copy loop nest. <code>fastBufOffsets</code> contain the expressions to be subtracted out from the respective copy loop iterators in order to index the fast buffer. If `copyOut' is true, generates a copy-out; otherwise a copy-in. Builder <code>b</code> should be set to the point the copy nest is inserted. The copy-in nest is generated as follows as an example for a 2-d region: for x = ... for y = ... fast_buf[x - offset_x][y - offset_y] = memref[x][y] </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01953">1953</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00221">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00873">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02633">mlir::createCanonicalizedAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>.</p>

</div>
</div>
<a id="a29d9620253cb64c4bf526fe054762b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d9620253cb64c4bf526fe054762b1a">&#9670;&nbsp;</a></span>generateShiftedLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp generateShiftedLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>ubMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; uint64_t, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>opGroupQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an affine.for op with the specified lower and upper bounds while generating the right IV remappings to realize shifts for operations in its body. </p>
<p>The operations that go into the loop body are specified in opGroupQueue starting from the specified offset, and in that order. The first element of the pair specifies the shift applied to that group of operations; the shift is multiplied by the loop step before being applied. Returns nullptr if the generated loop simplifies to a single iteration one. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00181">181</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00221">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00131">mlir::promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="a6a3d5bafce05406f1c3de35328216d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3d5bafce05406f1c3de35328216d3f">&#9670;&nbsp;</a></span>generateUnrolledLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> generateUnrolledLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>loopBodyBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>forOpIV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>ivRemapFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>yieldedValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates unrolled copies of AffineForOp 'loopBodyBlock', with associated 'forOpIV' by 'unrollFactor', calling 'ivRemapFn' to remap 'forOpIV' for each unrolled body. </p>
<p>If specified, annotates the Ops in each unrolled iteration using annotateFn. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01003">1003</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00221">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="Block_8h_source.html#l00134">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00066">mlir::BlockAndValueMapping::lookup()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00200">mlir::Operation::setOperands()</a>, and <a class="el" href="Value_8h_source.html#l00203">mlir::Value::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01092">mlir::loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="ae9f5fd0b12aa6c54ccac5e3b989058e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5fd0b12aa6c54ccac5e3b989058e1">&#9670;&nbsp;</a></span>getCleanupLoopLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> getCleanupLoopLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>cleanupLbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cleanupLbOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop. </p>
<p>Computes the bound as an AffineMap with its operands or a null map when the trip count can't be expressed as an affine expression. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResult()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">mlir::getTripCountMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateCleanupLoopForUnroll()</a>.</p>

</div>
</div>
<a id="a3841de62eb5a230cd65788335217c99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3841de62eb5a230cd65788335217c99c">&#9670;&nbsp;</a></span>getFullMemRefAsRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool getFullMemRefAsRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numParamLoopIVs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the memref region to just include the entire memref. </p>
<p>Returns false dynamic shaped memref's for now. <code>numParamLoopIVs</code> is the number of enclosing loop IVs of <code>op</code> (starting from the outermost) that the region is parametric on. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02333">2333</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01959">mlir::extractForInductionVars()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00286">mlir::MemRefRegion::getConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00035">mlir::getLoopIVs()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::LB</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00333">mlir::MemRefRegion::memref</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00289">mlir::MemRefRegion::setWrite()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00351">mlir::presburger::IntegerRelation::UB</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02374">mlir::affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a809d332a4034932b525aab736987d9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809d332a4034932b525aab736987d9ff">&#9670;&nbsp;</a></span>getMultiLevelStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> getMultiLevelStrides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>bufferShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structStrideInfo.html">StrideInfo</a> &gt; *&#160;</td>
          <td class="paramname"><em>strideInfos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns striding information for a copy/transfer of this region with potentially multiple striding levels from outermost to innermost. </p>
<p>For an n-dimensional region, there can be at most n-1 levels of striding successively nested. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01917">1917</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00333">mlir::MemRefRegion::memref</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02042">generateCopy()</a>.</p>

</div>
</div>
<a id="a7afe2b5dcbd5bf71e7f53551d5667543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afe2b5dcbd5bf71e7f53551d5667543">&#9670;&nbsp;</a></span>moveLoopBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> moveLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the loop body of AffineForOp 'src' from 'src' to the start of dest body. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00503">503</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00494">moveLoopBodyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00509">constructTiledLoopNest()</a>.</p>

</div>
</div>
<a id="a5924e91f0fcb574f01a0ef718fd0d38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5924e91f0fcb574f01a0ef718fd0d38e">&#9670;&nbsp;</a></span>moveLoopBodyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> moveLoopBodyImpl </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the loop body of AffineForOp 'src' from 'src' into the specified location in destination's body, ignoring the terminator. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00494">494</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00503">moveLoopBody()</a>.</p>

</div>
</div>
<a id="ab9b7a574e08b011e149e862de81bc39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b7a574e08b011e149e862de81bc39b">&#9670;&nbsp;</a></span>performPreTilingChecks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> performPreTilingChecks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the input nest is supported for tiling and whether tiling would be legal or not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00463">463</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00442">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00437">checkTilingLegality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01470">mlir::isPerfectlyNested()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00860">mlir::tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00904">mlir::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="afec6a79e25848be5701c5726d5c58c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec6a79e25848be5701c5726d5c58c45">&#9670;&nbsp;</a></span>replaceIterArgsAndYieldResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> replaceIterArgsAndYieldResults </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to replace uses of loop carried values (iter_args) and loop yield values while promoting single iteration affine.for ops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00114">114</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00131">mlir::promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a61d47dd5a912dd47b30a64a582d8ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d47dd5a912dd47b30a64a582d8ddb7">&#9670;&nbsp;</a></span>setInterTileBoundsParametric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> setInterTileBoundsParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>origLoop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>newLoop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set lower and upper bounds of inter-tile loops for parametric tiling. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00645">645</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">mlir::ceilDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00293">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00289">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00452">mlir::AffineBound::getMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00454">mlir::AffineBound::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8h_source.html#l00455">mlir::AffineBound::getOperand()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00746">constructParametricallyTiledIndexSetHyperRect()</a>.</p>

</div>
</div>
<a id="a63fecf5961f8da1b944c27825666cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fecf5961f8da1b944c27825666cdf6">&#9670;&nbsp;</a></span>setIntraTileBoundsParametric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> setIntraTileBoundsParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>origLoop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>newInterTileLoop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>newIntraTileLoop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set lower and upper bounds of intra-tile loops for parametric tiling. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00550">550</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00980">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00293">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00285">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00289">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00452">mlir::AffineBound::getMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00454">mlir::AffineBound::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8h_source.html#l00455">mlir::AffineBound::getOperand()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00746">constructParametricallyTiledIndexSetHyperRect()</a>.</p>

</div>
</div>
<a id="a3c23a22770f1ccbee4357e3dbddf42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c23a22770f1ccbee4357e3dbddf42ce">&#9670;&nbsp;</a></span>stripmineSink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;AffineForOp, 8&gt; stripmineSink </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01642">1642</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00221">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01622">augmentMapAndBounds()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00024">mlir::replaceAllUsesInRegionWith()</a>.</p>

</div>
</div>
<a id="adda437963a9fbf87b5b4ec7660ab18de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda437963a9fbf87b5b4ec7660ab18de">&#9670;&nbsp;</a></span>stripmineSink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp stripmineSink </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01685">1685</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:01 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
