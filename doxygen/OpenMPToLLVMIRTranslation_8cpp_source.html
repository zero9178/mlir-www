<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_794e483eb1cc7921d35fd149d9cc325b.html">Target</a></li><li class="navelem"><a class="el" href="dir_12a96bdcc885ecacc799866a8efa56d5.html">LLVMIR</a></li><li class="navelem"><a class="el" href="dir_38c1dda222e2fa1f8060eb14e2940f7d.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_d09a340c4a749dcbe74b34243f5130f5.html">OpenMP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">OpenMPToLLVMIRTranslation.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="OpenMPToLLVMIRTranslation_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- OpenMPToLLVMIRTranslation.cpp - Translate OpenMP dialect to LLVM IR-===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// This file implements a translation between the MLIR OpenMP dialect and LLVM</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// IR.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="OpenMPToLLVMIRTranslation_8h.html">mlir/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.h</a>&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="OpenMPDialect_8h.html">mlir/Dialect/OpenMP/OpenMPDialect.h</a>&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="BlockAndValueMapping_8h.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IR_2Operation_8h.html">mlir/IR/Operation.h</a>&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Support_2LLVM_8h.html">mlir/Support/LLVM.h</a>&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ModuleTranslation_8h.html">mlir/Target/LLVMIR/ModuleTranslation.h</a>&quot;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;llvm/ADT/SetVector.h&quot;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;llvm/ADT/TypeSwitch.h&quot;</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;llvm/Frontend/OpenMP/OMPIRBuilder.h&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/DebugInfoMetadata.h&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/IRBuilder.h&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacemlir.html">mlir</a>;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">static</span> llvm::omp::ScheduleKind</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;convertToScheduleKind(<a class="code" href="classllvm_1_1Optional.html">Optional&lt;omp::ClauseScheduleKind&gt;</a> schedKind) {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keywordflow">if</span> (!schedKind.hasValue())</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Default;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="keywordflow">switch</span> (schedKind.getValue()) {</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="keywordflow">case</span> omp::ClauseScheduleKind::Static:</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Static;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="keywordflow">case</span> omp::ClauseScheduleKind::Dynamic:</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Dynamic;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">case</span> omp::ClauseScheduleKind::Guided:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Guided;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keywordflow">case</span> omp::ClauseScheduleKind::Auto:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Auto;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">case</span> <a class="code" href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">omp::ClauseScheduleKind::Runtime</a>:</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">return</span> llvm::omp::OMP_SCHEDULE_Runtime;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  }</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  llvm_unreachable(<span class="stringliteral">&quot;unhandled schedule clause argument&quot;</span>);</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">/// ModuleTranslation stack frame for OpenMP operations. This keeps track of the</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">/// insertion points for allocas.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"></span><span class="keyword">class </span>OpenMPAllocaStackFrame</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    : <span class="keyword">public</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation_1_1StackFrameBase.html">LLVM::ModuleTranslation::StackFrameBase</a>&lt;OpenMPAllocaStackFrame&gt; {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <a class="code" href="TypeID_8h.html#a46d3bf341617d344fdcfdd82ba53c863">MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID</a>(OpenMPAllocaStackFrame)</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="keyword">explicit</span> OpenMPAllocaStackFrame(llvm::OpenMPIRBuilder::InsertPointTy allocaIP)</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;      : allocaInsertPoint(allocaIP) {}</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy allocaInsertPoint;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;};</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">/// ModuleTranslation stack frame containing the partial mapping between MLIR</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">/// values and their LLVM IR equivalents.</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"></span><span class="keyword">class </span>OpenMPVarMappingStackFrame</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    : <span class="keyword">public</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation_1_1StackFrameBase.html">LLVM::ModuleTranslation::StackFrameBase</a>&lt;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;          OpenMPVarMappingStackFrame&gt; {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <a class="code" href="TypeID_8h.html#a46d3bf341617d344fdcfdd82ba53c863">MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID</a>(OpenMPVarMappingStackFrame)</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keyword">explicit</span> OpenMPVarMappingStackFrame(</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value, llvm::Value *&gt;</a> &amp;mapping)</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      : mapping(mapping) {}</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value, llvm::Value *&gt;</a> mapping;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;};</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;} <span class="comment">// namespace</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">/// Find the insertion point for allocas given the current insertion point for</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">/// normal operations in the builder.</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"></span><span class="keyword">static</span> llvm::OpenMPIRBuilder::InsertPointTy</div><div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">   79</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                      <span class="keyword">const</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// If there is an alloca insertion point on stack, i.e. we are in a nested</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// operation and a specific point was provided by some surrounding operation,</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// use it.</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy allocaInsertPoint;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <a class="code" href="classmlir_1_1WalkResult.html">WalkResult</a> walkResult = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ade661f55bf6b8d2fdc0f19f77db51e1d">stackWalk</a>&lt;OpenMPAllocaStackFrame&gt;(</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      [&amp;](<span class="keyword">const</span> OpenMPAllocaStackFrame &amp;frame) {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        allocaInsertPoint = frame.allocaInsertPoint;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt</a>();</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      });</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordflow">if</span> (walkResult.<a class="code" href="classmlir_1_1WalkResult.html#a9c12a1d7d7c0f04aa34dc5cd35226c5e">wasInterrupted</a>())</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">return</span> allocaInsertPoint;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// Otherwise, insert to the entry block of the surrounding function.</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="comment">// If the current IRBuilder InsertPoint is the function&#39;s entry, it cannot</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// also be used for alloca insertion which would result in insertion order</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// confusion. Create a new BasicBlock for the Builder and use the entry block</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="comment">// for the allocs.</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// TODO: Create a dedicated alloca BasicBlock at function creation such that</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="comment">// we do not need to move the current InertPoint here.</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="keywordflow">if</span> (builder.GetInsertBlock() ==</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      &amp;builder.GetInsertBlock()-&gt;getParent()-&gt;getEntryBlock()) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    assert(builder.GetInsertPoint() == builder.GetInsertBlock()-&gt;end() &amp;&amp;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;           <span class="stringliteral">&quot;Assuming end of basic block&quot;</span>);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    llvm::BasicBlock *entryBB = llvm::BasicBlock::Create(</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        builder.getContext(), <span class="stringliteral">&quot;entry&quot;</span>, builder.GetInsertBlock()-&gt;getParent(),</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        builder.GetInsertBlock()-&gt;getNextNode());</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    builder.CreateBr(entryBB);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    builder.SetInsertPoint(entryBB);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  llvm::BasicBlock &amp;funcEntryBlock =</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      builder.GetInsertBlock()-&gt;getParent()-&gt;getEntryBlock();</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordflow">return</span> llvm::OpenMPIRBuilder::InsertPointTy(</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      &amp;funcEntryBlock, funcEntryBlock.getFirstInsertionPt());</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">/// Converts the given region that appears within an OpenMP dialect operation to</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">/// LLVM IR, creating a branch from the `sourceBlock` to the entry block of the</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">/// region, and a branch from any block with an successor-less OpenMP terminator</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">/// to `continuationBlock`. Populates `continuationBlockPHIs` with the PHI nodes</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">/// of the continuation block if provided.</span></div><div class="line"><a name="l00122"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">  122</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> llvm::BasicBlock *<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef blockName, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation, <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> &amp;bodyGenStatus,</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;llvm::PHINode *&gt;</a> *continuationBlockPHIs = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  llvm::BasicBlock *continuationBlock =</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      splitBB(builder, <span class="keyword">true</span>, <span class="stringliteral">&quot;omp.region.cont&quot;</span>);</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  llvm::BasicBlock *sourceBlock = builder.GetInsertBlock();</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  llvm::LLVMContext &amp;llvmContext = builder.getContext();</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;bb : region) {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    llvm::BasicBlock *llvmBB = llvm::BasicBlock::Create(</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        llvmContext, blockName, builder.GetInsertBlock()-&gt;getParent(),</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        builder.GetInsertBlock()-&gt;getNextNode());</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#accf46c19a673ef7b85e73343e9eaff38">mapBlock</a>(&amp;bb, llvmBB);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  llvm::Instruction *sourceTerminator = sourceBlock-&gt;getTerminator();</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// Terminators (namely YieldOp) may be forwarding values to the region that</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="comment">// need to be available in the continuation block. Collect the types of these</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">// operands in preparation of creating PHI nodes.</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Type *&gt;</a> continuationBlockPHITypes;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keywordtype">bool</span> operandsProcessed = <span class="keyword">false</span>;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keywordtype">unsigned</span> numYields = 0;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;bb : region.getBlocks()) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">if</span> (omp::YieldOp yield = dyn_cast&lt;omp::YieldOp&gt;(bb.getTerminator())) {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      <span class="keywordflow">if</span> (!operandsProcessed) {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = yield-&gt;getNumOperands(); i &lt; e; ++i) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;          continuationBlockPHITypes.push_back(</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;              moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(yield-&gt;getOperand(i).getType()));</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        }</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        operandsProcessed = <span class="keyword">true</span>;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        assert(continuationBlockPHITypes.size() == yield-&gt;getNumOperands() &amp;&amp;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;               <span class="stringliteral">&quot;mismatching number of values yielded from the region&quot;</span>);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = yield-&gt;getNumOperands(); i &lt; e; ++i) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;          llvm::Type *operandType =</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;              moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(yield-&gt;getOperand(i).getType());</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;          (<a class="code" href="classvoid.html">void</a>)operandType;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;          assert(continuationBlockPHITypes[i] == operandType &amp;&amp;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                 <span class="stringliteral">&quot;values of mismatching types yielded from the region&quot;</span>);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      }</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      numYields++;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  }</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="comment">// Insert PHI nodes in the continuation block for any values forwarded by the</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="comment">// terminators in this region.</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="keywordflow">if</span> (!continuationBlockPHITypes.empty())</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    assert(</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        continuationBlockPHIs &amp;&amp;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="stringliteral">&quot;expected continuation block PHIs if converted regions yield values&quot;</span>);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="keywordflow">if</span> (continuationBlockPHIs) {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    llvm::IRBuilderBase::InsertPointGuard guard(builder);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    continuationBlockPHIs-&gt;reserve(continuationBlockPHITypes.size());</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    builder.SetInsertPoint(continuationBlock, continuationBlock-&gt;begin());</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">for</span> (llvm::Type *ty : continuationBlockPHITypes)</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      continuationBlockPHIs-&gt;push_back(builder.CreatePHI(ty, numYields));</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  }</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="comment">// Convert blocks one by one in topological order to ensure</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="comment">// defs are converted before uses.</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;Block *&gt;</a> blocks =</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">LLVM::detail::getTopologicallySortedBlocks</a>(region);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> *bb : blocks) {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    llvm::BasicBlock *llvmBB = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a51bb831df4cf8bf4b4bf13a1be791701">lookupBlock</a>(bb);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">// Retarget the branch of the entry block to the entry block of the</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="comment">// converted region (regions are single-entry).</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordflow">if</span> (bb-&gt;isEntryBlock()) {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      assert(sourceTerminator-&gt;getNumSuccessors() == 1 &amp;&amp;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;             <span class="stringliteral">&quot;provided entry block has multiple successors&quot;</span>);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      assert(sourceTerminator-&gt;getSuccessor(0) == continuationBlock &amp;&amp;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;             <span class="stringliteral">&quot;ContinuationBlock is not the successor of the entry block&quot;</span>);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      sourceTerminator-&gt;setSuccessor(0, llvmBB);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    llvm::IRBuilderBase::InsertPointGuard guard(builder);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">convertBlock</a>(*bb, bb-&gt;isEntryBlock(), builder))) {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;      bodyGenStatus = <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      <span class="keywordflow">return</span> continuationBlock;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="comment">// Special handling for `omp.yield` and `omp.terminator` (we may have more</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="comment">// than one): they return the control to the parent OpenMP dialect operation</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="comment">// so replace them with the branch to the continuation block. We handle this</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="comment">// here to avoid relying inter-function communication through the</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="comment">// ModuleTranslation class to set up the correct insertion point. This is</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="comment">// also consistent with MLIR&#39;s idiom of handling special region terminators</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">// in the same code that handles the region-owning operation.</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <a class="code" href="classmlir_1_1Operation.html">Operation</a> *terminator = bb-&gt;getTerminator();</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">if</span> (isa&lt;omp::TerminatorOp, omp::YieldOp&gt;(terminator)) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      builder.CreateBr(continuationBlock);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = terminator-&gt;<a class="code" href="classmlir_1_1Operation.html#a80db2165a86e0837b30f5f3e0dc899df">getNumOperands</a>(); i &lt; e; ++i)</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        (*continuationBlockPHIs)[i]-&gt;addIncoming(</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(terminator-&gt;<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(i)), llvmBB);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="comment">// After all blocks have been traversed and values mapped, connect the PHI</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="comment">// nodes to the results of preceding blocks.</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">LLVM::detail::connectPHINodes</a>(region, moduleTranslation);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="comment">// Remove the blocks and values defined in this region from the mapping since</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="comment">// they are not visible outside of this region. This allows the same region to</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// be converted several times, that is cloned, without clashes, and slightly</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// speeds up the lookups.</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">forgetMapping</a>(region);</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="keywordflow">return</span> continuationBlock;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">/// Convert ProcBindKind from MLIR-generated enum to LLVM enum.</span></div><div class="line"><a name="l00236"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#ac5636d91dac35282746c7d2ad5cca0b2">  236</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> llvm::omp::ProcBindKind <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#ac5636d91dac35282746c7d2ad5cca0b2">getProcBindKind</a>(omp::ClauseProcBindKind kind) {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="keywordflow">switch</span> (kind) {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keywordflow">case</span> omp::ClauseProcBindKind::Close:</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> llvm::omp::ProcBindKind::OMP_PROC_BIND_close;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  <span class="keywordflow">case</span> omp::ClauseProcBindKind::Master:</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordflow">return</span> llvm::omp::ProcBindKind::OMP_PROC_BIND_master;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordflow">case</span> omp::ClauseProcBindKind::Primary:</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">return</span> llvm::omp::ProcBindKind::OMP_PROC_BIND_primary;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="keywordflow">case</span> omp::ClauseProcBindKind::Spread:</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="keywordflow">return</span> llvm::omp::ProcBindKind::OMP_PROC_BIND_spread;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  llvm_unreachable(<span class="stringliteral">&quot;Unknown ClauseProcBindKind kind&quot;</span>);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;}</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">/// Converts the OpenMP parallel operation to LLVM IR.</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00252"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a9003e5d3559d38af21012cc7c88ea97c">  252</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a9003e5d3559d38af21012cc7c88ea97c">convertOmpParallel</a>(omp::ParallelOp opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                   <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="keyword">auto</span> bodyGenCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codeGenIP) {</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="comment">// Save the alloca insertion point on ModuleTranslation stack for use in</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="comment">// nested regions.</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <a class="code" href="structmlir_1_1LLVM_1_1ModuleTranslation_1_1SaveStack.html">LLVM::ModuleTranslation::SaveStack&lt;OpenMPAllocaStackFrame&gt;</a> frame(</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        moduleTranslation, allocaIP);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="comment">// ParallelOp has only one region associated with it.</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    builder.restoreIP(codeGenIP);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(opInst.getRegion(), <span class="stringliteral">&quot;omp.par.region&quot;</span>, builder,</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  };</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="comment">// TODO: Perform appropriate actions according to the data-sharing</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">// attribute (shared, private, firstprivate, ...) of variables.</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// Currently defaults to shared.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="keyword">auto</span> privCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codeGenIP,</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    llvm::Value &amp;, llvm::Value &amp;vPtr,</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                    llvm::Value *&amp;replacementValue) -&gt; InsertPointTy {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    replacementValue = &amp;vPtr;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">return</span> codeGenIP;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  };</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="comment">// TODO: Perform finalization actions for variables. This has to be</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// called for variables which have destructors/finalizers.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  llvm::Value *ifCond = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> ifExprVar = opInst.if_expr_var())</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    ifCond = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(ifExprVar);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  llvm::Value *numThreads = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> numThreadsVar = opInst.num_threads_var())</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    numThreads = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(numThreadsVar);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="keyword">auto</span> pbKind = llvm::omp::OMP_PROC_BIND_default;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> bind = opInst.proc_bind_val())</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    pbKind = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#ac5636d91dac35282746c7d2ad5cca0b2">getProcBindKind</a>(*bind);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// TODO: Is the Parallel construct cancellable?</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="keywordtype">bool</span> isCancellable = <span class="keyword">false</span>;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy allocaIP =</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createParallel(</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      ompLoc, allocaIP, bodyGenCB, privCB, finiCB, ifCond, numThreads, pbKind,</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      isCancellable));</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="keywordflow">return</span> bodyGenStatus;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;}</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">/// Converts an OpenMP &#39;master&#39; operation into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00310"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a272457451d2c075defa2344ae9905ea8">  310</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a272457451d2c075defa2344ae9905ea8">convertOmpMaster</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                 <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="keyword">auto</span> bodyGenCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codeGenIP) {</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="comment">// MasterOp has only one region associated with it.</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="keyword">auto</span> &amp;region = cast&lt;omp::MasterOp&gt;(opInst).getRegion();</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    builder.restoreIP(codeGenIP);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(region, <span class="stringliteral">&quot;omp.master.region&quot;</span>, builder, moduleTranslation,</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                        bodyGenStatus);</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  };</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="comment">// TODO: Perform finalization actions for variables. This has to be</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="comment">// called for variables which have destructors/finalizers.</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createMaster(</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;      ompLoc, bodyGenCB, finiCB));</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;}</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">/// Converts an OpenMP &#39;critical&#39; operation into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00337"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a4a5bd11314b16528872656e2817741a7">  337</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a4a5bd11314b16528872656e2817741a7">convertOmpCritical</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                   <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  <span class="keyword">auto</span> criticalOp = cast&lt;omp::CriticalOp&gt;(opInst);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  <span class="keyword">auto</span> bodyGenCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codeGenIP) {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="comment">// CriticalOp has only one region associated with it.</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="keyword">auto</span> &amp;region = cast&lt;omp::CriticalOp&gt;(opInst).getRegion();</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    builder.restoreIP(codeGenIP);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(region, <span class="stringliteral">&quot;omp.critical.region&quot;</span>, builder,</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  };</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">// TODO: Perform finalization actions for variables. This has to be</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  <span class="comment">// called for variables which have destructors/finalizers.</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  llvm::LLVMContext &amp;llvmContext = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab4c38d7dad8c41373557f61ae08eb925">getLLVMContext</a>();</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *hint = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="comment">// If it has a name, it probably has a hint too.</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keywordflow">if</span> (criticalOp.nameAttr()) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="comment">// The verifiers in OpenMP Dialect guarentee that all the pointers are</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="comment">// non-null</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keyword">auto</span> symbolRef = criticalOp.nameAttr().cast&lt;SymbolRefAttr&gt;();</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keyword">auto</span> criticalDeclareOp =</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        SymbolTable::lookupNearestSymbolFrom&lt;omp::CriticalDeclareOp&gt;(criticalOp,</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                                                     symbolRef);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    hint =</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvmContext),</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                               static_cast&lt;int&gt;(criticalDeclareOp.hint_val()));</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  }</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createCritical(</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      ompLoc, bodyGenCB, finiCB, criticalOp.name().getValueOr(<span class="stringliteral">&quot;&quot;</span>), hint));</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;}</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">/// Returns a reduction declaration that corresponds to the given reduction</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">/// operation in the given container. Currently only supports reductions inside</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">/// WsLoopOp but can be easily extended.</span></div><div class="line"><a name="l00381"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#aaf6865017db3e23e6386336053b912d5">  381</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> omp::ReductionDeclareOp <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aaf6865017db3e23e6386336053b912d5">findReductionDecl</a>(omp::WsLoopOp container,</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                                                 omp::ReductionOp reduction) {</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  SymbolRefAttr reductionSymbol;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = container.getNumReductionVars(); i &lt; e; ++i) {</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">if</span> (container.reduction_vars()[i] != reduction.accumulator())</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    reductionSymbol = (*container.reductions())[i].cast&lt;SymbolRefAttr&gt;();</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  }</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  assert(reductionSymbol &amp;&amp;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;         <span class="stringliteral">&quot;reduction operation must be associated with a declaration&quot;</span>);</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="keywordflow">return</span> SymbolTable::lookupNearestSymbolFrom&lt;omp::ReductionDeclareOp&gt;(</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      container, reductionSymbol);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;}</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">/// Populates `reductions` with reduction declarations used in the given loop.</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line"><a name="l00399"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d543163721257ec9d23567cf4412183">  399</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d543163721257ec9d23567cf4412183">collectReductionDecls</a>(omp::WsLoopOp loop,</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                      <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;omp::ReductionDeclareOp&gt;</a> &amp;reductions) {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  <a class="code" href="classllvm_1_1Optional.html">Optional&lt;ArrayAttr&gt;</a> attr = loop.reductions();</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="keywordflow">if</span> (!attr)</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  reductions.reserve(reductions.size() + loop.getNumReductionVars());</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> symbolRef : attr-&gt;getAsRange&lt;SymbolRefAttr&gt;()) {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    reductions.push_back(</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        SymbolTable::lookupNearestSymbolFrom&lt;omp::ReductionDeclareOp&gt;(</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            loop, symbolRef));</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;}</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">/// Translates the blocks contained in the given region and appends them to at</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">/// the current insertion point of `builder`. The operations of the entry block</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">/// are appended to the current insertion block, which is not expected to have a</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">/// terminator. If set, `continuationBlockArgs` is populated with translated</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">/// values that correspond to the values omp.yield&#39;ed from the region.</span></div><div class="line"><a name="l00418"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">  418</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a>(</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region, StringRef blockName, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation,</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;llvm::Value *&gt;</a> *continuationBlockArgs = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  <span class="keywordflow">if</span> (region.<a class="code" href="classmlir_1_1Region.html#a747a700d4bd623c363f99aa3025a156c">empty</a>())</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  <span class="comment">// Special case for single-block regions that don&#39;t create additional blocks:</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  <span class="comment">// insert operations without creating additional blocks.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  <span class="keywordflow">if</span> (llvm::hasSingleElement(region)) {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#accf46c19a673ef7b85e73343e9eaff38">mapBlock</a>(&amp;region.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>(), builder.GetInsertBlock());</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">convertBlock</a>(</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            region.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>(), <span class="comment">/*ignoreArguments=*/</span><span class="keyword">true</span>, builder)))</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="comment">// The continuation arguments are simply the translated terminator operands.</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="keywordflow">if</span> (continuationBlockArgs)</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;      llvm::append_range(</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;          *continuationBlockArgs,</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;          moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97">lookupValues</a>(region.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a2bad7a54cba47bc6d6c563aafe827a38">back</a>().<a class="code" href="classmlir_1_1Operation.html#ac632a7783f8ec353f79c4f17cb188454">getOperands</a>()));</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="comment">// Drop the mapping that is no longer necessary so that the same region can</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="comment">// be processed multiple times.</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">forgetMapping</a>(region);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::PHINode *&gt;</a> phis;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  llvm::BasicBlock *continuationBlock = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      region, blockName, builder, moduleTranslation, bodyGenStatus, &amp;phis);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(bodyGenStatus))</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  <span class="keywordflow">if</span> (continuationBlockArgs)</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    llvm::append_range(*continuationBlockArgs, phis);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  builder.SetInsertPoint(continuationBlock,</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                         continuationBlock-&gt;getFirstInsertionPt());</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;}</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">/// Owning equivalents of OpenMPIRBuilder::(Atomic)ReductionGen that are used to</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">/// store lambdas with capture.</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment"></span><span class="keyword">using</span> OwningReductionGen = std::function&lt;llvm::OpenMPIRBuilder::InsertPointTy(</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    llvm::OpenMPIRBuilder::InsertPointTy, llvm::Value *, llvm::Value *,</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    llvm::Value *&amp;)&gt;;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="keyword">using</span> OwningAtomicReductionGen =</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    std::function&lt;llvm::OpenMPIRBuilder::InsertPointTy(</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        llvm::OpenMPIRBuilder::InsertPointTy, llvm::Type *, llvm::Value *,</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        llvm::Value *)&gt;;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;} <span class="comment">// namespace</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment">/// Create an OpenMPIRBuilder-compatible reduction generator for the given</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">/// reduction declaration. The generator uses `builder` but ignores its</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">/// insertion point.</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment"></span><span class="keyword">static</span> OwningReductionGen</div><div class="line"><a name="l00474"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a2be8cac12b7a38596ac1e19e87e17b67">  474</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2be8cac12b7a38596ac1e19e87e17b67">makeReductionGen</a>(omp::ReductionDeclareOp decl, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                 <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="comment">// The lambda is mutable because we need access to non-const methods of decl</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="comment">// (which aren&#39;t actually mutating it), and we must capture decl by-value to</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  <span class="comment">// avoid the dangling reference after the parent function returns.</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  OwningReductionGen gen =</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      [&amp;, decl](llvm::OpenMPIRBuilder::InsertPointTy insertPoint,</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                llvm::Value *lhs, llvm::Value *rhs,</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                llvm::Value *&amp;result) <span class="keyword">mutable</span> {</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;reductionRegion = decl.reductionRegion();</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(reductionRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(0), lhs);</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(reductionRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(1), rhs);</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        builder.restoreIP(insertPoint);</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> phis;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a>(reductionRegion,</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                                           <span class="stringliteral">&quot;omp.reduction.nonatomic.body&quot;</span>,</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                                           builder, moduleTranslation, &amp;phis)))</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;          <span class="keywordflow">return</span> llvm::OpenMPIRBuilder::InsertPointTy();</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        assert(phis.size() == 1);</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        result = phis[0];</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        <span class="keywordflow">return</span> builder.saveIP();</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      };</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  <span class="keywordflow">return</span> gen;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;}</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">/// Create an OpenMPIRBuilder-compatible atomic reduction generator for the</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">/// given reduction declaration. The generator uses `builder` but ignores its</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">/// insertion point. Returns null if there is no atomic region available in the</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">/// reduction declaration.</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment"></span><span class="keyword">static</span> OwningAtomicReductionGen</div><div class="line"><a name="l00504"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#aa21773c76aa0b7734125f1ba689211dd">  504</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aa21773c76aa0b7734125f1ba689211dd">makeAtomicReductionGen</a>(omp::ReductionDeclareOp decl,</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                       llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                       <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  <span class="keywordflow">if</span> (decl.atomicReductionRegion().empty())</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="keywordflow">return</span> OwningAtomicReductionGen();</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;  <span class="comment">// The lambda is mutable because we need access to non-const methods of decl</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;  <span class="comment">// (which aren&#39;t actually mutating it), and we must capture decl by-value to</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  <span class="comment">// avoid the dangling reference after the parent function returns.</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  OwningAtomicReductionGen atomicGen =</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;      [&amp;, decl](llvm::OpenMPIRBuilder::InsertPointTy insertPoint, llvm::Type *,</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                llvm::Value *lhs, llvm::Value *rhs) <span class="keyword">mutable</span> {</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;atomicRegion = decl.atomicReductionRegion();</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(atomicRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(0), lhs);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(atomicRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(1), rhs);</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        builder.restoreIP(insertPoint);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> phis;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a>(atomicRegion,</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                                           <span class="stringliteral">&quot;omp.reduction.atomic.body&quot;</span>, builder,</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                                           moduleTranslation, &amp;phis)))</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;          <span class="keywordflow">return</span> llvm::OpenMPIRBuilder::InsertPointTy();</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        assert(phis.empty());</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="keywordflow">return</span> builder.saveIP();</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;      };</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  <span class="keywordflow">return</span> atomicGen;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;}</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">/// Converts an OpenMP &#39;ordered&#39; operation into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00533"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a6989593b8c8f315bf76ba77def5852d6">  533</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a6989593b8c8f315bf76ba77def5852d6">convertOmpOrdered</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                  <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  <span class="keyword">auto</span> orderedOp = cast&lt;omp::OrderedOp&gt;(opInst);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  omp::ClauseDepend dependType = *orderedOp.depend_type_val();</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keywordtype">bool</span> isDependSource = dependType == omp::ClauseDepend::dependsource;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="keywordtype">unsigned</span> numLoops = orderedOp.num_loops_val().getValue();</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> vecValues =</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97">lookupValues</a>(orderedOp.depend_vec_vars());</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <span class="keywordtype">size_t</span> indexVecValues = 0;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <span class="keywordflow">while</span> (indexVecValues &lt; vecValues.size()) {</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> storeValues;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    storeValues.reserve(numLoops);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numLoops; i++) {</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;      storeValues.push_back(vecValues[indexVecValues]);</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;      indexVecValues++;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    }</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    llvm::OpenMPIRBuilder::InsertPointTy allocaIP =</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createOrderedDepend(</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        ompLoc, allocaIP, numLoops, storeValues, <span class="stringliteral">&quot;.cnt.addr&quot;</span>, isDependSource));</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;}</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">/// Converts an OpenMP &#39;ordered_region&#39; operation into LLVM IR using</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">/// OpenMPIRBuilder.</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00563"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a16c90aa4759d61d1435d4358692da8ef">  563</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16c90aa4759d61d1435d4358692da8ef">convertOmpOrderedRegion</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                        <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  <span class="keyword">auto</span> orderedRegionOp = cast&lt;omp::OrderedRegionOp&gt;(opInst);</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  <span class="comment">// TODO: The code generation for ordered simd directive is not supported yet.</span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="keywordflow">if</span> (orderedRegionOp.simd())</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  <span class="keyword">auto</span> bodyGenCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codeGenIP) {</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="comment">// OrderedOp has only one region associated with it.</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keyword">auto</span> &amp;region = cast&lt;omp::OrderedRegionOp&gt;(opInst).getRegion();</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    builder.restoreIP(codeGenIP);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(region, <span class="stringliteral">&quot;omp.ordered.region&quot;</span>, builder,</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  };</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  <span class="comment">// TODO: Perform finalization actions for variables. This has to be</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  <span class="comment">// called for variables which have destructors/finalizers.</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  builder.restoreIP(</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createOrderedThreadsSimd(</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;          ompLoc, bodyGenCB, finiCB, !orderedRegionOp.simd()));</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  <span class="keywordflow">return</span> bodyGenStatus;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;}</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00596"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a4580d408d65014e5354937f850a4822c">  596</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a4580d408d65014e5354937f850a4822c">convertOmpSections</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                   <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <span class="keyword">using</span> StorableBodyGenCallbackTy =</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      llvm::OpenMPIRBuilder::StorableBodyGenCallbackTy;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  <span class="keyword">auto</span> sectionsOp = cast&lt;omp::SectionsOp&gt;(opInst);</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <span class="comment">// TODO: Support the following clauses: private, firstprivate, lastprivate,</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  <span class="comment">// reduction, allocate</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <span class="keywordflow">if</span> (!sectionsOp.reduction_vars().empty() || sectionsOp.reductions() ||</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      !sectionsOp.allocate_vars().empty() ||</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      !sectionsOp.allocators_vars().empty())</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(sectionsOp.getLoc())</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;           &lt;&lt; <span class="stringliteral">&quot;reduction and allocate clauses are not supported for sections &quot;</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;              <span class="stringliteral">&quot;construct&quot;</span>;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;StorableBodyGenCallbackTy&gt;</a> sectionCBs;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op : *sectionsOp.region().begin()) {</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    <span class="keyword">auto</span> sectionOp = dyn_cast&lt;omp::SectionOp&gt;(op);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="keywordflow">if</span> (!sectionOp) <span class="comment">// omp.terminator</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region = sectionOp.region();</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="keyword">auto</span> sectionCB = [&amp;region, &amp;builder, &amp;moduleTranslation, &amp;bodyGenStatus](</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                         InsertPointTy allocaIP, InsertPointTy codeGenIP) {</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      builder.restoreIP(codeGenIP);</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(region, <span class="stringliteral">&quot;omp.section.region&quot;</span>, builder,</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                          moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    };</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    sectionCBs.push_back(sectionCB);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  }</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  <span class="comment">// No sections within omp.sections operation - skip generation. This situation</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;  <span class="comment">// is only possible if there is only a terminator operation inside the</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="comment">// sections operation</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <span class="keywordflow">if</span> (sectionCBs.empty())</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  assert(isa&lt;omp::SectionOp&gt;(*sectionsOp.region().op_begin()));</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <span class="comment">// TODO: Perform appropriate actions according to the data-sharing</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="comment">// attribute (shared, private, firstprivate, ...) of variables.</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  <span class="comment">// Currently defaults to shared.</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="keyword">auto</span> privCB = [&amp;](InsertPointTy, InsertPointTy codeGenIP, llvm::Value &amp;,</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                    llvm::Value &amp;vPtr,</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                    llvm::Value *&amp;replacementValue) -&gt; InsertPointTy {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    replacementValue = &amp;vPtr;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keywordflow">return</span> codeGenIP;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  };</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  <span class="comment">// TODO: Perform finalization actions for variables. This has to be</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="comment">// called for variables which have destructors/finalizers.</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy allocaIP =</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createSections(</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;      ompLoc, allocaIP, sectionCBs, privCB, finiCB, <span class="keyword">false</span>,</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;      sectionsOp.nowait()));</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  <span class="keywordflow">return</span> bodyGenStatus;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;}</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="comment">/// Converts an OpenMP single construct into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00664"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#aca9135c2c869eddc2da508f23757c3bc">  664</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aca9135c2c869eddc2da508f23757c3bc">convertOmpSingle</a>(omp::SingleOp &amp;singleOp, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                 <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  <span class="keyword">using</span> InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  <span class="keyword">auto</span> bodyCB = [&amp;](InsertPointTy allocaIP, InsertPointTy codegenIP) {</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    builder.restoreIP(codegenIP);</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(singleOp.region(), <span class="stringliteral">&quot;omp.single.region&quot;</span>, builder,</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  };</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;  <span class="keyword">auto</span> finiCB = [&amp;](InsertPointTy codeGenIP) {};</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  builder.restoreIP(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createSingle(</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;      ompLoc, bodyCB, finiCB, singleOp.nowait(), <span class="comment">/*DidIt=*/</span><span class="keyword">nullptr</span>));</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="keywordflow">return</span> bodyGenStatus;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;}</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment">/// Converts an OpenMP workshare loop into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00682"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#ada3742d4afd1f62523af29edc7828d18">  682</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#ada3742d4afd1f62523af29edc7828d18">convertOmpWsLoop</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                 <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  <span class="keyword">auto</span> loop = cast&lt;omp::WsLoopOp&gt;(opInst);</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  <span class="comment">// TODO: this should be in the op verifier instead.</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  <span class="keywordflow">if</span> (loop.lowerBound().empty())</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="comment">// Static is the default.</span></div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <span class="keyword">auto</span> schedule =</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;      loop.schedule_val().getValueOr(omp::ClauseScheduleKind::Static);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  <span class="comment">// Find the loop configuration.</span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  llvm::Value *step = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.step()[0]);</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;  llvm::Type *ivType = step-&gt;getType();</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  llvm::Value *chunk = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  <span class="keywordflow">if</span> (loop.schedule_chunk_var()) {</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    llvm::Value *chunkVar =</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.schedule_chunk_var());</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;    llvm::Type *chunkVarType = chunkVar-&gt;getType();</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    assert(chunkVarType-&gt;isIntegerTy() &amp;&amp;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;           <span class="stringliteral">&quot;chunk size must be one integer expression&quot;</span>);</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    <span class="keywordflow">if</span> (chunkVarType-&gt;getIntegerBitWidth() &lt; ivType-&gt;getIntegerBitWidth())</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;      chunk = builder.CreateSExt(chunkVar, ivType);</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (chunkVarType-&gt;getIntegerBitWidth() &gt; ivType-&gt;getIntegerBitWidth())</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;      chunk = builder.CreateTrunc(chunkVar, ivType);</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;      chunk = chunkVar;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  }</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;omp::ReductionDeclareOp&gt;</a> reductionDecls;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;  <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d543163721257ec9d23567cf4412183">collectReductionDecls</a>(loop, reductionDecls);</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy allocaIP =</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;  <span class="comment">// Allocate space for privatized reduction variables.</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> privateReductionVariables;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value, llvm::Value *&gt;</a> reductionVariableMap;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  <span class="keywordtype">unsigned</span> numReductions = loop.getNumReductionVars();</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;  privateReductionVariables.reserve(numReductions);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  <span class="keywordflow">if</span> (numReductions != 0) {</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    llvm::IRBuilderBase::InsertPointGuard guard(builder);</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    builder.restoreIP(allocaIP);</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numReductions; ++i) {</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;      <span class="keyword">auto</span> reductionType =</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;          loop.reduction_vars()[i].getType().cast&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;      llvm::Value *var = builder.CreateAlloca(</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;          moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(reductionType.getElementType()));</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;      privateReductionVariables.push_back(var);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;      reductionVariableMap.try_emplace(loop.reduction_vars()[i], var);</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    }</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  }</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  <span class="comment">// Store the mapping between reduction variables and their private copies on</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;  <span class="comment">// ModuleTranslation stack. It can be then recovered when translating</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;  <span class="comment">// omp.reduce operations in a separate call.</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  <a class="code" href="structmlir_1_1LLVM_1_1ModuleTranslation_1_1SaveStack.html">LLVM::ModuleTranslation::SaveStack&lt;OpenMPVarMappingStackFrame&gt;</a> mappingGuard(</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;      moduleTranslation, reductionVariableMap);</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;  <span class="comment">// Before the loop, store the initial values of reductions into reduction</span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;  <span class="comment">// variables. Although this could be done after allocas, we don&#39;t want to mess</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;  <span class="comment">// up with the alloca insertion point.</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numReductions; ++i) {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> phis;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a>(reductionDecls[i].initializerRegion(),</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                                       <span class="stringliteral">&quot;omp.reduction.neutral&quot;</span>, builder,</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                                       moduleTranslation, &amp;phis)))</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    assert(phis.size() == 1 &amp;&amp; <span class="stringliteral">&quot;expected one value to be yielded from the &quot;</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                               <span class="stringliteral">&quot;reduction neutral element declaration region&quot;</span>);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    builder.CreateStore(phis[0], privateReductionVariables[i]);</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;  }</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  <span class="comment">// Set up the source location value for OpenMP runtime.</span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <span class="comment">// Generator of the canonical loop body.</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::CanonicalLoopInfo *&gt;</a> loopInfos;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::OpenMPIRBuilder::InsertPointTy&gt;</a> bodyInsertPoints;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="keyword">auto</span> bodyGen = [&amp;](llvm::OpenMPIRBuilder::InsertPointTy ip, llvm::Value *iv) {</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="comment">// Make sure further conversions know about the induction variable.</span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;        loop.getRegion().front().getArgument(loopInfos.size()), iv);</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="comment">// Capture the body insertion point for use in nested loops. BodyIP of the</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    <span class="comment">// CanonicalLoopInfo always points to the beginning of the entry block of</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    <span class="comment">// the body.</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    bodyInsertPoints.push_back(ip);</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keywordflow">if</span> (loopInfos.size() != loop.getNumLoops() - 1)</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    <span class="comment">// Convert the body of the loop.</span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    builder.restoreIP(ip);</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(loop.region(), <span class="stringliteral">&quot;omp.wsloop.region&quot;</span>, builder,</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  };</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <span class="comment">// Delegate actual loop construction to the OpenMP IRBuilder.</span></div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;  <span class="comment">// TODO: this currently assumes WsLoop is semantically similar to SCF loop,</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  <span class="comment">// i.e. it has a positive step, uses signed integer semantics. Reconsider</span></div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;  <span class="comment">// this code when WsLoop clearly supports more cases.</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = loop.getNumLoops(); i &lt; e; ++i) {</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    llvm::Value *lowerBound =</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.lowerBound()[i]);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;    llvm::Value *upperBound =</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.upperBound()[i]);</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    llvm::Value *step = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.step()[i]);</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    <span class="comment">// Make sure loop trip count are emitted in the preheader of the outermost</span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    <span class="comment">// loop at the latest so that they are all available for the new collapsed</span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="comment">// loop will be created below.</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;    llvm::OpenMPIRBuilder::LocationDescription loc = ompLoc;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    llvm::OpenMPIRBuilder::InsertPointTy computeIP = ompLoc.IP;</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="keywordflow">if</span> (i != 0) {</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;      loc = llvm::OpenMPIRBuilder::LocationDescription(bodyInsertPoints.back());</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;      computeIP = loopInfos.front()-&gt;getPreheaderIP();</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    }</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    loopInfos.push_back(ompBuilder-&gt;createCanonicalLoop(</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;        loc, bodyGen, lowerBound, upperBound, step,</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;        <span class="comment">/*IsSigned=*/</span><span class="keyword">true</span>, loop.inclusive(), computeIP));</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(bodyGenStatus))</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  }</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  <span class="comment">// Collapse loops. Store the insertion point because LoopInfos may get</span></div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="comment">// invalidated.</span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  llvm::IRBuilderBase::InsertPoint afterIP = loopInfos.front()-&gt;getAfterIP();</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  llvm::CanonicalLoopInfo *loopInfo =</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;      ompBuilder-&gt;collapseLoops(ompLoc.DL, loopInfos, {});</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  allocaIP = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;  <span class="comment">// TODO: Handle doacross loops when the ordered clause has a parameter.</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;  <span class="keywordtype">bool</span> isOrdered = loop.ordered_val().hasValue();</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;  <a class="code" href="classllvm_1_1Optional.html">Optional&lt;omp::ScheduleModifier&gt;</a> scheduleModifier = loop.schedule_modifier();</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;  <span class="keywordtype">bool</span> isSimd = loop.simd_modifier();</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  ompBuilder-&gt;applyWorkshareLoop(</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      ompLoc.DL, loopInfo, allocaIP, !loop.nowait(),</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;      convertToScheduleKind(schedule), chunk, isSimd,</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      scheduleModifier == omp::ScheduleModifier::monotonic,</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;      scheduleModifier == omp::ScheduleModifier::nonmonotonic, isOrdered);</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;  <span class="comment">// Continue building IR after the loop. Note that the LoopInfo returned by</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;  <span class="comment">// `collapseLoops` points inside the outermost loop and is intended for</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  <span class="comment">// potential further loop transformations. Use the insertion point stored</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;  <span class="comment">// before collapsing loops instead.</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  builder.restoreIP(afterIP);</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  <span class="comment">// Process the reductions if required.</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  <span class="keywordflow">if</span> (numReductions == 0)</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;  <span class="comment">// Create the reduction generators. We need to own them here because</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;  <span class="comment">// ReductionInfo only accepts references to the generators.</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;OwningReductionGen&gt;</a> owningReductionGens;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;OwningAtomicReductionGen&gt;</a> owningAtomicReductionGens;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numReductions; ++i) {</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    owningReductionGens.push_back(</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;        <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2be8cac12b7a38596ac1e19e87e17b67">makeReductionGen</a>(reductionDecls[i], builder, moduleTranslation));</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    owningAtomicReductionGens.push_back(</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aa21773c76aa0b7734125f1ba689211dd">makeAtomicReductionGen</a>(reductionDecls[i], builder, moduleTranslation));</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;  }</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;  <span class="comment">// Collect the reduction information.</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::OpenMPIRBuilder::ReductionInfo&gt;</a> reductionInfos;</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  reductionInfos.reserve(numReductions);</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numReductions; ++i) {</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    llvm::OpenMPIRBuilder::AtomicReductionGenTy atomicGen = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    <span class="keywordflow">if</span> (owningAtomicReductionGens[i])</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;      atomicGen = owningAtomicReductionGens[i];</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;    <span class="keyword">auto</span> reductionType =</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;        loop.reduction_vars()[i].getType().cast&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;    llvm::Value *variable =</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.reduction_vars()[i]);</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    reductionInfos.push_back(</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        {moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(reductionType.getElementType()),</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;         variable, privateReductionVariables[i], owningReductionGens[i],</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;         atomicGen});</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;  }</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;  <span class="comment">// The call to createReductions below expects the block to have a</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;  <span class="comment">// terminator. Create an unreachable instruction to serve as terminator</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;  <span class="comment">// and remove it later.</span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;  llvm::UnreachableInst *tempTerminator = builder.CreateUnreachable();</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;  builder.SetInsertPoint(tempTerminator);</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;  llvm::OpenMPIRBuilder::InsertPointTy contInsertPoint =</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;      ompBuilder-&gt;createReductions(builder.saveIP(), allocaIP, reductionInfos,</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                                   loop.nowait());</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  <span class="keywordflow">if</span> (!contInsertPoint.getBlock())</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <span class="keywordflow">return</span> loop-&gt;emitOpError() &lt;&lt; <span class="stringliteral">&quot;failed to convert reductions&quot;</span>;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <span class="keyword">auto</span> nextInsertionPoint =</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      ompBuilder-&gt;createBarrier(contInsertPoint, llvm::omp::OMPD_for);</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;  tempTerminator-&gt;eraseFromParent();</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;  builder.restoreIP(nextInsertionPoint);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;}</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">/// Converts an OpenMP simd loop into LLVM IR using OpenMPIRBuilder.</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00888"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a029bcdc5c5a31bc0ff5ea2fdce138af9">  888</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a029bcdc5c5a31bc0ff5ea2fdce138af9">convertOmpSimdLoop</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                   <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;  <span class="keyword">auto</span> loop = cast&lt;omp::SimdLoopOp&gt;(opInst);</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="comment">// Generator of the canonical loop body.</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;  <span class="comment">// TODO: support error propagation in OpenMPIRBuilder and use it instead of</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  <span class="comment">// relying on captured variables.</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::CanonicalLoopInfo *&gt;</a> loopInfos;</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::OpenMPIRBuilder::InsertPointTy&gt;</a> bodyInsertPoints;</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bodyGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  <span class="keyword">auto</span> bodyGen = [&amp;](llvm::OpenMPIRBuilder::InsertPointTy ip, llvm::Value *iv) {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="comment">// Make sure further conversions know about the induction variable.</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        loop.getRegion().front().getArgument(loopInfos.size()), iv);</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    <span class="comment">// Capture the body insertion point for use in nested loops. BodyIP of the</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;    <span class="comment">// CanonicalLoopInfo always points to the beginning of the entry block of</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    <span class="comment">// the body.</span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    bodyInsertPoints.push_back(ip);</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="keywordflow">if</span> (loopInfos.size() != loop.getNumLoops() - 1)</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">// Convert the body of the loop.</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    builder.restoreIP(ip);</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a>(loop.region(), <span class="stringliteral">&quot;omp.simdloop.region&quot;</span>, builder,</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;                        moduleTranslation, bodyGenStatus);</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  };</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  <span class="comment">// Delegate actual loop construction to the OpenMP IRBuilder.</span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;  <span class="comment">// TODO: this currently assumes SimdLoop is semantically similar to SCF loop,</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;  <span class="comment">// i.e. it has a positive step, uses signed integer semantics. Reconsider</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;  <span class="comment">// this code when SimdLoop clearly supports more cases.</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = loop.getNumLoops(); i &lt; e; ++i) {</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    llvm::Value *lowerBound =</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.lowerBound()[i]);</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    llvm::Value *upperBound =</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.upperBound()[i]);</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    llvm::Value *step = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(loop.step()[i]);</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    <span class="comment">// Make sure loop trip count are emitted in the preheader of the outermost</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <span class="comment">// loop at the latest so that they are all available for the new collapsed</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="comment">// loop will be created below.</span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    llvm::OpenMPIRBuilder::LocationDescription loc = ompLoc;</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    llvm::OpenMPIRBuilder::InsertPointTy computeIP = ompLoc.IP;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="keywordflow">if</span> (i != 0) {</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;      loc = llvm::OpenMPIRBuilder::LocationDescription(bodyInsertPoints.back(),</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                                                       ompLoc.DL);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;      computeIP = loopInfos.front()-&gt;getPreheaderIP();</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    loopInfos.push_back(ompBuilder-&gt;createCanonicalLoop(</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;        loc, bodyGen, lowerBound, upperBound, step,</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;        <span class="comment">/*IsSigned=*/</span><span class="keyword">true</span>, <span class="comment">/*Inclusive=*/</span><span class="keyword">true</span>, computeIP));</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(bodyGenStatus))</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  }</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;  <span class="comment">// Collapse loops.</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;  llvm::IRBuilderBase::InsertPoint afterIP = loopInfos.front()-&gt;getAfterIP();</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;  llvm::CanonicalLoopInfo *loopInfo =</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;      ompBuilder-&gt;collapseLoops(ompLoc.DL, loopInfos, {});</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;  ompBuilder-&gt;applySimd(ompLoc.DL, loopInfo);</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;  builder.restoreIP(afterIP);</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;}</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="comment">/// Convert an Atomic Ordering attribute to llvm::AtomicOrdering.</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="comment"></span>llvm::AtomicOrdering</div><div class="line"><a name="l00962"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">  962</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a>(<a class="code" href="classllvm_1_1Optional.html">Optional&lt;omp::ClauseMemoryOrderKind&gt;</a> ao) {</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;  <span class="keywordflow">if</span> (!ao)</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::Monotonic; <span class="comment">// Default Memory Ordering</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;  <span class="keywordflow">switch</span> (*ao) {</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;  <span class="keywordflow">case</span> omp::ClauseMemoryOrderKind::Seq_cst:</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::SequentiallyConsistent;</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;  <span class="keywordflow">case</span> omp::ClauseMemoryOrderKind::Acq_rel:</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::AcquireRelease;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;  <span class="keywordflow">case</span> omp::ClauseMemoryOrderKind::Acquire:</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::Acquire;</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;  <span class="keywordflow">case</span> omp::ClauseMemoryOrderKind::Release:</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::Release;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  <span class="keywordflow">case</span> omp::ClauseMemoryOrderKind::Relaxed:</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <span class="keywordflow">return</span> llvm::AtomicOrdering::Monotonic;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;  }</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;  llvm_unreachable(<span class="stringliteral">&quot;Unknown ClauseMemoryOrderKind kind&quot;</span>);</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;}</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="comment">/// Convert omp.atomic.read operation to LLVM IR.</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00983"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#adc39c5aed6b02a118f143c88713d92e8">  983</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#adc39c5aed6b02a118f143c88713d92e8">convertOmpAtomicRead</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                     <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;  <span class="keyword">auto</span> readOp = cast&lt;omp::AtomicReadOp&gt;(opInst);</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;  llvm::AtomicOrdering AO = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a>(readOp.memory_order_val());</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;  llvm::Value *x = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(readOp.x());</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;  <a class="code" href="classmlir_1_1Type.html">Type</a> xTy = readOp.x().getType().<a class="code" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a>&lt;omp::PointerLikeType&gt;().<a class="code" href="SPIRVOps_8cpp.html#abd74f50e4c10ee44a38440a796501ff3">getElementType</a>();</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;  llvm::Value *v = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(readOp.v());</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  <a class="code" href="classmlir_1_1Type.html">Type</a> vTy = readOp.v().getType().<a class="code" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a>&lt;omp::PointerLikeType&gt;().<a class="code" href="SPIRVOps_8cpp.html#abd74f50e4c10ee44a38440a796501ff3">getElementType</a>();</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue V = {</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;      v, moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(vTy), <span class="keyword">false</span>, <span class="keyword">false</span>};</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue X = {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;      x, moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(xTy), <span class="keyword">false</span>, <span class="keyword">false</span>};</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  builder.restoreIP(ompBuilder-&gt;createAtomicRead(ompLoc, X, V, AO));</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;}</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="comment">/// Converts an omp.atomic.write operation to LLVM IR.</span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01006"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a19a3ba1c1d989e9309c69b4bb3888022"> 1006</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a19a3ba1c1d989e9309c69b4bb3888022">convertOmpAtomicWrite</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                      <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;  <span class="keyword">auto</span> writeOp = cast&lt;omp::AtomicWriteOp&gt;(opInst);</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;  llvm::AtomicOrdering ao = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a>(writeOp.memory_order_val());</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  llvm::Value *expr = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(writeOp.value());</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;  llvm::Value *dest = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(writeOp.address());</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;  llvm::Type *ty = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(writeOp.value().getType());</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue x = {dest, ty, <span class="comment">/*isSigned=*/</span><span class="keyword">false</span>,</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;                                            <span class="comment">/*isVolatile=*/</span><span class="keyword">false</span>};</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;  builder.restoreIP(ompBuilder-&gt;createAtomicWrite(ompLoc, x, expr, ao));</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;}</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="comment">/// Converts an LLVM dialect binary operation to the corresponding enum value</span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="comment">/// for `atomicrmw` supported binary operation.</span></div><div class="line"><a name="l01024"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a3b10b14906add421f04b5ad1660feb89"> 1024</a></span>&#160;<span class="comment"></span>llvm::AtomicRMWInst::BinOp <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3b10b14906add421f04b5ad1660feb89">convertBinOpToAtomic</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op) {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch&lt;Operation *, llvm::AtomicRMWInst::BinOp&gt;</a>(&amp;op)</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;      .Case([&amp;](LLVM::AddOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::Add; })</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;      .Case([&amp;](LLVM::SubOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::Sub; })</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;      .Case([&amp;](LLVM::AndOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::And; })</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;      .Case([&amp;](LLVM::OrOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::Or; })</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;      .Case([&amp;](LLVM::XOrOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::Xor; })</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;      .Case([&amp;](LLVM::UMaxOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::UMax; })</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;      .Case([&amp;](LLVM::UMinOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::UMin; })</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;      .Case([&amp;](LLVM::FAddOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::FAdd; })</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;      .Case([&amp;](LLVM::FSubOp) { <span class="keywordflow">return</span> llvm::AtomicRMWInst::BinOp::FSub; })</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;      .Default(llvm::AtomicRMWInst::BinOp::BAD_BINOP);</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;}</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="comment">/// Converts an OpenMP atomic update operation using OpenMPIRBuilder.</span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01040"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a03e24a8d468a8b34665f09465cd143a0"> 1040</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a03e24a8d468a8b34665f09465cd143a0">convertOmpAtomicUpdate</a>(omp::AtomicUpdateOp &amp;opInst,</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;                       llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                       <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="comment">// Convert values and types.</span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;  <span class="keyword">auto</span> &amp;innerOpList = opInst.region().front().getOperations();</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;  <span class="keywordflow">if</span> (innerOpList.size() != 2)</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="keywordflow">return</span> opInst.emitError(<span class="stringliteral">&quot;exactly two operations are allowed inside an &quot;</span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                            <span class="stringliteral">&quot;atomic update region while lowering to LLVM IR&quot;</span>);</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;  <a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;innerUpdateOp = innerOpList.front();</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;  <span class="keywordflow">if</span> (innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a80db2165a86e0837b30f5f3e0dc899df">getNumOperands</a>() != 2 ||</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;      !llvm::is_contained(innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#ac632a7783f8ec353f79c4f17cb188454">getOperands</a>(),</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                          opInst.getRegion().getArgument(0)))</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <span class="keywordflow">return</span> opInst.<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;        <span class="stringliteral">&quot;the update operation inside the region must be a binary operation and &quot;</span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;        <span class="stringliteral">&quot;that update operation must have the region argument as an operand&quot;</span>);</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;  llvm::AtomicRMWInst::BinOp binop = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3b10b14906add421f04b5ad1660feb89">convertBinOpToAtomic</a>(innerUpdateOp);</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;  <span class="keywordtype">bool</span> isXBinopExpr =</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;      innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a80db2165a86e0837b30f5f3e0dc899df">getNumOperands</a>() &gt; 0 &amp;&amp;</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;      innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(0) == opInst.getRegion().getArgument(0);</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;  <a class="code" href="classmlir_1_1Value.html">mlir::Value</a> mlirExpr = (isXBinopExpr ? innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(1)</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;                                       : innerUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(0));</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;  llvm::Value *llvmExpr = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(mlirExpr);</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;  llvm::Value *llvmX = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(opInst.x());</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;  <a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a> mlirXType =</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;      opInst.x().getType().cast&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;  llvm::Type *llvmXElementType =</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(mlirXType.<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html#a983be92ef4674457af12abdfdb50e96f">getElementType</a>());</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue llvmAtomicX = {llvmX, llvmXElementType,</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;                                                      <span class="comment">/*isSigned=*/</span><span class="keyword">false</span>,</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;                                                      <span class="comment">/*isVolatile=*/</span><span class="keyword">false</span>};</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;  llvm::AtomicOrdering atomicOrdering =</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a>(opInst.memory_order_val());</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;  <span class="comment">// Generate update code.</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> updateGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;  <span class="keyword">auto</span> updateFn = [&amp;opInst, &amp;moduleTranslation, &amp;updateGenStatus](</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;                      llvm::Value *atomicx,</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                      llvm::IRBuilder&lt;&gt; &amp;builder) -&gt; llvm::Value * {</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <a class="code" href="classmlir_1_1Block.html">Block</a> &amp;bb = *opInst.region().<a class="code" href="classmlir_1_1Block.html#aae2dc2f0bf00a23306aba81178b06631">begin</a>();</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    moduleTranslation.mapValue(*opInst.region().args_begin(), atomicx);</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    moduleTranslation.mapBlock(&amp;bb, builder.GetInsertBlock());</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(moduleTranslation.convertBlock(bb, <span class="keyword">true</span>, builder))) {</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;      updateGenStatus = (opInst.emitError()</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                         &lt;&lt; <span class="stringliteral">&quot;unable to convert update operation to llvm IR&quot;</span>);</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    }</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    omp::YieldOp yieldop = dyn_cast&lt;omp::YieldOp&gt;(bb.<a class="code" href="classmlir_1_1Block.html#a7e0b0c445d4e1e011fef4a1e59bcd118">getTerminator</a>());</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    assert(yieldop &amp;&amp; yieldop.results().size() == 1 &amp;&amp;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;           <span class="stringliteral">&quot;terminator must be omp.yield op and it must have exactly one &quot;</span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;           <span class="stringliteral">&quot;argument&quot;</span>);</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;    <span class="keywordflow">return</span> moduleTranslation.lookupValue(yieldop.results()[0]);</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;  };</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;  <span class="comment">// Handle ambiguous alloca, if any.</span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;  <span class="keyword">auto</span> allocaIP = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;  builder.restoreIP(ompBuilder-&gt;createAtomicUpdate(</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;      ompLoc, allocaIP, llvmAtomicX, llvmExpr, atomicOrdering, binop, updateFn,</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;      isXBinopExpr));</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;  <span class="keywordflow">return</span> updateGenStatus;</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;}</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01111"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a0ba7b30f464691677fff8fcf4a050d32"> 1111</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a0ba7b30f464691677fff8fcf4a050d32">convertOmpAtomicCapture</a>(omp::AtomicCaptureOp atomicCaptureOp,</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;                        llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;                        <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  <a class="code" href="classmlir_1_1Value.html">mlir::Value</a> mlirExpr;</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  <span class="keywordtype">bool</span> isXBinopExpr = <span class="keyword">false</span>, isPostfixUpdate = <span class="keyword">false</span>;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  llvm::AtomicRMWInst::BinOp binop = llvm::AtomicRMWInst::BinOp::BAD_BINOP;</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  omp::AtomicUpdateOp atomicUpdateOp = atomicCaptureOp.getAtomicUpdateOp();</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;  omp::AtomicWriteOp atomicWriteOp = atomicCaptureOp.getAtomicWriteOp();</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;  assert((atomicUpdateOp || atomicWriteOp) &amp;&amp;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;         <span class="stringliteral">&quot;internal op must be an atomic.update or atomic.write op&quot;</span>);</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;  <span class="keywordflow">if</span> (atomicWriteOp) {</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    isPostfixUpdate = <span class="keyword">true</span>;</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    mlirExpr = atomicWriteOp.value();</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    isPostfixUpdate = atomicCaptureOp.getSecondOp() ==</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;                      atomicCaptureOp.getAtomicUpdateOp().getOperation();</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    <span class="keyword">auto</span> &amp;innerOpList = atomicUpdateOp.region().front().getOperations();</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    <span class="keywordflow">if</span> (innerOpList.size() != 2)</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;      <span class="keywordflow">return</span> atomicUpdateOp.emitError(</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;          <span class="stringliteral">&quot;exactly two operations are allowed inside an &quot;</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;          <span class="stringliteral">&quot;atomic update region while lowering to LLVM IR&quot;</span>);</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    <a class="code" href="classmlir_1_1Operation.html">Operation</a> *innerUpdateOp = atomicUpdateOp.getFirstOp();</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    <span class="keywordflow">if</span> (innerUpdateOp-&gt;<a class="code" href="classmlir_1_1Operation.html#a80db2165a86e0837b30f5f3e0dc899df">getNumOperands</a>() != 2 ||</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        !llvm::is_contained(innerUpdateOp-&gt;<a class="code" href="classmlir_1_1Operation.html#ac632a7783f8ec353f79c4f17cb188454">getOperands</a>(),</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;                            atomicUpdateOp.getRegion().getArgument(0)))</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;      <span class="keywordflow">return</span> atomicUpdateOp.<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;          <span class="stringliteral">&quot;the update operation inside the region must be a binary operation &quot;</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;          <span class="stringliteral">&quot;and that update operation must have the region argument as an &quot;</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;          <span class="stringliteral">&quot;operand&quot;</span>);</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    binop = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3b10b14906add421f04b5ad1660feb89">convertBinOpToAtomic</a>(*innerUpdateOp);</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;    isXBinopExpr = innerUpdateOp-&gt;<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(0) ==</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                   atomicUpdateOp.getRegion().getArgument(0);</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    mlirExpr = (isXBinopExpr ? innerUpdateOp-&gt;<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(1)</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;                             : innerUpdateOp-&gt;<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(0));</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;  }</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;  llvm::Value *llvmExpr = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(mlirExpr);</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;  llvm::Value *llvmX =</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(atomicCaptureOp.getAtomicReadOp().x());</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;  llvm::Value *llvmV =</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(atomicCaptureOp.getAtomicReadOp().v());</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  <span class="keyword">auto</span> mlirXType = atomicCaptureOp.getAtomicReadOp()</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;                       .x()</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;                       .getType()</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                       .cast&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;  llvm::Type *llvmXElementType =</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(mlirXType.getElementType());</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue llvmAtomicX = {llvmX, llvmXElementType,</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                                                      <span class="comment">/*isSigned=*/</span><span class="keyword">false</span>,</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                                                      <span class="comment">/*isVolatile=*/</span><span class="keyword">false</span>};</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;  llvm::OpenMPIRBuilder::AtomicOpValue llvmAtomicV = {llvmV, llvmXElementType,</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;                                                      <span class="comment">/*isSigned=*/</span><span class="keyword">false</span>,</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;                                                      <span class="comment">/*isVolatile=*/</span><span class="keyword">false</span>};</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;  llvm::AtomicOrdering atomicOrdering =</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a>(atomicCaptureOp.memory_order_val());</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> updateGenStatus = <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;  <span class="keyword">auto</span> updateFn = [&amp;](llvm::Value *atomicx,</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;                      llvm::IRBuilder&lt;&gt; &amp;builder) -&gt; llvm::Value * {</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    <span class="keywordflow">if</span> (atomicWriteOp)</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;      <span class="keywordflow">return</span> moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(atomicWriteOp.value());</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <a class="code" href="classmlir_1_1Block.html">Block</a> &amp;bb = *atomicUpdateOp.region().<a class="code" href="classmlir_1_1Block.html#aae2dc2f0bf00a23306aba81178b06631">begin</a>();</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(*atomicUpdateOp.region().args_begin(), atomicx);</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#accf46c19a673ef7b85e73343e9eaff38">mapBlock</a>(&amp;bb, builder.GetInsertBlock());</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">convertBlock</a>(bb, <span class="keyword">true</span>, builder))) {</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;      updateGenStatus = (atomicUpdateOp.emitError()</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;                         &lt;&lt; <span class="stringliteral">&quot;unable to convert update operation to llvm IR&quot;</span>);</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    }</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    omp::YieldOp yieldop = dyn_cast&lt;omp::YieldOp&gt;(bb.<a class="code" href="classmlir_1_1Block.html#a7e0b0c445d4e1e011fef4a1e59bcd118">getTerminator</a>());</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    assert(yieldop &amp;&amp; yieldop.results().size() == 1 &amp;&amp;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;           <span class="stringliteral">&quot;terminator must be omp.yield op and it must have exactly one &quot;</span></div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;           <span class="stringliteral">&quot;argument&quot;</span>);</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;    <span class="keywordflow">return</span> moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(yieldop.results()[0]);</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;  };</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;  <span class="comment">// Handle ambiguous alloca, if any.</span></div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;  <span class="keyword">auto</span> allocaIP = <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a>(builder, moduleTranslation);</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;  builder.restoreIP(ompBuilder-&gt;createAtomicCapture(</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;      ompLoc, allocaIP, llvmAtomicX, llvmAtomicV, llvmExpr, atomicOrdering,</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;      binop, updateFn, atomicUpdateOp, isPostfixUpdate, isXBinopExpr));</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;  <span class="keywordflow">return</span> updateGenStatus;</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;}</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="comment">/// Converts an OpenMP reduction operation using OpenMPIRBuilder. Expects the</span></div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="comment">/// mapping between reduction variables and their private equivalents to have</span></div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="comment">/// been stored on the ModuleTranslation stack. Currently only supports</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment">/// reduction within WsLoopOp, but can be easily extended.</span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01208"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d2b07b9318ccddfa6e87f397df2694d"> 1208</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d2b07b9318ccddfa6e87f397df2694d">convertOmpReductionOp</a>(omp::ReductionOp reductionOp,</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                      llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;                      <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;  <span class="comment">// Find the declaration that corresponds to the reduction op.</span></div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;  <span class="keyword">auto</span> reductionContainer = reductionOp-&gt;getParentOfType&lt;omp::WsLoopOp&gt;();</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;  omp::ReductionDeclareOp declaration =</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;      <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aaf6865017db3e23e6386336053b912d5">findReductionDecl</a>(reductionContainer, reductionOp);</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;  assert(declaration &amp;&amp; <span class="stringliteral">&quot;could not find reduction declaration&quot;</span>);</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;  <span class="comment">// Retrieve the mapping between reduction variables and their private</span></div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;  <span class="comment">// equivalents.</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value, llvm::Value *&gt;</a> *reductionVariableMap = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;  moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ade661f55bf6b8d2fdc0f19f77db51e1d">stackWalk</a>&lt;OpenMPVarMappingStackFrame&gt;(</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;      [&amp;](<span class="keyword">const</span> OpenMPVarMappingStackFrame &amp;frame) {</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;        reductionVariableMap = &amp;frame.mapping;</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt</a>();</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;      });</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;  assert(reductionVariableMap &amp;&amp; <span class="stringliteral">&quot;couldn&#39;t find private reduction variables&quot;</span>);</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;  <span class="comment">// Translate the reduction operation by emitting the body of the corresponding</span></div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;  <span class="comment">// reduction declaration.</span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;  <a class="code" href="classmlir_1_1Region.html">Region</a> &amp;reductionRegion = declaration.reductionRegion();</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;  llvm::Value *privateReductionVar =</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;      reductionVariableMap-&gt;lookup(reductionOp.accumulator());</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;  llvm::Value *reductionVal = builder.CreateLoad(</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">convertType</a>(reductionOp.operand().getType()),</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;      privateReductionVar);</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;  moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(reductionRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(0),</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;                             reductionVal);</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;  moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;      reductionRegion.<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>().<a class="code" href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">getArgument</a>(1),</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(reductionOp.operand()));</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> phis;</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a>(reductionRegion, <span class="stringliteral">&quot;omp.reduction.body&quot;</span>,</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                                     builder, moduleTranslation, &amp;phis)))</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;  assert(phis.size() == 1 &amp;&amp; <span class="stringliteral">&quot;expected one value to be yielded from &quot;</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;                             <span class="stringliteral">&quot;the reduction body declaration region&quot;</span>);</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;  builder.CreateStore(phis[0], privateReductionVar);</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;}</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="comment">/// Converts an OpenMP Threadprivate operation into LLVM IR using</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="comment">/// OpenMPIRBuilder.</span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01255"></a><span class="lineno"><a class="line" href="OpenMPToLLVMIRTranslation_8cpp.html#a9bf5e55777df2cf81f6acd6b94517906"> 1255</a></span>&#160;<a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a9bf5e55777df2cf81f6acd6b94517906">convertOmpThreadprivate</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;                        <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;  <span class="keyword">auto</span> threadprivateOp = cast&lt;omp::ThreadprivateOp&gt;(opInst);</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;  <a class="code" href="classmlir_1_1Value.html">Value</a> symAddr = threadprivateOp.sym_addr();</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;  <span class="keyword">auto</span> *symOp = symAddr.<a class="code" href="classmlir_1_1Value.html#aed80a742a36c5b3298467ce5d01738c8">getDefiningOp</a>();</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  <span class="keywordflow">if</span> (!isa&lt;LLVM::AddressOfOp&gt;(symOp))</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;    <span class="keywordflow">return</span> opInst.<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(<span class="stringliteral">&quot;Addressing symbol not found&quot;</span>);</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  LLVM::AddressOfOp addressOfOp = dyn_cast&lt;LLVM::AddressOfOp&gt;(symOp);</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  LLVM::GlobalOp global = addressOfOp.getGlobal();</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  llvm::GlobalValue *globalValue = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab582c7fe5225be57e369e68a8b589d54">lookupGlobal</a>(global);</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;  llvm::Value *data =</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;      builder.CreateBitCast(globalValue, builder.getInt8PtrTy());</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;  llvm::Type *type = globalValue-&gt;getValueType();</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;  llvm::TypeSize typeSize =</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;      builder.GetInsertBlock()-&gt;getModule()-&gt;getDataLayout().getTypeStoreSize(</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;          type);</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;  llvm::ConstantInt *size = builder.getInt64(typeSize.getFixedSize());</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;  llvm::StringRef suffix = llvm::StringRef(<span class="stringliteral">&quot;.cache&quot;</span>, 6);</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;  std::string cacheName = (Twine(global.getSymName()).<a class="code" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a>(suffix)).str();</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;  <span class="comment">// Emit runtime function and bitcast its type (i8*) to real data type.</span></div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;  llvm::Value *callInst =</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;      moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>()-&gt;createCachedThreadPrivate(</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;          ompLoc, data, size, cacheName);</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;  llvm::Value *result = builder.CreateBitCast(callInst, globalValue-&gt;getType());</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;  moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mapValue</a>(opInst.<a class="code" href="classmlir_1_1Operation.html#a56f58b55c803b3313da7b4a04a3d542d">getResult</a>(0), result);</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;}</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="comment">/// Implementation of the dialect interface that converts operations belonging</span></div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="comment">/// to the OpenMP dialect to LLVM IR.</span></div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="comment"></span><span class="keyword">class </span>OpenMPDialectLLVMIRTranslationInterface</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;    : <span class="keyword">public</span> <a class="code" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a> {</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;  <span class="keyword">using</span> <a class="code" href="classmlir_1_1LLVMTranslationDialectInterface.html#acbe047965f9212727c6737919351cab0">LLVMTranslationDialectInterface::LLVMTranslationDialectInterface</a>;</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="comment">  /// Translates the given operation to LLVM IR using the provided IR builder</span></div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;<span class="comment">  /// and saving the state in `moduleTranslation`.</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="comment"></span>  <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;  convertOperation(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;                   <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation) <span class="keyword">const</span> <span class="keyword">final</span>;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;};</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;} <span class="comment">// namespace</span></div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="comment">/// Given an OpenMP MLIR operation, create the corresponding LLVM IR</span></div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="comment">/// (including OpenMP runtime calls).</span></div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="comment"></span><a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> OpenMPDialectLLVMIRTranslationInterface::convertOperation(</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;    <a class="code" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::IRBuilderBase &amp;builder,</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">LLVM::ModuleTranslation</a> &amp;moduleTranslation)<span class="keyword"> const </span>{</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">getOpenMPBuilder</a>();</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch&lt;Operation *, LogicalResult&gt;</a>(op)</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;      .Case([&amp;](omp::BarrierOp) {</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;        ompBuilder-&gt;createBarrier(builder.saveIP(), llvm::omp::OMPD_barrier);</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;      })</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;      .Case([&amp;](omp::TaskwaitOp) {</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;        ompBuilder-&gt;createTaskwait(builder.saveIP());</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;      })</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;      .Case([&amp;](omp::TaskyieldOp) {</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;        ompBuilder-&gt;createTaskyield(builder.saveIP());</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;      })</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;      .Case([&amp;](omp::FlushOp) {</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;        <span class="comment">// No support in Openmp runtime function (__kmpc_flush) to accept</span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;        <span class="comment">// the argument list.</span></div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;        <span class="comment">// OpenMP standard states the following:</span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;        <span class="comment">//  &quot;An implementation may implement a flush with a list by ignoring</span></div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;        <span class="comment">//   the list, and treating it the same as a flush without a list.&quot;</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;        <span class="comment">//</span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;        <span class="comment">// The argument list is discarded so that, flush with a list is treated</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;        <span class="comment">// same as a flush without a list.</span></div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;        ompBuilder-&gt;createFlush(builder.saveIP());</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;      })</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;      .Case([&amp;](omp::ParallelOp op) {</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a9003e5d3559d38af21012cc7c88ea97c">convertOmpParallel</a>(op, builder, moduleTranslation);</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;      })</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;      .Case([&amp;](omp::ReductionOp reductionOp) {</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a2d2b07b9318ccddfa6e87f397df2694d">convertOmpReductionOp</a>(reductionOp, builder, moduleTranslation);</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;      })</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;      .Case([&amp;](omp::MasterOp) {</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a272457451d2c075defa2344ae9905ea8">convertOmpMaster</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;      })</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;      .Case([&amp;](omp::CriticalOp) {</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a4a5bd11314b16528872656e2817741a7">convertOmpCritical</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;      })</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;      .Case([&amp;](omp::OrderedRegionOp) {</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a16c90aa4759d61d1435d4358692da8ef">convertOmpOrderedRegion</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;      })</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;      .Case([&amp;](omp::OrderedOp) {</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a6989593b8c8f315bf76ba77def5852d6">convertOmpOrdered</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;      })</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;      .Case([&amp;](omp::WsLoopOp) {</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#ada3742d4afd1f62523af29edc7828d18">convertOmpWsLoop</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;      })</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;      .Case([&amp;](omp::SimdLoopOp) {</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a029bcdc5c5a31bc0ff5ea2fdce138af9">convertOmpSimdLoop</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;      })</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;      .Case([&amp;](omp::AtomicReadOp) {</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#adc39c5aed6b02a118f143c88713d92e8">convertOmpAtomicRead</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;      })</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;      .Case([&amp;](omp::AtomicWriteOp) {</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a19a3ba1c1d989e9309c69b4bb3888022">convertOmpAtomicWrite</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;      })</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;      .Case([&amp;](omp::AtomicUpdateOp op) {</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a03e24a8d468a8b34665f09465cd143a0">convertOmpAtomicUpdate</a>(op, builder, moduleTranslation);</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;      })</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;      .Case([&amp;](omp::AtomicCaptureOp op) {</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a0ba7b30f464691677fff8fcf4a050d32">convertOmpAtomicCapture</a>(op, builder, moduleTranslation);</div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;      })</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;      .Case([&amp;](omp::SectionsOp) {</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a4580d408d65014e5354937f850a4822c">convertOmpSections</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;      })</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;      .Case([&amp;](omp::SingleOp op) {</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#aca9135c2c869eddc2da508f23757c3bc">convertOmpSingle</a>(op, builder, moduleTranslation);</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;      })</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;      .Case&lt;omp::YieldOp, omp::TerminatorOp, omp::ReductionDeclareOp,</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;            omp::CriticalDeclareOp&gt;([](<span class="keyword">auto</span> op) {</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;        <span class="comment">// `yield` and `terminator` can be just omitted. The block structure</span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;        <span class="comment">// was created in the region that handles their parent operation.</span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;        <span class="comment">// `reduction.declare` will be used by reductions and is not</span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;        <span class="comment">// converted directly, skip it.</span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;        <span class="comment">// `critical.declare` is only used to declare names of critical</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;        <span class="comment">// sections which will be used by `critical` ops and hence can be</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;        <span class="comment">// ignored for lowering. The OpenMP IRBuilder will create unique</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;        <span class="comment">// name for critical section names.</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;      })</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;      .Case([&amp;](omp::ThreadprivateOp) {</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="OpenMPToLLVMIRTranslation_8cpp.html#a9bf5e55777df2cf81f6acd6b94517906">convertOmpThreadprivate</a>(*op, builder, moduleTranslation);</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;      })</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;      .Default([&amp;](<a class="code" href="classmlir_1_1Operation.html">Operation</a> *inst) {</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;        <span class="keywordflow">return</span> inst-&gt;<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(<span class="stringliteral">&quot;unsupported OpenMP operation: &quot;</span>)</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;               &lt;&lt; inst-&gt;<a class="code" href="classmlir_1_1Operation.html#ab2e11ba83ff765eb7595554f97aaaa75">getName</a>();</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;      });</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;}</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;</div><div class="line"><a name="l01400"></a><span class="lineno"><a class="line" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7"> 1400</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">mlir::registerOpenMPDialectTranslation</a>(<a class="code" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry) {</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;  registry.<a class="code" href="classmlir_1_1DialectRegistry.html#af7b5c8edb622ee3b1ab5f7103bc7557d">insert</a>&lt;omp::OpenMPDialect&gt;();</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;  registry.<a class="code" href="classmlir_1_1DialectRegistry.html#aa2a1f3416c601ae1807f828a6cab5cd8">addExtension</a>(+[](<a class="code" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, omp::OpenMPDialect *dialect) {</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    dialect-&gt;addInterfaces&lt;OpenMPDialectLLVMIRTranslationInterface&gt;();</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;  });</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;}</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;</div><div class="line"><a name="l01407"></a><span class="lineno"><a class="line" href="namespacemlir.html#aaa35b353841b70d090e1ead360536308"> 1407</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">mlir::registerOpenMPDialectTranslation</a>(<a class="code" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context) {</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;  <a class="code" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> registry;</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;  <a class="code" href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">registerOpenMPDialectTranslation</a>(registry);</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;  context.<a class="code" href="classmlir_1_1MLIRContext.html#a0253384ac14aa63ad76b04167c9b3e53">appendDialectRegistry</a>(registry);</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;}</div><div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a4580d408d65014e5354937f850a4822c"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a4580d408d65014e5354937f850a4822c">convertOmpSections</a></div><div class="ttdeci">static LogicalResult convertOmpSections(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00596">OpenMPToLLVMIRTranslation.cpp:596</a></div></div>
<div class="ttc" id="namespacemlir_html"><div class="ttname"><a href="namespacemlir.html">mlir</a></div><div class="ttdoc">Include the generated interface declarations. </div><div class="ttdef"><b>Definition:</b> <a href="LocalAliasAnalysis_8h_source.html#l00020">LocalAliasAnalysis.h:20</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html"><div class="ttname"><a href="classmlir_1_1Region.html">mlir::Region</a></div><div class="ttdoc">This class contains a list of basic blocks and a link to the parent operation it is attached to...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00026">Region.h:26</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_aae2dc2f0bf00a23306aba81178b06631"><div class="ttname"><a href="classmlir_1_1Block.html#aae2dc2f0bf00a23306aba81178b06631">mlir::Block::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00134">Block.h:134</a></div></div>
<div class="ttc" id="Support_2LLVM_8h_html"><div class="ttname"><a href="Support_2LLVM_8h.html">LLVM.h</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a9bf5e55777df2cf81f6acd6b94517906"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a9bf5e55777df2cf81f6acd6b94517906">convertOmpThreadprivate</a></div><div class="ttdeci">static LogicalResult convertOmpThreadprivate(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP Threadprivate operation into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01255">OpenMPToLLVMIRTranslation.cpp:1255</a></div></div>
<div class="ttc" id="classvoid_html"><div class="ttname"><a href="classvoid.html">void</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_aaf6865017db3e23e6386336053b912d5"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#aaf6865017db3e23e6386336053b912d5">findReductionDecl</a></div><div class="ttdeci">static omp::ReductionDeclareOp findReductionDecl(omp::WsLoopOp container, omp::ReductionOp reduction)</div><div class="ttdoc">Returns a reduction declaration that corresponds to the given reduction operation in the given contai...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00381">OpenMPToLLVMIRTranslation.cpp:381</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is a basic unit of execution within MLIR. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00028">Operation.h:28</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a2bad7a54cba47bc6d6c563aafe827a38"><div class="ttname"><a href="classmlir_1_1Block.html#a2bad7a54cba47bc6d6c563aafe827a38">mlir::Block::back</a></div><div class="ttdeci">Operation &amp; back()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00143">Block.h:143</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_ac632a7783f8ec353f79c4f17cb188454"><div class="ttname"><a href="classmlir_1_1Operation.html#ac632a7783f8ec353f79c4f17cb188454">mlir::Operation::getOperands</a></div><div class="ttdeci">operand_range getOperands()</div><div class="ttdoc">Returns an iterator on the underlying Value&amp;#39;s. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00301">Operation.h:301</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_ac5636d91dac35282746c7d2ad5cca0b2"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#ac5636d91dac35282746c7d2ad5cca0b2">getProcBindKind</a></div><div class="ttdeci">static llvm::omp::ProcBindKind getProcBindKind(omp::ClauseProcBindKind kind)</div><div class="ttdoc">Convert ProcBindKind from MLIR-generated enum to LLVM enum. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00236">OpenMPToLLVMIRTranslation.cpp:236</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html"><div class="ttname"><a href="classmlir_1_1Block.html">mlir::Block</a></div><div class="ttdoc">Block represents an ordered list of Operations. </div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00029">Block.h:29</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html_ac5f83e51909b69039a7506737b458452"><div class="ttname"><a href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">mlir::Region::front</a></div><div class="ttdeci">Block &amp; front()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00065">Region.h:65</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a7e4fa6f72a2fb1a03c35b01f2a7615b1"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">mlir::LLVM::ModuleTranslation::convertType</a></div><div class="ttdeci">llvm::Type * convertType(Type type)</div><div class="ttdoc">Converts the type from MLIR LLVM dialect to LLVM. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01067">ModuleTranslation.cpp:1067</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMap_html"><div class="ttname"><a href="classllvm_1_1DenseMap.html">llvm::DenseMap</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00050">LLVM.h:50</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_adc39c5aed6b02a118f143c88713d92e8"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#adc39c5aed6b02a118f143c88713d92e8">convertOmpAtomicRead</a></div><div class="ttdeci">static LogicalResult convertOmpAtomicRead(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Convert omp.atomic.read operation to LLVM IR. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00983">OpenMPToLLVMIRTranslation.cpp:983</a></div></div>
<div class="ttc" id="classmlir_1_1WalkResult_html_a9c12a1d7d7c0f04aa34dc5cd35226c5e"><div class="ttname"><a href="classmlir_1_1WalkResult.html#a9c12a1d7d7c0f04aa34dc5cd35226c5e">mlir::WalkResult::wasInterrupted</a></div><div class="ttdeci">bool wasInterrupted() const</div><div class="ttdoc">Returns true if the walk was interrupted. </div><div class="ttdef"><b>Definition:</b> <a href="Visitors_8h_source.html#l00055">Visitors.h:55</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a1eecfffb7445e24f9fbdec2d619251ff"><div class="ttname"><a href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">mlir::Operation::getOperand</a></div><div class="ttdeci">Value getOperand(unsigned idx)</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00273">Operation.h:273</a></div></div>
<div class="ttc" id="namespacemlir_html_aeec13ab4fb753865cdfd2699aa01c23b"><div class="ttname"><a href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">mlir::failed</a></div><div class="ttdeci">bool failed(LogicalResult result)</div><div class="ttdoc">Utility function that returns true if the provided LogicalResult corresponds to a failure value...</div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00072">LogicalResult.h:72</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_ada3742d4afd1f62523af29edc7828d18"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#ada3742d4afd1f62523af29edc7828d18">convertOmpWsLoop</a></div><div class="ttdeci">static LogicalResult convertOmpWsLoop(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP workshare loop into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00682">OpenMPToLLVMIRTranslation.cpp:682</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a6989593b8c8f315bf76ba77def5852d6"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a6989593b8c8f315bf76ba77def5852d6">convertOmpOrdered</a></div><div class="ttdeci">static LogicalResult convertOmpOrdered(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP &amp;#39;ordered&amp;#39; operation into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00533">OpenMPToLLVMIRTranslation.cpp:533</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a80db2165a86e0837b30f5f3e0dc899df"><div class="ttname"><a href="classmlir_1_1Operation.html#a80db2165a86e0837b30f5f3e0dc899df">mlir::Operation::getNumOperands</a></div><div class="ttdeci">unsigned getNumOperands()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00269">Operation.h:269</a></div></div>
<div class="ttc" id="TypeID_8h_html_a46d3bf341617d344fdcfdd82ba53c863"><div class="ttname"><a href="TypeID_8h.html#a46d3bf341617d344fdcfdd82ba53c863">MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID</a></div><div class="ttdeci">#define MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CLASS_NAME)</div><div class="ttdef"><b>Definition:</b> <a href="TypeID_8h_source.html#l00274">TypeID.h:274</a></div></div>
<div class="ttc" id="SPIRVOps_8cpp_html_abd74f50e4c10ee44a38440a796501ff3"><div class="ttname"><a href="SPIRVOps_8cpp.html#abd74f50e4c10ee44a38440a796501ff3">getElementType</a></div><div class="ttdeci">static Type getElementType(Type type, ArrayRef&lt; int32_t &gt; indices, function_ref&lt; InFlightDiagnostic(StringRef)&gt; emitErrorFn)</div><div class="ttdoc">Walks the given type hierarchy with the given indices, potentially down to component granularity...</div><div class="ttdef"><b>Definition:</b> <a href="SPIRVOps_8cpp_source.html#l00687">SPIRVOps.cpp:687</a></div></div>
<div class="ttc" id="classmlir_1_1MLIRContext_html_a0253384ac14aa63ad76b04167c9b3e53"><div class="ttname"><a href="classmlir_1_1MLIRContext.html#a0253384ac14aa63ad76b04167c9b3e53">mlir::MLIRContext::appendDialectRegistry</a></div><div class="ttdeci">void appendDialectRegistry(const DialectRegistry &amp;registry)</div><div class="ttdoc">Append the contents of the given dialect registry to the registry associated with this context...</div><div class="ttdef"><b>Definition:</b> <a href="MLIRContext_8cpp_source.html#l00357">MLIRContext.cpp:357</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ab4c38d7dad8c41373557f61ae08eb925"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab4c38d7dad8c41373557f61ae08eb925">mlir::LLVM::ModuleTranslation::getLLVMContext</a></div><div class="ttdeci">llvm::LLVMContext &amp; getLLVMContext() const</div><div class="ttdoc">Returns the LLVM context in which the IR is being constructed. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00156">ModuleTranslation.h:156</a></div></div>
<div class="ttc" id="classllvm_1_1TypeSwitch_html"><div class="ttname"><a href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00065">LLVM.h:65</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_1_1StackFrameBase_html"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation_1_1StackFrameBase.html">mlir::LLVM::ModuleTranslation::StackFrameBase</a></div><div class="ttdoc">Concrete CRTP base class for ModuleTranslation stack frames. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00213">ModuleTranslation.h:213</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a16c90aa4759d61d1435d4358692da8ef"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a16c90aa4759d61d1435d4358692da8ef">convertOmpOrderedRegion</a></div><div class="ttdeci">static LogicalResult convertOmpOrderedRegion(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP &amp;#39;ordered_region&amp;#39; operation into LLVM IR using OpenMPIRBuilder. ...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00563">OpenMPToLLVMIRTranslation.cpp:563</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a42c761d9d5fc2d11837f9bd33227bfb8"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a42c761d9d5fc2d11837f9bd33227bfb8">convertAtomicOrdering</a></div><div class="ttdeci">llvm::AtomicOrdering convertAtomicOrdering(Optional&lt; omp::ClauseMemoryOrderKind &gt; ao)</div><div class="ttdoc">Convert an Atomic Ordering attribute to llvm::AtomicOrdering. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00962">OpenMPToLLVMIRTranslation.cpp:962</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a412839b57abb733219f4ea73df143e97"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97">mlir::LLVM::ModuleTranslation::lookupValues</a></div><div class="ttdeci">SmallVector&lt; llvm::Value * &gt; lookupValues(ValueRange values)</div><div class="ttdoc">Looks up remapped a list of remapped values. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01072">ModuleTranslation.cpp:1072</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a04c2e13596c2bc9d0cfada820eea7358"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">mlir::LLVM::ModuleTranslation::convertBlock</a></div><div class="ttdeci">LogicalResult convertBlock(Block &amp;bb, bool ignoreArguments, llvm::IRBuilderBase &amp;builder)</div><div class="ttdoc">Translates the contents of the given block to LLVM IR using this translator. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00567">ModuleTranslation.cpp:567</a></div></div>
<div class="ttc" id="classllvm_1_1Optional_html"><div class="ttname"><a href="classllvm_1_1Optional.html">llvm::Optional</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00055">LLVM.h:55</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a51bb831df4cf8bf4b4bf13a1be791701"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a51bb831df4cf8bf4b4bf13a1be791701">mlir::LLVM::ModuleTranslation::lookupBlock</a></div><div class="ttdeci">llvm::BasicBlock * lookupBlock(Block *block) const</div><div class="ttdoc">Finds an LLVM IR basic block that corresponds to the given MLIR block. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00097">ModuleTranslation.h:97</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a250ea7db8c8fae47972d867cc65900ff"><div class="ttname"><a href="classmlir_1_1Block.html#a250ea7db8c8fae47972d867cc65900ff">mlir::Block::getArgument</a></div><div class="ttdeci">BlockArgument getArgument(unsigned i)</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00120">Block.h:120</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a3ac7a6fd700dd719a1a571d7c3af185a"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a3ac7a6fd700dd719a1a571d7c3af185a">inlineConvertOmpRegions</a></div><div class="ttdeci">static LogicalResult inlineConvertOmpRegions(Region &amp;region, StringRef blockName, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation, SmallVectorImpl&lt; llvm::Value *&gt; *continuationBlockArgs=nullptr)</div><div class="ttdoc">Translates the blocks contained in the given region and appends them to at the current insertion poin...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00418">OpenMPToLLVMIRTranslation.cpp:418</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00061">LLVM.h:61</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ae7cb9d75828602a93097d60f55ae6c1c"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">mlir::LLVM::ModuleTranslation::forgetMapping</a></div><div class="ttdeci">void forgetMapping(Region &amp;region)</div><div class="ttdoc">Removes the mapping for blocks contained in the region and values defined in these blocks...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00406">ModuleTranslation.cpp:406</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_accf46c19a673ef7b85e73343e9eaff38"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#accf46c19a673ef7b85e73343e9eaff38">mlir::LLVM::ModuleTranslation::mapBlock</a></div><div class="ttdeci">void mapBlock(Block *mlir, llvm::BasicBlock *llvm)</div><div class="ttdoc">Stores the mapping between an MLIR block and LLVM IR basic block. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00090">ModuleTranslation.h:90</a></div></div>
<div class="ttc" id="IR_2Operation_8h_html"><div class="ttname"><a href="IR_2Operation_8h.html">Operation.h</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html">mlir::LLVM::ModuleTranslation</a></div><div class="ttdoc">Implementation class for module translation. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00051">ModuleTranslation.h:51</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a9f44e072590ad67cc75d240bfa86b936"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a9f44e072590ad67cc75d240bfa86b936">mlir::LLVM::ModuleTranslation::getOpenMPBuilder</a></div><div class="ttdeci">llvm::OpenMPIRBuilder * getOpenMPBuilder()</div><div class="ttdoc">Returns the OpenMP IR builder associated with the LLVM IR module being constructed. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00166">ModuleTranslation.h:166</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a2d2b07b9318ccddfa6e87f397df2694d"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a2d2b07b9318ccddfa6e87f397df2694d">convertOmpReductionOp</a></div><div class="ttdeci">static LogicalResult convertOmpReductionOp(omp::ReductionOp reductionOp, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP reduction operation using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01208">OpenMPToLLVMIRTranslation.cpp:1208</a></div></div>
<div class="ttc" id="namespacemlir_html_a5f55c06c7c4aeace3f6824dd68f8b1ed"><div class="ttname"><a href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">mlir::success</a></div><div class="ttdeci">LogicalResult success(bool isSuccess=true)</div><div class="ttdoc">Utility function to generate a LogicalResult. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00056">LogicalResult.h:56</a></div></div>
<div class="ttc" id="classmlir_1_1DialectRegistry_html_aa2a1f3416c601ae1807f828a6cab5cd8"><div class="ttname"><a href="classmlir_1_1DialectRegistry.html#aa2a1f3416c601ae1807f828a6cab5cd8">mlir::DialectRegistry::addExtension</a></div><div class="ttdeci">void addExtension(std::unique_ptr&lt; DialectExtensionBase &gt; extension)</div><div class="ttdoc">Add the given extension to the registry. </div><div class="ttdef"><b>Definition:</b> <a href="DialectRegistry_8h_source.html#l00171">DialectRegistry.h:171</a></div></div>
<div class="ttc" id="structmlir_1_1LogicalResult_html"><div class="ttname"><a href="structmlir_1_1LogicalResult.html">mlir::LogicalResult</a></div><div class="ttdoc">This class represents an efficient way to signal success or failure. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00026">LogicalResult.h:26</a></div></div>
<div class="ttc" id="namespacemlir_html_a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><div class="ttname"><a href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">mlir::failure</a></div><div class="ttdeci">LogicalResult failure(bool isFailure=true)</div><div class="ttdoc">Utility function to generate a LogicalResult. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00062">LogicalResult.h:62</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_af292822b3f890f22fafba471974afa1f"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af292822b3f890f22fafba471974afa1f">mlir::LLVM::ModuleTranslation::mapValue</a></div><div class="ttdeci">void mapValue(Value mlir, llvm::Value *llvm)</div><div class="ttdoc">Stores the mapping between an MLIR value and its LLVM IR counterpart. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00070">ModuleTranslation.h:70</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_aca9135c2c869eddc2da508f23757c3bc"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#aca9135c2c869eddc2da508f23757c3bc">convertOmpSingle</a></div><div class="ttdeci">static LogicalResult convertOmpSingle(omp::SingleOp &amp;singleOp, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP single construct into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00664">OpenMPToLLVMIRTranslation.cpp:664</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html_a747a700d4bd623c363f99aa3025a156c"><div class="ttname"><a href="classmlir_1_1Region.html#a747a700d4bd623c363f99aa3025a156c">mlir::Region::empty</a></div><div class="ttdeci">bool empty()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00060">Region.h:60</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a0ba7b30f464691677fff8fcf4a050d32"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a0ba7b30f464691677fff8fcf4a050d32">convertOmpAtomicCapture</a></div><div class="ttdeci">static LogicalResult convertOmpAtomicCapture(omp::AtomicCaptureOp atomicCaptureOp, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01111">OpenMPToLLVMIRTranslation.cpp:1111</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_afdd6b3f42db60825f35ab10122e0a514"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#afdd6b3f42db60825f35ab10122e0a514">convertOmpOpRegions</a></div><div class="ttdeci">static llvm::BasicBlock * convertOmpOpRegions(Region &amp;region, StringRef blockName, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation, LogicalResult &amp;bodyGenStatus, SmallVectorImpl&lt; llvm::PHINode *&gt; *continuationBlockPHIs=nullptr)</div><div class="ttdoc">Converts the given region that appears within an OpenMP dialect operation to LLVM IR...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00122">OpenMPToLLVMIRTranslation.cpp:122</a></div></div>
<div class="ttc" id="classmlir_1_1LLVMTranslationDialectInterface_html"><div class="ttname"><a href="classmlir_1_1LLVMTranslationDialectInterface.html">mlir::LLVMTranslationDialectInterface</a></div><div class="ttdoc">Base class for dialect interfaces providing translation to LLVM IR. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTranslationInterface_8h_source.html#l00035">LLVMTranslationInterface.h:35</a></div></div>
<div class="ttc" id="structmlir_1_1LLVM_1_1ModuleTranslation_1_1SaveStack_html"><div class="ttname"><a href="structmlir_1_1LLVM_1_1ModuleTranslation_1_1SaveStack.html">mlir::LLVM::ModuleTranslation::SaveStack</a></div><div class="ttdoc">RAII object calling stackPush/stackPop on construction/destruction. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00255">ModuleTranslation.h:255</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a56f58b55c803b3313da7b4a04a3d542d"><div class="ttname"><a href="classmlir_1_1Operation.html#a56f58b55c803b3313da7b4a04a3d542d">mlir::Operation::getResult</a></div><div class="ttdeci">OpResult getResult(unsigned idx)</div><div class="ttdoc">Get the &amp;#39;idx&amp;#39;th result of this operation. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00330">Operation.h:330</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a4a5bd11314b16528872656e2817741a7"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a4a5bd11314b16528872656e2817741a7">convertOmpCritical</a></div><div class="ttdeci">static LogicalResult convertOmpCritical(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP &amp;#39;critical&amp;#39; operation into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00337">OpenMPToLLVMIRTranslation.cpp:337</a></div></div>
<div class="ttc" id="classmlir_1_1WalkResult_html_abab80dca5987e18f9abf08162cd3faaa"><div class="ttname"><a href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">mlir::WalkResult::interrupt</a></div><div class="ttdeci">static WalkResult interrupt()</div><div class="ttdef"><b>Definition:</b> <a href="Visitors_8h_source.html#l00050">Visitors.h:50</a></div></div>
<div class="ttc" id="classmlir_1_1WalkResult_html"><div class="ttname"><a href="classmlir_1_1WalkResult.html">mlir::WalkResult</a></div><div class="ttdoc">A utility result that is used to signal how to proceed with an ongoing walk: </div><div class="ttdef"><b>Definition:</b> <a href="Visitors_8h_source.html#l00034">Visitors.h:34</a></div></div>
<div class="ttc" id="namespacemlir_html_a6ea20d97a32efd36c02468e54db4b2e7"><div class="ttname"><a href="namespacemlir.html#a6ea20d97a32efd36c02468e54db4b2e7">mlir::registerOpenMPDialectTranslation</a></div><div class="ttdeci">void registerOpenMPDialectTranslation(DialectRegistry &amp;registry)</div><div class="ttdoc">Register the OpenMP dialect and the translation from it to the LLVM IR in the given registry;...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01400">OpenMPToLLVMIRTranslation.cpp:1400</a></div></div>
<div class="ttc" id="ModuleTranslation_8h_html"><div class="ttname"><a href="ModuleTranslation_8h.html">ModuleTranslation.h</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a03e24a8d468a8b34665f09465cd143a0"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a03e24a8d468a8b34665f09465cd143a0">convertOmpAtomicUpdate</a></div><div class="ttdeci">static LogicalResult convertOmpAtomicUpdate(omp::AtomicUpdateOp &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP atomic update operation using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01040">OpenMPToLLVMIRTranslation.cpp:1040</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a077b1182e55dd26f2e921fdce534aa38"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">mlir::LLVM::ModuleTranslation::lookupValue</a></div><div class="ttdeci">llvm::Value * lookupValue(Value value) const</div><div class="ttdoc">Finds an LLVM IR value corresponding to the given MLIR value. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00082">ModuleTranslation.h:82</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a2d543163721257ec9d23567cf4412183"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a2d543163721257ec9d23567cf4412183">collectReductionDecls</a></div><div class="ttdeci">static void collectReductionDecls(omp::WsLoopOp loop, SmallVectorImpl&lt; omp::ReductionDeclareOp &gt; &amp;reductions)</div><div class="ttdoc">Populates reductions with reduction declarations used in the given loop. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00399">OpenMPToLLVMIRTranslation.cpp:399</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8h_html"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8h.html">OpenMPToLLVMIRTranslation.h</a></div></div>
<div class="ttc" id="classmlir_1_1Type_html"><div class="ttname"><a href="classmlir_1_1Type.html">mlir::Type</a></div><div class="ttdoc">Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Types_8h_source.html#l00072">Types.h:72</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ade661f55bf6b8d2fdc0f19f77db51e1d"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ade661f55bf6b8d2fdc0f19f77db51e1d">mlir::LLVM::ModuleTranslation::stackWalk</a></div><div class="ttdeci">WalkResult stackWalk(llvm::function_ref&lt; WalkResult(const T &amp;)&gt; callback) const</div><div class="ttdoc">Calls callback for every ModuleTranslation stack frame of type T starting from the top of the stack...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00238">ModuleTranslation.h:238</a></div></div>
<div class="ttc" id="namespacemlir_1_1gpu_1_1amd_html_a8637afbd01b984be30dbd1cdb78ae45f"><div class="ttname"><a href="namespacemlir_1_1gpu_1_1amd.html#a8637afbd01b984be30dbd1cdb78ae45f">mlir::gpu::amd::Runtime</a></div><div class="ttdeci">Runtime</div><div class="ttdoc">Potential runtimes for AMD GPU kernels. </div><div class="ttdef"><b>Definition:</b> <a href="Runtimes_8h_source.html#l00015">Runtimes.h:15</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_a2b966f440106b35eb828bab13414c55b"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">mlir::LLVM::detail::connectPHINodes</a></div><div class="ttdeci">void connectPHINodes(Region &amp;region, const ModuleTranslation &amp;state)</div><div class="ttdoc">For all blocks in the region that were converted to LLVM IR using the given ModuleTranslation, connect the PHI nodes of the corresponding LLVM IR blocks to the results of preceding blocks. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00484">ModuleTranslation.cpp:484</a></div></div>
<div class="ttc" id="classmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00085">Value.h:85</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a16d6b3386558adb178dd8a76c5ae7fde"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a16d6b3386558adb178dd8a76c5ae7fde">findAllocaInsertPoint</a></div><div class="ttdeci">static llvm::OpenMPIRBuilder::InsertPointTy findAllocaInsertPoint(llvm::IRBuilderBase &amp;builder, const LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Find the insertion point for allocas given the current insertion point for normal operations in the b...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00079">OpenMPToLLVMIRTranslation.cpp:79</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00060">LLVM.h:60</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a7e0b0c445d4e1e011fef4a1e59bcd118"><div class="ttname"><a href="classmlir_1_1Block.html#a7e0b0c445d4e1e011fef4a1e59bcd118">mlir::Block::getTerminator</a></div><div class="ttdeci">Operation * getTerminator()</div><div class="ttdoc">Get the terminator operation of this block. </div><div class="ttdef"><b>Definition:</b> <a href="Block_8cpp_source.html#l00230">Block.cpp:230</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a9003e5d3559d38af21012cc7c88ea97c"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a9003e5d3559d38af21012cc7c88ea97c">convertOmpParallel</a></div><div class="ttdeci">static LogicalResult convertOmpParallel(omp::ParallelOp opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts the OpenMP parallel operation to LLVM IR. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00252">OpenMPToLLVMIRTranslation.cpp:252</a></div></div>
<div class="ttc" id="namespacemlir_html_a4e96b0c437652eb5a4890734bb6bcee7"><div class="ttname"><a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">mlir::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(Location loc)</div><div class="ttdoc">Utility method to emit an error message using this location. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Diagnostics_8cpp_source.html#l00322">Diagnostics.cpp:322</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_ada0ca08d24a9978d5465be28eba253f0"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">mlir::LLVM::detail::getTopologicallySortedBlocks</a></div><div class="ttdeci">SetVector&lt; Block * &gt; getTopologicallySortedBlocks(Region &amp;region)</div><div class="ttdoc">Get a topologically sorted list of blocks of the given region. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00517">ModuleTranslation.cpp:517</a></div></div>
<div class="ttc" id="classmlir_1_1DialectRegistry_html"><div class="ttname"><a href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a></div><div class="ttdoc">The DialectRegistry maps a dialect namespace to a constructor for the matching dialect. </div><div class="ttdef"><b>Definition:</b> <a href="DialectRegistry_8h_source.html#l00108">DialectRegistry.h:108</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ab582c7fe5225be57e369e68a8b589d54"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab582c7fe5225be57e369e68a8b589d54">mlir::LLVM::ModuleTranslation::lookupGlobal</a></div><div class="ttdeci">llvm::GlobalValue * lookupGlobal(Operation *op)</div><div class="ttdoc">Finds an LLVM IR global value that corresponds to the given MLIR operation defining a global value...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00160">ModuleTranslation.h:160</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a3b10b14906add421f04b5ad1660feb89"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a3b10b14906add421f04b5ad1660feb89">convertBinOpToAtomic</a></div><div class="ttdeci">llvm::AtomicRMWInst::BinOp convertBinOpToAtomic(Operation &amp;op)</div><div class="ttdoc">Converts an LLVM dialect binary operation to the corresponding enum value for atomicrmw supported bin...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01024">OpenMPToLLVMIRTranslation.cpp:1024</a></div></div>
<div class="ttc" id="classmlir_1_1Value_html_aed80a742a36c5b3298467ce5d01738c8"><div class="ttname"><a href="classmlir_1_1Value.html#aed80a742a36c5b3298467ce5d01738c8">mlir::Value::getDefiningOp</a></div><div class="ttdeci">Operation * getDefiningOp() const</div><div class="ttdoc">If this value is the result of an operation, return the operation that defines it. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00020">Value.cpp:20</a></div></div>
<div class="ttc" id="classmlir_1_1MLIRContext_html"><div class="ttname"><a href="classmlir_1_1MLIRContext.html">mlir::MLIRContext</a></div><div class="ttdoc">MLIRContext is the top-level object for a collection of MLIR operations. </div><div class="ttdef"><b>Definition:</b> <a href="MLIRContext_8h_source.html#l00055">MLIRContext.h:55</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_aa21773c76aa0b7734125f1ba689211dd"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#aa21773c76aa0b7734125f1ba689211dd">makeAtomicReductionGen</a></div><div class="ttdeci">static OwningAtomicReductionGen makeAtomicReductionGen(omp::ReductionDeclareOp decl, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Create an OpenMPIRBuilder-compatible atomic reduction generator for the given reduction declaration...</div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00504">OpenMPToLLVMIRTranslation.cpp:504</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1LLVMPointerType_html"><div class="ttname"><a href="classmlir_1_1LLVM_1_1LLVMPointerType.html">mlir::LLVM::LLVMPointerType</a></div><div class="ttdoc">LLVM dialect pointer type. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTypes_8h_source.html#l00182">LLVMTypes.h:182</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a19a3ba1c1d989e9309c69b4bb3888022"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a19a3ba1c1d989e9309c69b4bb3888022">convertOmpAtomicWrite</a></div><div class="ttdeci">static LogicalResult convertOmpAtomicWrite(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an omp.atomic.write operation to LLVM IR. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01006">OpenMPToLLVMIRTranslation.cpp:1006</a></div></div>
<div class="ttc" id="classmlir_1_1LLVMTranslationDialectInterface_html_acbe047965f9212727c6737919351cab0"><div class="ttname"><a href="classmlir_1_1LLVMTranslationDialectInterface.html#acbe047965f9212727c6737919351cab0">mlir::LLVMTranslationDialectInterface::LLVMTranslationDialectInterface</a></div><div class="ttdeci">LLVMTranslationDialectInterface(Dialect *dialect)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMTranslationInterface_8h_source.html#l00038">LLVMTranslationInterface.h:38</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a272457451d2c075defa2344ae9905ea8"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a272457451d2c075defa2344ae9905ea8">convertOmpMaster</a></div><div class="ttdeci">static LogicalResult convertOmpMaster(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP &amp;#39;master&amp;#39; operation into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00310">OpenMPToLLVMIRTranslation.cpp:310</a></div></div>
<div class="ttc" id="BlockAndValueMapping_8h_html"><div class="ttname"><a href="BlockAndValueMapping_8h.html">BlockAndValueMapping.h</a></div></div>
<div class="ttc" id="OpenMPDialect_8h_html"><div class="ttname"><a href="OpenMPDialect_8h.html">OpenMPDialect.h</a></div></div>
<div class="ttc" id="namespacemlir_html_a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"><div class="ttname"><a href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">mlir::AffineExprKind::Constant</a></div><div class="ttdoc">Constant integer. </div></div>
<div class="ttc" id="classmlir_1_1Operation_html_ab2e11ba83ff765eb7595554f97aaaa75"><div class="ttname"><a href="classmlir_1_1Operation.html#ab2e11ba83ff765eb7595554f97aaaa75">mlir::Operation::getName</a></div><div class="ttdeci">OperationName getName()</div><div class="ttdoc">The name of an operation is the key identifier for it. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00057">Operation.h:57</a></div></div>
<div class="ttc" id="classllvm_1_1SetVector_html"><div class="ttname"><a href="classllvm_1_1SetVector.html">llvm::SetVector</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00057">LLVM.h:57</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a919e866989c544204210029d45e45e49"><div class="ttname"><a href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">mlir::Operation::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(const Twine &amp;message={})</div><div class="ttdoc">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers tha...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8cpp_source.html#l00231">Operation.cpp:231</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1LLVMPointerType_html_a983be92ef4674457af12abdfdb50e96f"><div class="ttname"><a href="classmlir_1_1LLVM_1_1LLVMPointerType.html#a983be92ef4674457af12abdfdb50e96f">mlir::LLVM::LLVMPointerType::getElementType</a></div><div class="ttdeci">Type getElementType() const</div><div class="ttdoc">Returns the pointed-to type. It may be null if the pointer is opaque. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTypes_8cpp_source.html#l00191">LLVMTypes.cpp:191</a></div></div>
<div class="ttc" id="classmlir_1_1DialectRegistry_html_af7b5c8edb622ee3b1ab5f7103bc7557d"><div class="ttname"><a href="classmlir_1_1DialectRegistry.html#af7b5c8edb622ee3b1ab5f7103bc7557d">mlir::DialectRegistry::insert</a></div><div class="ttdeci">void insert()</div><div class="ttdef"><b>Definition:</b> <a href="DialectRegistry_8h_source.html#l00116">DialectRegistry.h:116</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a029bcdc5c5a31bc0ff5ea2fdce138af9"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a029bcdc5c5a31bc0ff5ea2fdce138af9">convertOmpSimdLoop</a></div><div class="ttdeci">static LogicalResult convertOmpSimdLoop(Operation &amp;opInst, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Converts an OpenMP simd loop into LLVM IR using OpenMPIRBuilder. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00888">OpenMPToLLVMIRTranslation.cpp:888</a></div></div>
<div class="ttc" id="classmlir_1_1Type_html_a1a9c3e06d3b23ad9457c13cb828a7c48"><div class="ttname"><a href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">mlir::Type::cast</a></div><div class="ttdeci">U cast() const</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Types_8h_source.html#l00250">Types.h:250</a></div></div>
<div class="ttc" id="OpenMPToLLVMIRTranslation_8cpp_html_a2be8cac12b7a38596ac1e19e87e17b67"><div class="ttname"><a href="OpenMPToLLVMIRTranslation_8cpp.html#a2be8cac12b7a38596ac1e19e87e17b67">makeReductionGen</a></div><div class="ttdeci">static OwningReductionGen makeReductionGen(omp::ReductionDeclareOp decl, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Create an OpenMPIRBuilder-compatible reduction generator for the given reduction declaration. </div><div class="ttdef"><b>Definition:</b> <a href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00474">OpenMPToLLVMIRTranslation.cpp:474</a></div></div>
<div class="ttc" id="namespacemlir_1_1linalg_html_a4f8ea0aae80d24eeffa3fef8f1f08c43"><div class="ttname"><a href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">mlir::linalg::concat</a></div><div class="ttdeci">SmallVector&lt; AffineExpr, 4 &gt; concat(ArrayRef&lt; AffineExpr &gt; a, ArrayRef&lt; AffineExpr &gt; b)</div><div class="ttdoc">Return the vector that is the concatenation of a and b. </div><div class="ttdef"><b>Definition:</b> <a href="LinalgOps_8cpp_source.html#l01479">LinalgOps.cpp:1479</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:32:59 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
