<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::MemRefAccess Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1MemRefAccess-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::MemRefAccess Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a memref load or store access information.  
 <a href="structmlir_1_1MemRefAccess.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for mlir::MemRefAccess:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1MemRefAccess__coll__graph.png" border="0" usemap="#mlir_1_1MemRefAccess_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1MemRefAccess_coll__map" id="mlir_1_1MemRefAccess_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value..." alt="" coords="1104,53,1196,79"/>
<area shape="rect" id="node3" href="classmlir_1_1detail_1_1ValueImpl.html" title="The base class for all derived Value classes. " alt="" coords="708,53,875,79"/>
<area shape="rect" id="node4" href="classmlir_1_1IRObjectWithUseList.html" title="mlir::IRObjectWithUseList\l\&lt; OpOperand \&gt;" alt="" coords="351,5,540,47"/>
<area shape="rect" id="node5" href="classmlir_1_1IRObjectWithUseList.html" title="This class represents a single IR object that contains a use list. " alt="" coords="5,5,195,47"/>
<area shape="rect" id="node7" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l mlir::Value, 4 \&gt;" alt="" coords="1076,104,1224,145"/>
<area shape="rect" id="node8" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l T, N \&gt;" alt="" coords="717,104,865,145"/>
<area shape="rect" id="node9" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. " alt="" coords="1090,177,1210,203"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8a67ba1cc245d85b3f0d877278a3f092"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#a8a67ba1cc245d85b3f0d877278a3f092">MemRefAccess</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="structmlir_1_1MemRefAccess.html#ad4cba763bdbfe3d53659981b6b220320">opInst</a>)</td></tr>
<tr class="memdesc:a8a67ba1cc245d85b3f0d877278a3f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmlir_1_1MemRefAccess.html" title="Encapsulates a memref load or store access information. ">MemRefAccess</a> from a load or store operation.  <a href="#a8a67ba1cc245d85b3f0d877278a3f092">More...</a><br /></td></tr>
<tr class="separator:a8a67ba1cc245d85b3f0d877278a3f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526c91a17c33ec0ecd61e02f8a9dc727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#a526c91a17c33ec0ecd61e02f8a9dc727">getRank</a> () const</td></tr>
<tr class="separator:a526c91a17c33ec0ecd61e02f8a9dc727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e1a81b38be947541f999798c21698"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#ad43e1a81b38be947541f999798c21698">isStore</a> () const</td></tr>
<tr class="separator:ad43e1a81b38be947541f999798c21698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5ccf44a5573384db5e0048703f98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#a89a5ccf44a5573384db5e0048703f98e">getAccessRelation</a> (<a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;accessRel) const</td></tr>
<tr class="memdesc:a89a5ccf44a5573384db5e0048703f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an access relation for the access.  <a href="#a89a5ccf44a5573384db5e0048703f98e">More...</a><br /></td></tr>
<tr class="separator:a89a5ccf44a5573384db5e0048703f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da32e1a020733c74c768fd5e8283efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#a8da32e1a020733c74c768fd5e8283efc">getAccessMap</a> (<a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *accessMap) const</td></tr>
<tr class="memdesc:a8da32e1a020733c74c768fd5e8283efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'accessMap' with composition of AffineApplyOps reachable from 'indices'.  <a href="#a8da32e1a020733c74c768fd5e8283efc">More...</a><br /></td></tr>
<tr class="separator:a8da32e1a020733c74c768fd5e8283efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85886d92df14c563fc1857b0d85911c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#ac85886d92df14c563fc1857b0d85911c">operator==</a> (const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ac85886d92df14c563fc1857b0d85911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal if both affine accesses can be proved to be equivalent at compile time (considering the memrefs, their respective affine access maps and operands).  <a href="#ac85886d92df14c563fc1857b0d85911c">More...</a><br /></td></tr>
<tr class="separator:ac85886d92df14c563fc1857b0d85911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f685199131f9c3d8496d0e6cc00b65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#ac8f685199131f9c3d8496d0e6cc00b65">operator!=</a> (const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;rhs) const</td></tr>
<tr class="separator:ac8f685199131f9c3d8496d0e6cc00b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3c443c42e6c438f0769bc2948863b98c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#a3c443c42e6c438f0769bc2948863b98c">memref</a></td></tr>
<tr class="separator:a3c443c42e6c438f0769bc2948863b98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cba763bdbfe3d53659981b6b220320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#ad4cba763bdbfe3d53659981b6b220320">opInst</a></td></tr>
<tr class="separator:ad4cba763bdbfe3d53659981b6b220320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a028201696ebeffc7fe1ec2850b49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html#ab4a028201696ebeffc7fe1ec2850b49a">indices</a></td></tr>
<tr class="separator:ab4a028201696ebeffc7fe1ec2850b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a memref load or store access information. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00080">80</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8a67ba1cc245d85b3f0d877278a3f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a67ba1cc245d85b3f0d877278a3f092">&#9670;&nbsp;</a></span>MemRefAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefAccess::MemRefAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>opInst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="structmlir_1_1MemRefAccess.html" title="Encapsulates a memref load or store access information. ">MemRefAccess</a> from a load or store operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01217">1217</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AffineReadOpInterface.html#ae9407dd550dfbd7ee87df02f27a63bc5">mlir::AffineReadOpInterface::getMapOperands()</a>, <a class="el" href="classmlir_1_1AffineWriteOpInterface.html#a9b465ec08145cb8a302f384ca887c486">mlir::AffineWriteOpInterface::getMapOperands()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#a8244a4feee85f6bd09a2c68ea316572d">mlir::AffineReadOpInterface::getMemRef()</a>, and <a class="el" href="classmlir_1_1AffineWriteOpInterface.html#a2fab3b6e91539f8e7c95428fd0352fce">mlir::AffineWriteOpInterface::getMemRef()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8da32e1a020733c74c768fd5e8283efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da32e1a020733c74c768fd5e8283efc">&#9670;&nbsp;</a></span>getAccessMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> MemRefAccess::getAccessMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>accessMap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'accessMap' with composition of AffineApplyOps reachable from 'indices'. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00497">497</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00873">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00699">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00019">mlir::AffineValueMap::reset()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00639">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>.</p>

</div>
</div>
<a id="a89a5ccf44a5573384db5e0048703f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5ccf44a5573384db5e0048703f98e">&#9670;&nbsp;</a></span>getAccessRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefAccess::getAccessRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineRelation.html">FlatAffineRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>accessRel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an access relation for the access. </p>
<p>An access relation maps elements of an iteration domain to the element(s) of an array domain accessed by that iteration of the associated statement through some array reference. For example, given the MLIR code:</p>
<p>affine.for i0 = 0 to 10 { affine.for i1 = 0 to 10 { a = affine.load arr[i0 + i1, i0 + 2 * i1] : memref&lt;100x100xf32&gt; } }</p>
<p>The access relation, assuming that the memory locations for arr are represented as m0, m1 would be:</p>
<p>(i0, i1) -&gt; (m0, m1) m0 = i0 + i1 m1 = i0 + 2 * i1 0 &lt;= i0 &lt; 10 0 &lt;= i1 &lt; 10</p>
<p>Returns failure for yet unimplemented/unsupported cases (see docs of <a class="el" href="namespacemlir.html#a170122f309092d69a928d6a64f1b2fe9" title="Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forO...">mlir::getIndexSet</a> and <a class="el" href="namespacemlir.html#a617813f648e1d9b892b6c800d454fb2e" title="Builds a relation from the given AffineMap/AffineValueMap map, containing all pairs of the form opera...">mlir::getRelationFromMap</a> for these cases). </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">458</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00041">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01307">mlir::FlatAffineValueConstraints::findId()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00137">mlir::presburger::IntegerRelation::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00523">mlir::FlatAffineRelation::getNumDomainDims()</a>, <a class="el" href="AffineStructures_8h_source.html#l00524">mlir::FlatAffineRelation::getNumRangeDims()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00275">getOpIndexSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01718">mlir::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00378">mlir::FlatAffineValueConstraints::getValue()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01669">mlir::FlatAffineRelation::insertDomainId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00421">mlir::FlatAffineValueConstraints::setValue()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01325">mlir::FlatAffineValueConstraints::swapId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::checkMemrefAccessDependence()</a>.</p>

</div>
</div>
<a id="a526c91a17c33ec0ecd61e02f8a9dc727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526c91a17c33ec0ecd61e02f8a9dc727">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> MemRefAccess::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01232">1232</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>.</p>

</div>
</div>
<a id="ad43e1a81b38be947541f999798c21698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43e1a81b38be947541f999798c21698">&#9670;&nbsp;</a></span>isStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemRefAccess::isStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01236">1236</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>.</p>

</div>
</div>
<a id="ac8f685199131f9c3d8496d0e6cc00b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f685199131f9c3d8496d0e6cc00b65">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::MemRefAccess::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00130">130</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

</div>
</div>
<a id="ac85886d92df14c563fc1857b0d85911c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85886d92df14c563fc1857b0d85911c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemRefAccess::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equal if both affine accesses can be proved to be equivalent at compile time (considering the memrefs, their respective affine access maps and operands). </p>
<p>Equal if both affine accesses are provably equivalent (at compile time) when considering the memref, the affine maps and their respective operands.</p>
<p>The equality of access functions + operands is checked by subtracting fully composed value maps, and then simplifying the difference using the expression flattener. TODO: this does not account for aliasing of memrefs. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01258">1258</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab4a028201696ebeffc7fe1ec2850b49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a028201696ebeffc7fe1ec2850b49a">&#9670;&nbsp;</a></span>indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt; mlir::MemRefAccess::indices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00083">83</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

</div>
</div>
<a id="a3c443c42e6c438f0769bc2948863b98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c443c42e6c438f0769bc2948863b98c">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::MemRefAccess::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00081">81</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">mlir::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00661">hasNoInterveningEffect()</a>.</p>

</div>
</div>
<a id="ad4cba763bdbfe3d53659981b6b220320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cba763bdbfe3d53659981b6b220320">&#9670;&nbsp;</a></span>opInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::MemRefAccess::opInst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00082">82</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00598">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00368">checkTilingLegalityImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00307">getCommonBlock()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00358">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:03 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
