<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::RewriterBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmlir_1_1RewriterBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::RewriterBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  
 <a href="classmlir_1_1RewriterBase.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::RewriterBase:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1RewriterBase__inherit__graph.png" border="0" usemap="#mlir_1_1RewriterBase_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1RewriterBase_inherit__map" id="mlir_1_1RewriterBase_inherit__map">
<area shape="rect" id="node5" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ..." alt="" coords="9,229,132,256"/>
<area shape="rect" id="node6" href="classmlir_1_1PatternRewriter.html" title="A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I..." alt="" coords="157,229,313,256"/>
<area shape="rect" id="node2" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. " alt="" coords="5,80,125,107"/>
<area shape="rect" id="node3" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context&#45;global objects like types, attributes, and affine expressions. " alt="" coords="14,5,117,32"/>
<area shape="rect" id="node4" href="structmlir_1_1OpBuilder_1_1Listener.html" title="This class represents a listener that may be used to hook into various actions within an OpBuilder..." alt="" coords="150,80,330,107"/>
<area shape="rect" id="node7" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns. " alt="" coords="120,304,349,331"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::RewriterBase:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1RewriterBase__coll__graph.png" border="0" usemap="#mlir_1_1RewriterBase_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1RewriterBase_coll__map" id="mlir_1_1RewriterBase_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. " alt="" coords="14,171,134,197"/>
<area shape="rect" id="node3" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context&#45;global objects like types, attributes, and affine expressions. " alt="" coords="23,95,125,121"/>
<area shape="rect" id="node4" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top&#45;level object for a collection of MLIR operations. " alt="" coords="5,5,143,32"/>
<area shape="rect" id="node5" href="structmlir_1_1OpBuilder_1_1Listener.html" title="This class represents a listener that may be used to hook into various actions within an OpBuilder..." alt="" coords="159,171,339,197"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adaf2b23302d524eeb5643dcff7668ebf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#adaf2b23302d524eeb5643dcff7668ebf">inlineRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before)</td></tr>
<tr class="memdesc:adaf2b23302d524eeb5643dcff7668ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the blocks that belong to "region" before the given position in another region "parent".  <a href="#adaf2b23302d524eeb5643dcff7668ebf">More...</a><br /></td></tr>
<tr class="separator:adaf2b23302d524eeb5643dcff7668ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0cf093ad5c10fb3e12a4e1fbb5e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#adbd0cf093ad5c10fb3e12a4e1fbb5e1b">inlineRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *before)</td></tr>
<tr class="separator:adbd0cf093ad5c10fb3e12a4e1fbb5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9992dd1eff9b9baf951368241fd083"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a1c9992dd1eff9b9baf951368241fd083">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a1c9992dd1eff9b9baf951368241fd083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the blocks that belong to "region" before the given position in another region "parent".  <a href="#a1c9992dd1eff9b9baf951368241fd083">More...</a><br /></td></tr>
<tr class="separator:a1c9992dd1eff9b9baf951368241fd083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20606a173cf42c30b7a8585bdab81b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#af20606a173cf42c30b7a8585bdab81b1">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before)</td></tr>
<tr class="separator:af20606a173cf42c30b7a8585bdab81b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ff71c74783a6385b4bbd597e44f21d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ac9ff71c74783a6385b4bbd597e44f21d">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *before)</td></tr>
<tr class="separator:ac9ff71c74783a6385b4bbd597e44f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000eb37e5f4dc20974b32e0fd9adaacd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a000eb37e5f4dc20974b32e0fd9adaacd">replaceOpWithIf</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues, bool *allUsesReplaced, llvm::unique_function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;) const &gt; functor)</td></tr>
<tr class="memdesc:a000eb37e5f4dc20974b32e0fd9adaacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method replaces the uses of the results of <code>op</code> with the values in <code>newValues</code> when the provided <code>functor</code> returns true for a specific use.  <a href="#a000eb37e5f4dc20974b32e0fd9adaacd">More...</a><br /></td></tr>
<tr class="separator:a000eb37e5f4dc20974b32e0fd9adaacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f179293e04a79213b6edc8ffc7ad8be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a0f179293e04a79213b6edc8ffc7ad8be">replaceOpWithIf</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues, llvm::unique_function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;) const &gt; functor)</td></tr>
<tr class="separator:a0f179293e04a79213b6edc8ffc7ad8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2839f48adcc7488cbe613b7586220e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a7b2839f48adcc7488cbe613b7586220e">replaceOpWithinBlock</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, bool *allUsesReplaced=nullptr)</td></tr>
<tr class="memdesc:a7b2839f48adcc7488cbe613b7586220e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method replaces the uses of the results of <code>op</code> with the values in <code>newValues</code> when a use is nested within the given <code>block</code>.  <a href="#a7b2839f48adcc7488cbe613b7586220e">More...</a><br /></td></tr>
<tr class="separator:a7b2839f48adcc7488cbe613b7586220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c88f3ce889be590b3801b4ddee627f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a53c88f3ce889be590b3801b4ddee627f">replaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues)</td></tr>
<tr class="memdesc:a53c88f3ce889be590b3801b4ddee627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method replaces the results of the operation with the specified list of values.  <a href="#a53c88f3ce889be590b3801b4ddee627f">More...</a><br /></td></tr>
<tr class="separator:a53c88f3ce889be590b3801b4ddee627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#afb1c910a57707f518d2b9c903c2bb5bc">replaceOpWithNewOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afb1c910a57707f518d2b9c903c2bb5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the result op with a new op that is created without verification.  <a href="#afb1c910a57707f518d2b9c903c2bb5bc">More...</a><br /></td></tr>
<tr class="separator:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786138ac6a91e0932da343ef5c6f1e70"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a786138ac6a91e0932da343ef5c6f1e70">eraseOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a786138ac6a91e0932da343ef5c6f1e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases an operation that is known to have no uses.  <a href="#a786138ac6a91e0932da343ef5c6f1e70">More...</a><br /></td></tr>
<tr class="separator:a786138ac6a91e0932da343ef5c6f1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286510e5cc47983e5b6017bad6aa6335"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a286510e5cc47983e5b6017bad6aa6335">eraseBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a286510e5cc47983e5b6017bad6aa6335"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases all operations in a block.  <a href="#a286510e5cc47983e5b6017bad6aa6335">More...</a><br /></td></tr>
<tr class="separator:a286510e5cc47983e5b6017bad6aa6335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af707a54463fefda9bd8d2ec5c455472a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#af707a54463fefda9bd8d2ec5c455472a">mergeBlocks</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *source, <a class="el" href="classmlir_1_1Block.html">Block</a> *dest, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> argValues=llvm::None)</td></tr>
<tr class="memdesc:af707a54463fefda9bd8d2ec5c455472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the operations of block 'source' into the end of block 'dest'.  <a href="#af707a54463fefda9bd8d2ec5c455472a">More...</a><br /></td></tr>
<tr class="separator:af707a54463fefda9bd8d2ec5c455472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453855dd11f55fd311d2f543b4a8914e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a453855dd11f55fd311d2f543b4a8914e">mergeBlockBefore</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *source, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> argValues=llvm::None)</td></tr>
<tr class="separator:a453855dd11f55fd311d2f543b4a8914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a495c76a07ca3e6c84a1594a64dd3cfa4">splitBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> before)</td></tr>
<tr class="memdesc:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the operations starting at "before" (inclusive) out of the given block into a new block, and return it.  <a href="#a495c76a07ca3e6c84a1594a64dd3cfa4">More...</a><br /></td></tr>
<tr class="separator:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef1756132627eeadf7f12bf810537d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#adef1756132627eeadf7f12bf810537d1">startRootUpdate</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:adef1756132627eeadf7f12bf810537d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to notify the rewriter that an in-place operation modification is about to happen.  <a href="#adef1756132627eeadf7f12bf810537d1">More...</a><br /></td></tr>
<tr class="separator:adef1756132627eeadf7f12bf810537d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d27913ece453c522fdd151ba853a7b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a88d27913ece453c522fdd151ba853a7b">finalizeRootUpdate</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a88d27913ece453c522fdd151ba853a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to signal the end of a root update on the given operation.  <a href="#a88d27913ece453c522fdd151ba853a7b">More...</a><br /></td></tr>
<tr class="separator:a88d27913ece453c522fdd151ba853a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d2f1aded51c1714d0cdae0fcf90b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#aa55d2f1aded51c1714d0cdae0fcf90b2">cancelRootUpdate</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aa55d2f1aded51c1714d0cdae0fcf90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method cancels a pending root update.  <a href="#aa55d2f1aded51c1714d0cdae0fcf90b2">More...</a><br /></td></tr>
<tr class="separator:aa55d2f1aded51c1714d0cdae0fcf90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5685828fb01fe53e90dce64a54db1e73"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:a5685828fb01fe53e90dce64a54db1e73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a5685828fb01fe53e90dce64a54db1e73">updateRootInPlace</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, CallableT &amp;&amp;callable)</td></tr>
<tr class="memdesc:a5685828fb01fe53e90dce64a54db1e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is a utility wrapper around a root update of an operation.  <a href="#a5685828fb01fe53e90dce64a54db1e73">More...</a><br /></td></tr>
<tr class="separator:a5685828fb01fe53e90dce64a54db1e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032aa8fe5345a286681688ef10f5cb84"><td class="memTemplParams" colspan="2">template&lt;typename CallbackT &gt; </td></tr>
<tr class="memitem:a032aa8fe5345a286681688ef10f5cb84"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; CallbackT, Twine &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a032aa8fe5345a286681688ef10f5cb84">notifyMatchFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, CallbackT &amp;&amp;reasonCallback)</td></tr>
<tr class="memdesc:a032aa8fe5345a286681688ef10f5cb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to notify the rewriter that the IR failed to be rewritten because of a match failure, and provide a callback to populate a diagnostic with the reason why the failure occurred.  <a href="#a032aa8fe5345a286681688ef10f5cb84">More...</a><br /></td></tr>
<tr class="separator:a032aa8fe5345a286681688ef10f5cb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081f7564cc3f62236c99e2a8098c3673"><td class="memTemplParams" colspan="2">template&lt;typename CallbackT &gt; </td></tr>
<tr class="memitem:a081f7564cc3f62236c99e2a8098c3673"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; CallbackT, Twine &gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a081f7564cc3f62236c99e2a8098c3673">notifyMatchFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, CallbackT &amp;&amp;reasonCallback)</td></tr>
<tr class="separator:a081f7564cc3f62236c99e2a8098c3673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d35106b18aaf457462915e16f3ea3"><td class="memTemplParams" colspan="2">template&lt;typename ArgT &gt; </td></tr>
<tr class="memitem:a2a1d35106b18aaf457462915e16f3ea3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a2a1d35106b18aaf457462915e16f3ea3">notifyMatchFailure</a> (ArgT &amp;&amp;arg, const Twine &amp;msg)</td></tr>
<tr class="separator:a2a1d35106b18aaf457462915e16f3ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab106a05ed09d9245211a36d3935945dd"><td class="memTemplParams" colspan="2">template&lt;typename ArgT &gt; </td></tr>
<tr class="memitem:ab106a05ed09d9245211a36d3935945dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ab106a05ed09d9245211a36d3935945dd">notifyMatchFailure</a> (ArgT &amp;&amp;arg, const char *msg)</td></tr>
<tr class="separator:ab106a05ed09d9245211a36d3935945dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpBuilder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpBuilder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></td></tr>
<tr class="memitem:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a245ee92bf58156a8a5bb45a291005c9b">OpBuilder</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder with the given context.  <a href="classmlir_1_1OpBuilder.html#a245ee92bf58156a8a5bb45a291005c9b">More...</a><br /></td></tr>
<tr class="separator:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a090f6be0ae24f31b82e895c565548cfa">OpBuilder</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to the start of the region.  <a href="classmlir_1_1OpBuilder.html#a090f6be0ae24f31b82e895c565548cfa">More...</a><br /></td></tr>
<tr class="separator:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70985fb2cb05aecda60bfd0386cec307 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a70985fb2cb05aecda60bfd0386cec307">OpBuilder</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="separator:a70985fb2cb05aecda60bfd0386cec307 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a89168853412a0ce71a3860889ccf6dc9">OpBuilder</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set insertion point to the given operation, which will cause subsequent insertions to go right before it.  <a href="classmlir_1_1OpBuilder.html#a89168853412a0ce71a3860889ccf6dc9">More...</a><br /></td></tr>
<tr class="separator:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876650f4cff966d33041f6d1954fb9ce inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a876650f4cff966d33041f6d1954fb9ce">OpBuilder</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> insertPoint, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="separator:a876650f4cff966d33041f6d1954fb9ce inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a3d81ba0de04d9847800a26cb5bb1c83a">setListener</a> (<a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *newListener)</td></tr>
<tr class="memdesc:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the listener of this builder to the one provided.  <a href="classmlir_1_1OpBuilder.html#a3d81ba0de04d9847800a26cb5bb1c83a">More...</a><br /></td></tr>
<tr class="separator:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a6126964a574a6d7b91d5288f2c05c42a">getListener</a> () const</td></tr>
<tr class="memdesc:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current listener of this builder, or nullptr if this builder doesn't have a listener.  <a href="classmlir_1_1OpBuilder.html#a6126964a574a6d7b91d5288f2c05c42a">More...</a><br /></td></tr>
<tr class="separator:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a29d8baf1c2e30971db34b30a90e1be6d">clearInsertionPoint</a> ()</td></tr>
<tr class="memdesc:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the insertion point to no location.  <a href="classmlir_1_1OpBuilder.html#a29d8baf1c2e30971db34b30a90e1be6d">More...</a><br /></td></tr>
<tr class="separator:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpBuilder_1_1InsertPoint.html">InsertPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a02eded6623aa092edee1a9a1c5514721">saveInsertionPoint</a> () const</td></tr>
<tr class="memdesc:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a saved insertion point.  <a href="classmlir_1_1OpBuilder.html#a02eded6623aa092edee1a9a1c5514721">More...</a><br /></td></tr>
<tr class="separator:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a60a1e767cb511f2ac91c2509198cb0a8">restoreInsertionPoint</a> (<a class="el" href="classmlir_1_1OpBuilder_1_1InsertPoint.html">InsertPoint</a> ip)</td></tr>
<tr class="memdesc:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the insert point to a previously saved point.  <a href="classmlir_1_1OpBuilder.html#a60a1e767cb511f2ac91c2509198cb0a8">More...</a><br /></td></tr>
<tr class="separator:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a4853433035d219e56febdb51d1b531cd">setInsertionPoint</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> insertPoint)</td></tr>
<tr class="memdesc:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the insertion point to the specified location.  <a href="classmlir_1_1OpBuilder.html#a4853433035d219e56febdb51d1b531cd">More...</a><br /></td></tr>
<tr class="separator:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a4c80a9fbc00dc28ab4a411eee5c9b1ef">setInsertionPoint</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the specified operation, which will cause subsequent insertions to go right before it.  <a href="classmlir_1_1OpBuilder.html#a4c80a9fbc00dc28ab4a411eee5c9b1ef">More...</a><br /></td></tr>
<tr class="separator:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#acd2bfec2b8f9c2a505a98da5252196b0">setInsertionPointAfter</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the node after the specified operation, which will cause subsequent insertions to go right after it.  <a href="classmlir_1_1OpBuilder.html#acd2bfec2b8f9c2a505a98da5252196b0">More...</a><br /></td></tr>
<tr class="separator:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ac40d8422df722bf8ba11cb360adb0534">setInsertionPointAfterValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the node after the specified value.  <a href="classmlir_1_1OpBuilder.html#ac40d8422df722bf8ba11cb360adb0534">More...</a><br /></td></tr>
<tr class="separator:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a3ef0d1056cf6968a09f4989cdf12e176">setInsertionPointToStart</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the start of the specified block.  <a href="classmlir_1_1OpBuilder.html#a3ef0d1056cf6968a09f4989cdf12e176">More...</a><br /></td></tr>
<tr class="separator:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5ff4c0abb5c98e53a3de90a8593026a9">setInsertionPointToEnd</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the end of the specified block.  <a href="classmlir_1_1OpBuilder.html#a5ff4c0abb5c98e53a3de90a8593026a9">More...</a><br /></td></tr>
<tr class="separator:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aef0f1df3c5d95482661b05b9944096c5">getInsertionBlock</a> () const</td></tr>
<tr class="memdesc:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block the current insertion point belongs to.  <a href="classmlir_1_1OpBuilder.html#aef0f1df3c5d95482661b05b9944096c5">More...</a><br /></td></tr>
<tr class="separator:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a10fe4674bc755659cb9d09131c713ebc">getInsertionPoint</a> () const</td></tr>
<tr class="memdesc:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current insertion point of the builder.  <a href="classmlir_1_1OpBuilder.html#a10fe4674bc755659cb9d09131c713ebc">More...</a><br /></td></tr>
<tr class="separator:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aa712737d7fe61de6b4a5d3d8bffc9ab2">getBlock</a> () const</td></tr>
<tr class="memdesc:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current block of the builder.  <a href="classmlir_1_1OpBuilder.html#aa712737d7fe61de6b4a5d3d8bffc9ab2">More...</a><br /></td></tr>
<tr class="separator:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eb36f5e608597be4fa16b155d045c6 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ab3eb36f5e608597be4fa16b155d045c6">createBlock</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> insertPt={}, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argTypes=llvm::None, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs=llvm::None)</td></tr>
<tr class="memdesc:ab3eb36f5e608597be4fa16b155d045c6 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new block with 'argTypes' arguments and set the insertion point to the end of it.  <a href="classmlir_1_1OpBuilder.html#ab3eb36f5e608597be4fa16b155d045c6">More...</a><br /></td></tr>
<tr class="separator:ab3eb36f5e608597be4fa16b155d045c6 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67ea23150f0587db83d8a074e1d8d18 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ad67ea23150f0587db83d8a074e1d8d18">createBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *insertBefore, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argTypes=llvm::None, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs=llvm::None)</td></tr>
<tr class="memdesc:ad67ea23150f0587db83d8a074e1d8d18 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new block with 'argTypes' arguments and set the insertion point to the end of it.  <a href="classmlir_1_1OpBuilder.html#ad67ea23150f0587db83d8a074e1d8d18">More...</a><br /></td></tr>
<tr class="separator:ad67ea23150f0587db83d8a074e1d8d18 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aea9f73b5462b5606846ccc58f985cf4f">insert</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given operation at the current insertion point and return it.  <a href="classmlir_1_1OpBuilder.html#aea9f73b5462b5606846ccc58f985cf4f">More...</a><br /></td></tr>
<tr class="separator:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ac6a6edadd39800db410864ef06a004b2">create</a> (const <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="memdesc:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation given the fields represented as an <a class="el" href="structmlir_1_1OperationState.html" title="This represents an operation in an abstracted form, suitable for use with the builder APIs...">OperationState</a>.  <a href="classmlir_1_1OpBuilder.html#ac6a6edadd39800db410864ef06a004b2">More...</a><br /></td></tr>
<tr class="separator:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5bc48b720754f906005f4ed8f744a3d4">create</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, StringAttr opName, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; attributes={}, <a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a> successors={}, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&gt; regions={})</td></tr>
<tr class="memdesc:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation with the given fields.  <a href="classmlir_1_1OpBuilder.html#a5bc48b720754f906005f4ed8f744a3d4">More...</a><br /></td></tr>
<tr class="separator:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a879310e19a53b06e60a2622a6177af8a">create</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an operation of specific op type at the current insertion point.  <a href="classmlir_1_1OpBuilder.html#a879310e19a53b06e60a2622a6177af8a">More...</a><br /></td></tr>
<tr class="separator:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a9bfa9ca1c08777d5eba6276c24c0cf9a">createOrFold</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;results, <a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an operation of specific op type at the current insertion point, and immediately try to fold it.  <a href="classmlir_1_1OpBuilder.html#a9bfa9ca1c08777d5eba6276c24c0cf9a">More...</a><br /></td></tr>
<tr class="separator:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910cd65113898b742750fbec85e90caa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a910cd65113898b742750fbec85e90caa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; OpTy::template hasTrait&lt; <a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">OpTrait::OneResult</a> &gt;), <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a910cd65113898b742750fbec85e90caa">createOrFold</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a910cd65113898b742750fbec85e90caa inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to create or fold a single result operation.  <a href="classmlir_1_1OpBuilder.html#a910cd65113898b742750fbec85e90caa">More...</a><br /></td></tr>
<tr class="separator:a910cd65113898b742750fbec85e90caa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a8585c9be7f47e4731bef14028f9e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:aa96a8585c9be7f47e4731bef14028f9e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; OpTy::template hasTrait&lt; <a class="el" href="classmlir_1_1OpTrait_1_1ZeroResult.html">OpTrait::ZeroResult</a> &gt;), OpTy &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aa96a8585c9be7f47e4731bef14028f9e">createOrFold</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa96a8585c9be7f47e4731bef14028f9e inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to create or fold a zero result operation.  <a href="classmlir_1_1OpBuilder.html#aa96a8585c9be7f47e4731bef14028f9e">More...</a><br /></td></tr>
<tr class="separator:aa96a8585c9be7f47e4731bef14028f9e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d948b899f697dd7021f60823ecc010 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ae1d948b899f697dd7021f60823ecc010">tryFold</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:ae1d948b899f697dd7021f60823ecc010 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to fold the given operation and places new results within 'results'.  <a href="classmlir_1_1OpBuilder.html#ae1d948b899f697dd7021f60823ecc010">More...</a><br /></td></tr>
<tr class="separator:ae1d948b899f697dd7021f60823ecc010 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd29be21675019d8f660b413c77cf64d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#acd29be21675019d8f660b413c77cf64d">clone</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper)</td></tr>
<tr class="memdesc:acd29be21675019d8f660b413c77cf64d inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the specified operation, remapping any operands that use values outside of the operation using the map that is provided ( leaving them alone if no entry is present).  <a href="classmlir_1_1OpBuilder.html#acd29be21675019d8f660b413c77cf64d">More...</a><br /></td></tr>
<tr class="separator:acd29be21675019d8f660b413c77cf64d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e70a2262a26f1f73610f421a4c5f8e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ae2e70a2262a26f1f73610f421a4c5f8e">clone</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:ae2e70a2262a26f1f73610f421a4c5f8e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001c9d24988c30a25e3c64fba4c78e43 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a001c9d24988c30a25e3c64fba4c78e43">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper)</td></tr>
<tr class="memdesc:a001c9d24988c30a25e3c64fba4c78e43 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this operation but keep the operation regions empty.  <a href="classmlir_1_1OpBuilder.html#a001c9d24988c30a25e3c64fba4c78e43">More...</a><br /></td></tr>
<tr class="separator:a001c9d24988c30a25e3c64fba4c78e43 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12998920bce0716f955818d0f3aa240d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a12998920bce0716f955818d0f3aa240d">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:a12998920bce0716f955818d0f3aa240d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpT &gt; </td></tr>
<tr class="memitem:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">OpT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a22db34c9d8628024441dc89ae09eb384">cloneWithoutRegions</a> (OpT op)</td></tr>
<tr class="separator:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Builder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Builder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Builder.html">mlir::Builder</a></td></tr>
<tr class="memitem:a826c8a69e4eb96b4f88ec839bef2d277 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a826c8a69e4eb96b4f88ec839bef2d277">Builder</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *<a class="el" href="classmlir_1_1Builder.html#a825fc6884f9ad5ac24ff3871ac5db811">context</a>)</td></tr>
<tr class="separator:a826c8a69e4eb96b4f88ec839bef2d277 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2fc4f0a55d99d41177d2f0d654ae7 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a83e2fc4f0a55d99d41177d2f0d654ae7">Builder</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a83e2fc4f0a55d99d41177d2f0d654ae7 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d1e114c8047cad1b014b504688a868 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa6d1e114c8047cad1b014b504688a868">getContext</a> () const</td></tr>
<tr class="separator:aa6d1e114c8047cad1b014b504688a868 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a2a66c362dcd5e58f46508e4ce53ea inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac9a2a66c362dcd5e58f46508e4ce53ea">getUnknownLoc</a> ()</td></tr>
<tr class="separator:ac9a2a66c362dcd5e58f46508e4ce53ea inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93df8270f308f1762fd9a3010a0aeb54 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a93df8270f308f1762fd9a3010a0aeb54">getFusedLoc</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> metadata=<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>())</td></tr>
<tr class="separator:a93df8270f308f1762fd9a3010a0aeb54 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99814a27f341d60847303ee8b3b276ed inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a99814a27f341d60847303ee8b3b276ed">getBF16Type</a> ()</td></tr>
<tr class="separator:a99814a27f341d60847303ee8b3b276ed inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a9688bbdedc91cd60043a5a90ba8a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a909a9688bbdedc91cd60043a5a90ba8a">getF16Type</a> ()</td></tr>
<tr class="separator:a909a9688bbdedc91cd60043a5a90ba8a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4a2d4767557f4dad38a4c5350ca4b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a22a4a2d4767557f4dad38a4c5350ca4b">getF32Type</a> ()</td></tr>
<tr class="separator:a22a4a2d4767557f4dad38a4c5350ca4b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21066e4cd1efbe5ed7801fb8f93755f inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af21066e4cd1efbe5ed7801fb8f93755f">getF64Type</a> ()</td></tr>
<tr class="separator:af21066e4cd1efbe5ed7801fb8f93755f inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cbcce8f79a98541c0c76ecbd56a0bc inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a14cbcce8f79a98541c0c76ecbd56a0bc">getF80Type</a> ()</td></tr>
<tr class="separator:a14cbcce8f79a98541c0c76ecbd56a0bc inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543bead785963a54eb35f3cbcc27f4e inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a1543bead785963a54eb35f3cbcc27f4e">getF128Type</a> ()</td></tr>
<tr class="separator:a1543bead785963a54eb35f3cbcc27f4e inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace585fd315aa2ebcc7bb87e18483f5b4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ace585fd315aa2ebcc7bb87e18483f5b4">getIndexType</a> ()</td></tr>
<tr class="separator:ace585fd315aa2ebcc7bb87e18483f5b4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68228481d9deafab913889e4fb01886 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac68228481d9deafab913889e4fb01886">getI1Type</a> ()</td></tr>
<tr class="separator:ac68228481d9deafab913889e4fb01886 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a967cff48476dd805b9f320e8b4f2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acf0a967cff48476dd805b9f320e8b4f2">getI8Type</a> ()</td></tr>
<tr class="separator:acf0a967cff48476dd805b9f320e8b4f2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6290adcfa7712b7f5c9cf84a068c6b02 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a6290adcfa7712b7f5c9cf84a068c6b02">getI32Type</a> ()</td></tr>
<tr class="separator:a6290adcfa7712b7f5c9cf84a068c6b02 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb6bdf570be01405614c0ef5ff210f inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a5eeb6bdf570be01405614c0ef5ff210f">getI64Type</a> ()</td></tr>
<tr class="separator:a5eeb6bdf570be01405614c0ef5ff210f inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658537562d6415b98373760c06b36d6 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a6658537562d6415b98373760c06b36d6">getIntegerType</a> (<a class="el" href="classunsigned.html">unsigned</a> width)</td></tr>
<tr class="separator:a6658537562d6415b98373760c06b36d6 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156864dbcd76ccad2ffe29493258d81 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ad156864dbcd76ccad2ffe29493258d81">getIntegerType</a> (<a class="el" href="classunsigned.html">unsigned</a> width, bool isSigned)</td></tr>
<tr class="separator:ad156864dbcd76ccad2ffe29493258d81 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e44a1083e200c0aea501f30f4ddc62c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FunctionType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a5e44a1083e200c0aea501f30f4ddc62c">getFunctionType</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> inputs, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> results)</td></tr>
<tr class="separator:a5e44a1083e200c0aea501f30f4ddc62c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26001422e6f097cd30c6ada96cb44bc0 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a26001422e6f097cd30c6ada96cb44bc0">getTupleType</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> elementTypes)</td></tr>
<tr class="separator:a26001422e6f097cd30c6ada96cb44bc0 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c894559415eb666eb033a7dde5ad4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">NoneType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a690c894559415eb666eb033a7dde5ad4">getNoneType</a> ()</td></tr>
<tr class="separator:a690c894559415eb666eb033a7dde5ad4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b53d9564f24a674ffee1e96fafba2 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename... Args&gt; </td></tr>
<tr class="memitem:a8a2b53d9564f24a674ffee1e96fafba2 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplItemLeft" align="right" valign="top">Ty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a8a2b53d9564f24a674ffee1e96fafba2">getType</a> (Args... args)</td></tr>
<tr class="memdesc:a8a2b53d9564f24a674ffee1e96fafba2 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or construct an instance of the type 'ty' with provided arguments.  <a href="classmlir_1_1Builder.html#a8a2b53d9564f24a674ffee1e96fafba2">More...</a><br /></td></tr>
<tr class="separator:a8a2b53d9564f24a674ffee1e96fafba2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5d3d4b21950f70e95fcd1a6584514 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#adbc5d3d4b21950f70e95fcd1a6584514">getNamedAttr</a> (StringRef name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> val)</td></tr>
<tr class="separator:adbc5d3d4b21950f70e95fcd1a6584514 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba94155c8438c805c7bf379d79d36c5 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">UnitAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a0ba94155c8438c805c7bf379d79d36c5">getUnitAttr</a> ()</td></tr>
<tr class="separator:a0ba94155c8438c805c7bf379d79d36c5 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1415e9c02ceddb2baa2c6bbbad4695 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a7c1415e9c02ceddb2baa2c6bbbad4695">getBoolAttr</a> (bool <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a7c1415e9c02ceddb2baa2c6bbbad4695 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4223706459ecde5d8c35783aafcff5c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">DictionaryAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ad4223706459ecde5d8c35783aafcff5c">getDictionaryAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:ad4223706459ecde5d8c35783aafcff5c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d04960e3b45799682ba40009a1201a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a28d04960e3b45799682ba40009a1201a">getIntegerAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a28d04960e3b45799682ba40009a1201a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b904aeae73bec8c25e402016bc7c162 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a9b904aeae73bec8c25e402016bc7c162">getIntegerAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const APInt &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a9b904aeae73bec8c25e402016bc7c162 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dda5590e9c173d5b7813095640b4199 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4dda5590e9c173d5b7813095640b4199">getFloatAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, double <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a4dda5590e9c173d5b7813095640b4199 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da014f35177bf242a185ebceb25066 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a73da014f35177bf242a185ebceb25066">getFloatAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const APFloat &amp;<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a73da014f35177bf242a185ebceb25066 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c9b2b69671833b1036e3c2a4542ff4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">StringAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a81c9b2b69671833b1036e3c2a4542ff4">getStringAttr</a> (const Twine &amp;bytes)</td></tr>
<tr class="separator:a81c9b2b69671833b1036e3c2a4542ff4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0170e1b16f9c7464823b7b2fcb042 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac9e0170e1b16f9c7464823b7b2fcb042">getArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:ac9e0170e1b16f9c7464823b7b2fcb042 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac357e21357d9d11d72ee23a51d89e00a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac357e21357d9d11d72ee23a51d89e00a">getZeroAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:ac357e21357d9d11d72ee23a51d89e00a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c56ae3e02345334101a0c93171b50d inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a32c56ae3e02345334101a0c93171b50d">getF16FloatAttr</a> (float <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a32c56ae3e02345334101a0c93171b50d inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd243c1ec9a8c264fa9cc9e7dfdeb01 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acfd243c1ec9a8c264fa9cc9e7dfdeb01">getF32FloatAttr</a> (float <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:acfd243c1ec9a8c264fa9cc9e7dfdeb01 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1a58ca9d0d2ba4819b8fd5db67f13d inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2b1a58ca9d0d2ba4819b8fd5db67f13d">getF64FloatAttr</a> (double <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a2b1a58ca9d0d2ba4819b8fd5db67f13d inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7b8d95ff2cfbd7092ae80db1682386 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aee7b8d95ff2cfbd7092ae80db1682386">getI8IntegerAttr</a> (int8_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:aee7b8d95ff2cfbd7092ae80db1682386 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4440d4fedcb8ebc61b33eb771fbc7f7c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4440d4fedcb8ebc61b33eb771fbc7f7c">getI16IntegerAttr</a> (int16_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a4440d4fedcb8ebc61b33eb771fbc7f7c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6e1fd34a9a089a70b6d3e4bb3b1afe inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a1a6e1fd34a9a089a70b6d3e4bb3b1afe">getI32IntegerAttr</a> (int32_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a1a6e1fd34a9a089a70b6d3e4bb3b1afe inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646e4cb04618d56320ba37cb51c91be2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a646e4cb04618d56320ba37cb51c91be2">getI64IntegerAttr</a> (int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a646e4cb04618d56320ba37cb51c91be2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06091b945ff2912cc077219350944b33 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a06091b945ff2912cc077219350944b33">getIndexAttr</a> (int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:a06091b945ff2912cc077219350944b33 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a8ccbf998590e8215c99ccd0676bd804c">getSI32IntegerAttr</a> (int32_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed and unsigned integer attribute getters.  <a href="classmlir_1_1Builder.html#a8ccbf998590e8215c99ccd0676bd804c">More...</a><br /></td></tr>
<tr class="separator:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ab0152483e78be2569eb7116bd99a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#adf2ab0152483e78be2569eb7116bd99a">getUI32IntegerAttr</a> (uint32_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="separator:adf2ab0152483e78be2569eb7116bd99a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a224248e0bdaf028d56c3211343ff4e16">getBoolVectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="memdesc:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-typed <a class="el" href="classmlir_1_1DenseIntElementsAttr.html" title="An attribute that represents a reference to a dense integer vector or tensor object. ">DenseIntElementsAttr</a> getters. <code>values</code> must not be empty.  <a href="classmlir_1_1Builder.html#a224248e0bdaf028d56c3211343ff4e16">More...</a><br /></td></tr>
<tr class="separator:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbb8249c04591c13ea5e460cc29132a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aacbb8249c04591c13ea5e460cc29132a">getI32VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="separator:aacbb8249c04591c13ea5e460cc29132a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab760708fd8802a3274d080d19ac15f98 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ab760708fd8802a3274d080d19ac15f98">getI64VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:ab760708fd8802a3274d080d19ac15f98 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af831b0dc7dd75d7069ff96e7f7218f05 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af831b0dc7dd75d7069ff96e7f7218f05">getIndexVectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:af831b0dc7dd75d7069ff96e7f7218f05 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a557059365d9158704d2cd9c0f137a387">getI32TensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="memdesc:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor-typed <a class="el" href="classmlir_1_1DenseIntElementsAttr.html" title="An attribute that represents a reference to a dense integer vector or tensor object. ">DenseIntElementsAttr</a> getters.  <a href="classmlir_1_1Builder.html#a557059365d9158704d2cd9c0f137a387">More...</a><br /></td></tr>
<tr class="separator:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7654e378a8f6e3ec0bc098303aa84a02 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a7654e378a8f6e3ec0bc098303aa84a02">getI64TensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a7654e378a8f6e3ec0bc098303aa84a02 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31beecf247ee57c3378e9b39e2377d2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa31beecf247ee57c3378e9b39e2377d2">getIndexTensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:aa31beecf247ee57c3378e9b39e2377d2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad513744f9110000663ed9e0a92baa2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#afad513744f9110000663ed9e0a92baa2">getAffineMapArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; values)</td></tr>
<tr class="separator:afad513744f9110000663ed9e0a92baa2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fe132a1059a68679775fa4c06666b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af40fe132a1059a68679775fa4c06666b">getBoolArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="separator:af40fe132a1059a68679775fa4c06666b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9bdaca0ca5495fd145156b03de3202 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2d9bdaca0ca5495fd145156b03de3202">getI32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="separator:a2d9bdaca0ca5495fd145156b03de3202 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd2d0313d6da2dca8c93872eac89889 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acdd2d0313d6da2dca8c93872eac89889">getI64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:acdd2d0313d6da2dca8c93872eac89889 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deaca809030599e11054cf100680aec inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a0deaca809030599e11054cf100680aec">getIndexArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a0deaca809030599e11054cf100680aec inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb2f1dc3b6bc85aa6aac50db2520d5 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aeeeb2f1dc3b6bc85aa6aac50db2520d5">getF32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; float &gt; values)</td></tr>
<tr class="separator:aeeeb2f1dc3b6bc85aa6aac50db2520d5 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29b1d52fd544bda5e21b86122f2e7ec inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac29b1d52fd544bda5e21b86122f2e7ec">getF64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; double &gt; values)</td></tr>
<tr class="separator:ac29b1d52fd544bda5e21b86122f2e7ec inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a745880a80d38381fe94470acc9ef inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af45a745880a80d38381fe94470acc9ef">getStrArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; values)</td></tr>
<tr class="separator:af45a745880a80d38381fe94470acc9ef inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe1c29ec99bccf51c3bdfe6da4826c9 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aabe1c29ec99bccf51c3bdfe6da4826c9">getTypeArrayAttr</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> values)</td></tr>
<tr class="separator:aabe1c29ec99bccf51c3bdfe6da4826c9 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06e1494dca3f76c97dcbf0600439191 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa06e1494dca3f76c97dcbf0600439191">getAffineDimExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="separator:aa06e1494dca3f76c97dcbf0600439191 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834164298c925d6a2f4206634421506 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4834164298c925d6a2f4206634421506">getAffineSymbolExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="separator:a4834164298c925d6a2f4206634421506 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532065b3a37e28c7bc34f1b78558b00e inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a532065b3a37e28c7bc34f1b78558b00e">getAffineConstantExpr</a> (int64_t constant)</td></tr>
<tr class="separator:a532065b3a37e28c7bc34f1b78558b00e inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a82d80016cf0c9ec35f0c0e12ab4328da">getEmptyAffineMap</a> ()</td></tr>
<tr class="memdesc:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with no dimensions or symbols: () -&gt; ().  <a href="classmlir_1_1Builder.html#a82d80016cf0c9ec35f0c0e12ab4328da">More...</a><br /></td></tr>
<tr class="separator:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a">getConstantAffineMap</a> (int64_t val)</td></tr>
<tr class="memdesc:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single constant result affine map with 0 dimensions and 0 symbols.  <a href="classmlir_1_1Builder.html#aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a">More...</a><br /></td></tr>
<tr class="separator:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55bf2d629ec55fdd702a185e89940b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a3f55bf2d629ec55fdd702a185e89940b">getDimIdentityMap</a> ()</td></tr>
<tr class="separator:a3f55bf2d629ec55fdd702a185e89940b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422a9ab33af4134efcb4044fb81deab1 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a422a9ab33af4134efcb4044fb81deab1">getMultiDimIdentityMap</a> (<a class="el" href="classunsigned.html">unsigned</a> rank)</td></tr>
<tr class="separator:a422a9ab33af4134efcb4044fb81deab1 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b7c4759b2a291f442fbb1f966d5f05 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ab7b7c4759b2a291f442fbb1f966d5f05">getSymbolIdentityMap</a> ()</td></tr>
<tr class="separator:ab7b7c4759b2a291f442fbb1f966d5f05 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a07254e03f44bb2ca0960ccbe68665467">getSingleDimShiftAffineMap</a> (int64_t shift)</td></tr>
<tr class="memdesc:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map that shifts its (single) input dimension by 'shift'.  <a href="classmlir_1_1Builder.html#a07254e03f44bb2ca0960ccbe68665467">More...</a><br /></td></tr>
<tr class="separator:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2b5d5ea8815753c883ef11f5cc6880d6">getShiftedAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, int64_t shift)</td></tr>
<tr class="memdesc:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map that is a translation (shift) of all result expressions in 'map' by 'shift'.  <a href="classmlir_1_1Builder.html#a2b5d5ea8815753c883ef11f5cc6880d6">More...</a><br /></td></tr>
<tr class="separator:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structmlir_1_1OpBuilder_1_1Listener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">mlir::OpBuilder::Listener</a></td></tr>
<tr class="memitem:a11ed0e55ee76bc1f61e714b58abfc244 inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html#a11ed0e55ee76bc1f61e714b58abfc244">~Listener</a> ()</td></tr>
<tr class="separator:a11ed0e55ee76bc1f61e714b58abfc244 inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd97312ec692a16a51fa3f8bbd653e9 inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html#abfd97312ec692a16a51fa3f8bbd653e9">notifyOperationInserted</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abfd97312ec692a16a51fa3f8bbd653e9 inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification handler for when an operation is inserted into the builder.  <a href="structmlir_1_1OpBuilder_1_1Listener.html#abfd97312ec692a16a51fa3f8bbd653e9">More...</a><br /></td></tr>
<tr class="separator:abfd97312ec692a16a51fa3f8bbd653e9 inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d41b8b2d66bc7e5a114ee20df90bbf inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html#a08d41b8b2d66bc7e5a114ee20df90bbf">notifyBlockCreated</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a08d41b8b2d66bc7e5a114ee20df90bbf inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification handler for when a block is created using the builder.  <a href="structmlir_1_1OpBuilder_1_1Listener.html#a08d41b8b2d66bc7e5a114ee20df90bbf">More...</a><br /></td></tr>
<tr class="separator:a08d41b8b2d66bc7e5a114ee20df90bbf inherit pub_methods_structmlir_1_1OpBuilder_1_1Listener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa87bef8543982ed95652a2fbf5e8ebfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#aa87bef8543982ed95652a2fbf5e8ebfc">RewriterBase</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:aa87bef8543982ed95652a2fbf5e8ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the builder with this rewriter as the listener.  <a href="#aa87bef8543982ed95652a2fbf5e8ebfc">More...</a><br /></td></tr>
<tr class="separator:aa87bef8543982ed95652a2fbf5e8ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55684591d9628c5db0b467ebea978701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a55684591d9628c5db0b467ebea978701">RewriterBase</a> (const <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;otherBuilder)</td></tr>
<tr class="separator:a55684591d9628c5db0b467ebea978701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7876e56411e94a46fec3cec5cdc57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ab0c7876e56411e94a46fec3cec5cdc57">~RewriterBase</a> () override</td></tr>
<tr class="separator:ab0c7876e56411e94a46fec3cec5cdc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672f6b3fe3588f24df9de7ce567c9350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a672f6b3fe3588f24df9de7ce567c9350">notifyRootReplaced</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a672f6b3fe3588f24df9de7ce567c9350"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the callback methods that subclasses can choose to implement if they would like to be notified about certain types of mutations.  <a href="#a672f6b3fe3588f24df9de7ce567c9350">More...</a><br /></td></tr>
<tr class="separator:a672f6b3fe3588f24df9de7ce567c9350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772b9635423cf0b2839f4fedb47528d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a772b9635423cf0b2839f4fedb47528d2">notifyOperationRemoved</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a772b9635423cf0b2839f4fedb47528d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called on an operation that a rewrite is removing, right before the operation is deleted.  <a href="#a772b9635423cf0b2839f4fedb47528d2">More...</a><br /></td></tr>
<tr class="separator:a772b9635423cf0b2839f4fedb47528d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e41336273274e057d232ee5125330da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a4e41336273274e057d232ee5125330da">notifyMatchFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt; reasonCallback)</td></tr>
<tr class="memdesc:a4e41336273274e057d232ee5125330da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the rewriter that the pattern failed to match the given operation, and provide a callback to populate a diagnostic with the reason why the failure occurred.  <a href="#a4e41336273274e057d232ee5125330da">More...</a><br /></td></tr>
<tr class="separator:a4e41336273274e057d232ee5125330da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpBuilder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpBuilder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></td></tr>
<tr class="memitem:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a08466834f26b5779d3fbe3b86f02ff0d">atBlockBegin</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to before the first operation in the block but still inside the block.  <a href="classmlir_1_1OpBuilder.html#a08466834f26b5779d3fbe3b86f02ff0d">More...</a><br /></td></tr>
<tr class="separator:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a2cfda0879e254d7fde93ccd5811c2d8f">atBlockEnd</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to after the last operation in the block but still inside the block.  <a href="classmlir_1_1OpBuilder.html#a2cfda0879e254d7fde93ccd5811c2d8f">More...</a><br /></td></tr>
<tr class="separator:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5cb50a345347f2e8be33473ffc3df78e">atBlockTerminator</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *listener=nullptr)</td></tr>
<tr class="memdesc:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to before the block terminator.  <a href="classmlir_1_1OpBuilder.html#a5cb50a345347f2e8be33473ffc3df78e">More...</a><br /></td></tr>
<tr class="separator:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1Builder"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1Builder')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1Builder.html">mlir::Builder</a></td></tr>
<tr class="memitem:a825fc6884f9ad5ac24ff3871ac5db811 inherit pro_attribs_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a825fc6884f9ad5ac24ff3871ac5db811">context</a></td></tr>
<tr class="separator:a825fc6884f9ad5ac24ff3871ac5db811 inherit pro_attribs_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations. </p>
<p>This class serves as a common API for IR mutation between pattern rewrites and non-pattern rewrites, and facilitates the development of shared IR transformation utilities. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00398">398</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa87bef8543982ed95652a2fbf5e8ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87bef8543982ed95652a2fbf5e8ebfc">&#9670;&nbsp;</a></span>RewriterBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::RewriterBase::RewriterBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the builder with this rewriter as the listener. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00538">538</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a55684591d9628c5db0b467ebea978701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55684591d9628c5db0b467ebea978701">&#9670;&nbsp;</a></span>RewriterBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::RewriterBase::RewriterBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>otherBuilder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00539">539</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ab0c7876e56411e94a46fec3cec5cdc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c7876e56411e94a46fec3cec5cdc57">&#9670;&nbsp;</a></span>~RewriterBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RewriterBase::~RewriterBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00204">204</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa55d2f1aded51c1714d0cdae0fcf90b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55d2f1aded51c1714d0cdae0fcf90b2">&#9670;&nbsp;</a></span>cancelRootUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoid.html">void</a> mlir::RewriterBase::cancelRootUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method cancels a pending root update. </p>
<p>This can only be called on operations that were provided to a call to <code>startRootUpdate</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#aa5ec71d27d9b622e5ff8205c3546701c">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00493">493</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1c9992dd1eff9b9baf951368241fd083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9992dd1eff9b9baf951368241fd083">&#9670;&nbsp;</a></span>cloneRegionBefore() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::cloneRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the blocks that belong to "region" before the given position in another region "parent". </p>
<p>The two regions must be different. The caller is responsible for creating or updating the operation transferring flow of control to the region and passing it the correct block arguments. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a8e1c61b0593c1477bceb5ba17b2846a1">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00351">351</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00070">mlir::Region::cloneInto()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01623">mlir::ConversionPatternRewriter::cloneRegionBefore()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00024">inlineIfCase()</a>, and <a class="el" href="TosaToSCF_8cpp_source.html#l00042">inlineWhileCase()</a>.</p>

</div>
</div>
<a id="af20606a173cf42c30b7a8585bdab81b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20606a173cf42c30b7a8585bdab81b1">&#9670;&nbsp;</a></span>cloneRegionBefore() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::cloneRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00356">356</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

</div>
</div>
<a id="ac9ff71c74783a6385b4bbd597e44f21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ff71c74783a6385b4bbd597e44f21d">&#9670;&nbsp;</a></span>cloneRegionBefore() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::cloneRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00361">361</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>.</p>

</div>
</div>
<a id="a286510e5cc47983e5b6017bad6aa6335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286510e5cc47983e5b6017bad6aa6335">&#9670;&nbsp;</a></span>eraseBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::eraseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases all operations in a block. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#aa6daaf4084b64e140a101b4b875d90c6">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00265">265</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00054">mlir::Block::erase()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00624">mlir::Operation::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00570">ableToUpdatePredOperands()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00079">mlir::eraseUnreachableBlocks()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00024">inlineIfCase()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00042">inlineWhileCase()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">mlir::lowerAffineLowerBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>.</p>

</div>
</div>
<a id="a786138ac6a91e0932da343ef5c6f1e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786138ac6a91e0932da343ef5c6f1e70">&#9670;&nbsp;</a></span>eraseOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::eraseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases an operation that is known to have no uses. </p>
<p>The uses of the given operation <em>must</em> be known to be dead. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a56f841ea5c2326350a6d7182e9028a0e">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00259">259</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00624">mlir::Operation::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00309">deleteDeadness()</a>, <a class="el" href="AsyncParallelFor_8cpp_source.html#l00649">doSequentialDispatch()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01217">foldMemRefCast()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00250">fuseElementwiseOpsImpl()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01508">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00024">inlineIfCase()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00042">inlineWhileCase()</a>, <a class="el" href="Merger_8cpp_source.html#l00790">mlir::sparse_tensor::insertYieldOp()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00205">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00355">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01105">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01257">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01688">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">mlir::outlineSingleBlockRegion()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00144">simplifyBrToBlockWithSinglePred()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>.</p>

</div>
</div>
<a id="a88d27913ece453c522fdd151ba853a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d27913ece453c522fdd151ba853a7b">&#9670;&nbsp;</a></span>finalizeRootUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoid.html">void</a> mlir::RewriterBase::finalizeRootUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to signal the end of a root update on the given operation. </p>
<p>This can only be called on operations that were provided to a call to <code>startRootUpdate</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a490be68aa183cbad7ed69f98d0dcc341">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00489">489</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>.</p>

</div>
</div>
<a id="adaf2b23302d524eeb5643dcff7668ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf2b23302d524eeb5643dcff7668ebf">&#9670;&nbsp;</a></span>inlineRegionBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::inlineRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the blocks that belong to "region" before the given position in another region "parent". </p>
<p>Move the blocks that belong to "region" before the given position in another region.</p>
<p>The two regions must be different. The caller is responsible for creating or updating the operation transferring flow of control to the region and passing it the correct block arguments.</p>
<p>The two regions must be different. The caller is in charge to update create the operation transferring the control flow to the region and pass it the correct block arguments. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a47becd4896180e2132b82f7d9071d0a9">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00339">339</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00181">createDecl()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00237">declareReduction()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="Generalization_8cpp_source.html#l00042">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01616">mlir::ConversionPatternRewriter::inlineRegionBefore()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">mlir::lowerAffineLowerBound()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00205">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, and <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>.</p>

</div>
</div>
<a id="adbd0cf093ad5c10fb3e12a4e1fbb5e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd0cf093ad5c10fb3e12a4e1fbb5e1b">&#9670;&nbsp;</a></span>inlineRegionBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::inlineRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00343">343</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>.</p>

</div>
</div>
<a id="a453855dd11f55fd311d2f543b4a8914e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453855dd11f55fd311d2f543b4a8914e">&#9670;&nbsp;</a></span>mergeBlockBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::mergeBlockBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>argValues</em> = <code>llvm::None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00298">298</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8h_source.html#l00230">mlir::Block::hasNoPredecessors()</a>, and <a class="el" href="Block_8h_source.html#l00233">mlir::Block::hasNoSuccessors()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="Merger_8cpp_source.html#l00790">mlir::sparse_tensor::insertYieldOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00355">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, and <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>.</p>

</div>
</div>
<a id="af707a54463fefda9bd8d2ec5c455472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af707a54463fefda9bd8d2ec5c455472a">&#9670;&nbsp;</a></span>mergeBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::mergeBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>argValues</em> = <code>llvm::None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the operations of block 'source' into the end of block 'dest'. </p>
<p>'source's predecessors must either be empty or only contain 'dest`. 'argValues' is used to replace the block arguments of 'source' after merging.</p>
<p>'source's predecessors must be empty or only contain 'dest`. 'argValues' is used to replace the block arguments of 'source' after merging. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a806a523a4db1d2b056855cc6cfd58c18">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00277">277</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00174">mlir::IRObjectWithUseList&lt; OperandType &gt;::dropAllUses()</a>, <a class="el" href="Block_8h_source.html#l00135">mlir::Block::end()</a>, <a class="el" href="Block_8cpp_source.html#l00054">mlir::Block::erase()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="Block_8h_source.html#l00119">mlir::Block::getNumArguments()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getOperations()</a>, and <a class="el" href="Block_8h_source.html#l00225">mlir::Block::getPredecessors()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00237">declareReduction()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00101">mlir::outlineSingleBlockRegion()</a>, and <a class="el" href="ControlFlowOps_8cpp_source.html#l00144">simplifyBrToBlockWithSinglePred()</a>.</p>

</div>
</div>
<a id="a032aa8fe5345a286681688ef10f5cb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032aa8fe5345a286681688ef10f5cb84">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;CallbackT, Twine&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&gt; mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>reasonCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to notify the rewriter that the IR failed to be rewritten because of a match failure, and provide a callback to populate a diagnostic with the reason why the failure occurred. </p>
<p>This method allows for derived rewriters to optionally hook into the reason why a rewrite failed, and display it to users. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00512">512</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">mlir::linalg::LinalgTransformationFilter::checkAndNotify()</a>, <a class="el" href="CoversionUtils_8h_source.html#l00054">mlir::tosa::checkHasDynamicBatchDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00044">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00042">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00100">inferDynamicDimsForConv()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00563">isGenericOpExpandable()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">mlir::lowerAffineLowerBound()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00772">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00249">TransposeOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00378">MaterializePadValue::matchAndRewrite()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00397">processParallelLoop()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00580">mlir::linalg::LinalgTileAndFuseTensorOpsPattern::returningMatchAndRewrite()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00059">mlir::linalg::splitReduction()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01069">mlir::detail::pdl_function_builder::verifyAsArgs()</a>.</p>

</div>
</div>
<a id="a081f7564cc3f62236c99e2a8098c3673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081f7564cc3f62236c99e2a8098c3673">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;CallbackT, Twine&gt;::<a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&gt; mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>reasonCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00522">522</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>.</p>

</div>
</div>
<a id="a2a1d35106b18aaf457462915e16f3ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d35106b18aaf457462915e16f3ea3">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype">ArgT &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00527">527</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00046">diag()</a>.</p>

</div>
</div>
<a id="ab106a05ed09d9245211a36d3935945dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab106a05ed09d9245211a36d3935945dd">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype">ArgT &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00532">532</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a4e41336273274e057d232ee5125330da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e41336273274e057d232ee5125330da">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>reasonCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the rewriter that the pattern failed to match the given operation, and provide a callback to populate a diagnostic with the reason why the failure occurred. </p>
<p>This method allows for derived rewriters to optionally hook into the reason why a rewrite failed, and display it to users. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a356fe2334f285b29cc420ade1d81afa5">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00562">562</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="classmlir_1_1PatternBenefit.html#a3abe1bd10f9264670a6aaf049739fc80">mlir::PatternBenefit::operator=()</a>.</p>

</div>
</div>
<a id="a772b9635423cf0b2839f4fedb47528d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772b9635423cf0b2839f4fedb47528d2">&#9670;&nbsp;</a></span>notifyOperationRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoid.html">void</a> mlir::RewriterBase::notifyOperationRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called on an operation that a rewrite is removing, right before the operation is deleted. </p>
<p>At this point, the operation has zero uses. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00555">555</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">mlir::bufferization::bufferizeOp()</a>.</p>

</div>
</div>
<a id="a672f6b3fe3588f24df9de7ce567c9350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672f6b3fe3588f24df9de7ce567c9350">&#9670;&nbsp;</a></span>notifyRootReplaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoid.html">void</a> mlir::RewriterBase::notifyRootReplaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are the callback methods that subclasses can choose to implement if they would like to be notified about certain types of mutations. </p>
<p>Notify the rewriter that the specified operation is about to be replaced with another set of operations. This is called before the uses of the operation have been changed. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00551">551</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a53c88f3ce889be590b3801b4ddee627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c88f3ce889be590b3801b4ddee627f">&#9670;&nbsp;</a></span>replaceOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::replaceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method replaces the results of the operation with the specified list of values. </p>
<p>The number of provided values must match the number of results of the operation. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a12fa2633cd26e201bb171204cc1d313b">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00245">245</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00424">mlir::Operation::erase()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00209">mlir::Operation::replaceAllUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01631">canonicalizeLoopBounds()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00794">computeMemRefRankReductionMask()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00606">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00337">mlir::linalg::eliminateInitTensors()</a>, <a class="el" href="ByteCode_8cpp_source.html#l01700">executeGetOperandsResults()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01217">foldMemRefCast()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00354">fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00684">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00042">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01291">generateCollapsedIndexingRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01508">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="VectorUnrollDistribute_8cpp_source.html#l00080">getTargetShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00449">mlir::vector::getVectorReductionOp()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00100">inferDynamicDimsForConv()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00042">inlineWhileCase()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00081">isSumOfMul()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">mlir::lowerAffineLowerBound()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00100">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00112">ReduceMultiDimReductionRank::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00116">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00223">TwoDimMultiReductionToElementWise::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00259">NoOpOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00262">TwoDimMultiReductionToReduction::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00292">AddZeroOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00329">MulOneOptimization::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00355">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01405">mlir::vector::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00425">MaxPool2dIsNoOp::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00460">ClampIsNoOp::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01571">mlir::vector::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00918">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00922">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01688">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01796">TransferReadToVectorLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02329">VectorCreateMaskOpConversion::matchAndRewrite()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01315">SliceCanonicalizer::operator()()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, <a class="el" href="Loops_8cpp_source.html#l00166">replaceIndexOpsByInductionVariables()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00356">mlir::bufferization::replaceOpWithBufferizedValues()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00084">replaceOpWithRegion()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00508">mlir::linalg::LinalgPaddingPattern::returningMatchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00901">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="Tiling_8cpp_source.html#l00284">tilePadOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00642">updateExpandedGenericOpRegion()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00626">mlir::linalg::vectorize()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00653">mlir::linalg::vectorizeCopy()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00117">verifyAllocLikeOp()</a>.</p>

</div>
</div>
<a id="a000eb37e5f4dc20974b32e0fd9adaacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000eb37e5f4dc20974b32e0fd9adaacd">&#9670;&nbsp;</a></span>replaceOpWithIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::replaceOpWithIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::unique_function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;) const &gt;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method replaces the uses of the results of <code>op</code> with the values in <code>newValues</code> when the provided <code>functor</code> returns true for a specific use. </p>
<p>The number of values in <code>newValues</code> is required to match the number of results of <code>op</code>. <code>allUsesReplaced</code>, if non-null, is set to true if all of the uses of <code>op</code> were replaced. Note that in some rewriters, the given 'functor' may be stored beyond the lifetime of the rewrite being applied. As such, the function should not capture by reference and instead use value capture as necessary.</p>
<p>The number of values in <code>newValues</code> is required to match the number of results of <code>op</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a5b89ba1e9175b709d937aac95de7bb1b">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00212">212</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>.</p>

</div>
</div>
<a id="a0f179293e04a79213b6edc8ffc7ad8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f179293e04a79213b6edc8ffc7ad8be">&#9670;&nbsp;</a></span>replaceOpWithIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::RewriterBase::replaceOpWithIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::unique_function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;) const &gt;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00430">430</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a7b2839f48adcc7488cbe613b7586220e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2839f48adcc7488cbe613b7586220e">&#9670;&nbsp;</a></span>replaceOpWithinBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> RewriterBase::replaceOpWithinBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method replaces the uses of the results of <code>op</code> with the values in <code>newValues</code> when a use is nested within the given <code>block</code>. </p>
<p>The number of values in <code>newValues</code> is required to match the number of results of <code>op</code>. If all uses of this operation are replaced, the operation is erased. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00235">235</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00182">mlir::Operation::isProperAncestor()</a>.</p>

</div>
</div>
<a id="afb1c910a57707f518d2b9c903c2bb5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c910a57707f518d2b9c903c2bb5bc">&#9670;&nbsp;</a></span>replaceOpWithNewOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::RewriterBase::replaceOpWithNewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the result op with a new op that is created without verification. </p>
<p>The result values of the two ops must be the same types. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00451">451</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToLLVM_8cpp_source.html#l00247">addResumeFunction()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00104">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00878">mlir::canonicalizeSetAndOperands()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00145">castBoolToIntN()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00115">castDataPtr()</a>, <a class="el" href="ArithmeticToLLVM_8cpp_source.html#l00159">convertCmpPredicate()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>, <a class="el" href="ExpandTanh_8cpp_source.html#l00024">convertTanhOp()</a>, <a class="el" href="Arithmetic_2Transforms_2ExpandOps_8cpp_source.html#l00018">createConst()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00181">createDecl()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00950">createReassociationMapsForCollapse()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00237">declareReduction()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00625">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00122">encodeKernelName()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00050">extractCompositeElement()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00141">extractVector()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00033">findAncestorOpInRegion()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01456">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01482">foldInsertAfterInsertSlice()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00660">foldSwitch()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00083">mlir::bufferization::foldToMemrefToTensorPair()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="SplitPadding_8cpp_source.html#l00036">getAsValue()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01068">getCanonicalSliceResultType()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00242">getDefaultABIAttrs()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00032">getFirstIntValue()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00819">getGenericEffectsImpl()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="FoldSubViewOps_8cpp_source.html#l00110">getPermutationMapAttr()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00049">getPtrToElementType()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00465">getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="X86Vector_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00028">getSrcVectorElementType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00272">hasaUniqueDim()</a>, <a class="el" href="ComplexToLLVM_8cpp_source.html#l00048">mlir::ComplexStructBuilder::imaginary()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00100">inferDynamicDimsForConv()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00296">insertCasts()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="ArithmeticToSPIRV_8cpp_source.html#l00270">isBoolScalarOrVector()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01692">mlir::vector::isBroadcastableTo()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02475">isTrivialSubViewOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00161">joinShapes()</a>, <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00090">mlir::lowerAffineLowerBound()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00030">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00097">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00040">InnerOuterDimReductionConversion::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00058">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00060">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00074">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00100">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00112">ReduceMultiDimReductionRank::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00125">ReshapeReshapeOptimization::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00148">TransferWritePermutationLowering::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00173">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00196">ConstantTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00203">Convert1DExtractStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="VectorTransferPermutationMapRewritePatterns_8cpp_source.html#l00208">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00229">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00288">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00289">ConvertAddressOf::matchAndRewrite()</a>, <a class="el" href="VectorMultiDimReductionTransforms_8cpp_source.html#l00300">OneDimMultiReductionToTwoDim::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00305">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00378">MaterializePadValue::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00387">ConvertStore::matchAndRewrite()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00528">ClampClampOptimization::matchAndRewrite()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00534">YieldOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00781">mlir::linalg::PadOpTransformationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00860">mlir::linalg::GeneralizePadOpPattern::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01703">SelectI1Simplify::matchAndRewrite()</a>, <a class="el" href="ArithmeticOps_8cpp_source.html#l01726">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01796">TransferReadToVectorLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01882">VectorLoadToMemrefLoadLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01900">VectorStoreToMemrefStoreLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01937">TransferWriteToVectorStoreLowering::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02004">BubbleDownVectorBitCastForExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02078">BubbleDownBitCastForStridedSliceExtract::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02157">BubbleUpBitCastForStridedSliceInsert::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02649">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02691">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02830">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02601">SubViewCanonicalizer::operator()()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00241">outlineExecuteOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00827">reduceMatchAndRewriteHelper()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00031">replaceTransferOpWithMubuf()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00074">reshapeLowerToHigher()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00901">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01055">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00067">mlir::DataDescriptor::setSize()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00702">simplifyPassThroughSwitch()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00826">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00775">simplifySwitchFromSwitchOnSameCondition()</a>, <a class="el" href="ControlFlowOps_8cpp_source.html#l00604">simplifySwitchWithOnlyDefault()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00035">splatZero()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00721">GenericPadOpVectorizationPattern::tryVectorizeCopy()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00802">verifyTensorReshapeOp()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00185">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a495c76a07ca3e6c84a1594a64dd3cfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495c76a07ca3e6c84a1594a64dd3cfa4">&#9670;&nbsp;</a></span>splitBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a> * RewriterBase::splitBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the operations starting at "before" (inclusive) out of the given block into a new block, and return it. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a7657805236edd9c1ae91ca83862c1b37">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00320">320</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00327">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00330">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00338">mlir::Operation::getResults()</a>, and <a class="el" href="Block_8cpp_source.html#l00289">mlir::Block::splitBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToOpenMP_8cpp_source.html#l00237">declareReduction()</a>, <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00101">eachHasOnlyOneOfTypes()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00205">MultiBlockExecuteInliner::matchAndRewrite()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l01595">mlir::ConversionPatternRewriter::splitBlock()</a>.</p>

</div>
</div>
<a id="adef1756132627eeadf7f12bf810537d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef1756132627eeadf7f12bf810537d1">&#9670;&nbsp;</a></span>startRootUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoid.html">void</a> mlir::RewriterBase::startRootUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to notify the rewriter that an in-place operation modification is about to happen. </p>
<p>A call to this function <em>must</em> be followed by a call to either <code>finalizeRootUpdate</code> or <code>cancelRootUpdate</code>. This is a minor efficiency win (it avoids creating a new operation and removing the old one) but also often allows simpler code in the client. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#ae93d2750ab20628c2b4d5d00ce8a283e">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00484">484</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00577">mlir::scf::buildLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01330">collapseGenericOpIterationDims()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l02062">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="Interchange_8cpp_source.html#l00051">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00631">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00148">replaceUnitDimIndexOps()</a>.</p>

</div>
</div>
<a id="a5685828fb01fe53e90dce64a54db1e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5685828fb01fe53e90dce64a54db1e73">&#9670;&nbsp;</a></span>updateRootInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallableT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::RewriterBase::updateRootInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is a utility wrapper around a root update of an operation. </p>
<p>It wraps calls to <code>startRootUpdate</code> and <code>finalizeRootUpdate</code> around the given callable. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00499">499</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l03051">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00020">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02998">foldTransferInBoundsAttribute()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01049">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00163">isComputeOperation()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00505">isGpuAsyncTokenType()</a>, <a class="el" href="LoopCanonicalization_8cpp_source.html#l00033">isShapePreserving()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00145">ReshapeConstOptimization::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00395">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00370">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02276">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01716">parseInferType()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00111">peelForLoop()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00041">mlir::populateCallOpTypeConversionPattern()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00839">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, and <a class="el" href="ControlFlowOps_8cpp_source.html#l00163">simplifyPassThroughBr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a></li>
<li>lib/IR/<a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:04 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
