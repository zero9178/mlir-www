<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVM::LLVMStructType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></li><li class="navelem"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1LLVM_1_1LLVMStructType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::LLVM::LLVMStructType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type representing a collection of different-typed elements manipulated together.  
 <a href="classmlir_1_1LLVM_1_1LLVMStructType.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="LLVMTypes_8h_source.html">mlir/Dialect/LLVMIR/LLVMTypes.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::LLVM::LLVMStructType:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1LLVM_1_1LLVMStructType__inherit__graph.png" border="0" usemap="#mlir_1_1LLVM_1_1LLVMStructType_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1LLVM_1_1LLVMStructType_inherit__map" id="mlir_1_1LLVM_1_1LLVMStructType_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Utility class for implementing users of storage classes uniqued by a StorageUniquer. " alt="" coords="207,9,480,79"/>
<area shape="rect" id="node3" href="classBaseT.html" title="BaseT" alt="" coords="51,5,113,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::LLVM::LLVMStructType:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1LLVM_1_1LLVMStructType__coll__graph.png" border="0" usemap="#mlir_1_1LLVM_1_1LLVMStructType_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1LLVM_1_1LLVMStructType_coll__map" id="mlir_1_1LLVM_1_1LLVMStructType_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Utility class for implementing users of storage classes uniqued by a StorageUniquer. " alt="" coords="207,9,480,79"/>
<area shape="rect" id="node3" href="classBaseT.html" title="BaseT" alt="" coords="51,5,113,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a51d61dbd143bff47a1331359fdc18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a0a51d61dbd143bff47a1331359fdc18c">setBody</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e8cd2124e2023a22223b8e6ce916654">isPacked</a>)</td></tr>
<tr class="memdesc:a0a51d61dbd143bff47a1331359fdc18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the body of an identified struct.  <a href="#a0a51d61dbd143bff47a1331359fdc18c">More...</a><br /></td></tr>
<tr class="separator:a0a51d61dbd143bff47a1331359fdc18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8cd2124e2023a22223b8e6ce916654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e8cd2124e2023a22223b8e6ce916654">isPacked</a> () const</td></tr>
<tr class="memdesc:a5e8cd2124e2023a22223b8e6ce916654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is packed.  <a href="#a5e8cd2124e2023a22223b8e6ce916654">More...</a><br /></td></tr>
<tr class="separator:a5e8cd2124e2023a22223b8e6ce916654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c1d3fa762081487aa622f6f40cea78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#af7c1d3fa762081487aa622f6f40cea78">isIdentified</a> () const</td></tr>
<tr class="memdesc:af7c1d3fa762081487aa622f6f40cea78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is identified.  <a href="#af7c1d3fa762081487aa622f6f40cea78">More...</a><br /></td></tr>
<tr class="separator:af7c1d3fa762081487aa622f6f40cea78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a96a0b1510ce9eed7c21b9a83652ce55e">isOpaque</a> ()</td></tr>
<tr class="memdesc:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is opaque.  <a href="#a96a0b1510ce9eed7c21b9a83652ce55e">More...</a><br /></td></tr>
<tr class="separator:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b583beb28f839f61169e419d3cd32b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a78b583beb28f839f61169e419d3cd32b">isInitialized</a> ()</td></tr>
<tr class="memdesc:a78b583beb28f839f61169e419d3cd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is initialized.  <a href="#a78b583beb28f839f61169e419d3cd32b">More...</a><br /></td></tr>
<tr class="separator:a78b583beb28f839f61169e419d3cd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28307288eaac35d84bab71207c9f9afa"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a28307288eaac35d84bab71207c9f9afa">getName</a> ()</td></tr>
<tr class="memdesc:a28307288eaac35d84bab71207c9f9afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an identified struct.  <a href="#a28307288eaac35d84bab71207c9f9afa">More...</a><br /></td></tr>
<tr class="separator:a28307288eaac35d84bab71207c9f9afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661cf6c68f45f273b9366f4015e1bd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a661cf6c68f45f273b9366f4015e1bd17">getBody</a> () const</td></tr>
<tr class="memdesc:a661cf6c68f45f273b9366f4015e1bd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of element types contained in a non-opaque struct.  <a href="#a661cf6c68f45f273b9366f4015e1bd17">More...</a><br /></td></tr>
<tr class="separator:a661cf6c68f45f273b9366f4015e1bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a26c05683913b4ae69d9903f5b16a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a10a26c05683913b4ae69d9903f5b16a5">getTypeSizeInBits</a> (const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params) const</td></tr>
<tr class="memdesc:a10a26c05683913b4ae69d9903f5b16a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hooks for DataLayoutTypeInterface.  <a href="#a10a26c05683913b4ae69d9903f5b16a5">More...</a><br /></td></tr>
<tr class="separator:a10a26c05683913b4ae69d9903f5b16a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4436c8f50f4cecaf70f02a7bce6dbf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ac4436c8f50f4cecaf70f02a7bce6dbf8">getABIAlignment</a> (const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params) const</td></tr>
<tr class="separator:ac4436c8f50f4cecaf70f02a7bce6dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7bbc9fb81c3bbcbe82a095a0e65895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a1f7bbc9fb81c3bbcbe82a095a0e65895">getPreferredAlignment</a> (const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params) const</td></tr>
<tr class="separator:a1f7bbc9fb81c3bbcbe82a095a0e65895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab154068bacafd1d62dfc71a3cc0a4fb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ab154068bacafd1d62dfc71a3cc0a4fb1">areCompatible</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> oldLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> newLayout) const</td></tr>
<tr class="separator:ab154068bacafd1d62dfc71a3cc0a4fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b80cf8ae686d0b4d7414f3a3147a613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5b80cf8ae686d0b4d7414f3a3147a613">verifyEntries</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, <a class="el" href="classmlir_1_1Location.html">Location</a> loc) const</td></tr>
<tr class="separator:a5b80cf8ae686d0b4d7414f3a3147a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a18b262fcce3d80816380b5a38b56f7c3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a18b262fcce3d80816380b5a38b56f7c3">isValidElementType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a18b262fcce3d80816380b5a38b56f7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given type can be contained in a structure type.  <a href="#a18b262fcce3d80816380b5a38b56f7c3">More...</a><br /></td></tr>
<tr class="separator:a18b262fcce3d80816380b5a38b56f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade376989c030c140645e36f57d903e87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ade376989c030c140645e36f57d903e87">getIdentified</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef name)</td></tr>
<tr class="memdesc:ade376989c030c140645e36f57d903e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates an identified struct with the given name in the provided context.  <a href="#ade376989c030c140645e36f57d903e87">More...</a><br /></td></tr>
<tr class="separator:ade376989c030c140645e36f57d903e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647f0039f9a4be6ead1d67194957cf7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a647f0039f9a4be6ead1d67194957cf7f">getIdentifiedChecked</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef name)</td></tr>
<tr class="separator:a647f0039f9a4be6ead1d67194957cf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad330b0f482e263f6ea876bf842c7b19f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ad330b0f482e263f6ea876bf842c7b19f">getNewIdentified</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef name, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; elements, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e8cd2124e2023a22223b8e6ce916654">isPacked</a>=false)</td></tr>
<tr class="memdesc:ad330b0f482e263f6ea876bf842c7b19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a new identified struct with the given body.  <a href="#ad330b0f482e263f6ea876bf842c7b19f">More...</a><br /></td></tr>
<tr class="separator:ad330b0f482e263f6ea876bf842c7b19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09f5756ecb8ce98a22863f3d834eefb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ad09f5756ecb8ce98a22863f3d834eefb">getLiteral</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e8cd2124e2023a22223b8e6ce916654">isPacked</a>=false)</td></tr>
<tr class="memdesc:ad09f5756ecb8ce98a22863f3d834eefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates a literal struct with the given body in the provided context.  <a href="#ad09f5756ecb8ce98a22863f3d834eefb">More...</a><br /></td></tr>
<tr class="separator:ad09f5756ecb8ce98a22863f3d834eefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013542408dda4b210433a8d32652bd98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a013542408dda4b210433a8d32652bd98">getLiteralChecked</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e8cd2124e2023a22223b8e6ce916654">isPacked</a>=false)</td></tr>
<tr class="separator:a013542408dda4b210433a8d32652bd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f1303d669c80754602d0ac1b9f3eac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ae3f1303d669c80754602d0ac1b9f3eac">getOpaque</a> (StringRef name, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae3f1303d669c80754602d0ac1b9f3eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates an intentionally-opaque identified struct.  <a href="#ae3f1303d669c80754602d0ac1b9f3eac">More...</a><br /></td></tr>
<tr class="separator:ae3f1303d669c80754602d0ac1b9f3eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd474b714116b30d96f9f5aebfa1d1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a4cd474b714116b30d96f9f5aebfa1d1b">getOpaqueChecked</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef name)</td></tr>
<tr class="separator:a4cd474b714116b30d96f9f5aebfa1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee98e4671cf42f9dc4ac8c230eb48d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a97ee98e4671cf42f9dc4ac8c230eb48d">verify</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, StringRef, bool)</td></tr>
<tr class="memdesc:a97ee98e4671cf42f9dc4ac8c230eb48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the type about to be constructed is well-formed.  <a href="#a97ee98e4671cf42f9dc4ac8c230eb48d">More...</a><br /></td></tr>
<tr class="separator:a97ee98e4671cf42f9dc4ac8c230eb48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e13649aa667b7bfae00aa16d6b79165"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a5e13649aa667b7bfae00aa16d6b79165">verify</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, bool)</td></tr>
<tr class="separator:a5e13649aa667b7bfae00aa16d6b79165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a1d588973ede0325016eb3f0230bff575">getTypeID</a> ()</td></tr>
<tr class="memdesc:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a1d588973ede0325016eb3f0230bff575">More...</a><br /></td></tr>
<tr class="separator:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a15bd0dcee2aea120f3cb2dae707e4d1f">classof</a> (T val)</td></tr>
<tr class="memdesc:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an implementation of 'classof' that compares the type id of the provided value with that of the concrete type.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a15bd0dcee2aea120f3cb2dae707e4d1f">More...</a><br /></td></tr>
<tr class="separator:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">detail::InterfaceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#ac9aae36667a28d6ca83a01ea10e9ea4c">getInterfaceMap</a> ()</td></tr>
<tr class="memdesc:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interface map for the interfaces registered to this storage user.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#ac9aae36667a28d6ca83a01ea10e9ea4c">More...</a><br /></td></tr>
<tr class="separator:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab5c619d5b65f9baf0c1e4d72805ec1 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a4519fd4f662bcb859f239cd6d99003ed">HasTraitFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a3ab5c619d5b65f9baf0c1e4d72805ec1">getHasTraitFn</a> ()</td></tr>
<tr class="memdesc:a3ab5c619d5b65f9baf0c1e4d72805ec1 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function that returns true if the given Trait ID matches the IDs of any of the traits defined by the storage user.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a3ab5c619d5b65f9baf0c1e4d72805ec1">More...</a><br /></td></tr>
<tr class="separator:a3ab5c619d5b65f9baf0c1e4d72805ec1 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f808944a0a00f5917e30b3642e3596a inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... IfaceModels&gt; </td></tr>
<tr class="memitem:a0f808944a0a00f5917e30b3642e3596a inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a0f808944a0a00f5917e30b3642e3596a">attachInterface</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:a0f808944a0a00f5917e30b3642e3596a inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the given models as implementations of the corresponding interfaces for the concrete storage user class.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a0f808944a0a00f5917e30b3642e3596a">More...</a><br /></td></tr>
<tr class="separator:a0f808944a0a00f5917e30b3642e3596a inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da59a295ce21e18919de2ad6a6bb2b inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a73da59a295ce21e18919de2ad6a6bb2b inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, Args... args)</td></tr>
<tr class="memdesc:a73da59a295ce21e18919de2ad6a6bb2b inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a new ConcreteT instance within the ctx.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b">More...</a><br /></td></tr>
<tr class="separator:a73da59a295ce21e18919de2ad6a6bb2b inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a323337e7f742be1c6a3ca921fb6244 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4a323337e7f742be1c6a3ca921fb6244 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a4a323337e7f742be1c6a3ca921fb6244">getChecked</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc, Args... args)</td></tr>
<tr class="memdesc:a4a323337e7f742be1c6a3ca921fb6244 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a new ConcreteT instance within the ctx, defined at the given, potentially unknown, location.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a4a323337e7f742be1c6a3ca921fb6244">More...</a><br /></td></tr>
<tr class="separator:a4a323337e7f742be1c6a3ca921fb6244 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415057f5c086722876d4f281acf61a92 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a415057f5c086722876d4f281acf61a92 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a415057f5c086722876d4f281acf61a92">getChecked</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; emitErrorFn, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, Args... args)</td></tr>
<tr class="memdesc:a415057f5c086722876d4f281acf61a92 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a new ConcreteT instance within the ctx.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a415057f5c086722876d4f281acf61a92">More...</a><br /></td></tr>
<tr class="separator:a415057f5c086722876d4f281acf61a92 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222b677e66912791b2e86da3f5cdfd91 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a222b677e66912791b2e86da3f5cdfd91">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *ptr)</td></tr>
<tr class="memdesc:a222b677e66912791b2e86da3f5cdfd91 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of the concrete type from a void pointer.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a222b677e66912791b2e86da3f5cdfd91">More...</a><br /></td></tr>
<tr class="separator:a222b677e66912791b2e86da3f5cdfd91 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a2c65c0623b8acc13869cfed3cd0193d8">Base</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a>&lt; ConcreteT, <a class="el" href="classBaseT.html">BaseT</a>, StorageT, UniquerT, Traits... &gt;</td></tr>
<tr class="memdesc:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility declarations for the concrete attribute class.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a2c65c0623b8acc13869cfed3cd0193d8">More...</a><br /></td></tr>
<tr class="separator:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172110ae9298fcf582ab2deccdc4039 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a9172110ae9298fcf582ab2deccdc4039">ImplType</a> = StorageT</td></tr>
<tr class="separator:a9172110ae9298fcf582ab2deccdc4039 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4519fd4f662bcb859f239cd6d99003ed inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a4519fd4f662bcb859f239cd6d99003ed">HasTraitFn</a> = bool(*)(<a class="el" href="classmlir_1_1TypeID.html">TypeID</a>)</td></tr>
<tr class="separator:a4519fd4f662bcb859f239cd6d99003ed inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a196e59db0f0b3e43082946fed226f13f">mutate</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutate the current storage instance.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a196e59db0f0b3e43082946fed226f13f">More...</a><br /></td></tr>
<tr class="separator:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a9172110ae9298fcf582ab2deccdc4039">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a8a88fd7c4a76677a3129e3a1be97a0cd">getImpl</a> () const</td></tr>
<tr class="memdesc:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for easy access to the storage instance.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a8a88fd7c4a76677a3129e3a1be97a0cd">More...</a><br /></td></tr>
<tr class="separator:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a87a1db5bc003c71fe95c8154b9e4d530 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a87a1db5bc003c71fe95c8154b9e4d530 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a87a1db5bc003c71fe95c8154b9e4d530">verify</a> (Args... args)</td></tr>
<tr class="memdesc:a87a1db5bc003c71fe95c8154b9e4d530 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation that just returns success.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a87a1db5bc003c71fe95c8154b9e4d530">More...</a><br /></td></tr>
<tr class="separator:a87a1db5bc003c71fe95c8154b9e4d530 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type representing a collection of different-typed elements manipulated together. </p>
<p>Structured can optionally be packed, meaning that their elements immediately follow each other in memory without accounting for potential alignment.</p>
<p>Structure types can be identified (named) or literal. Literal structures are uniquely represented by the list of types they contain and packedness. Literal structure types are immutable after construction.</p>
<p>Identified structures are uniquely represented by their name, a string. They have a mutable component, consisting of the list of types they contain, the packedness and the opacity bits. Identified structs can be created without providing the lists of element types, making them suitable to represent recursive, i.e. self-referring, structures. Identified structs without body are considered opaque. For such structs, one can set the body. Identified structs can be created as intentionally-opaque, implying that the caller does not intend to ever set the body (e.g. forward-declarations of structs from another module) and wants to disallow further modification of the body. For intentionally-opaque structs or non-opaque structs with the body, one is not allowed to set another body (however, one can set exactly the same body).</p>
<p>Note that the packedness of the struct takes place in uniquing of literal structs, but does not in uniquing of identified structs. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8h_source.html#l00265">265</a> of file <a class="el" href="LLVMTypes_8h_source.html">LLVMTypes.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab154068bacafd1d62dfc71a3cc0a4fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab154068bacafd1d62dfc71a3cc0a4fb1">&#9670;&nbsp;</a></span>areCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::areCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00539">539</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8cpp_source.html#l00534">extractStructSpecValue()</a>.</p>

</div>
</div>
<a id="ac4436c8f50f4cecaf70f02a7bce6dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4436c8f50f4cecaf70f02a7bce6dbf8">&#9670;&nbsp;</a></span>getABIAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMStructType::getABIAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00521">521</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8cpp_source.html#l00496">calculateStructAlignment()</a>.</p>

</div>
</div>
<a id="a661cf6c68f45f273b9366f4015e1bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661cf6c68f45f273b9366f4015e1bd17">&#9670;&nbsp;</a></span>getBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; LLVMStructType::getBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of element types contained in a non-opaque struct. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00430">430</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00496">calculateStructAlignment()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00406">recordStructIndices()</a>, and <a class="el" href="TypeToLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="ade376989c030c140645e36f57d903e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade376989c030c140645e36f57d903e87">&#9670;&nbsp;</a></span>getIdentified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getIdentified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates an identified struct with the given name in the provided context. </p>
<p>Note that unlike llvm::StructType::create, this function will <em>NOT</em> rename a struct in case a struct with the same name already exists in the context. Instead, it will just return the existing struct, similarly to the rest of MLIR type ::get methods. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00365">365</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00376">getNewIdentified()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, and <a class="el" href="TypeFromLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a647f0039f9a4be6ead1d67194957cf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647f0039f9a4be6ead1d67194957cf7f">&#9670;&nbsp;</a></span>getIdentifiedChecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getIdentifiedChecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00370">370</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00149">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="ad09f5756ecb8ce98a22863f3d834eefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09f5756ecb8ce98a22863f3d834eefb">&#9670;&nbsp;</a></span>getLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates a literal struct with the given body in the provided context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00393">393</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="WmmaOpsToNvvm_8cpp_source.html#l00362">mlir::convertMMAToLLVMType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00284">convertStructType()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00201">convertStructTypePacked()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00187">convertStructTypeWithOffset()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00323">mlir::LLVMTypeConverter::getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00172">mlir::LLVMTypeConverter::getPointerBitwidth()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00356">mlir::LLVMTypeConverter::getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00020">inferIntrinsicResultType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="LLVM_8cpp_source.html#l00039">mlirLLVMStructTypeLiteralGet()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00457">mlir::LLVMTypeConverter::packFunctionResults()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00460">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="TypeFromLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>, and <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00115">unpackOperandVector()</a>.</p>

</div>
</div>
<a id="a013542408dda4b210433a8d32652bd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013542408dda4b210433a8d32652bd98">&#9670;&nbsp;</a></span>getLiteralChecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getLiteralChecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00399">399</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00149">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a28307288eaac35d84bab71207c9f9afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28307288eaac35d84bab71207c9f9afa">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef LLVMStructType::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an identified struct. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00429">429</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00054">printStructType()</a>, and <a class="el" href="TypeToLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="ad330b0f482e263f6ea876bf842c7b19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad330b0f482e263f6ea876bf842c7b19f">&#9670;&nbsp;</a></span>getNewIdentified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getNewIdentified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a new identified struct with the given body. </p>
<p>The body <em>cannot</em> be changed later. If a struct with the given name already exists, renames the struct by appending a <code>.</code> followed by a number to the name. Renaming happens even if the existing struct has the same body. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00376">376</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00365">getIdentified()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00541">isDefinedByCallTo()</a>, and <a class="el" href="OpenACCToLLVM_8cpp_source.html#l00030">mlir::DataDescriptor::undef()</a>.</p>

</div>
</div>
<a id="ae3f1303d669c80754602d0ac1b9f3eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f1303d669c80754602d0ac1b9f3eac">&#9670;&nbsp;</a></span>getOpaque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getOpaque </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates an intentionally-opaque identified struct. </p>
<p>Such a struct cannot have its body set. To create an opaque struct with a mutable body, use <code>getIdentified</code>. Note that unlike llvm::StructType::create, this function will <em>NOT</em> rename a struct in case a struct with the same name already exists in the context. Instead, it will just return the existing struct, similarly to the rest of MLIR type ::get methods. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00405">405</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00137">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeFromLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a4cd474b714116b30d96f9f5aebfa1d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd474b714116b30d96f9f5aebfa1d1b">&#9670;&nbsp;</a></span>getOpaqueChecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getOpaqueChecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00410">410</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00149">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a1f7bbc9fb81c3bbcbe82a095a0e65895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7bbc9fb81c3bbcbe82a095a0e65895">&#9670;&nbsp;</a></span>getPreferredAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMStructType::getPreferredAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00528">528</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8cpp_source.html#l00496">calculateStructAlignment()</a>.</p>

</div>
</div>
<a id="a10a26c05683913b4ae69d9903f5b16a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a26c05683913b4ae69d9903f5b16a5">&#9670;&nbsp;</a></span>getTypeSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMStructType::getTypeSizeInBits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hooks for DataLayoutTypeInterface. </p>
<p>Should not be called directly. Obtain a <a class="el" href="classmlir_1_1DataLayout.html" title="The main mechanism for performing data layout queries. ">DataLayout</a> instance and query it instead. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00451">451</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00435">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00411">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00028">kBitsInByte</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00193">max()</a>.</p>

</div>
</div>
<a id="af7c1d3fa762081487aa622f6f40cea78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c1d3fa762081487aa622f6f40cea78">&#9670;&nbsp;</a></span>isIdentified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isIdentified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is identified. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00423">423</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00054">printStructType()</a>, and <a class="el" href="TypeToLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a78b583beb28f839f61169e419d3cd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b583beb28f839f61169e419d3cd32b">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is initialized. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00428">428</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

</div>
</div>
<a id="a96a0b1510ce9eed7c21b9a83652ce55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a0b1510ce9eed7c21b9a83652ce55e">&#9670;&nbsp;</a></span>isOpaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isOpaque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is opaque. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00424">424</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeToLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a5e8cd2124e2023a22223b8e6ce916654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8cd2124e2023a22223b8e6ce916654">&#9670;&nbsp;</a></span>isPacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isPacked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is packed. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00422">422</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquerSupport_8h_source.html#l00184">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00496">calculateStructAlignment()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00023">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, and <a class="el" href="TypeToLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a18b262fcce3d80816380b5a38b56f7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b262fcce3d80816380b5a38b56f7c3">&#9670;&nbsp;</a></span>isValidElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isValidElementType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given type can be contained in a structure type. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00360">360</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00415">setBody()</a>.</p>

</div>
</div>
<a id="a0a51d61dbd143bff47a1331359fdc18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a51d61dbd143bff47a1331359fdc18c">&#9670;&nbsp;</a></span>setBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> LLVMStructType::setBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the body of an identified struct. </p>
<p>Returns failure if the body could not be set, e.g. if the struct already has a body or if it was marked as intentionally opaque. This might happen in a multi-threaded context when a different thread modified the struct after it was created. Most callers are likely to assert this always succeeds, but it is possible to implement a local renaming scheme based on the result of this call. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00415">415</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8cpp_source.html#l00360">isValidElementType()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00173">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::mutate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeFromLLVM_8cpp_source.html#l00031">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a97ee98e4671cf42f9dc4ac8c230eb48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ee98e4671cf42f9dc4ac8c230eb48d">&#9670;&nbsp;</a></span>verify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> LLVMStructType::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies that the type about to be constructed is well-formed. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00435">435</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a5e13649aa667b7bfae00aa16d6b79165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e13649aa667b7bfae00aa16d6b79165">&#9670;&nbsp;</a></span>verify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> LLVMStructType::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00441">441</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00034">mlir::LLVM::LLVMArrayType::isValidElementType()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a5b80cf8ae686d0b4d7414f3a3147a613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b80cf8ae686d0b4d7414f3a3147a613">&#9670;&nbsp;</a></span>verifyEntries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> LLVMStructType::verifyEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00562">562</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00534">extractStructSpecValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/LLVMIR/<a class="el" href="LLVMTypes_8h_source.html">LLVMTypes.h</a></li>
<li>lib/Dialect/LLVMIR/IR/<a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:33:05 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
