<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Target/LLVMIR/ModuleTranslation.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_794e483eb1cc7921d35fd149d9cc325b.html">Target</a></li><li class="navelem"><a class="el" href="dir_12a96bdcc885ecacc799866a8efa56d5.html">LLVMIR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ModuleTranslation.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ModuleTranslation_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- ModuleTranslation.cpp - MLIR to LLVM conversion --------------------===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// This file implements the translation between an MLIR LLVM dialect module and</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// the corresponding LLVMIR module. It only handles core LLVM IR operations.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ModuleTranslation_8h.html">mlir/Target/LLVMIR/ModuleTranslation.h</a>&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DebugTranslation_8h.html">DebugTranslation.h</a>&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DLTI_8h.html">mlir/Dialect/DLTI/DLTI.h</a>&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LLVMDialect_8h.html">mlir/Dialect/LLVMIR/LLVMDialect.h</a>&quot;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LegalizeForExport_8h.html">mlir/Dialect/LLVMIR/Transforms/LegalizeForExport.h</a>&quot;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="OpenMPDialect_8h.html">mlir/Dialect/OpenMP/OpenMPDialect.h</a>&quot;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Attributes_8h.html">mlir/IR/Attributes.h</a>&quot;</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="BuiltinOps_8h.html">mlir/IR/BuiltinOps.h</a>&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IR_2BuiltinTypes_8h.html">mlir/IR/BuiltinTypes.h</a>&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="RegionGraphTraits_8h.html">mlir/IR/RegionGraphTraits.h</a>&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Support_2LLVM_8h.html">mlir/Support/LLVM.h</a>&quot;</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LLVMTranslationInterface_8h.html">mlir/Target/LLVMIR/LLVMTranslationInterface.h</a>&quot;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TypeToLLVM_8h.html">mlir/Target/LLVMIR/TypeToLLVM.h</a>&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;llvm/ADT/TypeSwitch.h&quot;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &quot;llvm/ADT/PostOrderIterator.h&quot;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &quot;llvm/ADT/SetVector.h&quot;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;llvm/Frontend/OpenMP/OMPIRBuilder.h&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/BasicBlock.h&quot;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/CFG.h&quot;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/Constants.h&quot;</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/DerivedTypes.h&quot;</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/IRBuilder.h&quot;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/InlineAsm.h&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/IntrinsicsNVPTX.h&quot;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/LLVMContext.h&quot;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/MDBuilder.h&quot;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/Module.h&quot;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#include &quot;llvm/IR/Verifier.h&quot;</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &quot;llvm/Transforms/Utils/BasicBlockUtils.h&quot;</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#include &quot;llvm/Transforms/Utils/Cloning.h&quot;</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#include &quot;llvm/Transforms/Utils/ModuleUtils.h&quot;</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacemlir.html">mlir</a>;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacemlir_1_1LLVM.html">mlir::LLVM</a>;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacemlir_1_1LLVM_1_1detail.html">mlir::LLVM::detail</a>;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="preprocessor">#include &quot;mlir/Dialect/LLVMIR/LLVMConversionEnumsToLLVM.inc&quot;</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">/// Translates the given data layout spec attribute to the LLVM IR data layout.</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">/// Only integer, float and endianness entries are currently supported.</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment"></span><a class="code" href="classmlir_1_1FailureOr.html">FailureOr&lt;llvm::DataLayout&gt;</a></div><div class="line"><a name="l00057"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a33a80e952460dbd2e019e80df22b48bc">   57</a></span>&#160;<a class="code" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a>(DataLayoutSpecInterface attribute,</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                    <span class="keyword">const</span> <a class="code" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout,</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                    <a class="code" href="classllvm_1_1Optional.html">Optional&lt;Location&gt;</a> loc = llvm::None) {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">if</span> (!loc)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    loc = UnknownLoc::get(attribute.getContext());</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="comment">// Translate the endianness attribute.</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  std::string llvmDataLayout;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  llvm::raw_string_ostream layoutStream(llvmDataLayout);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="keywordflow">for</span> (DataLayoutEntryInterface entry : attribute.getEntries()) {</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">auto</span> key = entry.getKey().dyn_cast&lt;StringAttr&gt;();</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">if</span> (!key)</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">if</span> (key.getValue() == DLTIDialect::kDataLayoutEndiannessKey) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      <span class="keyword">auto</span> <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> = entry.getValue().cast&lt;StringAttr&gt;();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;      <span class="keywordtype">bool</span> isLittleEndian =</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;          <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>.getValue() == DLTIDialect::kDataLayoutEndiannessLittle;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      layoutStream &lt;&lt; (isLittleEndian ? <span class="stringliteral">&quot;e&quot;</span> : <span class="stringliteral">&quot;E&quot;</span>);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      layoutStream.flush();</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(*loc) &lt;&lt; <span class="stringliteral">&quot;unsupported data layout key &quot;</span> &lt;&lt; key;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// Go through the list of entries to check which types are explicitly</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// specified in entries. Don&#39;t use the entries directly though but query the</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// data from the layout.</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keywordflow">for</span> (DataLayoutEntryInterface entry : attribute.getEntries()) {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">auto</span> type = entry.getKey().dyn_cast&lt;<a class="code" href="classmlir_1_1Type.html">Type</a>&gt;();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">if</span> (!type)</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="comment">// Data layout for the index type is irrelevant at this point.</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">if</span> (type.isa&lt;IndexType&gt;())</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <a class="code" href="classmlir_1_1FailureOr.html">FailureOr&lt;std::string&gt;</a> prefix =</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <a class="code" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch&lt;Type, FailureOr&lt;std::string&gt;</a>&gt;(type)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            .Case&lt;IntegerType&gt;(</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                [loc](IntegerType integerType) -&gt; <a class="code" href="classmlir_1_1FailureOr.html">FailureOr&lt;std::string&gt;</a> {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                  <span class="keywordflow">if</span> (integerType.getSignedness() == IntegerType::Signless)</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                    <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;i&quot;</span>);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                  <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(*loc)</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot;unsupported data layout for non-signless integer &quot;</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                      &lt;&lt; integerType;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                })</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            .Case&lt;Float16Type, Float32Type, Float64Type, Float80Type,</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                  Float128Type&gt;([](<a class="code" href="classmlir_1_1Type.html">Type</a>) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;f&quot;</span>); })</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            .Default([loc](<a class="code" href="classmlir_1_1Type.html">Type</a> type) -&gt; <a class="code" href="classmlir_1_1FailureOr.html">FailureOr&lt;std::string&gt;</a> {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;              <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(*loc) &lt;&lt; <span class="stringliteral">&quot;unsupported type in data layout: &quot;</span> &lt;&lt; type;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;              <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            });</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(prefix))</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordtype">unsigned</span> size = dataLayout.<a class="code" href="classmlir_1_1DataLayout.html#a525f9e65851b765eddc7efd767056f82">getTypeSizeInBits</a>(type);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordtype">unsigned</span> abi = dataLayout.<a class="code" href="classmlir_1_1DataLayout.html#a4d5abbdc0d7af8cb3db2081eb6184fda">getTypeABIAlignment</a>(type) * 8u;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordtype">unsigned</span> preferred = dataLayout.<a class="code" href="classmlir_1_1DataLayout.html#a54192cee619ca92ee41a46972a96580f">getTypePreferredAlignment</a>(type) * 8u;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    layoutStream &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; *prefix &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; abi;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">if</span> (abi != preferred)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      layoutStream &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; preferred;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  }</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  layoutStream.flush();</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  StringRef layoutSpec(llvmDataLayout);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="keywordflow">if</span> (layoutSpec.startswith(<span class="stringliteral">&quot;-&quot;</span>))</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    layoutSpec = layoutSpec.drop_front();</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keywordflow">return</span> llvm::DataLayout(layoutSpec);</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;}</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">/// Builds a constant of a sequential LLVM type `type`, potentially containing</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">/// other sequential types recursively, from the individual constant values</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">/// provided in `constants`. `shape` contains the number of elements in nested</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">/// sequential types. Reports errors at `loc` and returns nullptr on error.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *</div><div class="line"><a name="l00132"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">  132</a></span>&#160;<a class="code" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a>(<a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Constant *&gt;</a> &amp;constants,</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                        <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> shape, llvm::Type *type,</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                        <a class="code" href="classmlir_1_1Location.html">Location</a> loc) {</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="keywordflow">if</span> (shape.empty()) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *result = constants.front();</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    constants = constants.drop_front();</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  llvm::Type *elementType;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> *arrayTy = dyn_cast&lt;llvm::ArrayType&gt;(type)) {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    elementType = arrayTy-&gt;getElementType();</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> *vectorTy = dyn_cast&lt;llvm::VectorType&gt;(type)) {</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    elementType = vectorTy-&gt;getElementType();</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc) &lt;&lt; <span class="stringliteral">&quot;expected sequential LLVM types wrapping a scalar&quot;</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Constant *, 8&gt;</a> nested;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  nested.reserve(shape.front());</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="keywordflow">for</span> (int64_t i = 0; i &lt; shape.front(); ++i) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    nested.push_back(<a class="code" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a>(constants, shape.drop_front(),</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                             elementType, loc));</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">if</span> (!nested.back())</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="keywordflow">if</span> (shape.size() == 1 &amp;&amp; type-&gt;isVectorTy())</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantVector::get(nested);</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  <span class="keywordflow">return</span> llvm::ConstantArray::get(</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      llvm::ArrayType::get(elementType, shape.front()), nested);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">/// Returns the first non-sequential type nested in sequential types.</span></div><div class="line"><a name="l00167"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#aa4111e6ff5cf4f1d365791ce9c8e0317">  167</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> llvm::Type *<a class="code" href="ModuleTranslation_8cpp.html#aa4111e6ff5cf4f1d365791ce9c8e0317">getInnermostElementType</a>(llvm::Type *type) {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="keywordflow">do</span> {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> *arrayTy = dyn_cast&lt;llvm::ArrayType&gt;(type)) {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;      type = arrayTy-&gt;getElementType();</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> *vectorTy = dyn_cast&lt;llvm::VectorType&gt;(type)) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      type = vectorTy-&gt;getElementType();</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <span class="keywordflow">return</span> type;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  } <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">/// Convert a dense elements attribute to an LLVM IR constant using its raw data</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">/// storage if possible. This supports elements attributes of tensor or vector</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">/// type and avoids constructing separate objects for individual values of the</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">/// innermost dimension. Constants for other dimensions are still constructed</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">/// recursively. Returns null if constructing from raw data is not supported for</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">/// this type, e.g., element type is not a power-of-two-sized primitive. Reports</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">/// other errors at `loc`.</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *</div><div class="line"><a name="l00187"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a22a0bdbdbbc9cfc1248bbaf6fc7d3037">  187</a></span>&#160;<a class="code" href="ModuleTranslation_8cpp.html#a22a0bdbdbbc9cfc1248bbaf6fc7d3037">convertDenseElementsAttr</a>(<a class="code" href="classmlir_1_1Location.html">Location</a> loc, <a class="code" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> denseElementsAttr,</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                         llvm::Type *llvmType,</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                         <span class="keyword">const</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">ModuleTranslation</a> &amp;moduleTranslation) {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="keywordflow">if</span> (!denseElementsAttr)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  llvm::Type *innermostLLVMType = <a class="code" href="ModuleTranslation_8cpp.html#aa4111e6ff5cf4f1d365791ce9c8e0317">getInnermostElementType</a>(llvmType);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">if</span> (!llvm::ConstantDataSequential::isElementTypeCompatible(innermostLLVMType))</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  ShapedType type = denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">getType</a>();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keywordflow">if</span> (type.getNumElements() == 0)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="comment">// Compute the shape of all dimensions but the innermost. Note that the</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="comment">// innermost dimension may be that of the vector element type.</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="keywordtype">bool</span> hasVectorElementType = type.getElementType().isa&lt;VectorType&gt;();</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="keywordtype">unsigned</span> numAggregates =</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a45eabfa2aa1c4da62c050b8c6f923553">getNumElements</a>() /</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      (hasVectorElementType ? 1</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                            : denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">getType</a>().getShape().back());</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> outerShape = type.getShape();</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="keywordflow">if</span> (!hasVectorElementType)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    outerShape = outerShape.drop_back();</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="comment">// Handle the case of vector splat, LLVM has special support for it.</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="keywordflow">if</span> (denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">isSplat</a>() &amp;&amp;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      (type.isa&lt;VectorType&gt;() || hasVectorElementType)) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *splatValue = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">LLVM::detail::getLLVMConstant</a>(</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        innermostLLVMType, denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a49be83cff03233289860200183e528f7">getSplatValue</a>&lt;<a class="code" href="classmlir_1_1Attribute.html">Attribute</a>&gt;(), loc,</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        moduleTranslation, <span class="comment">/*isTopLevel=*/</span><span class="keyword">false</span>);</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *splatVector =</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        llvm::ConstantDataVector::getSplat(0, splatValue);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Constant *&gt;</a> constants(numAggregates, splatVector);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Constant *&gt;</a> constantsRef = constants;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a>(constantsRef, outerShape, llvmType, loc);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="keywordflow">if</span> (denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">isSplat</a>())</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="comment">// In case of non-splat, create a constructor for the innermost constant from</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// a piece of raw data.</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  std::function&lt;llvm::Constant *(StringRef)&gt; buildCstData;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="keywordflow">if</span> (type.isa&lt;<a class="code" href="classmlir_1_1TensorType.html">TensorType</a>&gt;()) {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keyword">auto</span> vectorElementType = type.getElementType().dyn_cast&lt;VectorType&gt;();</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">if</span> (vectorElementType &amp;&amp; vectorElementType.getRank() == 1) {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      buildCstData = [&amp;](StringRef data) {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">return</span> llvm::ConstantDataVector::getRaw(</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            data, vectorElementType.getShape().back(), innermostLLVMType);</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      };</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!vectorElementType) {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      buildCstData = [&amp;](StringRef data) {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">return</span> llvm::ConstantDataArray::getRaw(data, type.getShape().back(),</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                                               innermostLLVMType);</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;      };</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    }</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type.isa&lt;VectorType&gt;()) {</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    buildCstData = [&amp;](StringRef data) {</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <span class="keywordflow">return</span> llvm::ConstantDataVector::getRaw(data, type.getShape().back(),</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                                              innermostLLVMType);</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    };</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="keywordflow">if</span> (!buildCstData)</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// Create innermost constants and defer to the default constant creation</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="comment">// mechanism for other dimensions.</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Constant *&gt;</a> constants;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="keywordtype">unsigned</span> aggregateSize = denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">getType</a>().getShape().back() *</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                           (innermostLLVMType-&gt;getScalarSizeInBits() / 8);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  constants.reserve(numAggregates);</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numAggregates; ++i) {</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    StringRef data(denseElementsAttr.<a class="code" href="classmlir_1_1DenseElementsAttr.html#a6814d418f6b952cd05a1fec9ca35ca0b">getRawData</a>().data() + i * aggregateSize,</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                   aggregateSize);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    constants.push_back(buildCstData(data));</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  }</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Constant *&gt;</a> constantsRef = constants;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a>(constantsRef, outerShape, llvmType, loc);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">/// Create an LLVM IR constant of `llvmType` from the MLIR attribute `attr`.</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">/// This currently supports integer, floating point, splat and dense element</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">/// attributes and combinations thereof. Also, an array attribute with two</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">/// elements is supported to represent a complex constant.  In case of error,</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">/// report it to `loc` and return nullptr.</span></div><div class="line"><a name="l00273"></a><span class="lineno"><a class="line" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">  273</a></span>&#160;<span class="comment"></span><a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *<a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">mlir::LLVM::detail::getLLVMConstant</a>(</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    llvm::Type *llvmType, <a class="code" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="code" href="classmlir_1_1Location.html">Location</a> loc,</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keyword">const</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">ModuleTranslation</a> &amp;moduleTranslation, <span class="keywordtype">bool</span> isTopLevel) {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="keywordflow">if</span> (!attr)</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">return</span> llvm::UndefValue::get(llvmType);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> *structType = dyn_cast&lt;::llvm::StructType&gt;(llvmType)) {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">if</span> (!isTopLevel) {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc, <span class="stringliteral">&quot;nested struct types are not supported in constants&quot;</span>);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    }</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keyword">auto</span> arrayAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a711073f32e43429d5faaada8c387ff88">cast</a>&lt;ArrayAttr&gt;();</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    llvm::Type *elementType = structType-&gt;getElementType(0);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *real = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(elementType, arrayAttr[0], loc,</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                           moduleTranslation, <span class="keyword">false</span>);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">if</span> (!real)</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *imag = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(elementType, arrayAttr[1], loc,</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                                           moduleTranslation, <span class="keyword">false</span>);</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">if</span> (!imag)</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantStruct::get(structType, {real, imag});</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// For integer types, we allow a mismatch in sizes as the index type in</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="comment">// MLIR might have a different size than the index type in the LLVM module.</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> intAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;IntegerAttr&gt;())</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantInt::get(</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        llvmType,</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        intAttr.getValue().sextOrTrunc(llvmType-&gt;getIntegerBitWidth()));</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> floatAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;FloatAttr&gt;()) {</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">if</span> (llvmType !=</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        llvm::Type::getFloatingPointTy(llvmType-&gt;getContext(),</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                       floatAttr.getValue().getSemantics())) {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc, <span class="stringliteral">&quot;FloatAttr does not match expected type of the constant&quot;</span>);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantFP::get(llvmType, floatAttr.getValue());</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  }</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> funcAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;<a class="code" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a>&gt;())</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantExpr::getBitCast(</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#aba58c7951025308aaefccac54a0ae344">lookupFunction</a>(funcAttr.getValue()), llvmType);</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> splatAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;<a class="code" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a>&gt;()) {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    llvm::Type *elementType;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    uint64_t numElements;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordtype">bool</span> isScalable = <span class="keyword">false</span>;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> *arrayTy = dyn_cast&lt;llvm::ArrayType&gt;(llvmType)) {</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      elementType = arrayTy-&gt;getElementType();</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;      numElements = arrayTy-&gt;getNumElements();</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> *fVectorTy = dyn_cast&lt;llvm::FixedVectorType&gt;(llvmType)) {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      elementType = fVectorTy-&gt;getElementType();</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;      numElements = fVectorTy-&gt;getNumElements();</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> *sVectorTy = dyn_cast&lt;llvm::ScalableVectorType&gt;(llvmType)) {</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;      elementType = sVectorTy-&gt;getElementType();</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      numElements = sVectorTy-&gt;getMinNumElements();</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      isScalable = <span class="keyword">true</span>;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;      llvm_unreachable(<span class="stringliteral">&quot;unrecognized constant vector type&quot;</span>);</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    }</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="comment">// Splat value is a scalar. Extract it only if the element type is not</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="comment">// another sequence type. The recursion terminates because each step removes</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">// one outer sequential type.</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordtype">bool</span> elementTypeSequential =</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        isa&lt;llvm::ArrayType, llvm::VectorType&gt;(elementType);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *child = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        elementType,</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        elementTypeSequential ? splatAttr</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                              : splatAttr.getSplatValue&lt;<a class="code" href="classmlir_1_1Attribute.html">Attribute</a>&gt;(),</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        loc, moduleTranslation, <span class="keyword">false</span>);</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">if</span> (!child)</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keywordflow">if</span> (llvmType-&gt;isVectorTy())</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <span class="keywordflow">return</span> llvm::ConstantVector::getSplat(</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;          llvm::ElementCount::get(numElements, <span class="comment">/*Scalable=*/</span>isScalable), child);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">if</span> (llvmType-&gt;isArrayTy()) {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keyword">auto</span> *arrayType = llvm::ArrayType::get(elementType, numElements);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Constant *, 8&gt;</a> constants(numElements, child);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      <span class="keywordflow">return</span> llvm::ConstantArray::get(arrayType, constants);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  }</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="comment">// Try using raw elements data if possible.</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *result =</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;          <a class="code" href="ModuleTranslation_8cpp.html#a22a0bdbdbbc9cfc1248bbaf6fc7d3037">convertDenseElementsAttr</a>(loc, attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;<a class="code" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&gt;(),</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                   llvmType, moduleTranslation)) {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="comment">// Fall back to element-by-element construction otherwise.</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> elementsAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;ElementsAttr&gt;()) {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    assert(elementsAttr.getType().hasStaticShape());</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    assert(!elementsAttr.getType().getShape().empty() &amp;&amp;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;           <span class="stringliteral">&quot;unexpected empty elements attribute shape&quot;</span>);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Constant *, 8&gt;</a> constants;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    constants.reserve(elementsAttr.getNumElements());</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    llvm::Type *innermostType = <a class="code" href="ModuleTranslation_8cpp.html#aa4111e6ff5cf4f1d365791ce9c8e0317">getInnermostElementType</a>(llvmType);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : elementsAttr.getValues&lt;<a class="code" href="classmlir_1_1Attribute.html">Attribute</a>&gt;()) {</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      constants.push_back(</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;          <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(innermostType, n, loc, moduleTranslation, <span class="keyword">false</span>));</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="keywordflow">if</span> (!constants.back())</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    }</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Constant *&gt;</a> constantsRef = constants;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *result = <a class="code" href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a>(</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        constantsRef, elementsAttr.getType().getShape(), llvmType, loc);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    assert(constantsRef.empty() &amp;&amp; <span class="stringliteral">&quot;did not consume all elemental constants&quot;</span>);</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  }</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> stringAttr = attr.<a class="code" href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">dyn_cast</a>&lt;StringAttr&gt;()) {</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">return</span> llvm::ConstantDataArray::get(</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        moduleTranslation.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab4c38d7dad8c41373557f61ae08eb925">getLLVMContext</a>(),</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;char&gt;</a>{stringAttr.getValue().data(),</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                       stringAttr.getValue().size()});</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  }</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc, <span class="stringliteral">&quot;unsupported constant value&quot;</span>);</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;}</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;ModuleTranslation::ModuleTranslation(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *module,</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                                     std::unique_ptr&lt;llvm::Module&gt; llvmModule)</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    : mlirModule(module), llvmModule(std::move(llvmModule)),</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      debugTranslation(</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;          std::make_unique&lt;DebugTranslation&gt;(module, *this-&gt;llvmModule)),</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      typeTranslator(this-&gt;llvmModule-&gt;getContext()),</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      iface(module-&gt;<a class="code" href="classmlir_1_1Operation.html#a6148c9c026c28a65985dad975c0106ef">getContext</a>()) {</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  assert(<a class="code" href="namespacemlir_1_1LLVM.html#a847e84be7235275135237a48a9813be9">satisfiesLLVMModule</a>(mlirModule) &amp;&amp;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;         <span class="stringliteral">&quot;mlirModule should honor LLVM&#39;s module semantics.&quot;</span>);</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;}</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;ModuleTranslation::~ModuleTranslation() {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="keywordflow">if</span> (ompBuilder)</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    ompBuilder-&gt;finalize();</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;}</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">  406</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">ModuleTranslation::forgetMapping</a>(<a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region) {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Region *&gt;</a> toProcess;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  toProcess.push_back(&amp;region);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  <span class="keywordflow">while</span> (!toProcess.empty()) {</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <a class="code" href="classmlir_1_1Region.html">Region</a> *current = toProcess.pop_back_val();</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;block : *current) {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      blockMapping.erase(&amp;block);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Value.html">Value</a> arg : block.getArguments())</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        valueMapping.erase(arg);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op : block) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Value.html">Value</a> <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> : op.getResults())</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;          valueMapping.erase(<a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>);</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">if</span> (op.hasSuccessors())</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;          branchMapping.erase(&amp;op);</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">if</span> (isa&lt;LLVM::GlobalOp&gt;(op))</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;          globalsMapping.erase(&amp;op);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        accessGroupMetadataMapping.erase(&amp;op);</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        llvm::append_range(</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            toProcess,</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            llvm::map_range(op.getRegions(), [](<a class="code" href="classmlir_1_1Region.html">Region</a> &amp;r) { <span class="keywordflow">return</span> &amp;r; }));</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      }</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">/// Get the SSA value passed to the current block from the terminator operation</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment">/// of its predecessor.</span></div><div class="line"><a name="l00433"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a091473715bf4679f1f429f317067664c">  433</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classmlir_1_1Value.html">Value</a> <a class="code" href="ModuleTranslation_8cpp.html#a091473715bf4679f1f429f317067664c">getPHISourceValue</a>(<a class="code" href="classmlir_1_1Block.html">Block</a> *current, <a class="code" href="classmlir_1_1Block.html">Block</a> *pred,</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                               <span class="keywordtype">unsigned</span> numArguments, <span class="keywordtype">unsigned</span> index) {</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;terminator = *pred-&gt;<a class="code" href="classmlir_1_1Block.html#a7e0b0c445d4e1e011fef4a1e59bcd118">getTerminator</a>();</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="keywordflow">if</span> (isa&lt;LLVM::BrOp&gt;(terminator))</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordflow">return</span> terminator.<a class="code" href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">getOperand</a>(index);</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet&lt;Block *, 4&gt;</a> seenSuccessors;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = terminator.<a class="code" href="classmlir_1_1Operation.html#a35655ce5e44c6822ffdda86737dcbd8d">getNumSuccessors</a>(); i &lt; e; ++i) {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <a class="code" href="classmlir_1_1Block.html">Block</a> *successor = terminator.<a class="code" href="classmlir_1_1Operation.html#a32a340b8b2384ce2a2bb9e3e56890459">getSuccessor</a>(i);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keyword">auto</span> branch = cast&lt;BranchOpInterface&gt;(terminator);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <a class="code" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> successorOperands = branch.getSuccessorOperands(i);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    assert(</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        (!seenSuccessors.contains(successor) || successorOperands.empty()) &amp;&amp;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="stringliteral">&quot;successors with arguments in LLVM branches must be different blocks&quot;</span>);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    seenSuccessors.insert(successor);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;  }</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  <span class="comment">// For instructions that branch based on a condition value, we need to take</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="comment">// the operands for the branch that was taken.</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> condBranchOp = dyn_cast&lt;LLVM::CondBrOp&gt;(terminator)) {</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="comment">// For conditional branches, we take the operands from either the &quot;true&quot; or</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="comment">// the &quot;false&quot; branch.</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">return</span> condBranchOp.getSuccessor(0) == current</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;               ? condBranchOp.getTrueDestOperands()[index]</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;               : condBranchOp.getFalseDestOperands()[index];</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  }</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> switchOp = dyn_cast&lt;LLVM::SwitchOp&gt;(terminator)) {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="comment">// For switches, we take the operands from either the default case, or from</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="comment">// the case branch that was taken.</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">if</span> (switchOp.getDefaultDestination() == current)</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      <span class="keywordflow">return</span> switchOp.getDefaultOperands()[index];</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : <a class="code" href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">llvm::enumerate</a>(switchOp.getCaseDestinations()))</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;      <span class="keywordflow">if</span> (i.value() == current)</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="keywordflow">return</span> switchOp.getCaseOperands(i.index())[index];</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> invokeOp = dyn_cast&lt;LLVM::InvokeOp&gt;(terminator)) {</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordflow">return</span> invokeOp.getNormalDest() == current</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;               ? invokeOp.getNormalDestOperands()[index]</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;               : invokeOp.getUnwindDestOperands()[index];</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  llvm_unreachable(</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      <span class="stringliteral">&quot;only branch, switch or invoke operations can be terminators &quot;</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      <span class="stringliteral">&quot;of a block that has successors&quot;</span>);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;}</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">/// Connect the PHI nodes to the results of preceding blocks.</span></div><div class="line"><a name="l00484"></a><span class="lineno"><a class="line" href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">  484</a></span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">mlir::LLVM::detail::connectPHINodes</a>(<a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region,</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                                         <span class="keyword">const</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">ModuleTranslation</a> &amp;state) {</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  <span class="comment">// Skip the first block, it cannot be branched to and its arguments correspond</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  <span class="comment">// to the arguments of the LLVM function.</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = std::next(region.<a class="code" href="classmlir_1_1Region.html#a99e4974818075f520c020901166400e5">begin</a>()), eit = region.<a class="code" href="classmlir_1_1Region.html#a7f33d2ab93ce37e650b6a4d2aded0883">end</a>(); it != eit;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;       ++it) {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <a class="code" href="classmlir_1_1Block.html">Block</a> *bb = &amp;*it;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    llvm::BasicBlock *llvmBB = state.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a51bb831df4cf8bf4b4bf13a1be791701">lookupBlock</a>(bb);</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="keyword">auto</span> phis = llvmBB-&gt;phis();</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keyword">auto</span> numArguments = bb-&gt;<a class="code" href="classmlir_1_1Block.html#a282b6551a40ded04aea6c3c0359230af">getNumArguments</a>();</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    assert(numArguments == std::distance(phis.begin(), phis.end()));</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;numberedPhiNode : <a class="code" href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">llvm::enumerate</a>(phis)) {</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;      <span class="keyword">auto</span> &amp;phiNode = numberedPhiNode.value();</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      <span class="keywordtype">unsigned</span> index = numberedPhiNode.index();</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> *pred : bb-&gt;<a class="code" href="classmlir_1_1Block.html#a87194ef9e9c47b3f831bb5207d41139e">getPredecessors</a>()) {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <span class="comment">// Find the LLVM IR block that contains the converted terminator</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="comment">// instruction and use it in the PHI node. Note that this block is not</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="comment">// necessarily the same as state.lookupBlock(pred), some operations</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="comment">// (in particular, OpenMP operations using OpenMPIRBuilder) may have</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="comment">// split the blocks.</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        llvm::Instruction *terminator =</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            state.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a36a0cff8c8e12f67fc2ea56086b5a8a9">lookupBranch</a>(pred-&gt;getTerminator());</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        assert(terminator &amp;&amp; <span class="stringliteral">&quot;missing the mapping for a terminator&quot;</span>);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        phiNode.addIncoming(</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            state.<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">lookupValue</a>(<a class="code" href="ModuleTranslation_8cpp.html#a091473715bf4679f1f429f317067664c">getPHISourceValue</a>(bb, pred, numArguments, index)),</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            terminator-&gt;getParent());</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  }</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;}</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">/// Sort function blocks topologically.</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;Block *&gt;</a></div><div class="line"><a name="l00517"></a><span class="lineno"><a class="line" href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">  517</a></span>&#160;<a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">mlir::LLVM::detail::getTopologicallySortedBlocks</a>(<a class="code" href="classmlir_1_1Region.html">Region</a> &amp;region) {</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  <span class="comment">// For each block that has not been visited yet (i.e. that has no</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  <span class="comment">// predecessors), add it to the list as well as its successors.</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;Block *&gt;</a> blocks;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;b : region) {</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="keywordflow">if</span> (blocks.count(&amp;b) == 0) {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      llvm::ReversePostOrderTraversal&lt;Block *&gt; traversal(&amp;b);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;      blocks.insert(traversal.begin(), traversal.end());</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    }</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  }</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;  assert(blocks.size() == region.getBlocks().size() &amp;&amp;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;         <span class="stringliteral">&quot;some blocks are not sorted&quot;</span>);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  <span class="keywordflow">return</span> blocks;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;}</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno"><a class="line" href="namespacemlir_1_1LLVM_1_1detail.html#aeb828d7be807860f497206190a9de766">  533</a></span>&#160;llvm::Value *<a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#aeb828d7be807860f497206190a9de766">mlir::LLVM::detail::createIntrinsicCall</a>(</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    llvm::IRBuilderBase &amp;builder, llvm::Intrinsic::ID intrinsic,</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Value *&gt;</a> args, <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;llvm::Type *&gt;</a> tys) {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  llvm::Module *module = builder.GetInsertBlock()-&gt;getModule();</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  llvm::Function *fn = llvm::Intrinsic::getDeclaration(module, intrinsic, tys);</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keywordflow">return</span> builder.CreateCall(fn, args);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;}</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">/// Given a single MLIR operation, create the corresponding LLVM IR operation</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">/// using the `builder`.</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment"></span><a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;ModuleTranslation::convertOperation(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op,</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                                    llvm::IRBuilderBase &amp;builder) {</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  <span class="keyword">const</span> <a class="code" href="classmlir_1_1LLVMTranslationDialectInterface.html">LLVMTranslationDialectInterface</a> *opIface = iface.getInterfaceFor(&amp;op);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="keywordflow">if</span> (!opIface)</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordflow">return</span> op.<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(<span class="stringliteral">&quot;cannot be converted to LLVM IR: missing &quot;</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                        <span class="stringliteral">&quot;`LLVMTranslationDialectInterface` registration for &quot;</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                        <span class="stringliteral">&quot;dialect for op: &quot;</span>)</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;           &lt;&lt; op.<a class="code" href="classmlir_1_1Operation.html#ab2e11ba83ff765eb7595554f97aaaa75">getName</a>();</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(opIface-&gt;<a class="code" href="classmlir_1_1LLVMTranslationDialectInterface.html#abd0cfc66f4647b5b8f6dc7fd326516a1">convertOperation</a>(&amp;op, builder, *<span class="keyword">this</span>)))</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keywordflow">return</span> op.<a class="code" href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">emitError</a>(<span class="stringliteral">&quot;LLVM Translation failed for operation: &quot;</span>)</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;           &lt;&lt; op.<a class="code" href="classmlir_1_1Operation.html#ab2e11ba83ff765eb7595554f97aaaa75">getName</a>();</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="keywordflow">return</span> convertDialectAttributes(&amp;op);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;}</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">/// Convert block to LLVM IR.  Unless `ignoreArguments` is set, emit PHI nodes</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">/// to define values corresponding to the MLIR block arguments.  These nodes</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">/// are not connected to the source basic blocks, which may not exist yet.  Uses</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment">/// `builder` to construct the LLVM IR. Expects the LLVM IR basic block to have</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">/// been created for `bb` and included in the block mapping.  Inserts new</span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="comment">/// instructions at the end of the block and leaves `builder` in a state</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment">/// suitable for further insertion into the end of the block.</span></div><div class="line"><a name="l00567"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">  567</a></span>&#160;<span class="comment"></span><a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">ModuleTranslation::convertBlock</a>(<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;bb, <span class="keywordtype">bool</span> ignoreArguments,</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                                              llvm::IRBuilderBase &amp;builder) {</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  builder.SetInsertPoint(lookupBlock(&amp;bb));</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <span class="keyword">auto</span> *subprogram = builder.GetInsertBlock()-&gt;getParent()-&gt;getSubprogram();</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="comment">// Before traversing operations, make block arguments available through</span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  <span class="comment">// value remapping and PHI nodes, but do not add incoming edges for the PHI</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <span class="comment">// nodes just yet: those values may be defined by this or following blocks.</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  <span class="comment">// This step is omitted if &quot;ignoreArguments&quot; is set.  The arguments of the</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  <span class="comment">// first block have been already made available through the remapping of</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;  <span class="comment">// LLVM function arguments.</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  <span class="keywordflow">if</span> (!ignoreArguments) {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    <span class="keyword">auto</span> predecessors = bb.<a class="code" href="classmlir_1_1Block.html#a87194ef9e9c47b3f831bb5207d41139e">getPredecessors</a>();</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    <span class="keywordtype">unsigned</span> numPredecessors =</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        std::distance(predecessors.begin(), predecessors.end());</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> arg : bb.<a class="code" href="classmlir_1_1Block.html#aa0bf059f5c09c7cf227bb6df2e49d4ad">getArguments</a>()) {</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;      <span class="keyword">auto</span> wrappedType = arg.getType();</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;      <span class="keywordflow">if</span> (!<a class="code" href="namespacemlir_1_1LLVM.html#ab597122c73cb66c5d56f486ef85d9c6e">isCompatibleType</a>(wrappedType))</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(bb.<a class="code" href="classmlir_1_1Block.html#aa904889345bf1bf23a54076768158c94">front</a>().<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>(),</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                         <span class="stringliteral">&quot;block argument does not have an LLVM type&quot;</span>);</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;      llvm::Type *type = convertType(wrappedType);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;      llvm::PHINode *phi = builder.CreatePHI(type, numPredecessors);</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;      mapValue(arg, phi);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    }</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  <span class="comment">// Traverse operations.</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;op : bb) {</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="comment">// Set the current debug location within the builder.</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    builder.SetCurrentDebugLocation(</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        debugTranslation-&gt;translateLoc(op.<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>(), subprogram));</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(convertOperation(op, builder)))</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;  }</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;}</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">/// A helper method to get the single Block in an operation honoring LLVM&#39;s</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">/// module requirements.</span></div><div class="line"><a name="l00608"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">  608</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classmlir_1_1Block.html">Block</a> &amp;<a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *module) {</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  <span class="keywordflow">return</span> module-&gt;<a class="code" href="classmlir_1_1Operation.html#aa01ae296df28a63def56ea015dea9929">getRegion</a>(0).<a class="code" href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">front</a>();</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;}</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment">/// A helper method to decide if a constant must not be set as a global variable</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment">/// initializer. For an external linkage variable, the variable with an</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment">/// initializer is considered externally visible and defined in this module, the</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">/// variable without an initializer is externally available and is defined</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment">/// elsewhere.</span></div><div class="line"><a name="l00617"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a9ad47513b43b960b9cc840b6e1fdc4e1">  617</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="ModuleTranslation_8cpp.html#a9ad47513b43b960b9cc840b6e1fdc4e1">shouldDropGlobalInitializer</a>(llvm::GlobalValue::LinkageTypes linkage,</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                                        <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *cst) {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;  <span class="keywordflow">return</span> (linkage == llvm::GlobalVariable::ExternalLinkage &amp;&amp; !cst) ||</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;         linkage == llvm::GlobalVariable::ExternalWeakLinkage;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;}</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="comment">/// Sets the runtime preemption specifier of `gv` to dso_local if</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="comment">/// `dsoLocalRequested` is true, otherwise it is left unchanged.</span></div><div class="line"><a name="l00625"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a632d2064f862636b251e13dd7773cddc">  625</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="ModuleTranslation_8cpp.html#a632d2064f862636b251e13dd7773cddc">addRuntimePreemptionSpecifier</a>(<span class="keywordtype">bool</span> dsoLocalRequested,</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                                          llvm::GlobalValue *gv) {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  <span class="keywordflow">if</span> (dsoLocalRequested)</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    gv-&gt;setDSOLocal(<span class="keyword">true</span>);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;}</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment">/// Create named global variables that correspond to llvm.mlir.global</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="comment">/// definitions. Convert llvm.global_ctors and global_dtors ops.</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment"></span><a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::convertGlobals() {</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> op : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(mlirModule).getOps&lt;LLVM::GlobalOp&gt;()) {</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    llvm::Type *type = convertType(op.getType());</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *cst = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="keywordflow">if</span> (op.getValueOrNull()) {</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      <span class="comment">// String attributes are treated separately because they cannot appear as</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      <span class="comment">// in-function constants and are thus not supported by getLLVMConstant.</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">auto</span> strAttr = op.getValueOrNull().dyn_cast_or_null&lt;StringAttr&gt;()) {</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        cst = llvm::ConstantDataArray::getString(</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            llvmModule-&gt;getContext(), strAttr.getValue(), <span class="comment">/*AddNull=*/</span><span class="keyword">false</span>);</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        type = cst-&gt;getType();</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(cst = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(type, op.getValueOrNull(), op.<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>(),</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                                         *<span class="keyword">this</span>))) {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;      }</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    }</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    <span class="keyword">auto</span> linkage = convertLinkageToLLVM(op.getLinkage());</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    <span class="keyword">auto</span> addrSpace = op.getAddrSpace();</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    <span class="comment">// LLVM IR requires constant with linkage other than external or weak</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    <span class="comment">// external to have initializers. If MLIR does not provide an initializer,</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <span class="comment">// default to undef.</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keywordtype">bool</span> dropInitializer = <a class="code" href="ModuleTranslation_8cpp.html#a9ad47513b43b960b9cc840b6e1fdc4e1">shouldDropGlobalInitializer</a>(linkage, cst);</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <span class="keywordflow">if</span> (!dropInitializer &amp;&amp; !cst)</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;      cst = llvm::UndefValue::get(type);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dropInitializer &amp;&amp; cst)</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;      cst = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    <span class="keyword">auto</span> *var = <span class="keyword">new</span> llvm::GlobalVariable(</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        *llvmModule, type, op.getConstant(), linkage, cst, op.getSymName(),</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="comment">/*InsertBefore=*/</span><span class="keyword">nullptr</span>,</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        op.getThreadLocal_() ? llvm::GlobalValue::GeneralDynamicTLSModel</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                             : llvm::GlobalValue::NotThreadLocal,</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        addrSpace);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keywordflow">if</span> (op.getUnnamedAddr().hasValue())</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;      var-&gt;setUnnamedAddr(convertUnnamedAddrToLLVM(*op.getUnnamedAddr()));</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    <span class="keywordflow">if</span> (op.getSection().hasValue())</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;      var-&gt;setSection(*op.getSection());</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    <a class="code" href="ModuleTranslation_8cpp.html#a632d2064f862636b251e13dd7773cddc">addRuntimePreemptionSpecifier</a>(op.getDsoLocal(), var);</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <a class="code" href="classllvm_1_1Optional.html">Optional&lt;uint64_t&gt;</a> alignment = op.getAlignment();</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="keywordflow">if</span> (alignment.hasValue())</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;      var-&gt;setAlignment(llvm::MaybeAlign(alignment.getValue()));</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    globalsMapping.try_emplace(op, var);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  }</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  <span class="comment">// Convert global variable bodies. This is done after all global variables</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  <span class="comment">// have been created in LLVM IR because a global body may refer to another</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  <span class="comment">// global or itself. So all global variables need to be mapped first.</span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> op : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(mlirModule).getOps&lt;LLVM::GlobalOp&gt;()) {</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> *initializer = op.getInitializerBlock()) {</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;      llvm::IRBuilder&lt;&gt; builder(llvmModule-&gt;getContext());</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;op : initializer-&gt;without_terminator()) {</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(convertOperation(op, builder)) ||</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;            !isa&lt;llvm::Constant&gt;(lookupValue(op.<a class="code" href="classmlir_1_1Operation.html#a56f58b55c803b3313da7b4a04a3d542d">getResult</a>(0))))</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;          <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(op.<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>(), <span class="stringliteral">&quot;unemittable constant value&quot;</span>);</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;      }</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;      ReturnOp ret = cast&lt;ReturnOp&gt;(initializer-&gt;getTerminator());</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;      <a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *cst =</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;          cast&lt;llvm::Constant&gt;(lookupValue(ret.getOperand(0)));</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;      <span class="keyword">auto</span> *global = cast&lt;llvm::GlobalVariable&gt;(lookupGlobal(op));</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;      <span class="keywordflow">if</span> (!<a class="code" href="ModuleTranslation_8cpp.html#a9ad47513b43b960b9cc840b6e1fdc4e1">shouldDropGlobalInitializer</a>(global-&gt;getLinkage(), cst))</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        global-&gt;setInitializer(cst);</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    }</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  }</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  <span class="comment">// Convert llvm.mlir.global_ctors and dtors.</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(mlirModule)) {</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <span class="keyword">auto</span> ctorOp = dyn_cast&lt;GlobalCtorsOp&gt;(op);</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keyword">auto</span> dtorOp = dyn_cast&lt;GlobalDtorsOp&gt;(op);</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <span class="keywordflow">if</span> (!ctorOp &amp;&amp; !dtorOp)</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="keyword">auto</span> range = ctorOp ? llvm::zip(ctorOp.getCtors(), ctorOp.getPriorities())</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                        : llvm::zip(dtorOp.getDtors(), dtorOp.getPriorities());</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    <span class="keyword">auto</span> appendGlobalFn =</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        ctorOp ? llvm::appendToGlobalCtors : llvm::appendToGlobalDtors;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> symbolAndPriority : range) {</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;      llvm::Function *f = lookupFunction(</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;          std::get&lt;0&gt;(symbolAndPriority).cast&lt;FlatSymbolRefAttr&gt;().getValue());</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;      appendGlobalFn(</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;          *llvmModule, f,</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;          std::get&lt;1&gt;(symbolAndPriority).cast&lt;IntegerAttr&gt;().getInt(),</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;          <span class="comment">/*Data=*/</span><span class="keyword">nullptr</span>);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    }</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  }</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;}</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">/// Attempts to add an attribute identified by `key`, optionally with the given</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">/// `value` to LLVM function `llvmFunc`. Reports errors at `loc` if any. If the</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="comment">/// attribute has a kind known to LLVM IR, create the attribute of this kind,</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="comment">/// otherwise keep it as a string attribute. Performs additional checks for</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="comment">/// attributes known to have or not have a value in order to avoid assertions</span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="comment">/// inside LLVM upon construction.</span></div><div class="line"><a name="l00733"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#a75dd84d365c4e04f975610b0d88ca301">  733</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="code" href="ModuleTranslation_8cpp.html#a75dd84d365c4e04f975610b0d88ca301">checkedAddLLVMFnAttribute</a>(<a class="code" href="classmlir_1_1Location.html">Location</a> loc,</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                                               llvm::Function *llvmFunc,</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                                               StringRef key,</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                                               StringRef <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a> = StringRef()) {</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  <span class="keyword">auto</span> kind = llvm::Attribute::getAttrKindFromName(key);</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;  <span class="keywordflow">if</span> (kind == llvm::Attribute::None) {</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    llvmFunc-&gt;addFnAttr(key, <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>);</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;  }</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;  <span class="keywordflow">if</span> (llvm::Attribute::isIntAttrKind(kind)) {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>.empty())</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc) &lt;&lt; <span class="stringliteral">&quot;LLVM attribute &#39;&quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot;&#39; expects a value&quot;</span>;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;    <span class="keywordtype">int</span> result;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>.getAsInteger(<span class="comment">/*Radix=*/</span>0, result))</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;      llvmFunc-&gt;addFnAttr(</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;          llvm::Attribute::get(llvmFunc-&gt;getContext(), kind, result));</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;      llvmFunc-&gt;addFnAttr(key, <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  }</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>.empty())</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc) &lt;&lt; <span class="stringliteral">&quot;LLVM attribute &#39;&quot;</span> &lt;&lt; key</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                          &lt;&lt; <span class="stringliteral">&quot;&#39; does not expect a value, found &#39;&quot;</span> &lt;&lt; <a class="code" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                          &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span>;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  llvmFunc-&gt;addFnAttr(kind);</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;}</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment">/// Attaches the attributes listed in the given array attribute to `llvmFunc`.</span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="comment">/// Reports error to `loc` if any and returns immediately. Expects `attributes`</span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="comment">/// to be an array attribute containing either string attributes, treated as</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment">/// value-less LLVM attributes, or array attributes containing two string</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment">/// attributes, with the first string being the name of the corresponding LLVM</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="comment">/// attribute and the second string beings its value. Note that even integer</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment">/// attributes are expected to have their values expressed as strings.</span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a></div><div class="line"><a name="l00773"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#afa2f691e00650388c78f61c834d54b31">  773</a></span>&#160;<a class="code" href="ModuleTranslation_8cpp.html#afa2f691e00650388c78f61c834d54b31">forwardPassthroughAttributes</a>(<a class="code" href="classmlir_1_1Location.html">Location</a> loc, <a class="code" href="classllvm_1_1Optional.html">Optional&lt;ArrayAttr&gt;</a> attributes,</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                             llvm::Function *llvmFunc) {</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="keywordflow">if</span> (!attributes)</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Attribute.html">Attribute</a> attr : *attributes) {</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> stringAttr = attr.dyn_cast&lt;StringAttr&gt;()) {</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;              <a class="code" href="ModuleTranslation_8cpp.html#a75dd84d365c4e04f975610b0d88ca301">checkedAddLLVMFnAttribute</a>(loc, llvmFunc, stringAttr.getValue())))</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    }</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <span class="keyword">auto</span> arrayAttr = attr.dyn_cast&lt;ArrayAttr&gt;();</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    <span class="keywordflow">if</span> (!arrayAttr || arrayAttr.size() != 2)</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc)</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;             &lt;&lt; <span class="stringliteral">&quot;expected &#39;passthrough&#39; to contain string or array attributes&quot;</span>;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;    <span class="keyword">auto</span> keyAttr = arrayAttr[0].dyn_cast&lt;StringAttr&gt;();</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keyword">auto</span> valueAttr = arrayAttr[1].dyn_cast&lt;StringAttr&gt;();</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;    <span class="keywordflow">if</span> (!keyAttr || !valueAttr)</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>(loc)</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;             &lt;&lt; <span class="stringliteral">&quot;expected arrays within &#39;passthrough&#39; to contain two strings&quot;</span>;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="ModuleTranslation_8cpp.html#a75dd84d365c4e04f975610b0d88ca301">checkedAddLLVMFnAttribute</a>(loc, llvmFunc, keyAttr.getValue(),</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                                         valueAttr.getValue())))</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;  }</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;}</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::convertOneFunction(LLVMFuncOp func) {</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  <span class="comment">// Clear the block, branch value mappings, they are only relevant within one</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  <span class="comment">// function.</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  blockMapping.clear();</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  valueMapping.clear();</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  branchMapping.clear();</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  llvm::Function *llvmFunc = lookupFunction(func.getName());</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="comment">// Translate the debug information for this function.</span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  debugTranslation-&gt;translate(func, *llvmFunc);</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  <span class="comment">// Add function arguments to the value remapping table.</span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  <span class="comment">// If there was noalias info then we decorate each argument accordingly.</span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> argIdx = 0;</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> kvp : llvm::zip(func.getArguments(), llvmFunc-&gt;args())) {</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    <a class="code" href="namespacemlir_1_1tblgen.html#ab3f48aae64cf4b158f008d5a2d730d68">llvm::Argument</a> &amp;llvmArg = std::get&lt;1&gt;(kvp);</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    <a class="code" href="classmlir_1_1BlockArgument.html">BlockArgument</a> mlirArg = std::get&lt;0&gt;(kvp);</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> attr = func.getArgAttrOfType&lt;UnitAttr&gt;(</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;            argIdx, LLVMDialect::getNoAliasAttrName())) {</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;      <span class="comment">// NB: Attribute already verified to be boolean, so check if we can indeed</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      <span class="comment">// attach the attribute to this argument, based on its type.</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;      <span class="keyword">auto</span> argTy = mlirArg.<a class="code" href="classmlir_1_1Value.html#a5348fc13d5201e2adf7ded6b4b2fb1ad">getType</a>();</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      <span class="keywordflow">if</span> (!argTy.isa&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;())</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        <span class="keywordflow">return</span> func.emitError(</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            <span class="stringliteral">&quot;llvm.noalias attribute attached to LLVM non-pointer argument&quot;</span>);</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;      llvmArg.addAttr(llvm::Attribute::AttrKind::NoAlias);</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    }</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> attr = func.getArgAttrOfType&lt;IntegerAttr&gt;(</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;            argIdx, LLVMDialect::getAlignAttrName())) {</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;      <span class="comment">// NB: Attribute already verified to be int, so check if we can indeed</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;      <span class="comment">// attach the attribute to this argument, based on its type.</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;      <span class="keyword">auto</span> argTy = mlirArg.getType();</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;      <span class="keywordflow">if</span> (!argTy.isa&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;())</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;        <span class="keywordflow">return</span> func.emitError(</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;            <span class="stringliteral">&quot;llvm.align attribute attached to LLVM non-pointer argument&quot;</span>);</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                           .addAlignmentAttr(llvm::Align(attr.getInt())));</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    }</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> attr = func.getArgAttrOfType&lt;UnitAttr&gt;(argIdx, <span class="stringliteral">&quot;llvm.sret&quot;</span>)) {</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;      <span class="keyword">auto</span> argTy = mlirArg.getType().<a class="code" href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">dyn_cast</a>&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;      <span class="keywordflow">if</span> (!argTy)</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        <span class="keywordflow">return</span> func.emitError(</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;            <span class="stringliteral">&quot;llvm.sret attribute attached to LLVM non-pointer argument&quot;</span>);</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;      llvmArg.addAttrs(</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;          llvm::AttrBuilder(llvmArg.getContext())</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;              .addStructRetAttr(convertType(argTy.getElementType())));</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    }</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> attr = func.getArgAttrOfType&lt;UnitAttr&gt;(argIdx, <span class="stringliteral">&quot;llvm.byval&quot;</span>)) {</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;      <span class="keyword">auto</span> argTy = mlirArg.getType().dyn_cast&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;();</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;      <span class="keywordflow">if</span> (!argTy)</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;        <span class="keywordflow">return</span> func.emitError(</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;            <span class="stringliteral">&quot;llvm.byval attribute attached to LLVM non-pointer argument&quot;</span>);</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                           .addByValAttr(convertType(argTy.getElementType())));</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    }</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> attr = func.getArgAttrOfType&lt;UnitAttr&gt;(argIdx, <span class="stringliteral">&quot;llvm.nest&quot;</span>)) {</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;      <span class="keyword">auto</span> argTy = mlirArg.getType();</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;      <span class="keywordflow">if</span> (!argTy.isa&lt;<a class="code" href="classmlir_1_1LLVM_1_1LLVMPointerType.html">LLVM::LLVMPointerType</a>&gt;())</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;        <span class="keywordflow">return</span> func.emitError(</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            <span class="stringliteral">&quot;llvm.nest attribute attached to LLVM non-pointer argument&quot;</span>);</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                           .addAttribute(llvm::Attribute::Nest));</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    }</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;    mapValue(mlirArg, &amp;llvmArg);</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    argIdx++;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;  }</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;  <span class="comment">// Check the personality and set it.</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <span class="keywordflow">if</span> (func.getPersonality().hasValue()) {</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    llvm::Type *ty = llvm::Type::getInt8PtrTy(llvmFunc-&gt;getContext());</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">llvm::Constant</a> *pfunc = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">getLLVMConstant</a>(ty, func.getPersonalityAttr(),</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;                                                func.getLoc(), *<span class="keyword">this</span>))</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;      llvmFunc-&gt;setPersonalityFn(pfunc);</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;  }</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> gc = func.getGarbageCollector())</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    llvmFunc-&gt;setGC(gc-&gt;str());</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;  <span class="comment">// First, create all blocks so we can jump to them.</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;  llvm::LLVMContext &amp;llvmContext = llvmFunc-&gt;getContext();</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;bb : func) {</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keyword">auto</span> *llvmBB = llvm::BasicBlock::Create(llvmContext);</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    llvmBB-&gt;insertInto(llvmFunc);</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;    mapBlock(&amp;bb, llvmBB);</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  }</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  <span class="comment">// Then, convert blocks one by one in topological order to ensure defs are</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <span class="comment">// converted before uses.</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  <span class="keyword">auto</span> blocks = <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">detail::getTopologicallySortedBlocks</a>(func.getBody());</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Block.html">Block</a> *bb : blocks) {</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    llvm::IRBuilder&lt;&gt; builder(llvmContext);</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(convertBlock(*bb, bb-&gt;isEntryBlock(), builder)))</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  }</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  <span class="comment">// After all blocks have been traversed and values mapped, connect the PHI</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;  <span class="comment">// nodes to the results of preceding blocks.</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;  <a class="code" href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">detail::connectPHINodes</a>(func.getBody(), *<span class="keyword">this</span>);</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;  <span class="comment">// Finally, convert dialect attributes attached to the function.</span></div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;  <span class="keywordflow">return</span> convertDialectAttributes(func);</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;}</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::convertDialectAttributes(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op) {</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> attribute : op-&gt;<a class="code" href="classmlir_1_1Operation.html#ab7c043033c648c675874eb3e579ca842">getDialectAttrs</a>())</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(iface.amendOperation(op, attribute, *<span class="keyword">this</span>)))</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;}</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::convertFunctionSignatures() {</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;  <span class="comment">// Declare all functions first because there may be function calls that form a</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;  <span class="comment">// call graph with cycles, or global initializers that reference functions.</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">function</span> : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(mlirModule).getOps&lt;LLVMFuncOp&gt;()) {</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    llvm::FunctionCallee llvmFuncCst = llvmModule-&gt;getOrInsertFunction(</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;        <span class="keyword">function</span>.getName(),</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;        cast&lt;llvm::FunctionType&gt;(convertType(<span class="keyword">function</span>.<a class="code" href="namespacemlir_1_1function__interface__impl.html#ac057283bc2c0fc26ed27a77de7c9f594">getFunctionType</a>())));</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    llvm::Function *llvmFunc = cast&lt;llvm::Function&gt;(llvmFuncCst.getCallee());</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    llvmFunc-&gt;setLinkage(convertLinkageToLLVM(<span class="keyword">function</span>.getLinkage()));</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    mapFunction(<span class="keyword">function</span>.getName(), llvmFunc);</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    <a class="code" href="ModuleTranslation_8cpp.html#a632d2064f862636b251e13dd7773cddc">addRuntimePreemptionSpecifier</a>(<span class="keyword">function</span>.getDsoLocal(), llvmFunc);</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <span class="comment">// Forward the pass-through attributes to LLVM.</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(<a class="code" href="ModuleTranslation_8cpp.html#afa2f691e00650388c78f61c834d54b31">forwardPassthroughAttributes</a>(</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;            <span class="keyword">function</span>.getLoc(), <span class="keyword">function</span>.getPassthrough(), llvmFunc)))</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;  }</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;}</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::convertFunctions() {</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  <span class="comment">// Convert functions.</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">function</span> : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(mlirModule).getOps&lt;LLVMFuncOp&gt;()) {</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="comment">// Ignore external functions.</span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">function</span>.isExternal())</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(convertOneFunction(<span class="keyword">function</span>)))</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a>();</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;  }</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;}</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;llvm::MDNode *</div><div class="line"><a name="l00956"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a75944e2cf496e0aaf42f87ea661afaa5">  956</a></span>&#160;<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a75944e2cf496e0aaf42f87ea661afaa5">ModuleTranslation::getAccessGroup</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst,</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                                  SymbolRefAttr accessGroupRef)<span class="keyword"> const </span>{</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;  <span class="keyword">auto</span> metadataName = accessGroupRef.getRootReference();</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;  <span class="keyword">auto</span> accessGroupName = accessGroupRef.getLeafReference();</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;  <span class="keyword">auto</span> metadataOp = SymbolTable::lookupNearestSymbolFrom&lt;LLVM::MetadataOp&gt;(</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;      opInst.<a class="code" href="classmlir_1_1Operation.html#a8d9761f2b79a46d10ffb6ba28880cc2f">getParentOp</a>(), metadataName);</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;  <span class="keyword">auto</span> *accessGroupOp =</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;      <a class="code" href="classmlir_1_1SymbolTable.html#ab2bbdb2e223faba1e86134740ca16122">SymbolTable::lookupNearestSymbolFrom</a>(metadataOp, accessGroupName);</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;  <span class="keywordflow">return</span> accessGroupMetadataMapping.lookup(accessGroupOp);</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;}</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::createAccessGroupMetadata() {</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;  mlirModule-&gt;walk([&amp;](LLVM::MetadataOp metadatas) {</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    metadatas.walk([&amp;](LLVM::AccessGroupMetadataOp op) {</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;      llvm::LLVMContext &amp;ctx = llvmModule-&gt;getContext();</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;      llvm::MDNode *accessGroup = llvm::MDNode::getDistinct(ctx, {});</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;      accessGroupMetadataMapping.insert({op, accessGroup});</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    });</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;  });</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;}</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a3aaf342cd160e71bcb1ed0cb991f63b8">  978</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a3aaf342cd160e71bcb1ed0cb991f63b8">ModuleTranslation::setAccessGroupsMetadata</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op,</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                                                llvm::Instruction *inst) {</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;  <span class="keyword">auto</span> accessGroups =</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;      op-&gt;<a class="code" href="classmlir_1_1Operation.html#a2bd374f63c1bc277ef0c2ccb1b4f9cc3">getAttrOfType</a>&lt;ArrayAttr&gt;(LLVMDialect::getAccessGroupsAttrName());</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;  <span class="keywordflow">if</span> (accessGroups &amp;&amp; !accessGroups.empty()) {</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;    llvm::Module *module = inst-&gt;getModule();</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Metadata *&gt;</a> metadatas;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    <span class="keywordflow">for</span> (SymbolRefAttr accessGroupRef :</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;         accessGroups.getAsRange&lt;SymbolRefAttr&gt;())</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;      metadatas.push_back(getAccessGroup(*op, accessGroupRef));</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    llvm::MDNode *unionMD = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    <span class="keywordflow">if</span> (metadatas.size() == 1)</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;      unionMD = llvm::cast&lt;llvm::MDNode&gt;(metadatas.front());</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (metadatas.size() &gt;= 2)</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;      unionMD = llvm::MDNode::get(module-&gt;getContext(), metadatas);</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    inst-&gt;setMetadata(module-&gt;getMDKindID(<span class="stringliteral">&quot;llvm.access.group&quot;</span>), unionMD);</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;  }</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;}</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<a class="code" href="structmlir_1_1LogicalResult.html">LogicalResult</a> ModuleTranslation::createAliasScopeMetadata() {</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  mlirModule-&gt;walk([&amp;](LLVM::MetadataOp metadatas) {</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <span class="comment">// Create the domains first, so they can be reference below in the scopes.</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Operation *, llvm::MDNode *&gt;</a> aliasScopeDomainMetadataMapping;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    metadatas.walk([&amp;](LLVM::AliasScopeDomainMetadataOp op) {</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;      llvm::LLVMContext &amp;ctx = llvmModule-&gt;getContext();</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;      <a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;llvm::Metadata *, 2&gt;</a> operands;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;      operands.push_back({}); <span class="comment">// Placeholder for self-reference</span></div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Optional.html">Optional&lt;StringRef&gt;</a> description = op.getDescription())</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;        operands.push_back(llvm::MDString::get(ctx, description.getValue()));</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;      llvm::MDNode *domain = llvm::MDNode::get(ctx, operands);</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;      domain-&gt;replaceOperandWith(0, domain); <span class="comment">// Self-reference for uniqueness</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;      aliasScopeDomainMetadataMapping.insert({op, domain});</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    });</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    <span class="comment">// Now create the scopes, referencing the domains created above.</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    metadatas.walk([&amp;](LLVM::AliasScopeMetadataOp op) {</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;      llvm::LLVMContext &amp;ctx = llvmModule-&gt;getContext();</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;      assert(isa&lt;LLVM::MetadataOp&gt;(op-&gt;getParentOp()));</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;      <span class="keyword">auto</span> metadataOp = dyn_cast&lt;LLVM::MetadataOp&gt;(op-&gt;getParentOp());</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;      <a class="code" href="classmlir_1_1Operation.html">Operation</a> *domainOp =</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;          <a class="code" href="classmlir_1_1SymbolTable.html#ab2bbdb2e223faba1e86134740ca16122">SymbolTable::lookupNearestSymbolFrom</a>(metadataOp, op.getDomainAttr());</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;      llvm::MDNode *domain = aliasScopeDomainMetadataMapping.lookup(domainOp);</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;      assert(domain &amp;&amp; <span class="stringliteral">&quot;Scope&#39;s domain should already be valid&quot;</span>);</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;      <a class="code" href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt;llvm::Metadata *, 3&gt;</a> operands;</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;      operands.push_back({}); <span class="comment">// Placeholder for self-reference</span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;      operands.push_back(domain);</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Optional.html">Optional&lt;StringRef&gt;</a> description = op.getDescription())</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        operands.push_back(llvm::MDString::get(ctx, description.getValue()));</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;      llvm::MDNode *scope = llvm::MDNode::get(ctx, operands);</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;      scope-&gt;replaceOperandWith(0, scope); <span class="comment">// Self-reference for uniqueness</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;      aliasScopeMetadataMapping.insert({op, scope});</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;    });</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;  });</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a>();</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;}</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;llvm::MDNode *</div><div class="line"><a name="l01037"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af2f810bd95939d3299dabd1f1ec3a232"> 1037</a></span>&#160;<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af2f810bd95939d3299dabd1f1ec3a232">ModuleTranslation::getAliasScope</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;opInst,</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                                 SymbolRefAttr aliasScopeRef)<span class="keyword"> const </span>{</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;  StringAttr metadataName = aliasScopeRef.getRootReference();</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;  StringAttr scopeName = aliasScopeRef.getLeafReference();</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;  <span class="keyword">auto</span> metadataOp = SymbolTable::lookupNearestSymbolFrom&lt;LLVM::MetadataOp&gt;(</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;      opInst.<a class="code" href="classmlir_1_1Operation.html#a8d9761f2b79a46d10ffb6ba28880cc2f">getParentOp</a>(), metadataName);</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  <a class="code" href="classmlir_1_1Operation.html">Operation</a> *aliasScopeOp =</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;      <a class="code" href="classmlir_1_1SymbolTable.html#ab2bbdb2e223faba1e86134740ca16122">SymbolTable::lookupNearestSymbolFrom</a>(metadataOp, scopeName);</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="keywordflow">return</span> aliasScopeMetadataMapping.lookup(aliasScopeOp);</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;}</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;</div><div class="line"><a name="l01048"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a803e34fd6fc83280874ceeb3558f6f4a"> 1048</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a803e34fd6fc83280874ceeb3558f6f4a">ModuleTranslation::setAliasScopeMetadata</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op,</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                                              llvm::Instruction *inst) {</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;  <span class="keyword">auto</span> populateScopeMetadata = [<span class="keyword">this</span>, op, inst](StringRef attrName,</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;                                                StringRef llvmMetadataName) {</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    <span class="keyword">auto</span> scopes = op-&gt;<a class="code" href="classmlir_1_1Operation.html#a2bd374f63c1bc277ef0c2ccb1b4f9cc3">getAttrOfType</a>&lt;ArrayAttr&gt;(attrName);</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    <span class="keywordflow">if</span> (!scopes || scopes.empty())</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    llvm::Module *module = inst-&gt;getModule();</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Metadata *&gt;</a> scopeMDs;</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    <span class="keywordflow">for</span> (SymbolRefAttr scopeRef : scopes.getAsRange&lt;SymbolRefAttr&gt;())</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;      scopeMDs.push_back(getAliasScope(*op, scopeRef));</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    llvm::MDNode *unionMD = llvm::MDNode::get(module-&gt;getContext(), scopeMDs);</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    inst-&gt;setMetadata(module-&gt;getMDKindID(llvmMetadataName), unionMD);</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;  };</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;  populateScopeMetadata(LLVMDialect::getAliasScopesAttrName(), <span class="stringliteral">&quot;alias.scope&quot;</span>);</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;  populateScopeMetadata(LLVMDialect::getNoAliasScopesAttrName(), <span class="stringliteral">&quot;noalias&quot;</span>);</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;}</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;</div><div class="line"><a name="l01067"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1"> 1067</a></span>&#160;llvm::Type *<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">ModuleTranslation::convertType</a>(<a class="code" href="classmlir_1_1Type.html">Type</a> type) {</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;  <span class="keywordflow">return</span> typeTranslator.translateType(type);</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;}</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="comment">/// A helper to look up remapped operands in the value remapping table.</span></div><div class="line"><a name="l01072"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97"> 1072</a></span>&#160;<span class="comment"></span><a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97">ModuleTranslation::lookupValues</a>(<a class="code" href="classmlir_1_1ValueRange.html">ValueRange</a> values) {</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;llvm::Value *&gt;</a> remapped;</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  remapped.reserve(values.size());</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Value.html">Value</a> v : values)</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    remapped.push_back(lookupValue(v));</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;  <span class="keywordflow">return</span> remapped;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;}</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="keyword">const</span> llvm::DILocation *</div><div class="line"><a name="l01081"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a5eb37753a783d224c0cd751746c1ad54"> 1081</a></span>&#160;<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a5eb37753a783d224c0cd751746c1ad54">ModuleTranslation::translateLoc</a>(<a class="code" href="classmlir_1_1Location.html">Location</a> loc, llvm::DILocalScope *scope) {</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <span class="keywordflow">return</span> debugTranslation-&gt;translateLoc(loc, scope);</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;}</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;llvm::NamedMDNode *</div><div class="line"><a name="l01086"></a><span class="lineno"><a class="line" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a325f93c33660b463ee68046f13ef7267"> 1086</a></span>&#160;<a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a325f93c33660b463ee68046f13ef7267">ModuleTranslation::getOrInsertNamedModuleMetadata</a>(StringRef name) {</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;  <span class="keywordflow">return</span> llvmModule-&gt;getOrInsertNamedMetadata(name);</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;}</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="keywordtype">void</span> ModuleTranslation::StackFrame::anchor() {}</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="keyword">static</span> std::unique_ptr&lt;llvm::Module&gt;</div><div class="line"><a name="l01093"></a><span class="lineno"><a class="line" href="ModuleTranslation_8cpp.html#aa97683e2f1d71cb0815811351c035d9c"> 1093</a></span>&#160;<a class="code" href="ModuleTranslation_8cpp.html#aa97683e2f1d71cb0815811351c035d9c">prepareLLVMModule</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *m, llvm::LLVMContext &amp;llvmContext,</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;                  StringRef name) {</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;  m-&gt;<a class="code" href="classmlir_1_1Operation.html#a6148c9c026c28a65985dad975c0106ef">getContext</a>()-&gt;<a class="code" href="classmlir_1_1MLIRContext.html#ae50174cfadfa2e812f35d86f2942edf7">getOrLoadDialect</a>&lt;LLVM::LLVMDialect&gt;();</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;  <span class="keyword">auto</span> llvmModule = std::make_unique&lt;llvm::Module&gt;(name, llvmContext);</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> dataLayoutAttr =</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;          m-&gt;<a class="code" href="classmlir_1_1Operation.html#a2bd7667bca9e92550f5535379e382fb3">getAttr</a>(LLVM::LLVMDialect::getDataLayoutAttrName())) {</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;    llvmModule-&gt;setDataLayout(dataLayoutAttr.cast&lt;StringAttr&gt;().getValue());</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    <a class="code" href="classmlir_1_1FailureOr.html">FailureOr&lt;llvm::DataLayout&gt;</a> llvmDataLayout(llvm::DataLayout(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> iface = dyn_cast&lt;DataLayoutOpInterface&gt;(m)) {</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;      <span class="keywordflow">if</span> (DataLayoutSpecInterface spec = iface.getDataLayoutSpec()) {</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        llvmDataLayout =</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;            <a class="code" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a>(spec, <a class="code" href="classmlir_1_1DataLayout.html">DataLayout</a>(iface), m-&gt;<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>());</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;      }</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> = dyn_cast&lt;ModuleOp&gt;(m)) {</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;      <span class="keywordflow">if</span> (DataLayoutSpecInterface spec = <a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a>.getDataLayoutSpec()) {</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;        llvmDataLayout =</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;            <a class="code" href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">translateDataLayout</a>(spec, <a class="code" href="classmlir_1_1DataLayout.html">DataLayout</a>(<a class="code" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a>), m-&gt;<a class="code" href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">getLoc</a>());</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;      }</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    }</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(llvmDataLayout))</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;    llvmModule-&gt;setDataLayout(*llvmDataLayout);</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  }</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> targetTripleAttr =</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;          m-&gt;<a class="code" href="classmlir_1_1Operation.html#a2bd7667bca9e92550f5535379e382fb3">getAttr</a>(LLVM::LLVMDialect::getTargetTripleAttrName()))</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    llvmModule-&gt;setTargetTriple(targetTripleAttr.cast&lt;StringAttr&gt;().getValue());</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  <span class="comment">// Inject declarations for `malloc` and `free` functions that can be used in</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;  <span class="comment">// memref allocation/deallocation coming from standard ops lowering.</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;  llvm::IRBuilder&lt;&gt; builder(llvmContext);</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;  llvmModule-&gt;getOrInsertFunction(<span class="stringliteral">&quot;malloc&quot;</span>, builder.getInt8PtrTy(),</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;                                  builder.getInt64Ty());</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;  llvmModule-&gt;getOrInsertFunction(<span class="stringliteral">&quot;free&quot;</span>, builder.getVoidTy(),</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;                                  builder.getInt8PtrTy());</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;  <span class="keywordflow">return</span> llvmModule;</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;}</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;std::unique_ptr&lt;llvm::Module&gt;</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<a class="code" href="namespacemlir.html#adc149979459c3123124db882fb765dba">mlir::translateModuleToLLVMIR</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *module, llvm::LLVMContext &amp;llvmContext,</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;                              StringRef name) {</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacemlir_1_1LLVM.html#a847e84be7235275135237a48a9813be9">satisfiesLLVMModule</a>(module))</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;  std::unique_ptr&lt;llvm::Module&gt; llvmModule =</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;      <a class="code" href="ModuleTranslation_8cpp.html#aa97683e2f1d71cb0815811351c035d9c">prepareLLVMModule</a>(module, llvmContext, name);</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;  <span class="keywordflow">if</span> (!llvmModule)</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;  <a class="code" href="namespacemlir_1_1LLVM.html#adb7597cb2576197146fcb4c2272cfd04">LLVM::ensureDistinctSuccessors</a>(module);</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  <a class="code" href="classmlir_1_1LLVM_1_1ModuleTranslation.html">ModuleTranslation</a> translator(module, std::move(llvmModule));</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.convertFunctionSignatures()))</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.convertGlobals()))</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.createAccessGroupMetadata()))</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.createAliasScopeMetadata()))</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.convertFunctions()))</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;  <span class="comment">// Convert other top-level operations if possible.</span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  llvm::IRBuilder&lt;&gt; llvmBuilder(llvmContext);</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;o : <a class="code" href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a>(module).getOperations()) {</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    <span class="keywordflow">if</span> (!isa&lt;LLVM::LLVMFuncOp, LLVM::GlobalOp, LLVM::GlobalCtorsOp,</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;             LLVM::GlobalDtorsOp, LLVM::MetadataOp&gt;(&amp;o) &amp;&amp;</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;        !o.hasTrait&lt;<a class="code" href="classmlir_1_1OpTrait_1_1IsTerminator.html">OpTrait::IsTerminator</a>&gt;() &amp;&amp;</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;        <a class="code" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a>(translator.convertOperation(o, llvmBuilder))) {</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    }</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;  }</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;  <span class="keywordflow">if</span> (llvm::verifyModule(*translator.llvmModule, &amp;llvm::errs()))</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;  <span class="keywordflow">return</span> std::move(translator.llvmModule);</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;}</div><div class="ttc" id="namespacemlir_html"><div class="ttname"><a href="namespacemlir.html">mlir</a></div><div class="ttdoc">Include the generated interface declarations. </div><div class="ttdef"><b>Definition:</b> <a href="LocalAliasAnalysis_8h_source.html#l00020">LocalAliasAnalysis.h:20</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_a1ef9f00eb906cc9ee9e92c244e939fa8"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#a1ef9f00eb906cc9ee9e92c244e939fa8">mlir::LLVM::detail::getLLVMConstant</a></div><div class="ttdeci">llvm::Constant * getLLVMConstant(llvm::Type *llvmType, Attribute attr, Location loc, const ModuleTranslation &amp;moduleTranslation, bool isTopLevel=true)</div><div class="ttdoc">Create an LLVM IR constant of llvmType from the MLIR attribute attr. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00273">ModuleTranslation.cpp:273</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html"><div class="ttname"><a href="classmlir_1_1Region.html">mlir::Region</a></div><div class="ttdoc">This class contains a list of basic blocks and a link to the parent operation it is attached to...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00026">Region.h:26</a></div></div>
<div class="ttc" id="Support_2LLVM_8h_html"><div class="ttname"><a href="Support_2LLVM_8h.html">LLVM.h</a></div></div>
<div class="ttc" id="classmlir_1_1Attribute_html_a711073f32e43429d5faaada8c387ff88"><div class="ttname"><a href="classmlir_1_1Attribute.html#a711073f32e43429d5faaada8c387ff88">mlir::Attribute::cast</a></div><div class="ttdeci">U cast() const</div><div class="ttdef"><b>Definition:</b> <a href="Attributes_8h_source.html#l00130">Attributes.h:130</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is a basic unit of execution within MLIR. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00028">Operation.h:28</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_af2f810bd95939d3299dabd1f1ec3a232"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#af2f810bd95939d3299dabd1f1ec3a232">mlir::LLVM::ModuleTranslation::getAliasScope</a></div><div class="ttdeci">llvm::MDNode * getAliasScope(Operation &amp;opInst, SymbolRefAttr aliasScopeRef) const</div><div class="ttdoc">Returns the LLVM metadata corresponding to a reference to an mlir LLVM dialect alias scope operation...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01037">ModuleTranslation.cpp:1037</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html"><div class="ttname"><a href="classmlir_1_1Block.html">mlir::Block</a></div><div class="ttdoc">Block represents an ordered list of Operations. </div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00029">Block.h:29</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html_ac5f83e51909b69039a7506737b458452"><div class="ttname"><a href="classmlir_1_1Region.html#ac5f83e51909b69039a7506737b458452">mlir::Region::front</a></div><div class="ttdeci">Block &amp; front()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00065">Region.h:65</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a5eb37753a783d224c0cd751746c1ad54"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a5eb37753a783d224c0cd751746c1ad54">mlir::LLVM::ModuleTranslation::translateLoc</a></div><div class="ttdeci">const llvm::DILocation * translateLoc(Location loc, llvm::DILocalScope *scope)</div><div class="ttdoc">Translates the given location. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01081">ModuleTranslation.cpp:1081</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a7e4fa6f72a2fb1a03c35b01f2a7615b1"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a7e4fa6f72a2fb1a03c35b01f2a7615b1">mlir::LLVM::ModuleTranslation::convertType</a></div><div class="ttdeci">llvm::Type * convertType(Type type)</div><div class="ttdoc">Converts the type from MLIR LLVM dialect to LLVM. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01067">ModuleTranslation.cpp:1067</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a325f93c33660b463ee68046f13ef7267"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a325f93c33660b463ee68046f13ef7267">mlir::LLVM::ModuleTranslation::getOrInsertNamedModuleMetadata</a></div><div class="ttdeci">llvm::NamedMDNode * getOrInsertNamedModuleMetadata(StringRef name)</div><div class="ttdoc">Gets the named metadata in the LLVM IR module being constructed, creating it if it does not exist...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01086">ModuleTranslation.cpp:1086</a></div></div>
<div class="ttc" id="classmlir_1_1FlatSymbolRefAttr_html"><div class="ttname"><a href="classmlir_1_1FlatSymbolRefAttr.html">mlir::FlatSymbolRefAttr</a></div><div class="ttdoc">A symbol reference with a reference path containing a single element. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8h_source.html#l00781">BuiltinAttributes.h:781</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMap_html"><div class="ttname"><a href="classllvm_1_1DenseMap.html">llvm::DenseMap</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00050">LLVM.h:50</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_aa4111e6ff5cf4f1d365791ce9c8e0317"><div class="ttname"><a href="ModuleTranslation_8cpp.html#aa4111e6ff5cf4f1d365791ce9c8e0317">getInnermostElementType</a></div><div class="ttdeci">static llvm::Type * getInnermostElementType(llvm::Type *type)</div><div class="ttdoc">Returns the first non-sequential type nested in sequential types. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00167">ModuleTranslation.cpp:167</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a1eecfffb7445e24f9fbdec2d619251ff"><div class="ttname"><a href="classmlir_1_1Operation.html#a1eecfffb7445e24f9fbdec2d619251ff">mlir::Operation::getOperand</a></div><div class="ttdeci">Value getOperand(unsigned idx)</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00273">Operation.h:273</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a2bd374f63c1bc277ef0c2ccb1b4f9cc3"><div class="ttname"><a href="classmlir_1_1Operation.html#a2bd374f63c1bc277ef0c2ccb1b4f9cc3">mlir::Operation::getAttrOfType</a></div><div class="ttdeci">AttrClass getAttrOfType(StringAttr name)</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00381">Operation.h:381</a></div></div>
<div class="ttc" id="namespacemlir_html_aeec13ab4fb753865cdfd2699aa01c23b"><div class="ttname"><a href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">mlir::failed</a></div><div class="ttdeci">bool failed(LogicalResult result)</div><div class="ttdoc">Utility function that returns true if the provided LogicalResult corresponds to a failure value...</div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00072">LogicalResult.h:72</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ab4c38d7dad8c41373557f61ae08eb925"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ab4c38d7dad8c41373557f61ae08eb925">mlir::LLVM::ModuleTranslation::getLLVMContext</a></div><div class="ttdeci">llvm::LLVMContext &amp; getLLVMContext() const</div><div class="ttdoc">Returns the LLVM context in which the IR is being constructed. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00156">ModuleTranslation.h:156</a></div></div>
<div class="ttc" id="classllvm_1_1TypeSwitch_html"><div class="ttname"><a href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00065">LLVM.h:65</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a87194ef9e9c47b3f831bb5207d41139e"><div class="ttname"><a href="classmlir_1_1Block.html#a87194ef9e9c47b3f831bb5207d41139e">mlir::Block::getPredecessors</a></div><div class="ttdeci">iterator_range&lt; pred_iterator &gt; getPredecessors()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00225">Block.h:225</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html_a94078d9d2001e2d92c2f27dac66970ab"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">mlir::DenseElementsAttr::getType</a></div><div class="ttdeci">ShapedType getType() const</div><div class="ttdoc">Return the type of this ElementsAttr, guaranteed to be a vector or tensor with static shape...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8cpp_source.html#l01010">BuiltinAttributes.cpp:1010</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a3aaf342cd160e71bcb1ed0cb991f63b8"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a3aaf342cd160e71bcb1ed0cb991f63b8">mlir::LLVM::ModuleTranslation::setAccessGroupsMetadata</a></div><div class="ttdeci">void setAccessGroupsMetadata(Operation *op, llvm::Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00978">ModuleTranslation.cpp:978</a></div></div>
<div class="ttc" id="classmlir_1_1OpTrait_1_1IsTerminator_html"><div class="ttname"><a href="classmlir_1_1OpTrait_1_1IsTerminator.html">mlir::OpTrait::IsTerminator</a></div><div class="ttdoc">This class provides the API for ops that are known to be terminators. </div><div class="ttdef"><b>Definition:</b> <a href="OpDefinition_8h_source.html#l00697">OpDefinition.h:697</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a412839b57abb733219f4ea73df143e97"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a412839b57abb733219f4ea73df143e97">mlir::LLVM::ModuleTranslation::lookupValues</a></div><div class="ttdeci">SmallVector&lt; llvm::Value * &gt; lookupValues(ValueRange values)</div><div class="ttdoc">Looks up remapped a list of remapped values. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01072">ModuleTranslation.cpp:1072</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a35655ce5e44c6822ffdda86737dcbd8d"><div class="ttname"><a href="classmlir_1_1Operation.html#a35655ce5e44c6822ffdda86737dcbd8d">mlir::Operation::getNumSuccessors</a></div><div class="ttdeci">unsigned getNumSuccessors()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00503">Operation.h:503</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a04c2e13596c2bc9d0cfada820eea7358"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a04c2e13596c2bc9d0cfada820eea7358">mlir::LLVM::ModuleTranslation::convertBlock</a></div><div class="ttdeci">LogicalResult convertBlock(Block &amp;bb, bool ignoreArguments, llvm::IRBuilderBase &amp;builder)</div><div class="ttdoc">Translates the contents of the given block to LLVM IR using this translator. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00567">ModuleTranslation.cpp:567</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_aa904889345bf1bf23a54076768158c94"><div class="ttname"><a href="classmlir_1_1Block.html#aa904889345bf1bf23a54076768158c94">mlir::Block::front</a></div><div class="ttdeci">Operation &amp; front()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00144">Block.h:144</a></div></div>
<div class="ttc" id="classllvm_1_1Optional_html"><div class="ttname"><a href="classllvm_1_1Optional.html">llvm::Optional</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00055">LLVM.h:55</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a51bb831df4cf8bf4b4bf13a1be791701"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a51bb831df4cf8bf4b4bf13a1be791701">mlir::LLVM::ModuleTranslation::lookupBlock</a></div><div class="ttdeci">llvm::BasicBlock * lookupBlock(Block *block) const</div><div class="ttdoc">Finds an LLVM IR basic block that corresponds to the given MLIR block. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00097">ModuleTranslation.h:97</a></div></div>
<div class="ttc" id="namespacemlir_1_1tblgen_html_ab3f48aae64cf4b158f008d5a2d730d68"><div class="ttname"><a href="namespacemlir_1_1tblgen.html#ab3f48aae64cf4b158f008d5a2d730d68">mlir::tblgen::Argument</a></div><div class="ttdeci">llvm::PointerUnion&lt; NamedAttribute *, NamedTypeConstraint * &gt; Argument</div><div class="ttdef"><b>Definition:</b> <a href="Argument_8h_source.html#l00062">Argument.h:62</a></div></div>
<div class="ttc" id="InterfaceSupport_8h_html_a53ed1830bfcbea42b0e7b10281e03865"><div class="ttname"><a href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a></div><div class="ttdeci">static constexpr const bool value</div><div class="ttdef"><b>Definition:</b> <a href="InterfaceSupport_8h_source.html#l00155">InterfaceSupport.h:155</a></div></div>
<div class="ttc" id="Attributes_8h_html"><div class="ttname"><a href="Attributes_8h.html">Attributes.h</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_ae7cb9d75828602a93097d60f55ae6c1c"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#ae7cb9d75828602a93097d60f55ae6c1c">mlir::LLVM::ModuleTranslation::forgetMapping</a></div><div class="ttdeci">void forgetMapping(Region &amp;region)</div><div class="ttdoc">Removes the mapping for blocks contained in the region and values defined in these blocks...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00406">ModuleTranslation.cpp:406</a></div></div>
<div class="ttc" id="classmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition:</b> <a href="Location_8h_source.html#l00048">Location.h:48</a></div></div>
<div class="ttc" id="classmlir_1_1NamedAttribute_html"><div class="ttname"><a href="classmlir_1_1NamedAttribute.html">mlir::NamedAttribute</a></div><div class="ttdoc">NamedAttribute represents a combination of a name and an Attribute value. </div><div class="ttdef"><b>Definition:</b> <a href="Attributes_8h_source.html#l00144">Attributes.h:144</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_aeb828d7be807860f497206190a9de766"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#aeb828d7be807860f497206190a9de766">mlir::LLVM::detail::createIntrinsicCall</a></div><div class="ttdeci">llvm::Value * createIntrinsicCall(llvm::IRBuilderBase &amp;builder, llvm::Intrinsic::ID intrinsic, ArrayRef&lt; llvm::Value *&gt; args={}, ArrayRef&lt; llvm::Type *&gt; tys={})</div><div class="ttdoc">Creates a call to an LLVM IR intrinsic function with the given arguments. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00533">ModuleTranslation.cpp:533</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html">mlir::LLVM::ModuleTranslation</a></div><div class="ttdoc">Implementation class for module translation. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00051">ModuleTranslation.h:51</a></div></div>
<div class="ttc" id="DebugTranslation_8h_html"><div class="ttname"><a href="DebugTranslation_8h.html">DebugTranslation.h</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a6148c9c026c28a65985dad975c0106ef"><div class="ttname"><a href="classmlir_1_1Operation.html#a6148c9c026c28a65985dad975c0106ef">mlir::Operation::getContext</a></div><div class="ttdeci">MLIRContext * getContext()</div><div class="ttdoc">Return the context this operation is associated with. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00154">Operation.h:154</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_afa2f691e00650388c78f61c834d54b31"><div class="ttname"><a href="ModuleTranslation_8cpp.html#afa2f691e00650388c78f61c834d54b31">forwardPassthroughAttributes</a></div><div class="ttdeci">static LogicalResult forwardPassthroughAttributes(Location loc, Optional&lt; ArrayAttr &gt; attributes, llvm::Function *llvmFunc)</div><div class="ttdoc">Attaches the attributes listed in the given array attribute to llvmFunc. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00773">ModuleTranslation.cpp:773</a></div></div>
<div class="ttc" id="namespacemlir_html_a5f55c06c7c4aeace3f6824dd68f8b1ed"><div class="ttname"><a href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">mlir::success</a></div><div class="ttdeci">LogicalResult success(bool isSuccess=true)</div><div class="ttdoc">Utility function to generate a LogicalResult. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00056">LogicalResult.h:56</a></div></div>
<div class="ttc" id="structmlir_1_1LogicalResult_html"><div class="ttname"><a href="structmlir_1_1LogicalResult.html">mlir::LogicalResult</a></div><div class="ttdoc">This class represents an efficient way to signal success or failure. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00026">LogicalResult.h:26</a></div></div>
<div class="ttc" id="namespacemlir_html_a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><div class="ttname"><a href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">mlir::failure</a></div><div class="ttdeci">LogicalResult failure(bool isFailure=true)</div><div class="ttdoc">Utility function to generate a LogicalResult. </div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00062">LogicalResult.h:62</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a75dd84d365c4e04f975610b0d88ca301"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a75dd84d365c4e04f975610b0d88ca301">checkedAddLLVMFnAttribute</a></div><div class="ttdeci">static LogicalResult checkedAddLLVMFnAttribute(Location loc, llvm::Function *llvmFunc, StringRef key, StringRef value=StringRef())</div><div class="ttdoc">Attempts to add an attribute identified by key, optionally with the given value to LLVM function llvm...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00733">ModuleTranslation.cpp:733</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_html_ab597122c73cb66c5d56f486ef85d9c6e"><div class="ttname"><a href="namespacemlir_1_1LLVM.html#ab597122c73cb66c5d56f486ef85d9c6e">mlir::LLVM::isCompatibleType</a></div><div class="ttdeci">bool isCompatibleType(Type type)</div><div class="ttdoc">Returns true if the given type is compatible with the LLVM dialect. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTypes_8cpp_source.html#l00778">LLVMTypes.cpp:778</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00044">LLVM.h:44</a></div></div>
<div class="ttc" id="BuiltinOps_8h_html"><div class="ttname"><a href="BuiltinOps_8h.html">BuiltinOps.h</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a32a340b8b2384ce2a2bb9e3e56890459"><div class="ttname"><a href="classmlir_1_1Operation.html#a32a340b8b2384ce2a2bb9e3e56890459">mlir::Operation::getSuccessor</a></div><div class="ttdeci">Block * getSuccessor(unsigned index)</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00505">Operation.h:505</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a5e74389f9630f54b6fdb23dba37e247e"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a5e74389f9630f54b6fdb23dba37e247e">buildSequentialConstant</a></div><div class="ttdeci">static llvm::Constant * buildSequentialConstant(ArrayRef&lt; llvm::Constant *&gt; &amp;constants, ArrayRef&lt; int64_t &gt; shape, llvm::Type *type, Location loc)</div><div class="ttdoc">Builds a constant of a sequential LLVM type type, potentially containing other sequential types recur...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00132">ModuleTranslation.cpp:132</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html_a99e4974818075f520c020901166400e5"><div class="ttname"><a href="classmlir_1_1Region.html#a99e4974818075f520c020901166400e5">mlir::Region::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00055">Region.h:55</a></div></div>
<div class="ttc" id="classmlir_1_1FailureOr_html"><div class="ttname"><a href="classmlir_1_1FailureOr.html">mlir::FailureOr</a></div><div class="ttdoc">This class provides support for representing a failure result, or a valid value of type T...</div><div class="ttdef"><b>Definition:</b> <a href="LogicalResult_8h_source.html#l00077">LogicalResult.h:77</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html">mlir::DenseElementsAttr</a></div><div class="ttdoc">An attribute that represents a reference to a dense vector or tensor object. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8h_source.html#l00071">BuiltinAttributes.h:71</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a22a0bdbdbbc9cfc1248bbaf6fc7d3037"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a22a0bdbdbbc9cfc1248bbaf6fc7d3037">convertDenseElementsAttr</a></div><div class="ttdeci">static llvm::Constant * convertDenseElementsAttr(Location loc, DenseElementsAttr denseElementsAttr, llvm::Type *llvmType, const ModuleTranslation &amp;moduleTranslation)</div><div class="ttdoc">Convert a dense elements attribute to an LLVM IR constant using its raw data storage if possible...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00187">ModuleTranslation.cpp:187</a></div></div>
<div class="ttc" id="classmlir_1_1LLVMTranslationDialectInterface_html"><div class="ttname"><a href="classmlir_1_1LLVMTranslationDialectInterface.html">mlir::LLVMTranslationDialectInterface</a></div><div class="ttdoc">Base class for dialect interfaces providing translation to LLVM IR. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTranslationInterface_8h_source.html#l00035">LLVMTranslationInterface.h:35</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a36a0cff8c8e12f67fc2ea56086b5a8a9"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a36a0cff8c8e12f67fc2ea56086b5a8a9">mlir::LLVM::ModuleTranslation::lookupBranch</a></div><div class="ttdeci">llvm::Instruction * lookupBranch(Operation *op) const</div><div class="ttdoc">Finds an LLVM IR instruction that corresponds to the given MLIR operation with successors. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00112">ModuleTranslation.h:112</a></div></div>
<div class="ttc" id="namespacemlir_1_1function__interface__impl_html_ac057283bc2c0fc26ed27a77de7c9f594"><div class="ttname"><a href="namespacemlir_1_1function__interface__impl.html#ac057283bc2c0fc26ed27a77de7c9f594">mlir::function_interface_impl::getFunctionType</a></div><div class="ttdeci">Type getFunctionType(Builder &amp;builder, ArrayRef&lt; OpAsmParser::Argument &gt; argAttrs, ArrayRef&lt; Type &gt; resultTypes)</div><div class="ttdoc">Get a function type corresponding to an array of arguments (which have types) and a set of result typ...</div></div>
<div class="ttc" id="classmlir_1_1Type_html_a6b8d33d03b9736dfcc3cc0e9351b1826"><div class="ttname"><a href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">mlir::Type::dyn_cast</a></div><div class="ttdeci">U dyn_cast() const</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Types_8h_source.html#l00244">Types.h:244</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a282b6551a40ded04aea6c3c0359230af"><div class="ttname"><a href="classmlir_1_1Block.html#a282b6551a40ded04aea6c3c0359230af">mlir::Block::getNumArguments</a></div><div class="ttdeci">unsigned getNumArguments()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00119">Block.h:119</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html_a6814d418f6b952cd05a1fec9ca35ca0b"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html#a6814d418f6b952cd05a1fec9ca35ca0b">mlir::DenseElementsAttr::getRawData</a></div><div class="ttdeci">ArrayRef&lt; char &gt; getRawData() const</div><div class="ttdoc">Return the raw storage data held by this attribute. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8cpp_source.html#l00947">BuiltinAttributes.cpp:947</a></div></div>
<div class="ttc" id="classmlir_1_1Attribute_html"><div class="ttname"><a href="classmlir_1_1Attribute.html">mlir::Attribute</a></div><div class="ttdoc">Attributes are known-constant values of operations. </div><div class="ttdef"><b>Definition:</b> <a href="Attributes_8h_source.html#l00024">Attributes.h:24</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a8d9761f2b79a46d10ffb6ba28880cc2f"><div class="ttname"><a href="classmlir_1_1Operation.html#a8d9761f2b79a46d10ffb6ba28880cc2f">mlir::Operation::getParentOp</a></div><div class="ttdeci">Operation * getParentOp()</div><div class="ttdoc">Returns the closest surrounding operation that contains this operation or nullptr if this is a top-le...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00172">Operation.h:172</a></div></div>
<div class="ttc" id="namespacemlir_1_1detail_html_a7146031ab7f6bb4cdacc53c4f1e96aac"><div class="ttname"><a href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">mlir::detail::enumerate</a></div><div class="ttdeci">constexpr void enumerate(std::tuple&lt; Tys... &gt; &amp;tuple, CallbackT &amp;&amp;callback)</div><div class="ttdef"><b>Definition:</b> <a href="Matchers_8h_source.html#l00234">Matchers.h:234</a></div></div>
<div class="ttc" id="classmlir_1_1DataLayout_html_a4d5abbdc0d7af8cb3db2081eb6184fda"><div class="ttname"><a href="classmlir_1_1DataLayout.html#a4d5abbdc0d7af8cb3db2081eb6184fda">mlir::DataLayout::getTypeABIAlignment</a></div><div class="ttdeci">unsigned getTypeABIAlignment(Type t) const</div><div class="ttdoc">Returns the required alignment of the given type in the current scope. </div><div class="ttdef"><b>Definition:</b> <a href="DataLayoutInterfaces_8cpp_source.html#l00435">DataLayoutInterfaces.cpp:435</a></div></div>
<div class="ttc" id="LLVMDialect_8h_html"><div class="ttname"><a href="LLVMDialect_8h.html">LLVMDialect.h</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a56f58b55c803b3313da7b4a04a3d542d"><div class="ttname"><a href="classmlir_1_1Operation.html#a56f58b55c803b3313da7b4a04a3d542d">mlir::Operation::getResult</a></div><div class="ttdeci">OpResult getResult(unsigned idx)</div><div class="ttdoc">Get the &amp;#39;idx&amp;#39;th result of this operation. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00330">Operation.h:330</a></div></div>
<div class="ttc" id="namespacemlir_html_afca33cad5b0cd935568ea0fc0a439abd"><div class="ttname"><a href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mlir::mod</a></div><div class="ttdeci">int64_t mod(int64_t lhs, int64_t rhs)</div><div class="ttdoc">Returns MLIR&amp;#39;s mod operation on constants. </div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00045">MathExtras.h:45</a></div></div>
<div class="ttc" id="LLVMTranslationInterface_8h_html"><div class="ttname"><a href="LLVMTranslationInterface_8h.html">LLVMTranslationInterface.h</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a6c0b8ce5ff714a34f0192f3aa60dc7ea"><div class="ttname"><a href="classmlir_1_1Operation.html#a6c0b8ce5ff714a34f0192f3aa60dc7ea">mlir::Operation::getLoc</a></div><div class="ttdeci">Location getLoc()</div><div class="ttdoc">The source location the operation was defined or derived from. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00161">Operation.h:161</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a632d2064f862636b251e13dd7773cddc"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a632d2064f862636b251e13dd7773cddc">addRuntimePreemptionSpecifier</a></div><div class="ttdeci">static void addRuntimePreemptionSpecifier(bool dsoLocalRequested, llvm::GlobalValue *gv)</div><div class="ttdoc">Sets the runtime preemption specifier of gv to dso_local if dsoLocalRequested is true, otherwise it is left unchanged. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00625">ModuleTranslation.cpp:625</a></div></div>
<div class="ttc" id="classmlir_1_1SuccessorOperands_html"><div class="ttname"><a href="classmlir_1_1SuccessorOperands.html">mlir::SuccessorOperands</a></div><div class="ttdoc">This class models how operands are forwarded to block arguments in control flow. </div><div class="ttdef"><b>Definition:</b> <a href="ControlFlowInterfaces_8h_source.html#l00043">ControlFlowInterfaces.h:43</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_aa0bf059f5c09c7cf227bb6df2e49d4ad"><div class="ttname"><a href="classmlir_1_1Block.html#aa0bf059f5c09c7cf227bb6df2e49d4ad">mlir::Block::getArguments</a></div><div class="ttdeci">BlockArgListType getArguments()</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00076">Block.h:76</a></div></div>
<div class="ttc" id="classmlir_1_1BlockArgument_html"><div class="ttname"><a href="classmlir_1_1BlockArgument.html">mlir::BlockArgument</a></div><div class="ttdoc">This class represents an argument of a Block. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00300">Value.h:300</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a440bf5dd2d26cd43111c69164407e762"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a440bf5dd2d26cd43111c69164407e762">getModuleBody</a></div><div class="ttdeci">static Block &amp; getModuleBody(Operation *module)</div><div class="ttdoc">A helper method to get the single Block in an operation honoring LLVM&amp;#39;s module requirements. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00608">ModuleTranslation.cpp:608</a></div></div>
<div class="ttc" id="ModuleTranslation_8h_html"><div class="ttname"><a href="ModuleTranslation_8h.html">ModuleTranslation.h</a></div></div>
<div class="ttc" id="classmlir_1_1TensorType_html"><div class="ttname"><a href="classmlir_1_1TensorType.html">mlir::TensorType</a></div><div class="ttdoc">Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and Unranked...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinTypes_8h_source.html#l00077">BuiltinTypes.h:77</a></div></div>
<div class="ttc" id="classmlir_1_1LLVMTranslationDialectInterface_html_abd0cfc66f4647b5b8f6dc7fd326516a1"><div class="ttname"><a href="classmlir_1_1LLVMTranslationDialectInterface.html#abd0cfc66f4647b5b8f6dc7fd326516a1">mlir::LLVMTranslationDialectInterface::convertOperation</a></div><div class="ttdeci">virtual LogicalResult convertOperation(Operation *op, llvm::IRBuilderBase &amp;builder, LLVM::ModuleTranslation &amp;moduleTranslation) const</div><div class="ttdoc">Hook for derived dialect interface to provide translation of the operations to LLVM IR...</div><div class="ttdef"><b>Definition:</b> <a href="LLVMTranslationInterface_8h_source.html#l00043">LLVMTranslationInterface.h:43</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_html_a847e84be7235275135237a48a9813be9"><div class="ttname"><a href="namespacemlir_1_1LLVM.html#a847e84be7235275135237a48a9813be9">mlir::LLVM::satisfiesLLVMModule</a></div><div class="ttdeci">bool satisfiesLLVMModule(Operation *op)</div><div class="ttdoc">LLVM requires some operations to be inside of a Module operation. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMDialect_8cpp_source.html#l02837">LLVMDialect.cpp:2837</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a803e34fd6fc83280874ceeb3558f6f4a"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a803e34fd6fc83280874ceeb3558f6f4a">mlir::LLVM::ModuleTranslation::setAliasScopeMetadata</a></div><div class="ttdeci">void setAliasScopeMetadata(Operation *op, llvm::Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01048">ModuleTranslation.cpp:1048</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a077b1182e55dd26f2e921fdce534aa38"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a077b1182e55dd26f2e921fdce534aa38">mlir::LLVM::ModuleTranslation::lookupValue</a></div><div class="ttdeci">llvm::Value * lookupValue(Value value) const</div><div class="ttdoc">Finds an LLVM IR value corresponding to the given MLIR value. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00082">ModuleTranslation.h:82</a></div></div>
<div class="ttc" id="classmlir_1_1Type_html"><div class="ttname"><a href="classmlir_1_1Type.html">mlir::Type</a></div><div class="ttdoc">Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Types_8h_source.html#l00072">Types.h:72</a></div></div>
<div class="ttc" id="classmlir_1_1SymbolTable_html_ab2bbdb2e223faba1e86134740ca16122"><div class="ttname"><a href="classmlir_1_1SymbolTable.html#ab2bbdb2e223faba1e86134740ca16122">mlir::SymbolTable::lookupNearestSymbolFrom</a></div><div class="ttdeci">static Operation * lookupNearestSymbolFrom(Operation *from, StringAttr symbol)</div><div class="ttdoc">Returns the operation registered with the given symbol name within the closest parent operation of...</div><div class="ttdef"><b>Definition:</b> <a href="SymbolTable_8cpp_source.html#l00370">SymbolTable.cpp:370</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_aa97683e2f1d71cb0815811351c035d9c"><div class="ttname"><a href="ModuleTranslation_8cpp.html#aa97683e2f1d71cb0815811351c035d9c">prepareLLVMModule</a></div><div class="ttdeci">static std::unique_ptr&lt; llvm::Module &gt; prepareLLVMModule(Operation *m, llvm::LLVMContext &amp;llvmContext, StringRef name)</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l01093">ModuleTranslation.cpp:1093</a></div></div>
<div class="ttc" id="DLTI_8h_html"><div class="ttname"><a href="DLTI_8h.html">DLTI.h</a></div></div>
<div class="ttc" id="classmlir_1_1DataLayout_html_a525f9e65851b765eddc7efd767056f82"><div class="ttname"><a href="classmlir_1_1DataLayout.html#a525f9e65851b765eddc7efd767056f82">mlir::DataLayout::getTypeSizeInBits</a></div><div class="ttdeci">unsigned getTypeSizeInBits(Type t) const</div><div class="ttdoc">Returns the size in bits of the given type in the current scope. </div><div class="ttdef"><b>Definition:</b> <a href="DataLayoutInterfaces_8cpp_source.html#l00423">DataLayoutInterfaces.cpp:423</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_a2b966f440106b35eb828bab13414c55b"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#a2b966f440106b35eb828bab13414c55b">mlir::LLVM::detail::connectPHINodes</a></div><div class="ttdeci">void connectPHINodes(Region &amp;region, const ModuleTranslation &amp;state)</div><div class="ttdoc">For all blocks in the region that were converted to LLVM IR using the given ModuleTranslation, connect the PHI nodes of the corresponding LLVM IR blocks to the results of preceding blocks. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00484">ModuleTranslation.cpp:484</a></div></div>
<div class="ttc" id="classmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00085">Value.h:85</a></div></div>
<div class="ttc" id="classmlir_1_1SplatElementsAttr_html"><div class="ttname"><a href="classmlir_1_1SplatElementsAttr.html">mlir::SplatElementsAttr</a></div><div class="ttdoc">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the ele...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8h_source.html#l00727">BuiltinAttributes.h:727</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSet_html"><div class="ttname"><a href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00058">LLVM.h:58</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a091473715bf4679f1f429f317067664c"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a091473715bf4679f1f429f317067664c">getPHISourceValue</a></div><div class="ttdeci">static Value getPHISourceValue(Block *current, Block *pred, unsigned numArguments, unsigned index)</div><div class="ttdoc">Get the SSA value passed to the current block from the terminator operation of its predecessor...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00433">ModuleTranslation.cpp:433</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00060">LLVM.h:60</a></div></div>
<div class="ttc" id="classmlir_1_1Block_html_a7e0b0c445d4e1e011fef4a1e59bcd118"><div class="ttname"><a href="classmlir_1_1Block.html#a7e0b0c445d4e1e011fef4a1e59bcd118">mlir::Block::getTerminator</a></div><div class="ttdeci">Operation * getTerminator()</div><div class="ttdoc">Get the terminator operation of this block. </div><div class="ttdef"><b>Definition:</b> <a href="Block_8cpp_source.html#l00230">Block.cpp:230</a></div></div>
<div class="ttc" id="classmlir_1_1MLIRContext_html_ae50174cfadfa2e812f35d86f2942edf7"><div class="ttname"><a href="classmlir_1_1MLIRContext.html#ae50174cfadfa2e812f35d86f2942edf7">mlir::MLIRContext::getOrLoadDialect</a></div><div class="ttdeci">T * getOrLoadDialect()</div><div class="ttdoc">Get (or create) a dialect for the given derived dialect type. </div><div class="ttdef"><b>Definition:</b> <a href="MLIRContext_8h_source.html#l00092">MLIRContext.h:92</a></div></div>
<div class="ttc" id="namespacemlir_html_a4e96b0c437652eb5a4890734bb6bcee7"><div class="ttname"><a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">mlir::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(Location loc)</div><div class="ttdoc">Utility method to emit an error message using this location. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Diagnostics_8cpp_source.html#l00322">Diagnostics.cpp:322</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_aba58c7951025308aaefccac54a0ae344"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#aba58c7951025308aaefccac54a0ae344">mlir::LLVM::ModuleTranslation::lookupFunction</a></div><div class="ttdeci">llvm::Function * lookupFunction(StringRef name) const</div><div class="ttdoc">Finds an LLVM IR function by its name. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8h_source.html#l00065">ModuleTranslation.h:65</a></div></div>
<div class="ttc" id="classmlir_1_1Value_html_a5348fc13d5201e2adf7ded6b4b2fb1ad"><div class="ttname"><a href="classmlir_1_1Value.html#a5348fc13d5201e2adf7ded6b4b2fb1ad">mlir::Value::getType</a></div><div class="ttdeci">Type getType() const</div><div class="ttdoc">Return the type of this value. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00118">Value.h:118</a></div></div>
<div class="ttc" id="classmlir_1_1Region_html_a7f33d2ab93ce37e650b6a4d2aded0883"><div class="ttname"><a href="classmlir_1_1Region.html#a7f33d2ab93ce37e650b6a4d2aded0883">mlir::Region::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Region_8h_source.html#l00056">Region.h:56</a></div></div>
<div class="ttc" id="classmlir_1_1DataLayout_html_a54192cee619ca92ee41a46972a96580f"><div class="ttname"><a href="classmlir_1_1DataLayout.html#a54192cee619ca92ee41a46972a96580f">mlir::DataLayout::getTypePreferredAlignment</a></div><div class="ttdeci">unsigned getTypePreferredAlignment(Type t) const</div><div class="ttdoc">Returns the preferred of the given type in the current scope. </div><div class="ttdef"><b>Definition:</b> <a href="DataLayoutInterfaces_8cpp_source.html#l00447">DataLayoutInterfaces.cpp:447</a></div></div>
<div class="ttc" id="classmlir_1_1Attribute_html_a23ec00c1bbd929f6b8a5031d617324b0"><div class="ttname"><a href="classmlir_1_1Attribute.html#a23ec00c1bbd929f6b8a5031d617324b0">mlir::Attribute::dyn_cast</a></div><div class="ttdeci">U dyn_cast() const</div><div class="ttdef"><b>Definition:</b> <a href="Attributes_8h_source.html#l00124">Attributes.h:124</a></div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1ModuleTranslation_html_a75944e2cf496e0aaf42f87ea661afaa5"><div class="ttname"><a href="classmlir_1_1LLVM_1_1ModuleTranslation.html#a75944e2cf496e0aaf42f87ea661afaa5">mlir::LLVM::ModuleTranslation::getAccessGroup</a></div><div class="ttdeci">llvm::MDNode * getAccessGroup(Operation &amp;opInst, SymbolRefAttr accessGroupRef) const</div><div class="ttdoc">Returns the LLVM metadata corresponding to a reference to an mlir LLVM dialect access group operation...</div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00956">ModuleTranslation.cpp:956</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html_ada0ca08d24a9978d5465be28eba253f0"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html#ada0ca08d24a9978d5465be28eba253f0">mlir::LLVM::detail::getTopologicallySortedBlocks</a></div><div class="ttdeci">SetVector&lt; Block * &gt; getTopologicallySortedBlocks(Region &amp;region)</div><div class="ttdoc">Get a topologically sorted list of blocks of the given region. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00517">ModuleTranslation.cpp:517</a></div></div>
<div class="ttc" id="IR_2BuiltinTypes_8h_html"><div class="ttname"><a href="IR_2BuiltinTypes_8h.html">BuiltinTypes.h</a></div></div>
<div class="ttc" id="LegalizeForExport_8h_html"><div class="ttname"><a href="LegalizeForExport_8h.html">LegalizeForExport.h</a></div></div>
<div class="ttc" id="namespacemlir_html_adc149979459c3123124db882fb765dba"><div class="ttname"><a href="namespacemlir.html#adc149979459c3123124db882fb765dba">mlir::translateModuleToLLVMIR</a></div><div class="ttdeci">std::unique_ptr&lt; llvm::Module &gt; translateModuleToLLVMIR(Operation *module, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;)</div><div class="ttdoc">Translate operation that satisfies LLVM dialect module requirements into an LLVM IR module living in ...</div></div>
<div class="ttc" id="classmlir_1_1LLVM_1_1LLVMPointerType_html"><div class="ttname"><a href="classmlir_1_1LLVM_1_1LLVMPointerType.html">mlir::LLVM::LLVMPointerType</a></div><div class="ttdoc">LLVM dialect pointer type. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMTypes_8h_source.html#l00182">LLVMTypes.h:182</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html_a45eabfa2aa1c4da62c050b8c6f923553"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html#a45eabfa2aa1c4da62c050b8c6f923553">mlir::DenseElementsAttr::getNumElements</a></div><div class="ttdeci">int64_t getNumElements() const</div><div class="ttdoc">Returns the number of elements held by this attribute. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8cpp_source.html#l01018">BuiltinAttributes.cpp:1018</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_1_1detail_html"><div class="ttname"><a href="namespacemlir_1_1LLVM_1_1detail.html">mlir::LLVM::detail</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00019">Pattern.h:19</a></div></div>
<div class="ttc" id="TypeToLLVM_8h_html"><div class="ttname"><a href="TypeToLLVM_8h.html">TypeToLLVM.h</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_ab7c043033c648c675874eb3e579ca842"><div class="ttname"><a href="classmlir_1_1Operation.html#ab7c043033c648c675874eb3e579ca842">mlir::Operation::getDialectAttrs</a></div><div class="ttdeci">dialect_attr_range getDialectAttrs()</div><div class="ttdoc">Return a range corresponding to the dialect attributes for this operation. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00444">Operation.h:444</a></div></div>
<div class="ttc" id="OpenMPDialect_8h_html"><div class="ttname"><a href="OpenMPDialect_8h.html">OpenMPDialect.h</a></div></div>
<div class="ttc" id="namespacemlir_html_a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"><div class="ttname"><a href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">mlir::AffineExprKind::Constant</a></div><div class="ttdoc">Constant integer. </div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_html_adb7597cb2576197146fcb4c2272cfd04"><div class="ttname"><a href="namespacemlir_1_1LLVM.html#adb7597cb2576197146fcb4c2272cfd04">mlir::LLVM::ensureDistinctSuccessors</a></div><div class="ttdeci">void ensureDistinctSuccessors(Operation *op)</div><div class="ttdoc">Make argument-taking successors of each block distinct. </div><div class="ttdef"><b>Definition:</b> <a href="LegalizeForExport_8cpp_source.html#l00059">LegalizeForExport.cpp:59</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_ab2e11ba83ff765eb7595554f97aaaa75"><div class="ttname"><a href="classmlir_1_1Operation.html#ab2e11ba83ff765eb7595554f97aaaa75">mlir::Operation::getName</a></div><div class="ttdeci">OperationName getName()</div><div class="ttdoc">The name of an operation is the key identifier for it. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00057">Operation.h:57</a></div></div>
<div class="ttc" id="classllvm_1_1SetVector_html"><div class="ttname"><a href="classllvm_1_1SetVector.html">llvm::SetVector</a></div><div class="ttdef"><b>Definition:</b> <a href="Support_2LLVM_8h_source.html#l00057">LLVM.h:57</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html_a5a415aaf672c2a9a8559335b29c31284"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">mlir::DenseElementsAttr::isSplat</a></div><div class="ttdeci">bool isSplat() const</div><div class="ttdoc">Returns true if this attribute corresponds to a splat, i.e. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8cpp_source.html#l00877">BuiltinAttributes.cpp:877</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a919e866989c544204210029d45e45e49"><div class="ttname"><a href="classmlir_1_1Operation.html#a919e866989c544204210029d45e45e49">mlir::Operation::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(const Twine &amp;message={})</div><div class="ttdoc">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers tha...</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8cpp_source.html#l00231">Operation.cpp:231</a></div></div>
<div class="ttc" id="classmlir_1_1DenseElementsAttr_html_a49be83cff03233289860200183e528f7"><div class="ttname"><a href="classmlir_1_1DenseElementsAttr.html#a49be83cff03233289860200183e528f7">mlir::DenseElementsAttr::getSplatValue</a></div><div class="ttdeci">std::enable_if&lt;!std::is_base_of&lt; Attribute, T &gt;::value||std::is_same&lt; Attribute, T &gt;::value, T &gt;::type getSplatValue() const</div><div class="ttdoc">Return the splat value for this attribute. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2BuiltinAttributes_8h_source.html#l00382">BuiltinAttributes.h:382</a></div></div>
<div class="ttc" id="classmlir_1_1ValueRange_html"><div class="ttname"><a href="classmlir_1_1ValueRange.html">mlir::ValueRange</a></div><div class="ttdoc">This class provides an abstraction over the different types of ranges over Values. </div><div class="ttdef"><b>Definition:</b> <a href="OperationSupport_8h_source.html#l01128">OperationSupport.h:1128</a></div></div>
<div class="ttc" id="RegionGraphTraits_8h_html"><div class="ttname"><a href="RegionGraphTraits_8h.html">RegionGraphTraits.h</a></div></div>
<div class="ttc" id="namespacemlir_1_1LLVM_html"><div class="ttname"><a href="namespacemlir_1_1LLVM.html">mlir::LLVM</a></div><div class="ttdef"><b>Definition:</b> <a href="GPUCommonPass_8h_source.html#l00037">GPUCommonPass.h:37</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_a2bd7667bca9e92550f5535379e382fb3"><div class="ttname"><a href="classmlir_1_1Operation.html#a2bd7667bca9e92550f5535379e382fb3">mlir::Operation::getAttr</a></div><div class="ttdeci">Attribute getAttr(StringAttr name)</div><div class="ttdoc">Return the specified attribute if present, null otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00377">Operation.h:377</a></div></div>
<div class="ttc" id="namespacemlir_html_a2f93379e5dbb5551bbe57170230a1d92"><div class="ttname"><a href="namespacemlir.html#a2f93379e5dbb5551bbe57170230a1d92">mlir::translateDataLayout</a></div><div class="ttdeci">DataLayoutSpecInterface translateDataLayout(const llvm::DataLayout &amp;dataLayout, MLIRContext *context)</div><div class="ttdoc">Translate the given LLVM data layout into an MLIR equivalent using the DLTI dialect. </div><div class="ttdef"><b>Definition:</b> <a href="ConvertFromLLVMIR_8cpp_source.html#l00094">ConvertFromLLVMIR.cpp:94</a></div></div>
<div class="ttc" id="classmlir_1_1Operation_html_aa01ae296df28a63def56ea015dea9929"><div class="ttname"><a href="classmlir_1_1Operation.html#aa01ae296df28a63def56ea015dea9929">mlir::Operation::getRegion</a></div><div class="ttdeci">Region &amp; getRegion(unsigned index)</div><div class="ttdoc">Returns the region held by this operation at position &amp;#39;index&amp;#39;. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00483">Operation.h:483</a></div></div>
<div class="ttc" id="classmlir_1_1DataLayout_html"><div class="ttname"><a href="classmlir_1_1DataLayout.html">mlir::DataLayout</a></div><div class="ttdoc">The main mechanism for performing data layout queries. </div><div class="ttdef"><b>Definition:</b> <a href="DataLayoutInterfaces_8h_source.html#l00141">DataLayoutInterfaces.h:141</a></div></div>
<div class="ttc" id="ModuleTranslation_8cpp_html_a9ad47513b43b960b9cc840b6e1fdc4e1"><div class="ttname"><a href="ModuleTranslation_8cpp.html#a9ad47513b43b960b9cc840b6e1fdc4e1">shouldDropGlobalInitializer</a></div><div class="ttdeci">static bool shouldDropGlobalInitializer(llvm::GlobalValue::LinkageTypes linkage, llvm::Constant *cst)</div><div class="ttdoc">A helper method to decide if a constant must not be set as a global variable initializer. </div><div class="ttdef"><b>Definition:</b> <a href="ModuleTranslation_8cpp_source.html#l00617">ModuleTranslation.cpp:617</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 4 2022 20:32:59 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
