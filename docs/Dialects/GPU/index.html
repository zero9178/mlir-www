<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'gpu' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/GPU/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'gpu' Dialect</h1><p>Note: this dialect is more likely to change than others in the near future; use
with caution.</p><p>This dialect provides middle-level abstractions for launching GPU kernels
following a programming model similar to that of CUDA or OpenCL. It provides
abstractions for kernel invocations (and may eventually provide those for device
management) that are not present at the lower level (e.g., as LLVM IR intrinsics
for GPUs). Its goal is to abstract away device- and driver-specific
manipulations to launch a GPU kernel and provide a simple path towards GPU
execution from MLIR. It may be targeted, for example, by DSLs using MLIR. The
dialect uses <code>gpu</code> as its canonical prefix.</p><h2 id=memory-attribution>Memory attribution&nbsp;<a class=headline-hash href=#memory-attribution>¶</a></h2><p>Memory buffers are defined at the function level, either in &ldquo;gpu.launch&rdquo; or in
&ldquo;gpu.func&rdquo; ops. This encoding makes it clear where the memory belongs and makes
the lifetime of the memory visible. The memory is only accessible while the
kernel is launched/the function is currently invoked. The latter is more strict
than actual GPU implementations but using static memory at the function level is
just for convenience. It is also always possible to pass pointers to the
workgroup memory into other functions, provided they expect the correct memory
space.</p><p>The buffers are considered live throughout the execution of the GPU function
body. The absence of memory attribution syntax means that the function does not
require special buffers. Rationale: although the underlying models declare
memory buffers at the module level, we chose to do it at the function level to
provide some structuring for the lifetime of those buffers; this avoids the
incentive to use the buffers for communicating between different kernels or
launches of the same kernel, which should be done through function arguments
instead; we chose not to use <code>alloca</code>-style approach that would require more
complex lifetime analysis following the principles of MLIR that promote
structure and representing analysis results in the IR.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=gpuall_reduce-mlirgpuallreduceop><code>gpu.all_reduce</code> (::mlir::gpu::AllReduceOp)&nbsp;<a class=headline-hash href=#gpuall_reduce-mlirgpuallreduceop>¶</a></h3><p>Reduce values among workgroup.</p><p>Syntax:</p><pre><code>operation ::= `gpu.all_reduce` custom&lt;AllReduceOperation&gt;($op) $value $body attr-dict
              `:` functional-type(operands, results)
</code></pre><p>The <code>all_reduce</code> op reduces the value of every work item across a local
workgroup. The result is equal for all work items of a workgroup.</p><p>For example, both</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce add <span class=nv>%0</span> <span class=p>{}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
<span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce <span class=nv>%0</span> <span class=p>{</span>
<span class=nl>^bb</span><span class=p>(</span><span class=nv>%lhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
  <span class=nv>%sum</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=s>&#34;gpu.yield&#34;</span><span class=p>(</span><span class=nv>%sum</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</code></pre></div><p>compute the sum of each work item&rsquo;s %0 value. The first version specifies
the accumulation as operation, whereas the second version specifies the
accumulation as code region. The accumulation operation must be one of:
<code>add</code>, <code>and</code>, <code>max</code>, <code>min</code>, <code>mul</code>, <code>or</code>, <code>xor</code>.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><p>Traits: IsolatedFromAbove, SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>op</code></td><td style=text-align:center>::mlir::gpu::AllReduceOperationAttr</td><td>built-in reduction operations supported by gpu.allreduce.</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=gpualloc-mlirgpuallocop><code>gpu.alloc</code> (::mlir::gpu::AllocOp)&nbsp;<a class=headline-hash href=#gpualloc-mlirgpuallocop>¶</a></h3><p>GPU memory allocation operation.</p><p>Syntax:</p><pre><code>operation ::= `gpu.alloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) ` `
              `(` $dynamicSizes `)` (`` `[` $symbolOperands^ `]`)? attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.alloc</code> operation allocates a region of memory on the GPU. It is
similar to the <code>memref.alloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it also returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%memref</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>alloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=p>(</span><span class=nv>%width</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>dynamicSizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>symbolOperands</code></td><td>index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpubarrier-mlirgpubarrierop><code>gpu.barrier</code> (::mlir::gpu::BarrierOp)&nbsp;<a class=headline-hash href=#gpubarrier-mlirgpubarrierop>¶</a></h3><p>Synchronizes all work items of a workgroup.</p><p>Syntax:</p><pre><code>operation ::= `gpu.barrier` attr-dict
</code></pre><p>The &ldquo;barrier&rdquo; op synchronizes all work items of a workgroup. It is used
to coordinate communication between the work items of the workgroup.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>barrier
</code></pre></div><p>waits until all work items in the workgroup have reached this point
and all memory accesses made by these work items prior to the op are
visible to all work items in the workgroup. Data hazards between work items
accessing the same memory can be avoided by synchronizing work items
in-between these accesses.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><h3 id=gpublock_dim-mlirgpublockdimop><code>gpu.block_dim</code> (::mlir::gpu::BlockDimOp)&nbsp;<a class=headline-hash href=#gpublock_dim-mlirgpublockdimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.block_dim` $dimension attr-dict
</code></pre><p>Returns the number of threads in the thread block (aka the block size) along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dimension</code></td><td style=text-align:center>::mlir::gpu::DimensionAttr</td><td>a dimension, either &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpublock_id-mlirgpublockidop><code>gpu.block_id</code> (::mlir::gpu::BlockIdOp)&nbsp;<a class=headline-hash href=#gpublock_id-mlirgpublockidop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.block_id` $dimension attr-dict
</code></pre><p>Returns the block id, i.e. the index of the current block within the grid
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dimension</code></td><td style=text-align:center>::mlir::gpu::DimensionAttr</td><td>a dimension, either &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpudealloc-mlirgpudeallocop><code>gpu.dealloc</code> (::mlir::gpu::DeallocOp)&nbsp;<a class=headline-hash href=#gpudealloc-mlirgpudeallocop>¶</a></h3><p>GPU memory deallocation operation</p><p>Syntax:</p><pre><code>operation ::= `gpu.dealloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $memref attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.dealloc</code> operation frees the region of memory referenced by a
memref which was originally created by the <code>gpu.alloc</code> operation. It is
similar to the <code>memref.dealloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>dealloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%memref</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudevice_async_copy-mlirgpudeviceasynccopyop><code>gpu.device_async_copy</code> (::mlir::gpu::DeviceAsyncCopyOp)&nbsp;<a class=headline-hash href=#gpudevice_async_copy-mlirgpudeviceasynccopyop>¶</a></h3><p>device-side asynchronous copy</p><p>Syntax:</p><pre><code>operation ::= `gpu.device_async_copy` $src `[` $srcIndices `]` `,` $dst `[` $dstIndices `]` `,` $numElements
              attr-dict `:` type($src) `to` type($dst)
</code></pre><p>The <code>gpu.device_async_copy</code> op initiates an asynchronous copy operation of
<code>$size</code> elements from source to the destination without blocking the thread.
The destination has to be in shared memory.</p><p>This is memory access will be pending to be added to a group.</p><p>This op is meant to be used with <code>gpu.device_async_create_group</code> and
<code>gpu.device_async_wait</code> to synchronize copies as explained in those ops
descriptions.</p><p>In order to do a copy and wait for the result we need the following
combination:</p><pre><code>// copy 1.
%cp1 = gpu.device_async_copy %A[%c0], %B[%c0], 4 :memref&lt;16xf32&gt; to memref&lt;16xf32, 3&gt;
// copy 2.
%cp2 = gpu.device_async_copy %C[%c0], %D[%c0], 4 : memref&lt;16xf32&gt; to memref&lt;16xf32, 3&gt;
// group 1 contains copy 1 and copy 2.
%token1 = gpu.device_async_create_group %cp1, %cp2
// copy 3.
%cp3 = gpu.device_async_copy %E[%c0], %F[%c0], 4 : memref&lt;16xf32&gt; to memref&lt;16xf32, 3&gt;
// group 2 contains copy 3.
%token2 = gpu.device_async_create_group %cp3
// after the wait copy 1 and copy 2 are complete.
gpu.device_async_wait %token1
// after the wait copy 3 is complete.
gpu.device_async_wait %token2
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>device_async_copy <span class=nv>%src</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>],</span> <span class=m>4</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x5x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x7x5x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>numElements</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>dstIndices</code></td><td>index</td></tr><tr><td style=text-align:center><code>src</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>srcIndices</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>device async token type</td></tr></tbody></table><h3 id=gpudevice_async_create_group-mlirgpudeviceasynccreategroupop><code>gpu.device_async_create_group</code> (::mlir::gpu::DeviceAsyncCreateGroupOp)&nbsp;<a class=headline-hash href=#gpudevice_async_create_group-mlirgpudeviceasynccreategroupop>¶</a></h3><p>device side asynchronous create group operation</p><p>Syntax:</p><pre><code>operation ::= `gpu.device_async_create_group` $inputTokens attr-dict
</code></pre><p>The <code>gpu.device_async_create_group</code> op creates a group of memory accesses
containing all the pending <code>device_async_copy</code> operations associated with
argument tokens. Each token can only be part of one group.</p><p>It returns a token that can be use to wait until the group fully completes.</p><p>This is meant to be used with <code>gpu.device_async_wait</code> to synchronize copies
as explained in those ops descriptions.</p><p>Groups are executed in the order they are created.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>device_async_create_group
</code></pre></div><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputTokens</code></td><td>device async token type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>device async token type</td></tr></tbody></table><h3 id=gpudevice_async_wait-mlirgpudeviceasyncwaitop><code>gpu.device_async_wait</code> (::mlir::gpu::DeviceAsyncWaitOp)&nbsp;<a class=headline-hash href=#gpudevice_async_wait-mlirgpudeviceasyncwaitop>¶</a></h3><p>Wait for async gpu ops to complete.</p><p>Syntax:</p><pre><code>operation ::= `gpu.device_async_wait` $asyncDependencies attr-dict
</code></pre><p>The <code>gpu.device_async_wait</code> op will block the execution thread until the group
associated with the source token is fully completed.</p><p>The optional <code>$numGroup</code> attribute gives a lower bound of the number of
groups uncompleted when the wait can unblock the thread.
Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>device_async_wait <span class=nv>%0</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>numGroups</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>device async token type</td></tr></tbody></table><h3 id=gpufunc-mlirgpugpufuncop><code>gpu.func</code> (::mlir::gpu::GPUFuncOp)&nbsp;<a class=headline-hash href=#gpufunc-mlirgpugpufuncop>¶</a></h3><p>Function executable on a GPU</p><p>Defines a function that can be executed on a GPU. This supports memory
attribution and its body has a particular execution model.</p><p>GPU functions are either kernels (as indicated by the <code>kernel</code> attribute) or
regular functions. The former can be launched from the host side, while the
latter are device side only.</p><p>The memory attribution defines SSA values that correspond to memory buffers
allocated in the memory hierarchy of the GPU (see below).</p><p>The operation has one attached region that corresponds to the body of the
function. The region arguments consist of the function arguments without
modification, followed by buffers defined in memory annotations. The body of
a GPU function, when launched, is executed by multiple work items. There are
no guarantees on the order in which work items execute, or on the connection
between them. In particular, work items are not necessarily executed in
lock-step. Synchronization ops such as &ldquo;gpu.barrier&rdquo; should be used to
coordinate work items. Declarations of GPU functions, i.e. not having the
body region, are not supported.</p><p>Syntax:</p><pre><code>op ::= `gpu.func` symbol-ref-id `(` argument-list `)` (`-&gt;`
function-result-list)?
       memory-attribution `kernel`? function-attributes? region

memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
    workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;)</span>
    private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;)</span>
    kernel
    attributes <span class=p>{</span>qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>{</span>
  gpu<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>The generic form illustrates the concept</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=s>&#34;gpu.func&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>sym_name<span class=p>:</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> kernel<span class=p>,</span> qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>({</span>
<span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span>
     <span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;):</span>
  <span class=s>&#34;gpu.return&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=p>})</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><p>Note the non-default memory spaces used in memref types in memory
attribution.</p><p>Traits: AutomaticAllocationScope, HasParent<gpumoduleop>, IsolatedFromAbove</p><p>Interfaces: FunctionOpInterface, Symbol</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>function_type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>type attribute of function type</td></tr></tbody></table><h3 id=gpumodule-mlirgpugpumoduleop><code>gpu.module</code> (::mlir::gpu::GPUModuleOp)&nbsp;<a class=headline-hash href=#gpumodule-mlirgpugpumoduleop>¶</a></h3><p>A top level compilation unit containing code to be run on a GPU.</p><p>GPU module contains code that is intended to be run on a GPU. A host device
can launch this code through a gpu.launc_func that creates a fully
qualified symbol through the gpu.module&rsquo;s symbol and a gpu.func symbol
contained in the gpu.module.</p><p>The module&rsquo;s top-level scope is modeled by a single region with a single
block. GPU modules are required to have a name that is used for symbol
resolution by the gpu.launch_func operation.</p><p>Using an op with a region to define a GPU module enables &ldquo;embedding&rdquo; GPU
modules with SIMT execution models in other dialects in a clean manner and
allows filtering of code regions to execute passes on only code intended to
or not intended to be run on the separate device.</p><pre><code>  gpu.module @symbol_name {
  gpu.func {}
    ...
  gpu.module_end
}

</code></pre><p>Traits: HasDefaultDLTIDataLayout, IsolatedFromAbove, SingleBlockImplicitTerminator<moduleendop>, SymbolTable</p><p>Interfaces: DataLayoutOpInterface, Symbol</p><h3 id=gpuglobal_id-mlirgpuglobalidop><code>gpu.global_id</code> (::mlir::gpu::GlobalIdOp)&nbsp;<a class=headline-hash href=#gpuglobal_id-mlirgpuglobalidop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.global_id` $dimension attr-dict
</code></pre><p>Returns the unique global workitem/thread id, i.e., the unique index of the
current workitem/thread within all workgroups / grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%gidX</span> <span class=p>=</span> gpu<span class=p>.</span>global_id <span class=p>x</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dimension</code></td><td style=text-align:center>::mlir::gpu::DimensionAttr</td><td>a dimension, either &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpugrid_dim-mlirgpugriddimop><code>gpu.grid_dim</code> (::mlir::gpu::GridDimOp)&nbsp;<a class=headline-hash href=#gpugrid_dim-mlirgpugriddimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.grid_dim` $dimension attr-dict
</code></pre><p>Returns the number of thread blocks in the grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dimension</code></td><td style=text-align:center>::mlir::gpu::DimensionAttr</td><td>a dimension, either &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuhost_register-mlirgpuhostregisterop><code>gpu.host_register</code> (::mlir::gpu::HostRegisterOp)&nbsp;<a class=headline-hash href=#gpuhost_register-mlirgpuhostregisterop>¶</a></h3><p>Registers a memref for access from device.</p><p>Syntax:</p><pre><code>operation ::= `gpu.host_register` $value attr-dict `:` type($value)
</code></pre><p>This op maps the provided host buffer into the device address space.</p><p>This operation may not be supported in every environment, there is not yet a
way to check at runtime whether this feature is supported.</p><p>Writes from the host are guaranteed to be visible to device kernels that are
launched afterwards. Writes from the device are guaranteed to be visible on
the host after synchronizing with the device kernel completion.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>unranked.memref of any type values</td></tr></tbody></table><h3 id=gpulane_id-mlirgpulaneidop><code>gpu.lane_id</code> (::mlir::gpu::LaneIdOp)&nbsp;<a class=headline-hash href=#gpulane_id-mlirgpulaneidop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.lane_id` attr-dict
</code></pre><p>Returns the lane id within the subgroup (warp/wave).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%laneId</span> <span class=p>=</span> gpu<span class=p>.</span>lane_id
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpulaunch_func-mlirgpulaunchfuncop><code>gpu.launch_func</code> (::mlir::gpu::LaunchFuncOp)&nbsp;<a class=headline-hash href=#gpulaunch_func-mlirgpulaunchfuncop>¶</a></h3><p>Launches a function as a GPU kernel</p><p>Syntax:</p><pre><code>operation ::= `gpu.launch_func` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $kernel
              `blocks` `in` ` ` `(`$gridSizeX`,` $gridSizeY`,` $gridSizeZ`)`
              `threads` `in` ` ` `(`$blockSizeX`,` $blockSizeY`,` $blockSizeZ`)`
              (`dynamic_shared_memory_size` $dynamicSharedMemorySize^)?
              custom&lt;LaunchFuncOperands&gt;($operands, type($operands)) attr-dict
</code></pre><p>Launch a kernel function on the specified grid of thread blocks.
<code>gpu.launch</code> operations are lowered to <code>gpu.launch_func</code> operations by
outlining the kernel body into a function in a dedicated module, which
reflects the separate compilation process. The kernel function is required
to have the <code>gpu.kernel</code> attribute. The module containing the kernel
function is required to be a gpu.module. And finally, the module containing
the kernel module (which thus cannot be the top-level module) is required
to have the <code>gpu.container_module</code> attribute. The <code>gpu.launch_func</code>
operation has a symbol attribute named <code>kernel</code> to identify the fully
specified kernel function to launch (both the gpu.module and func).</p><p>The <code>gpu.launch_func</code> supports async dependencies: the kernel does not start
executing until the ops producing those async dependencies have completed.</p><p>By the default, the host implicitly blocks until kernel execution has
completed. If the <code>async</code> keyword is present, the host does not block but
instead a <code>!gpu.async.token</code> is returned. Other async GPU ops can take this
token as dependency.</p><p>The operation requires at least the grid and block sizes along the x,y,z
dimensions as arguments. When a lower-dimensional kernel is required,
unused sizes must be explicitly set to <code>1</code>.</p><p>The remaining operands are optional. The first optional operand corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The remaining operands if present are passed as arguments to the kernel
function.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module attributes <span class=p>{</span>gpu<span class=p>.</span>container_module<span class=p>}</span> <span class=p>{</span>

  <span class=c>// This module creates a separate compilation unit for the GPU compiler.
</span><span class=c></span>  gpu<span class=p>.</span>module <span class=nf>@kernels</span> <span class=p>{</span>
    <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@kernel_1</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
        attributes <span class=p>{</span> <span class=nl>nvvm.kernel =</span> true <span class=p>}</span> <span class=p>{</span>

      <span class=c>// Operations that produce block/thread IDs and dimensions are
</span><span class=c></span>      <span class=c>// injected when outlining the `gpu.launch` body to a function called
</span><span class=c></span>      <span class=c>// by `gpu.launch_func`.
</span><span class=c></span>      <span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
      <span class=nv>%tIdY</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id y
      <span class=nv>%tIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id z

      <span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
      <span class=nv>%bDimY</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim y
      <span class=nv>%bDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim z

      <span class=nv>%bIdX</span> <span class=p>=</span> gpu<span class=p>.</span>block_id <span class=p>x</span>
      <span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
      <span class=nv>%bIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_id z

      <span class=nv>%gDimX</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim <span class=p>x</span>
      <span class=nv>%gDimY</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim y
      <span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z

      <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
      <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>wait async
  gpu<span class=p>.</span>launch_func
      async                           <span class=c>// (Optional) Don&#39;t block host, return token.
</span><span class=c></span>      <span class=p>[</span><span class=nv>%t0</span><span class=p>]</span>                           <span class=c>// (Optional) Execute only after %t0 has completed.
</span><span class=c></span>      <span class=nf>@kernels</span><span class=p>::</span><span class=nf>@kernel_1</span>             <span class=c>// Kernel function.
</span><span class=c></span>      blocks in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>    <span class=c>// Grid size.
</span><span class=c></span>      threads in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>   <span class=c>// Block size.
</span><span class=c></span>      dynamic_shared_memory_size <span class=nv>%s</span>   <span class=c>// (Optional) Amount of dynamic shared
</span><span class=c></span>                                      <span class=c>// memory to allocate for a workgroup.
</span><span class=c></span>      args<span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span>               <span class=c>// (Optional) Kernel arguments.
</span><span class=c></span>           <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
<span class=p>}</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>kernel</code></td><td style=text-align:center>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpulaunch-mlirgpulaunchop><code>gpu.launch</code> (::mlir::gpu::LaunchOp)&nbsp;<a class=headline-hash href=#gpulaunch-mlirgpulaunchop>¶</a></h3><p>GPU kernel launch operation</p><p>Launch a kernel on the specified grid of thread blocks. The body of the
kernel is defined by the single region that this operation contains. The
operation takes an optional list of async dependencies followed by six
operands and an optional operand.</p><p>The <code>async</code> keyword indicates the kernel should be launched asynchronously;
the operation returns a new !gpu.async.token when the keyword is specified.
The kernel launched does not start executing until the ops producing its
async dependencies (optional operands) have completed.</p><p>The first three operands (following any async dependencies) are grid sizes
along the x,y,z dimensions and the following three are block sizes along the
x,y,z dimensions. When a lower-dimensional kernel is required, unused sizes
must be explicitly set to <code>1</code>. The last operand is optional and corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The body region has <em>twelve</em> arguments, grouped as follows:</p><ul><li>three arguments that contain block identifiers along x,y,z dimensions;</li><li>three arguments that contain thread identifiers along x,y,z dimensions;</li><li>operands of the <code>gpu.launch</code> operation as is (i.e. the operands for
grid and block sizes).</li></ul><p>Syntax:</p><pre><code>operation ::= `gpu.launch` (`async` (`[` ssa-id-list `]`)? )?
                         `block` `(` ssa-id-list `)` `in` ssa-reassignment
                         `threads` `(` ssa-id-list `)` `in` ssa-reassignment
                         (dynamic_shared_memory_size ssa-use)?
                         region attr-dict?
ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span><span class=c></span>  <span class=c>// immediately usable inside body region.
</span><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%val1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
<span class=p>}</span>

<span class=c>// Generic syntax explains how the pretty syntax maps to the IR structure.
</span><span class=c></span><span class=s>&#34;gpu.launch&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span>  <span class=c>// Grid sizes.
</span><span class=c></span>             <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>)</span>   <span class=c>// Block sizes.
</span><span class=c></span>
    <span class=p>{</span><span class=err>/</span><span class=p>*</span>attributes<span class=p>*</span><span class=err>/</span><span class=p>}</span>
    <span class=c>// All sizes and identifiers have &#34;index&#34; size.
</span><span class=c></span>    <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
<span class=c>// The operation passes block and thread identifiers, followed by grid and
</span><span class=c>// block sizes.
</span><span class=c></span><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%num_bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
     <span class=nv>%num_tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;memref.load&#34;</span><span class=p>(</span><span class=nv>%val1</span><span class=p>,</span> <span class=nv>%bx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><p>Rationale: using operation/block arguments gives analyses a clear way of
understanding that a value has additional semantics (e.g., we will need to
know what value corresponds to threadIdx.x for coalescing). We can recover
these properties by analyzing the operations producing values, but it is
easier just to have that information by construction.</p><p>Traits: AttrSizedOperandSegments, AutomaticAllocationScope</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemcpy-mlirgpumemcpyop><code>gpu.memcpy</code> (::mlir::gpu::MemcpyOp)&nbsp;<a class=headline-hash href=#gpumemcpy-mlirgpumemcpyop>¶</a></h3><p>GPU memcpy operation</p><p>Syntax:</p><pre><code>operation ::= `gpu.memcpy` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $src `:` type($dst)`,` type($src) attr-dict
</code></pre><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memcpy async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>src</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemset-mlirgpumemsetop><code>gpu.memset</code> (::mlir::gpu::MemsetOp)&nbsp;<a class=headline-hash href=#gpumemset-mlirgpumemsetop>¶</a></h3><p>GPU memset operation</p><p>Syntax:</p><pre><code>operation ::= `gpu.memset` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $value `:` type($dst)`,` type($value) attr-dict
</code></pre><p>The <code>gpu.memset</code> operation sets the content of memref to a scalar value.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memset async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>f32</span>
</code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumodule_end-mlirgpumoduleendop><code>gpu.module_end</code> (::mlir::gpu::ModuleEndOp)&nbsp;<a class=headline-hash href=#gpumodule_end-mlirgpumoduleendop>¶</a></h3><p>A pseudo op that marks the end of a gpu.module.</p><p>Syntax:</p><pre><code>operation ::= `gpu.module_end` attr-dict
</code></pre><p>This op terminates the only block inside the only region of a <code>gpu.module</code>.</p><p>Traits: HasParent<gpumoduleop>, Terminator</p><h3 id=gpunum_subgroups-mlirgpunumsubgroupsop><code>gpu.num_subgroups</code> (::mlir::gpu::NumSubgroupsOp)&nbsp;<a class=headline-hash href=#gpunum_subgroups-mlirgpunumsubgroupsop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.num_subgroups` attr-dict `:` type($result)
</code></pre><p>Returns the number of subgroups within a workgroup.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%numSg</span> <span class=p>=</span> gpu<span class=p>.</span>num_subgroups <span class=p>:</span> <span class=k>index</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpuprintf-mlirgpuprintfop><code>gpu.printf</code> (::mlir::gpu::PrintfOp)&nbsp;<a class=headline-hash href=#gpuprintf-mlirgpuprintfop>¶</a></h3><p>Device-side printf, as in CUDA or OpenCL, for debugging</p><p>Syntax:</p><pre><code>operation ::= `gpu.printf` $format attr-dict ($args^ `:` type($args))?
</code></pre><p><code>gpu.printf</code> takes a literal format string <code>format</code> and an arbitrary number of
scalar arguments that should be printed.</p><p>The format string is a C-style printf string, subject to any restrictions
imposed by one&rsquo;s target platform.</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>format</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>integer or index or floating-point</td></tr></tbody></table><h3 id=gpureturn-mlirgpureturnop><code>gpu.return</code> (::mlir::gpu::ReturnOp)&nbsp;<a class=headline-hash href=#gpureturn-mlirgpureturnop>¶</a></h3><p>Terminator for GPU functions.</p><p>Syntax:</p><pre><code>operation ::= `gpu.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.func</code>
functions. The operands to the <code>gpu.return</code> are the result values returned
by an invocation of the <code>gpu.func</code>.</p><p>Traits: HasParent<gpufuncop>, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=gpuset_default_device-mlirgpusetdefaultdeviceop><code>gpu.set_default_device</code> (::mlir::gpu::SetDefaultDeviceOp)&nbsp;<a class=headline-hash href=#gpuset_default_device-mlirgpusetdefaultdeviceop>¶</a></h3><p>Set default GPU for operations after this by index</p><p>Syntax:</p><pre><code>operation ::= `gpu.set_default_device` attr-dict $devIndex
</code></pre><p>Operation that sets the current default GPU, using a zero-based index
into the set of GPUs on the system. The default GPU setting may be
thread-local.</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>devIndex</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=gpushuffle-mlirgpushuffleop><code>gpu.shuffle</code> (::mlir::gpu::ShuffleOp)&nbsp;<a class=headline-hash href=#gpushuffle-mlirgpushuffleop>¶</a></h3><p>Shuffles values within a subgroup.</p><p>Syntax:</p><pre><code>operation ::= `gpu.shuffle` $mode $value `,` $offset `,` $width attr-dict `:` type($value)
</code></pre><p>The &ldquo;shuffle&rdquo; op moves values to a different invocation within the same
subgroup.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle <span class=nv>%0</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%width</span> xor <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><p>For lane k returns the value from lane <code>k ^ offset</code> and <code>true</code> if that lane
is smaller than %width. Otherwise it returns an unspecified value and
<code>false</code>. A lane is the index of an invocation relative to its subgroup.</p><p>The width specifies the number of invocations that participate in the
shuffle. The width needs to be the same for all invocations that participate
in the shuffle. Exactly the first <code>width</code> invocations of a subgroup need to
execute this op in convergence.</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mode</code></td><td style=text-align:center>::mlir::gpu::ShuffleModeAttr</td><td>Indexing modes supported by gpu.shuffle.</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>i32 or f32</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>width</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>i32 or f32</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=gpusubgroup_id-mlirgpusubgroupidop><code>gpu.subgroup_id</code> (::mlir::gpu::SubgroupIdOp)&nbsp;<a class=headline-hash href=#gpusubgroup_id-mlirgpusubgroupidop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_id` attr-dict `:` type($result)
</code></pre><p>Returns the subgroup id, i.e. the index of the current subgroup within the
workgroup.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%sgId</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_id <span class=p>:</span> <span class=k>index</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpusubgroup_mma_compute-mlirgpusubgroupmmacomputeop><code>gpu.subgroup_mma_compute</code> (::mlir::gpu::SubgroupMmaComputeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_compute-mlirgpusubgroupmmacomputeop>¶</a></h3><p>GPU warp synchronous matrix multiply accumulate</p><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_mma_compute` $opA`,` $opB`,` $opC attr-dict `:` type($opA)`,` type($opB) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_compute</code> operation performs a matrix-multiply accumulate (mma)
operation using all the threads in a subgroup.</p><p>This operation takes three <code>!gpu.mma_matrix</code>s as arguments: these hold <code>A</code>,
<code>B</code> and <code>C</code>operands for the mma operation. The operation performed is represented
as <code>C += A * B</code>. The op returns a <code>!gpu.mma_matrix</code> which contains the result of
the operation held by all threads in a subgroup.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_load_matrix</code> ops.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%D</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_compute_matrix <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span><span class=p>,</span> <span class=nv>%C</span> <span class=p>:</span>
  <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;BOp&#34;</span><span class=p>&gt;&gt;</span>
  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>opA</code></td><td>gpu.mma_matrix of 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>opB</code></td><td>gpu.mma_matrix of 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>opC</code></td><td>gpu.mma_matrix of 16-bit float or 32-bit float values</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_constant_matrix-mlirgpusubgroupmmaconstantmatrixop><code>gpu.subgroup_mma_constant_matrix</code> (::mlir::gpu::SubgroupMmaConstantMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_constant_matrix-mlirgpusubgroupmmaconstantmatrixop>¶</a></h3><p>GPU warp synchronous constant matrix</p><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_mma_constant_matrix` $value attr-dict `:` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_constant_matrix</code> creates a <code>!gpu.mma_matrix</code> with
constant elements.</p><p>The operation takes a scalar input and return a <code>!gpu.mma_matrix</code> where each
element of is equal to the operand constant. The destination mma_matrix type
must have elememt type equal to the constant type. Since the layout of
<code>!gpu.mma_matrix</code> is opaque this only support setting all the elements to
the same value.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%a</span> <span class=p>:</span>
   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
 <span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%b</span> <span class=p>:</span>
   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f32</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16-bit float or 32-bit float</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_elementwise-mlirgpusubgroupmmaelementwiseop><code>gpu.subgroup_mma_elementwise</code> (::mlir::gpu::SubgroupMmaElementwiseOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_elementwise-mlirgpusubgroupmmaelementwiseop>¶</a></h3><p>GPU warp elementwise operation on a matrix</p><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_mma_elementwise` $operation $args attr-dict `:` functional-type($args, $res)
</code></pre><p>The <code>gpu.subgroup_mma_elementwise</code> takes <code>!gpu.mma_matrix</code> inputs and
compute a new <code>!gpu.mma_matrix</code> by applying an elementwise operation to each
element.</p><p>Since the operation is elementwise and the matrix type must match, the
matrix elements are processed independently of the matrix layout.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir> <span class=nv>%0</span> <span class=p>=</span>  <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span> <span class=p>{</span> <span class=nl>operation =</span> <span class=s>&#34;ADD&#34;</span> <span class=p>}</span> <span class=p>:</span>
  <span class=p>(!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;)</span>
  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operation</code></td><td style=text-align:center>::mlir::gpu::MMAElementwiseOpAttr</td><td>elementwise operation to apply to mma matrix</td></tr></tbody></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>MMAMatrix type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_load_matrix-mlirgpusubgroupmmaloadmatrixop><code>gpu.subgroup_mma_load_matrix</code> (::mlir::gpu::SubgroupMmaLoadMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_load_matrix-mlirgpusubgroupmmaloadmatrixop>¶</a></h3><p>GPU warp synchronous matrix load</p><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_mma_load_matrix` $srcMemref`[`$indices`]` attr-dict `:` type($srcMemref) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_load_matrix</code> operation loads a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a memref as its first operand: it is the source matrix
from which data is to be loaded. The op returns a <code>!gpu.mma_matrix</code>. The
source memref can be in global memory or shared memory. The load address is
determined using <code>indices</code>. The matrix being loaded into is the result. The
<code>leadDimension</code> attribute specifies the leading dimension size of the source
matrix which eventually allows the lowering to determine the size of each
row.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_load_matrix src<span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span><span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
      <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>leadDimension</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcMemref</code></td><td>memref of 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_store_matrix-mlirgpusubgroupmmastorematrixop><code>gpu.subgroup_mma_store_matrix</code> (::mlir::gpu::SubgroupMmaStoreMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_store_matrix-mlirgpusubgroupmmastorematrixop>¶</a></h3><p>GPU warp synchronous matrix store</p><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_mma_store_matrix` $src`,` $dstMemref`[`$indices`]` attr-dict `:` type($src)`,` type($dstMemref)
</code></pre><p>The <code>gpu.subgroup_mma_store_matrix</code> operation stores a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a <code>!gpu.mma_matrix</code> and a memref as operands.
<code>!gpu.mma_matrix</code> is the source value containing the data to be stored into the
destination memref which can be in global or shared memory. The store address
is determined using the indices provided. The <code>leadDimension</code> attribute
specifies the leading dimension of the destination matrix.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_load_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>subgroup_mma_store_matrix <span class=nv>%D</span><span class=p>,</span> <span class=nv>%sg</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span> <span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
                <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>leadDimension</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>gpu.mma_matrix of 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>dstMemref</code></td><td>memref of 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=gpusubgroup_size-mlirgpusubgroupsizeop><code>gpu.subgroup_size</code> (::mlir::gpu::SubgroupSizeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_size-mlirgpusubgroupsizeop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.subgroup_size` attr-dict `:` type($result)
</code></pre><p>Returns the number of threads within a subgroup.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%sgSz</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_size <span class=p>:</span> <span class=k>index</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gputerminator-mlirgputerminatorop><code>gpu.terminator</code> (::mlir::gpu::TerminatorOp)&nbsp;<a class=headline-hash href=#gputerminator-mlirgputerminatorop>¶</a></h3><p>Terminator for GPU launch regions.</p><p>Syntax:</p><pre><code>operation ::= `gpu.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.launch</code>
operation. These regions are not expected to return any value so the
terminator takes no operands.</p><p>Traits: HasParent<launchop>, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h3 id=gputhread_id-mlirgputhreadidop><code>gpu.thread_id</code> (::mlir::gpu::ThreadIdOp)&nbsp;<a class=headline-hash href=#gputhread_id-mlirgputhreadidop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `gpu.thread_id` $dimension attr-dict
</code></pre><p>Returns the thread id, i.e. the index of the current thread within the block
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dimension</code></td><td style=text-align:center>::mlir::gpu::DimensionAttr</td><td>a dimension, either &lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuwait-mlirgpuwaitop><code>gpu.wait</code> (::mlir::gpu::WaitOp)&nbsp;<a class=headline-hash href=#gpuwait-mlirgpuwaitop>¶</a></h3><p>Wait for async gpu ops to complete.</p><p>Syntax:</p><pre><code>operation ::= `gpu.wait` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) attr-dict
</code></pre><p>This op synchronizes the host or the device with a list of dependent ops.</p><p>If the op contains the <code>async</code> keyword, it returns a new async token which
is synchronized with the op arguments. This new token is merely a shortcut
to the argument list, and one could replace the uses of the result with the
arguments for the same effect. The async version of this op is primarily
used to make each async token have a single use during lowering and
thereby make forks in async execution explicit. Example usage:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
<span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
<span class=nv>%t2</span> <span class=p>=</span> gpu<span class=p>.</span>wait async <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
<span class=c>// gpu.baz doesn&#39;t run until gpu.foo and gpu.bar have both completed, just
</span><span class=c>// as if the async dependencies were [%t0, %t1].
</span><span class=c></span><span class=nv>%t3</span> <span class=p>=</span> gpu<span class=p>.</span>baz async <span class=p>[</span><span class=nv>%t2</span><span class=p>]</span>
</code></pre></div><p>If the op does not contain the <code>async</code> keyword, it does not return a new
async token but blocks until all ops producing the async dependency tokens
finished execution. All dependent memory operations are visible to the host
once this op completes. Example usage:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
<span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
<span class=c>// The gpu.wait op blocks until gpu.foo and gpu.bar have completed.
</span><span class=c></span>gpu<span class=p>.</span>wait <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
</code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>async token type</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuyield-mlirgpuyieldop><code>gpu.yield</code> (::mlir::gpu::YieldOp)&nbsp;<a class=headline-hash href=#gpuyield-mlirgpuyieldop>¶</a></h3><p>GPU yield operation</p><p>gpu.yield` is a special terminator operation for blocks inside regions
in gpu ops. It returns values to the immediately enclosing gpu op.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>yield <span class=nv>%f0</span><span class=p>,</span> <span class=nv>%f1</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span>
</code></pre></div><p>Traits: Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Func/ title="'func' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'func' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Linalg/ title="'linalg' Dialect">Next - 'linalg' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li class=active><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>