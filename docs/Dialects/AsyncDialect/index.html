<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'async' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'async' Dialect</h1><p>Types and operations for async dialect
This dialect contains operations for modeling asynchronous execution.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#coroutine-handle>coroutine handle</a></li><li><a href=#switched-resume-coroutine-identifier>switched-resume coroutine identifier</a></li><li><a href=#saved-coroutine-state>saved coroutine state</a></li><li><a href=#async-group-type>async group type</a></li><li><a href=#async-token-type>async token type</a></li><li><a href=#async-value-type>async value type</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#asyncadd_to_group-mlirasyncaddtogroupop><code>async.add_to_group</code> (::mlir::async::AddToGroupOp)</a></li><li><a href=#asyncawait_all-mlirasyncawaitallop><code>async.await_all</code> (::mlir::async::AwaitAllOp)</a></li><li><a href=#asyncawait-mlirasyncawaitop><code>async.await</code> (::mlir::async::AwaitOp)</a></li><li><a href=#asynccorobegin-mlirasynccorobeginop><code>async.coro.begin</code> (::mlir::async::CoroBeginOp)</a></li><li><a href=#asynccoroend-mlirasynccoroendop><code>async.coro.end</code> (::mlir::async::CoroEndOp)</a></li><li><a href=#asynccorofree-mlirasynccorofreeop><code>async.coro.free</code> (::mlir::async::CoroFreeOp)</a></li><li><a href=#asynccoroid-mlirasynccoroidop><code>async.coro.id</code> (::mlir::async::CoroIdOp)</a></li><li><a href=#asynccorosave-mlirasynccorosaveop><code>async.coro.save</code> (::mlir::async::CoroSaveOp)</a></li><li><a href=#asynccorosuspend-mlirasynccorosuspendop><code>async.coro.suspend</code> (::mlir::async::CoroSuspendOp)</a></li><li><a href=#asynccreate_group-mlirasynccreategroupop><code>async.create_group</code> (::mlir::async::CreateGroupOp)</a></li><li><a href=#asyncexecute-mlirasyncexecuteop><code>async.execute</code> (::mlir::async::ExecuteOp)</a></li><li><a href=#asyncruntimeadd_ref-mlirasyncruntimeaddrefop><code>async.runtime.add_ref</code> (::mlir::async::RuntimeAddRefOp)</a></li><li><a href=#asyncruntimeadd_to_group-mlirasyncruntimeaddtogroupop><code>async.runtime.add_to_group</code> (::mlir::async::RuntimeAddToGroupOp)</a></li><li><a href=#asyncruntimeawait_and_resume-mlirasyncruntimeawaitandresumeop><code>async.runtime.await_and_resume</code> (::mlir::async::RuntimeAwaitAndResumeOp)</a></li><li><a href=#asyncruntimeawait-mlirasyncruntimeawaitop><code>async.runtime.await</code> (::mlir::async::RuntimeAwaitOp)</a></li><li><a href=#asyncruntimecreate_group-mlirasyncruntimecreategroupop><code>async.runtime.create_group</code> (::mlir::async::RuntimeCreateGroupOp)</a></li><li><a href=#asyncruntimecreate-mlirasyncruntimecreateop><code>async.runtime.create</code> (::mlir::async::RuntimeCreateOp)</a></li><li><a href=#asyncruntimedrop_ref-mlirasyncruntimedroprefop><code>async.runtime.drop_ref</code> (::mlir::async::RuntimeDropRefOp)</a></li><li><a href=#asyncruntimeis_error-mlirasyncruntimeiserrorop><code>async.runtime.is_error</code> (::mlir::async::RuntimeIsErrorOp)</a></li><li><a href=#asyncruntimeload-mlirasyncruntimeloadop><code>async.runtime.load</code> (::mlir::async::RuntimeLoadOp)</a></li><li><a href=#asyncruntimenum_worker_threads-mlirasyncruntimenumworkerthreadsop><code>async.runtime.num_worker_threads</code> (::mlir::async::RuntimeNumWorkerThreadsOp)</a></li><li><a href=#asyncruntimeresume-mlirasyncruntimeresumeop><code>async.runtime.resume</code> (::mlir::async::RuntimeResumeOp)</a></li><li><a href=#asyncruntimeset_available-mlirasyncruntimesetavailableop><code>async.runtime.set_available</code> (::mlir::async::RuntimeSetAvailableOp)</a></li><li><a href=#asyncruntimeset_error-mlirasyncruntimeseterrorop><code>async.runtime.set_error</code> (::mlir::async::RuntimeSetErrorOp)</a></li><li><a href=#asyncruntimestore-mlirasyncruntimestoreop><code>async.runtime.store</code> (::mlir::async::RuntimeStoreOp)</a></li><li><a href=#asyncyield-mlirasyncyieldop><code>async.yield</code> (::mlir::async::YieldOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#corohandletype>CoroHandleType</a></li><li><a href=#coroidtype>CoroIdType</a></li><li><a href=#corostatetype>CoroStateType</a></li><li><a href=#grouptype>GroupType</a></li><li><a href=#tokentype>TokenType</a></li><li><a href=#valuetype>ValueType</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=coroutine-handle>coroutine handle&nbsp;<a class=headline-hash href=#coroutine-handle>¶</a></h3><p><code>async.coro.handle</code> is a handle to the coroutine (pointer to the coroutine
frame) that can be passed around to resume or destroy the coroutine.</p><h3 id=switched-resume-coroutine-identifier>switched-resume coroutine identifier&nbsp;<a class=headline-hash href=#switched-resume-coroutine-identifier>¶</a></h3><p><code>async.coro.id</code> is a type identifying a switched-resume coroutine.</p><h3 id=saved-coroutine-state>saved coroutine state&nbsp;<a class=headline-hash href=#saved-coroutine-state>¶</a></h3><p><code>async.coro.state</code> is a saved coroutine state that should be passed to the
coroutine suspension operation.</p><h3 id=async-group-type>async group type&nbsp;<a class=headline-hash href=#async-group-type>¶</a></h3><p><code>async.group</code> represent a set of async tokens or values and allows to
execute async operations on all of them together (e.g. wait for the
completion of all/any of them).</p><h3 id=async-token-type>async token type&nbsp;<a class=headline-hash href=#async-token-type>¶</a></h3><p><code>async.token</code> is a type returned by asynchronous operations, and it becomes
<code>available</code> when the asynchronous operations that created it is completed.</p><h3 id=async-value-type>async value type&nbsp;<a class=headline-hash href=#async-value-type>¶</a></h3><p><code>async.value</code> represents a value returned by asynchronous operations,
which may or may not be available currently, but will be available at some
point in the future.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=asyncadd_to_group-mlirasyncaddtogroupop><code>async.add_to_group</code> (::mlir::async::AddToGroupOp)&nbsp;<a class=headline-hash href=#asyncadd_to_group-mlirasyncaddtogroupop>¶</a></h3><p>adds and async token or value to the group</p><p>Syntax:</p><pre><code>operation ::= `async.add_to_group` $operand `,` $group `:` type($operand) attr-dict
</code></pre><p>The <code>async.add_to_group</code> adds an async token or value to the async group.
Returns the rank of the added element in the group. This rank is fixed
for the group lifetime.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group
<span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
<span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</code></pre></div><p>Interfaces: InferTypeOpInterface</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr><tr><td style=text-align:center><code>group</code></td><td>async group type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rank</code></td><td>index</td></tr></tbody></table><h3 id=asyncawait_all-mlirasyncawaitallop><code>async.await_all</code> (::mlir::async::AwaitAllOp)&nbsp;<a class=headline-hash href=#asyncawait_all-mlirasyncawaitallop>¶</a></h3><p>waits for the all async tokens or values in the group to become ready</p><p>Syntax:</p><pre><code>operation ::= `async.await_all` $operand attr-dict
</code></pre><p>The <code>async.await_all</code> operation waits until all the tokens or values in the
group become ready.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group

<span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
<span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token

<span class=nv>%3</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
<span class=nv>%4</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%2</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token

async<span class=p>.</span>await_all <span class=nv>%0</span>
</code></pre></div><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async group type</td></tr></tbody></table><h3 id=asyncawait-mlirasyncawaitop><code>async.await</code> (::mlir::async::AwaitOp)&nbsp;<a class=headline-hash href=#asyncawait-mlirasyncawaitop>¶</a></h3><p>waits for the argument to become ready</p><p>Syntax:</p><pre><code>operation ::= `async.await` $operand `:` custom&lt;AwaitResultType&gt;(
              type($operand), type($result)
              ) attr-dict
</code></pre><p>The <code>async.await</code> operation waits until the argument becomes ready, and for
the <code>async.value</code> arguments it unwraps the underlying value</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
async<span class=p>.</span>await <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token

<span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>await <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=asynccorobegin-mlirasynccorobeginop><code>async.coro.begin</code> (::mlir::async::CoroBeginOp)&nbsp;<a class=headline-hash href=#asynccorobegin-mlirasynccorobeginop>¶</a></h3><p>returns a handle to the coroutine</p><p>Syntax:</p><pre><code>operation ::= `async.coro.begin` $id attr-dict
</code></pre><p>The <code>async.coro.begin</code> allocates a coroutine frame and returns a handle to
the coroutine.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccoroend-mlirasynccoroendop><code>async.coro.end</code> (::mlir::async::CoroEndOp)&nbsp;<a class=headline-hash href=#asynccoroend-mlirasynccoroendop>¶</a></h3><p>marks the end of the coroutine in the suspend block</p><p>Syntax:</p><pre><code>operation ::= `async.coro.end` $handle attr-dict
</code></pre><p>The <code>async.coro.end</code> marks the point where a coroutine needs to return
control back to the caller if it is not an initial invocation of the
coroutine. It the start part of the coroutine is is no-op.</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccorofree-mlirasynccorofreeop><code>async.coro.free</code> (::mlir::async::CoroFreeOp)&nbsp;<a class=headline-hash href=#asynccorofree-mlirasynccorofreeop>¶</a></h3><p>deallocates the coroutine frame</p><p>Syntax:</p><pre><code>operation ::= `async.coro.free` $id `,` $handle attr-dict
</code></pre><p>The <code>async.coro.free</code> deallocates the coroutine frame created by the
async.coro.begin operation.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccoroid-mlirasynccoroidop><code>async.coro.id</code> (::mlir::async::CoroIdOp)&nbsp;<a class=headline-hash href=#asynccoroid-mlirasynccoroidop>¶</a></h3><p>returns a switched-resume coroutine identifier</p><p>Syntax:</p><pre><code>operation ::= `async.coro.id` attr-dict
</code></pre><p>The <code>async.coro.id</code> returns a switched-resume coroutine identifier.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr></tbody></table><h3 id=asynccorosave-mlirasynccorosaveop><code>async.coro.save</code> (::mlir::async::CoroSaveOp)&nbsp;<a class=headline-hash href=#asynccorosave-mlirasynccorosaveop>¶</a></h3><p>saves the coroutine state</p><p>Syntax:</p><pre><code>operation ::= `async.coro.save` $handle attr-dict
</code></pre><p>The <code>async.coro.saves</code> saves the coroutine state.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td>saved coroutine state</td></tr></tbody></table><h3 id=asynccorosuspend-mlirasynccorosuspendop><code>async.coro.suspend</code> (::mlir::async::CoroSuspendOp)&nbsp;<a class=headline-hash href=#asynccorosuspend-mlirasynccorosuspendop>¶</a></h3><p>suspends the coroutine</p><p>Syntax:</p><pre><code>operation ::= `async.coro.suspend` $state `,` $suspendDest `,` $resumeDest  `,` $cleanupDest attr-dict
</code></pre><p>The <code>async.coro.suspend</code> suspends the coroutine and transfers control to the
<code>suspend</code> successor. If suspended coroutine later resumed it will transfer
control to the <code>resume</code> successor. If it is destroyed it will transfer
control to the the <code>cleanup</code> successor.</p><p>In switched-resume lowering coroutine can be already in resumed state when
suspend operation is called, in this case control will be transferred to the
<code>resume</code> successor skipping the <code>suspend</code> successor.</p><p>Traits: Terminator</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td>saved coroutine state</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>suspendDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>resumeDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cleanupDest</code></td><td>any successor</td></tr></tbody></table><h3 id=asynccreate_group-mlirasynccreategroupop><code>async.create_group</code> (::mlir::async::CreateGroupOp)&nbsp;<a class=headline-hash href=#asynccreate_group-mlirasynccreategroupop>¶</a></h3><p>creates an empty async group</p><p>Syntax:</p><pre><code>operation ::= `async.create_group` $size `:` type($result) attr-dict
</code></pre><p>The <code>async.create_group</code> allocates an empty async group. Async tokens or
values can be added to this group later. The size of the group must be
specified at construction time, and <code>await_all</code> operation will first
wait until the number of added tokens or values reaches the group size.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%size</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%group</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group
<span class=p>...</span>
async<span class=p>.</span>await_all <span class=nv>%group</span>
</code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>size</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async group type</td></tr></tbody></table><h3 id=asyncexecute-mlirasyncexecuteop><code>async.execute</code> (::mlir::async::ExecuteOp)&nbsp;<a class=headline-hash href=#asyncexecute-mlirasyncexecuteop>¶</a></h3><p>Asynchronous execute operation</p><p>The <code>body</code> region attached to the <code>async.execute</code> operation semantically
can be executed concurrently with the successor operation. In the followup
example &ldquo;compute0&rdquo; can be executed concurrently with &ldquo;compute1&rdquo;.</p><p>The actual concurrency semantics depends on the dialect lowering to the
executable format. Fully sequential execution (&ldquo;compute0&rdquo; completes before
&ldquo;compute1&rdquo; starts) is a completely legal execution.</p><p>Because concurrent execution is not guaranteed, it is illegal to create an
implicit dependency from &ldquo;compute1&rdquo; to &ldquo;compute0&rdquo; (e.g. via shared global
state). All dependencies must be made explicit with async execute arguments
(<code>async.token</code> or <code>async.value</code>).</p><p><code>async.execute</code> operation takes <code>async.token</code> dependencies and <code>async.value</code>
operands separately, and starts execution of the attached body region only
when all tokens and values become ready.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%dependency</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
<span class=nv>%value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=nv>%token</span><span class=p>,</span> <span class=nv>%results</span> <span class=p>=</span>
  async<span class=p>.</span>execute <span class=p>[</span><span class=nv>%dependency</span><span class=p>](</span><span class=nv>%value</span> as <span class=nv>%unwrapped</span><span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;)</span>
             <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;!</span>some<span class=p>.</span>type<span class=p>&gt;</span>
  <span class=p>{</span>
    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;compute0&#34;</span><span class=p>(</span><span class=nv>%unwrapped</span><span class=p>):</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>some<span class=p>.</span>type
    async<span class=p>.</span>yield <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>some<span class=p>.</span>type
  <span class=p>}</span>

<span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;compute1&#34;</span><span class=p>(...)</span> <span class=p>:</span> <span class=p>!</span>some<span class=p>.</span>type
</code></pre></div><p>In the example above asynchronous execution starts only after dependency
token and value argument become ready. Unwrapped value passed to the
attached body region as an %unwrapped value of f32 type.</p><p>Traits: AttrSizedOperandSegments, AutomaticAllocationScope, SingleBlockImplicitTerminator<yieldop></p><p>Interfaces: RegionBranchOpInterface</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dependencies</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>operands</code></td><td>async value type or async token type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>results</code></td><td>async value type</td></tr></tbody></table><h3 id=asyncruntimeadd_ref-mlirasyncruntimeaddrefop><code>async.runtime.add_ref</code> (::mlir::async::RuntimeAddRefOp)&nbsp;<a class=headline-hash href=#asyncruntimeadd_ref-mlirasyncruntimeaddrefop>¶</a></h3><p>adds a reference to async value</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.add_ref` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.add_ref</code> operation adds a reference(s) to async value
(token, value or group).</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>count</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is positive</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimeadd_to_group-mlirasyncruntimeaddtogroupop><code>async.runtime.add_to_group</code> (::mlir::async::RuntimeAddToGroupOp)&nbsp;<a class=headline-hash href=#asyncruntimeadd_to_group-mlirasyncruntimeaddtogroupop>¶</a></h3><p>adds and async token or value to the group</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.add_to_group` $operand `,` $group attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.add_to_group</code> adds an async token or value to the async
group. Returns the rank of the added element in the group.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr><tr><td style=text-align:center><code>group</code></td><td>async group type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rank</code></td><td>index</td></tr></tbody></table><h3 id=asyncruntimeawait_and_resume-mlirasyncruntimeawaitandresumeop><code>async.runtime.await_and_resume</code> (::mlir::async::RuntimeAwaitAndResumeOp)&nbsp;<a class=headline-hash href=#asyncruntimeawait_and_resume-mlirasyncruntimeawaitandresumeop>¶</a></h3><p>awaits the async operand and resumes the coroutine</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.await_and_resume` $operand `,` $handle attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.await_and_resume</code> operation awaits for the operand to
become available or error and resumes the coroutine on a thread managed by
the runtime.</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asyncruntimeawait-mlirasyncruntimeawaitop><code>async.runtime.await</code> (::mlir::async::RuntimeAwaitOp)&nbsp;<a class=headline-hash href=#asyncruntimeawait-mlirasyncruntimeawaitop>¶</a></h3><p>blocks the caller thread until the operand becomes available</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.await` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.await</code> operation blocks the caller thread until the
operand becomes available or error.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimecreate_group-mlirasyncruntimecreategroupop><code>async.runtime.create_group</code> (::mlir::async::RuntimeCreateGroupOp)&nbsp;<a class=headline-hash href=#asyncruntimecreate_group-mlirasyncruntimecreategroupop>¶</a></h3><p>creates an async runtime group</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.create_group` $size `:` type($result) attr-dict
</code></pre><p>The <code>async.runtime.create_group</code> operation creates an async dialect group
of the given size. Group created in the empty state.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>size</code></td><td>index</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async group type</td></tr></tbody></table><h3 id=asyncruntimecreate-mlirasyncruntimecreateop><code>async.runtime.create</code> (::mlir::async::RuntimeCreateOp)&nbsp;<a class=headline-hash href=#asyncruntimecreate-mlirasyncruntimecreateop>¶</a></h3><p>creates an async runtime token or value</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.create` attr-dict `:` type($result)
</code></pre><p>The <code>async.runtime.create</code> operation creates an async dialect token or
value. Tokens and values are created in the non-ready state.</p><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimedrop_ref-mlirasyncruntimedroprefop><code>async.runtime.drop_ref</code> (::mlir::async::RuntimeDropRefOp)&nbsp;<a class=headline-hash href=#asyncruntimedrop_ref-mlirasyncruntimedroprefop>¶</a></h3><p>drops a reference to async value</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.drop_ref` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.drop_ref</code> operation drops a reference(s) to async value
(token, value or group).</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>count</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is positive</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimeis_error-mlirasyncruntimeiserrorop><code>async.runtime.is_error</code> (::mlir::async::RuntimeIsErrorOp)&nbsp;<a class=headline-hash href=#asyncruntimeis_error-mlirasyncruntimeiserrorop>¶</a></h3><p>returns true if token, value or group is in error state</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.is_error` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.is_error</code> operation returns true if the token, value or
group (any of the async runtime values) is in the error state. It is the
caller responsibility to check error state after the call to <code>await</code> or
resuming after <code>await_and_resume</code>.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>is_error</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=asyncruntimeload-mlirasyncruntimeloadop><code>async.runtime.load</code> (::mlir::async::RuntimeLoadOp)&nbsp;<a class=headline-hash href=#asyncruntimeload-mlirasyncruntimeloadop>¶</a></h3><p>loads the value from the runtime async.value</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.load` $storage attr-dict `:` type($storage)
</code></pre><p>The <code>async.runtime.load</code> operation loads the value from the runtime
async.value storage.</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td>async value type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=asyncruntimenum_worker_threads-mlirasyncruntimenumworkerthreadsop><code>async.runtime.num_worker_threads</code> (::mlir::async::RuntimeNumWorkerThreadsOp)&nbsp;<a class=headline-hash href=#asyncruntimenum_worker_threads-mlirasyncruntimenumworkerthreadsop>¶</a></h3><p>gets the number of threads in the threadpool from the runtime</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.num_worker_threads` attr-dict `:` type($result)
</code></pre><p>The <code>async.runtime.num_worker_threads</code> operation gets the number of threads
in the threadpool from the runtime.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=asyncruntimeresume-mlirasyncruntimeresumeop><code>async.runtime.resume</code> (::mlir::async::RuntimeResumeOp)&nbsp;<a class=headline-hash href=#asyncruntimeresume-mlirasyncruntimeresumeop>¶</a></h3><p>resumes the coroutine on a thread managed by the runtime</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.resume` $handle attr-dict
</code></pre><p>The <code>async.runtime.resume</code> operation resumes the coroutine on a thread
managed by the runtime.</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asyncruntimeset_available-mlirasyncruntimesetavailableop><code>async.runtime.set_available</code> (::mlir::async::RuntimeSetAvailableOp)&nbsp;<a class=headline-hash href=#asyncruntimeset_available-mlirasyncruntimesetavailableop>¶</a></h3><p>switches token or value to available state</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.set_available` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.set_available</code> operation switches async token or value
state to available.</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimeset_error-mlirasyncruntimeseterrorop><code>async.runtime.set_error</code> (::mlir::async::RuntimeSetErrorOp)&nbsp;<a class=headline-hash href=#asyncruntimeset_error-mlirasyncruntimeseterrorop>¶</a></h3><p>switches token or value to error state</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.set_error` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.set_error</code> operation switches async token or value
state to error.</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimestore-mlirasyncruntimestoreop><code>async.runtime.store</code> (::mlir::async::RuntimeStoreOp)&nbsp;<a class=headline-hash href=#asyncruntimestore-mlirasyncruntimestoreop>¶</a></h3><p>stores the value into the runtime async.value</p><p>Syntax:</p><pre><code>operation ::= `async.runtime.store` $value `,` $storage attr-dict `:` type($storage)
</code></pre><p>The <code>async.runtime.store</code> operation stores the value into the runtime
async.value storage.</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>storage</code></td><td>async value type</td></tr></tbody></table><h3 id=asyncyield-mlirasyncyieldop><code>async.yield</code> (::mlir::async::YieldOp)&nbsp;<a class=headline-hash href=#asyncyield-mlirasyncyieldop>¶</a></h3><p>terminator for Async execute operation</p><p>Syntax:</p><pre><code>operation ::= `async.yield` ($operands^ `:` type($operands))? attr-dict
</code></pre><p>The <code>async.yield</code> is a special terminator operation for the block inside
<code>async.execute</code> operation.</p><p>Traits: HasParent<executeop>, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), RegionBranchTerminatorOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=corohandletype>CoroHandleType&nbsp;<a class=headline-hash href=#corohandletype>¶</a></h3><p>coroutine handle</p><p>Syntax: <code>!async.coro.handle</code></p><p><code>async.coro.handle</code> is a handle to the coroutine (pointer to the coroutine
frame) that can be passed around to resume or destroy the coroutine.</p><h3 id=coroidtype>CoroIdType&nbsp;<a class=headline-hash href=#coroidtype>¶</a></h3><p>switched-resume coroutine identifier</p><p>Syntax: <code>!async.coro.id</code></p><p><code>async.coro.id</code> is a type identifying a switched-resume coroutine.</p><h3 id=corostatetype>CoroStateType&nbsp;<a class=headline-hash href=#corostatetype>¶</a></h3><p>saved coroutine state</p><p>Syntax: <code>!async.coro.state</code></p><p><code>async.coro.state</code> is a saved coroutine state that should be passed to the
coroutine suspension operation.</p><h3 id=grouptype>GroupType&nbsp;<a class=headline-hash href=#grouptype>¶</a></h3><p>async group type</p><p>Syntax: <code>!async.group</code></p><p><code>async.group</code> represent a set of async tokens or values and allows to
execute async operations on all of them together (e.g. wait for the
completion of all/any of them).</p><h3 id=tokentype>TokenType&nbsp;<a class=headline-hash href=#tokentype>¶</a></h3><p>async token type</p><p>Syntax: <code>!async.token</code></p><p><code>async.token</code> is a type returned by asynchronous operations, and it becomes
<code>available</code> when the asynchronous operations that created it is completed.</p><h3 id=valuetype>ValueType&nbsp;<a class=headline-hash href=#valuetype>¶</a></h3><p>async value type</p><p><code>async.value</code> represents a value returned by asynchronous operations,
which may or may not be available currently, but will be available at some
point in the future.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ArmSVE/ title="'arm_sve' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'arm_sve' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/BufferizationOps/ title="'bufferization' Dialect">Next - 'bufferization' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li class=active><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>