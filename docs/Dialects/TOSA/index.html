<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Tensor Operator Set Architecture (TOSA) Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/TOSA/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Tensor Operator Set Architecture (TOSA) Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a></li><li><a href=#tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness</a><ul><li><a href=#complete>Complete</a></li><li><a href=#minimal>Minimal</a></li><li><a href=#numerical-precision>Numerical Precision</a></li></ul></li><li><a href=#tosa-operator-rationale>TOSA Operator Rationale</a><ul><li><a href=#cond_if-and-while_loop>COND_IF and WHILE_LOOP</a></li></ul></li><li><a href=#using-tosa-in-a-compiler>Using TOSA In A Compiler</a><ul><li><a href=#quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors</a></li></ul></li><li><a href=#operation-definitions>Operation definitions</a><ul><li><a href=#tosaabs-mlirtosaabsop><code>tosa.abs</code> (mlir::tosa::AbsOp)</a></li><li><a href=#tosaadd-mlirtosaaddop><code>tosa.add</code> (mlir::tosa::AddOp)</a></li><li><a href=#tosaapply_scale-mlirtosaapplyscaleop><code>tosa.apply_scale</code> (mlir::tosa::ApplyScaleOp)</a></li><li><a href=#tosaargmax-mlirtosaargmaxop><code>tosa.argmax</code> (mlir::tosa::ArgMaxOp)</a></li><li><a href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop><code>tosa.arithmetic_right_shift</code> (mlir::tosa::ArithmeticRightShiftOp)</a></li><li><a href=#tosaavg_pool2d-mlirtosaavgpool2dop><code>tosa.avg_pool2d</code> (mlir::tosa::AvgPool2dOp)</a></li><li><a href=#tosabitwise_and-mlirtosabitwiseandop><code>tosa.bitwise_and</code> (mlir::tosa::BitwiseAndOp)</a></li><li><a href=#tosabitwise_not-mlirtosabitwisenotop><code>tosa.bitwise_not</code> (mlir::tosa::BitwiseNotOp)</a></li><li><a href=#tosabitwise_or-mlirtosabitwiseorop><code>tosa.bitwise_or</code> (mlir::tosa::BitwiseOrOp)</a></li><li><a href=#tosabitwise_xor-mlirtosabitwisexorop><code>tosa.bitwise_xor</code> (mlir::tosa::BitwiseXorOp)</a></li><li><a href=#tosacast-mlirtosacastop><code>tosa.cast</code> (mlir::tosa::CastOp)</a></li><li><a href=#tosaceil-mlirtosaceilop><code>tosa.ceil</code> (mlir::tosa::CeilOp)</a></li><li><a href=#tosaclamp-mlirtosaclampop><code>tosa.clamp</code> (mlir::tosa::ClampOp)</a></li><li><a href=#tosaclz-mlirtosaclzop><code>tosa.clz</code> (mlir::tosa::ClzOp)</a></li><li><a href=#tosaconcat-mlirtosaconcatop><code>tosa.concat</code> (mlir::tosa::ConcatOp)</a></li><li><a href=#tosaconst-mlirtosaconstop><code>tosa.const</code> (mlir::tosa::ConstOp)</a></li><li><a href=#tosaconv2d-mlirtosaconv2dop><code>tosa.conv2d</code> (mlir::tosa::Conv2DOp)</a></li><li><a href=#tosaconv3d-mlirtosaconv3dop><code>tosa.conv3d</code> (mlir::tosa::Conv3DOp)</a></li><li><a href=#tosacustom-mlirtosacustomop><code>tosa.custom</code> (mlir::tosa::CustomOp)</a></li><li><a href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop><code>tosa.depthwise_conv2d</code> (mlir::tosa::DepthwiseConv2DOp)</a></li><li><a href=#tosadiv-mlirtosadivop><code>tosa.div</code> (mlir::tosa::DivOp)</a></li><li><a href=#tosaequal-mlirtosaequalop><code>tosa.equal</code> (mlir::tosa::EqualOp)</a></li><li><a href=#tosaexp-mlirtosaexpop><code>tosa.exp</code> (mlir::tosa::ExpOp)</a></li><li><a href=#tosafloor-mlirtosafloorop><code>tosa.floor</code> (mlir::tosa::FloorOp)</a></li><li><a href=#tosafully_connected-mlirtosafullyconnectedop><code>tosa.fully_connected</code> (mlir::tosa::FullyConnectedOp)</a></li><li><a href=#tosagather-mlirtosagatherop><code>tosa.gather</code> (mlir::tosa::GatherOp)</a></li><li><a href=#tosagreater_equal-mlirtosagreaterequalop><code>tosa.greater_equal</code> (mlir::tosa::GreaterEqualOp)</a></li><li><a href=#tosagreater-mlirtosagreaterop><code>tosa.greater</code> (mlir::tosa::GreaterOp)</a></li><li><a href=#tosaidentity-mlirtosaidentityop><code>tosa.identity</code> (mlir::tosa::IdentityOp)</a></li><li><a href=#tosacond_if-mlirtosaifop><code>tosa.cond_if</code> (mlir::tosa::IfOp)</a></li><li><a href=#tosalog-mlirtosalogop><code>tosa.log</code> (mlir::tosa::LogOp)</a></li><li><a href=#tosalogical_and-mlirtosalogicalandop><code>tosa.logical_and</code> (mlir::tosa::LogicalAndOp)</a></li><li><a href=#tosalogical_left_shift-mlirtosalogicalleftshiftop><code>tosa.logical_left_shift</code> (mlir::tosa::LogicalLeftShiftOp)</a></li><li><a href=#tosalogical_not-mlirtosalogicalnotop><code>tosa.logical_not</code> (mlir::tosa::LogicalNotOp)</a></li><li><a href=#tosalogical_or-mlirtosalogicalorop><code>tosa.logical_or</code> (mlir::tosa::LogicalOrOp)</a></li><li><a href=#tosalogical_right_shift-mlirtosalogicalrightshiftop><code>tosa.logical_right_shift</code> (mlir::tosa::LogicalRightShiftOp)</a></li><li><a href=#tosalogical_xor-mlirtosalogicalxorop><code>tosa.logical_xor</code> (mlir::tosa::LogicalXorOp)</a></li><li><a href=#tosamatmul-mlirtosamatmulop><code>tosa.matmul</code> (mlir::tosa::MatMulOp)</a></li><li><a href=#tosamax_pool2d-mlirtosamaxpool2dop><code>tosa.max_pool2d</code> (mlir::tosa::MaxPool2dOp)</a></li><li><a href=#tosamaximum-mlirtosamaximumop><code>tosa.maximum</code> (mlir::tosa::MaximumOp)</a></li><li><a href=#tosaminimum-mlirtosaminimumop><code>tosa.minimum</code> (mlir::tosa::MinimumOp)</a></li><li><a href=#tosamul-mlirtosamulop><code>tosa.mul</code> (mlir::tosa::MulOp)</a></li><li><a href=#tosanegate-mlirtosanegateop><code>tosa.negate</code> (mlir::tosa::NegateOp)</a></li><li><a href=#tosapad-mlirtosapadop><code>tosa.pad</code> (mlir::tosa::PadOp)</a></li><li><a href=#tosapow-mlirtosapowop><code>tosa.pow</code> (mlir::tosa::PowOp)</a></li><li><a href=#tosareciprocal-mlirtosareciprocalop><code>tosa.reciprocal</code> (mlir::tosa::ReciprocalOp)</a></li><li><a href=#tosareduce_all-mlirtosareduceallop><code>tosa.reduce_all</code> (mlir::tosa::ReduceAllOp)</a></li><li><a href=#tosareduce_any-mlirtosareduceanyop><code>tosa.reduce_any</code> (mlir::tosa::ReduceAnyOp)</a></li><li><a href=#tosareduce_max-mlirtosareducemaxop><code>tosa.reduce_max</code> (mlir::tosa::ReduceMaxOp)</a></li><li><a href=#tosareduce_min-mlirtosareduceminop><code>tosa.reduce_min</code> (mlir::tosa::ReduceMinOp)</a></li><li><a href=#tosareduce_prod-mlirtosareduceprodop><code>tosa.reduce_prod</code> (mlir::tosa::ReduceProdOp)</a></li><li><a href=#tosareduce_sum-mlirtosareducesumop><code>tosa.reduce_sum</code> (mlir::tosa::ReduceSumOp)</a></li><li><a href=#tosarelun-mlirtosarelunop><code>tosa.reluN</code> (mlir::tosa::ReluNOp)</a></li><li><a href=#tosarescale-mlirtosarescaleop><code>tosa.rescale</code> (mlir::tosa::RescaleOp)</a></li><li><a href=#tosareshape-mlirtosareshapeop><code>tosa.reshape</code> (mlir::tosa::ReshapeOp)</a></li><li><a href=#tosaresize-mlirtosaresizeop><code>tosa.resize</code> (mlir::tosa::ResizeOp)</a></li><li><a href=#tosareverse-mlirtosareverseop><code>tosa.reverse</code> (mlir::tosa::ReverseOp)</a></li><li><a href=#tosarsqrt-mlirtosarsqrtop><code>tosa.rsqrt</code> (mlir::tosa::RsqrtOp)</a></li><li><a href=#tosascatter-mlirtosascatterop><code>tosa.scatter</code> (mlir::tosa::ScatterOp)</a></li><li><a href=#tosaselect-mlirtosaselectop><code>tosa.select</code> (mlir::tosa::SelectOp)</a></li><li><a href=#tosasigmoid-mlirtosasigmoidop><code>tosa.sigmoid</code> (mlir::tosa::SigmoidOp)</a></li><li><a href=#tosaslice-mlirtosasliceop><code>tosa.slice</code> (mlir::tosa::SliceOp)</a></li><li><a href=#tosasub-mlirtosasubop><code>tosa.sub</code> (mlir::tosa::SubOp)</a></li><li><a href=#tosatable-mlirtosatableop><code>tosa.table</code> (mlir::tosa::TableOp)</a></li><li><a href=#tosatanh-mlirtosatanhop><code>tosa.tanh</code> (mlir::tosa::TanhOp)</a></li><li><a href=#tosatile-mlirtosatileop><code>tosa.tile</code> (mlir::tosa::TileOp)</a></li><li><a href=#tosatranspose_conv2d-mlirtosatransposeconv2dop><code>tosa.transpose_conv2d</code> (mlir::tosa::TransposeConv2DOp)</a></li><li><a href=#tosatranspose-mlirtosatransposeop><code>tosa.transpose</code> (mlir::tosa::TransposeOp)</a></li><li><a href=#tosawhile_loop-mlirtosawhileop><code>tosa.while_loop</code> (mlir::tosa::WhileOp)</a></li><li><a href=#tosayield-mlirtosayieldop><code>tosa.yield</code> (mlir::tosa::YieldOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The MLIR TOSA dialect implements the
<a href=https://developer.mlplatform.org/w/tosa/>TOSA
specification</a>. This document
describes the decision process for how TOSA expresses operators in
high level dialects.</p><p>TOSA was developed after parallel efforts to rationalize the top-down picture
from multiple high-level frameworks, as well as a bottom-up view of different
hardware target concerns (CPU, GPU and NPU), and reflects a set of choices
that attempt to manage both sets of requirements.</p><h2 id=tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness&nbsp;<a class=headline-hash href=#tosa-and-tensor-level-expressiveness>¶</a></h2><p>TOSA endeavors to provide an operator set that tries to fulfil the following
expressiveness goals at the <em>tensor level of abstraction</em> :</p><h3 id=complete>Complete&nbsp;<a class=headline-hash href=#complete>¶</a></h3><p>This is driven by the top-down perspective, needing to express as much of
multiple high level frameworks fully in TOSA, as possible. This was originally
done from an operator frequency analysis done upon dozens of high level
networks in different frameworks, to select the most frequently occurring ones
and establish a common set of tensor-level operators that could express them.</p><p>TOSA categorizes its operator set into classes and attempts to address major
functional operations at the tensor level, including compute, reduction,
elementwise transformations, comparison and control flow.</p><h3 id=minimal>Minimal&nbsp;<a class=headline-hash href=#minimal>¶</a></h3><p>This takes the bottom-up approach - keep the TOSA operator set minimal in
order to bound the design of hardware, operator kernels, code generation
strategies and associated considerations that effect the executability of TOSA
content.</p><p>In this regard TOSA seeks to avoid creating compound operators, instead
leaving it to compiler backend to fuse multiple TOSA ops if required. This
choice also benefits the numerical precision goal, since it is easier to fuse the
numerical functionality of successive operators, than to split the numerical
functionality of a compound operator.</p><h3 id=numerical-precision>Numerical Precision&nbsp;<a class=headline-hash href=#numerical-precision>¶</a></h3><p>TOSA began as a means to address operator-level numerical precision for
code generation and hardware development. It therefore incorporates precision
detail into the operator set.</p><p>In this regard, TOSA operators are best understood as a combination of the visible
quantization information embedded within an operation, together with the
functional information about how that information is used, as described in the
specification of the operation.</p><h2 id=tosa-operator-rationale>TOSA Operator Rationale&nbsp;<a class=headline-hash href=#tosa-operator-rationale>¶</a></h2><p>The general basis of selection of the operator set that constitutes TOSA is
described in the TOSA specification document under Section 1.3 Operator
Selection. Explanation of the thinking behind some operators is listed here:</p><h3 id=cond_if-and-while_loop>COND_IF and WHILE_LOOP&nbsp;<a class=headline-hash href=#cond_if-and-while_loop>¶</a></h3><p>Several neural networks express conditional control flow at the tensor level.
A survey of multiple high level frameworks indicated that conditional if and
a loop construct are common in all major frameworks, with some variation.
Since TOSA endeavors to be complete in expressing tensor level functionality
including control flow, it implements these constructs.</p><p>The COND_IF and WHILE_LOOP operators implement such structured control
flow forms and should be lowerable to corresponding ops in the scf dialect.
Since the dialect seeks to remain isomorphic with an external, serialized form,
the decision was to keep these ops in the dialect (as opposed to deferring
completely to scf), and this may be re-evaluated if this turns out to not yield
the expected value.</p><h2 id=using-tosa-in-a-compiler>Using TOSA In A Compiler&nbsp;<a class=headline-hash href=#using-tosa-in-a-compiler>¶</a></h2><p>The TOSA specification describes each operator in functional detail. It is
expected that compilers that use TOSA will use its builders to construct the
operators so that the quantization information for the operator is correctly
generated.</p><p>The functional steps described in the pseudocode of the specification enables
the construction of code generation for that operation, or decisions on the
design of underlying hardware. The functional pseudocode also describes
how the quantization parameters are utilized within the operation.</p><h3 id=quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors&nbsp;<a class=headline-hash href=#quantization-parameters-in-ops-vs-tensors>¶</a></h3><p>TOSA uses the quantization parameters embedded in the input and output
tensors to construct the quantization attributes that sit within the operator.
Once these attributes are constructed, the quantization information within
the tensors are no longer necessary for code generation.</p><p>This enables the tensors to be subsequently interpreted simply as contiguous
buffers containing raw data, with no &lsquo;meta information&rsquo; in the form of the
quantization_type. Precision related manipulation of the input or output are
instead described by the operator itself which describes, for example, when
the zero point is applied, or when the scale multiplication is done.</p><p>However, TOSA does <em>not</em> eliminate the existing MLIR QuantOps quantization
type information within the tensors; this leaves the choice of how to handle
quantization information, to later backend code generation steps.</p><p>Maintaining the ability to overlap these different representations of
quantization parameters (i.e. tensor-carried vs op-carried) is an important
capability when considering progressive lowering between uses that expect one
scheme vs the other.</p><h2 id=operation-definitions>Operation definitions&nbsp;<a class=headline-hash href=#operation-definitions>¶</a></h2><h3 id=tosaabs-mlirtosaabsop><code>tosa.abs</code> (mlir::tosa::AbsOp)&nbsp;<a class=headline-hash href=#tosaabs-mlirtosaabsop>¶</a></h3><p>Elementwise abs op</p><p>Elementwise absolute value operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaadd-mlirtosaaddop><code>tosa.add</code> (mlir::tosa::AddOp)&nbsp;<a class=headline-hash href=#tosaadd-mlirtosaaddop>¶</a></h3><p>Elementwise addition operator</p><p>Elementwise addition of input1 and input2. Axis of size 1 will be broadcast,
as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaapply_scale-mlirtosaapplyscaleop><code>tosa.apply_scale</code> (mlir::tosa::ApplyScaleOp)&nbsp;<a class=headline-hash href=#tosaapply_scale-mlirtosaapplyscaleop>¶</a></h3><p>Rescale scalar operator for Tosa tensor operators</p><p>Applies rescaling for fixed point values. This behavior is replicated in
multiple quantized operations (mul, convolution, rescale, matmul, pooling).</p><p>The commonplace implementation is to use i64 operations to avoid integer
overflow with target specific implementations can use native operations to
avoid wider than necessary types.</p><p>Traits: Elementwise, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>double_round</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>multiplier</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>shift</code></td><td>signless-integer-8-bit-like</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=tosaargmax-mlirtosaargmaxop><code>tosa.argmax</code> (mlir::tosa::ArgMaxOp)&nbsp;<a class=headline-hash href=#tosaargmax-mlirtosaargmaxop>¶</a></h3><p>Perform argmax on the input.</p><p>This returns the index with the largest value across the given axis of the
input tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop><code>tosa.arithmetic_right_shift</code> (mlir::tosa::ArithmeticRightShiftOp)&nbsp;<a class=headline-hash href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop>¶</a></h3><p>Elementwise Arithmetic Right Shift</p><p>Elementwise arithmetic right shift of input1 by the amount specified in
input2. Axis of size 1 will be broadcast, as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>round</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaavg_pool2d-mlirtosaavgpool2dop><code>tosa.avg_pool2d</code> (mlir::tosa::AvgPool2dOp)&nbsp;<a class=headline-hash href=#tosaavg_pool2d-mlirtosaavgpool2dop>¶</a></h3><p>Performs max pooling on the input.</p><p>This performs an average pooling over the given input tensor. A sliding
window of size given by <kernel size>is passed over the input tensor, with
the mean value being placed in the output tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>kernel</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::UnaryOpQuantizationAttr</td><td>Attribute for UnaryOp quantization information.</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_and-mlirtosabitwiseandop><code>tosa.bitwise_and</code> (mlir::tosa::BitwiseAndOp)&nbsp;<a class=headline-hash href=#tosabitwise_and-mlirtosabitwiseandop>¶</a></h3><p>Bitwise AND operator</p><p>Elementwise bitwise AND of input1 and input2. Axis of size 1
will be broadcast as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_not-mlirtosabitwisenotop><code>tosa.bitwise_not</code> (mlir::tosa::BitwiseNotOp)&nbsp;<a class=headline-hash href=#tosabitwise_not-mlirtosabitwisenotop>¶</a></h3><p>Bitwise NOT operator</p><p>Elementwise bitwise NOT of input tensor.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_or-mlirtosabitwiseorop><code>tosa.bitwise_or</code> (mlir::tosa::BitwiseOrOp)&nbsp;<a class=headline-hash href=#tosabitwise_or-mlirtosabitwiseorop>¶</a></h3><p>Bitwise OR operator</p><p>Elementwise bitwise OR of input1 and input2. Axis of size 1 will be
broadcast as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_xor-mlirtosabitwisexorop><code>tosa.bitwise_xor</code> (mlir::tosa::BitwiseXorOp)&nbsp;<a class=headline-hash href=#tosabitwise_xor-mlirtosabitwisexorop>¶</a></h3><p>Bitwise XOR operator</p><p>Elementwise bitwise XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosacast-mlirtosacastop><code>tosa.cast</code> (mlir::tosa::CastOp)&nbsp;<a class=headline-hash href=#tosacast-mlirtosacastop>¶</a></h3><p>Cast operation</p><p>Performs a set of permissible cast operations</p><table><thead><tr><th>Mode Input Output</th></tr></thead><tbody><tr><td>signed 8 to bool int8 Boolean</td></tr><tr><td>signed 16 to bool int16 Boolean</td></tr><tr><td>signed 32 to bool int32 Boolean</td></tr><tr><td>bool to 8 Boolean int8</td></tr><tr><td>bool to 16 Boolean int16</td></tr><tr><td>bool to 32 Boolean int32</td></tr><tr><td>signed 8 to signed 16 int8 int16</td></tr><tr><td>signed 8 to signed 32 int8 int32</td></tr><tr><td>signed 16 to signed 8 int16 int8</td></tr><tr><td>signed 16 to signed 32 int16 int32</td></tr><tr><td>signed 32 to signed 8 int32 int8</td></tr><tr><td>signed 32 to signed 16 int32 int16</td></tr><tr><td>float to signed 8 float int8</td></tr><tr><td>float to signed 16 float int16</td></tr><tr><td>signed 8 to float int8 float</td></tr><tr><td>signed 16 to float int16 float</td></tr></tbody></table><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaceil-mlirtosaceilop><code>tosa.ceil</code> (mlir::tosa::CeilOp)&nbsp;<a class=headline-hash href=#tosaceil-mlirtosaceilop>¶</a></h3><p>Elementwise ceil op</p><p>Elementwise ceiling operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaclamp-mlirtosaclampop><code>tosa.clamp</code> (mlir::tosa::ClampOp)&nbsp;<a class=headline-hash href=#tosaclamp-mlirtosaclampop>¶</a></h3><p>Computes clamp(features, min, max).</p><p>Clamp to an arbitrary minimum and maximum value.
Maximum and minimum values are specified as values in the range of the
input type.
No zero point subtraction is done to the values, thus to clamp to the zero
point value, the zero point itself should be supplied as the minimum value.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>min_int</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>max_int</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>min_fp</code></td><td style=text-align:center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr><tr><td style=text-align:center><code>max_fp</code></td><td style=text-align:center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaclz-mlirtosaclzop><code>tosa.clz</code> (mlir::tosa::ClzOp)&nbsp;<a class=headline-hash href=#tosaclz-mlirtosaclzop>¶</a></h3><p>Elementwise count leading zero op</p><p>Elementwise count leading zeros operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaconcat-mlirtosaconcatop><code>tosa.concat</code> (mlir::tosa::ConcatOp)&nbsp;<a class=headline-hash href=#tosaconcat-mlirtosaconcatop>¶</a></h3><p>Concatenates tensors along one dimension.</p><p>Concatenate a variadic amount of tensors along a given axis. No data
conversion happens during a concat operation.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaconst-mlirtosaconstop><code>tosa.const</code> (mlir::tosa::ConstOp)&nbsp;<a class=headline-hash href=#tosaconst-mlirtosaconstop>¶</a></h3><p>Constant op.</p><p>A node containing constant data for use as the input to an operation. May
hold data in any of the supported data formats.</p><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaconv2d-mlirtosaconv2dop><code>tosa.conv2d</code> (mlir::tosa::Conv2DOp)&nbsp;<a class=headline-hash href=#tosaconv2d-mlirtosaconv2dop>¶</a></h3><p>2D Convolution Operator</p><p>Performs a 2D convolution over the given tensor input, using the weight
tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>dilation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>weight</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>bias</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosaconv3d-mlirtosaconv3dop><code>tosa.conv3d</code> (mlir::tosa::Conv3DOp)&nbsp;<a class=headline-hash href=#tosaconv3d-mlirtosaconv3dop>¶</a></h3><p>3D Convolution operator</p><p>Performs a 3D convolution over the given input tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 6 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 3 elements</td></tr><tr><td style=text-align:center><code>dilation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 3 elements</td></tr><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 5D tensor of number values</td></tr><tr><td style=text-align:center><code>weight</code></td><td>unranked.tensor of number values or 5D tensor of number values</td></tr><tr><td style=text-align:center><code>bias</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 5D tensor of number values</td></tr></tbody></table><h3 id=tosacustom-mlirtosacustomop><code>tosa.custom</code> (mlir::tosa::CustomOp)&nbsp;<a class=headline-hash href=#tosacustom-mlirtosacustomop>¶</a></h3><p>Custom operator wrapper for Tosa</p><p>Hardware implementing TOSA may choose to add additional custom operators
that are not expressed in the existing TOSA operations. These operators are
not expected to be portable across TOSA implementations. The input and
output signatures must be expressed in the corresponding TOSA node.</p><p>Interfaces: TosaOpInterface</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>identifier</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosadepthwise_conv2d-mlirtosadepthwiseconv2dop><code>tosa.depthwise_conv2d</code> (mlir::tosa::DepthwiseConv2DOp)&nbsp;<a class=headline-hash href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop>¶</a></h3><p>Depthwise 2D Convolution operator</p><p>Performs 2D convolutions separately over each channel of the given tensor
input, using the weight tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>dilation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>weight</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>bias</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosadiv-mlirtosadivop><code>tosa.div</code> (mlir::tosa::DivOp)&nbsp;<a class=headline-hash href=#tosadiv-mlirtosadivop>¶</a></h3><p>Integer divide operator</p><p>Elementwise integer divide operator of input1 by input2. Axis of size 1
will be broadcast, as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of 32-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of 32-bit signless integer values</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of 32-bit signless integer values</td></tr></tbody></table><h3 id=tosaequal-mlirtosaequalop><code>tosa.equal</code> (mlir::tosa::EqualOp)&nbsp;<a class=headline-hash href=#tosaequal-mlirtosaequalop>¶</a></h3><p>Returns the truth value of (x == y) element-wise.</p><p>Elementwise comparison operation</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaexp-mlirtosaexpop><code>tosa.exp</code> (mlir::tosa::ExpOp)&nbsp;<a class=headline-hash href=#tosaexp-mlirtosaexpop>¶</a></h3><p>Elementwise exp op</p><p>Elementwise e to the x operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosafloor-mlirtosafloorop><code>tosa.floor</code> (mlir::tosa::FloorOp)&nbsp;<a class=headline-hash href=#tosafloor-mlirtosafloorop>¶</a></h3><p>Elementwise floor op</p><p>Elementwise floor operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosafully_connected-mlirtosafullyconnectedop><code>tosa.fully_connected</code> (mlir::tosa::FullyConnectedOp)&nbsp;<a class=headline-hash href=#tosafully_connected-mlirtosafullyconnectedop>¶</a></h3><p>Fully Connected operator</p><p>Performs a fully connected network.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 2D tensor of number values</td></tr><tr><td style=text-align:center><code>weight</code></td><td>unranked.tensor of number values or 2D tensor of number values</td></tr><tr><td style=text-align:center><code>bias</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 2D tensor of number values</td></tr></tbody></table><h3 id=tosagather-mlirtosagatherop><code>tosa.gather</code> (mlir::tosa::GatherOp)&nbsp;<a class=headline-hash href=#tosagather-mlirtosagatherop>¶</a></h3><p>Gather operation,</p><p>Generate a tensor for which each element in the output is a slice of the
values tensor based on the value of indices.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>2D tensor of 32-bit signless integer values</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr></tbody></table><h3 id=tosagreater_equal-mlirtosagreaterequalop><code>tosa.greater_equal</code> (mlir::tosa::GreaterEqualOp)&nbsp;<a class=headline-hash href=#tosagreater_equal-mlirtosagreaterequalop>¶</a></h3><p>Returns the truth value of (x >= y) element-wise.</p><p>Elementwise comparison operation</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosagreater-mlirtosagreaterop><code>tosa.greater</code> (mlir::tosa::GreaterOp)&nbsp;<a class=headline-hash href=#tosagreater-mlirtosagreaterop>¶</a></h3><p>Returns the truth value of (x > y) element-wise.</p><p>Elementwise greater than comparison operation</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaidentity-mlirtosaidentityop><code>tosa.identity</code> (mlir::tosa::IdentityOp)&nbsp;<a class=headline-hash href=#tosaidentity-mlirtosaidentityop>¶</a></h3><p>Identity operator</p><p>Returns a tensor with the same shape, size, type
and content as the input.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosacond_if-mlirtosaifop><code>tosa.cond_if</code> (mlir::tosa::IfOp)&nbsp;<a class=headline-hash href=#tosacond_if-mlirtosaifop>¶</a></h3><p>Conditional if operator</p><p>Evaluates a Boolean condition and then takes one of two distinct execution
paths. This implements the semantic If-then-else structure.</p><p>Traits: RecursiveSideEffects, SingleBlockImplicitTerminator<yieldop></p><p>Interfaces: InferShapedTypeOpInterface, TosaOpInterface</p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosalog-mlirtosalogop><code>tosa.log</code> (mlir::tosa::LogOp)&nbsp;<a class=headline-hash href=#tosalog-mlirtosalogop>¶</a></h3><p>Elementwise log op</p><p>Elementwise natural logarithm operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosalogical_and-mlirtosalogicalandop><code>tosa.logical_and</code> (mlir::tosa::LogicalAndOp)&nbsp;<a class=headline-hash href=#tosalogical_and-mlirtosalogicalandop>¶</a></h3><p>Returns the truth value of x AND y element-wise.</p><p>Elementwise logical AND of input1 and input2. Axis of size 1 will be
broadcast, as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_left_shift-mlirtosalogicalleftshiftop><code>tosa.logical_left_shift</code> (mlir::tosa::LogicalLeftShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_left_shift-mlirtosalogicalleftshiftop>¶</a></h3><p>Elementwise Logical Left Shift</p><p>Elementwise left shift of input1 and input2. Axis of size 1 will be
broadcast, as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosalogical_not-mlirtosalogicalnotop><code>tosa.logical_not</code> (mlir::tosa::LogicalNotOp)&nbsp;<a class=headline-hash href=#tosalogical_not-mlirtosalogicalnotop>¶</a></h3><p>Returns the truth value of NOT x element-wise.</p><p>Elementwise logical NOT of input.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_or-mlirtosalogicalorop><code>tosa.logical_or</code> (mlir::tosa::LogicalOrOp)&nbsp;<a class=headline-hash href=#tosalogical_or-mlirtosalogicalorop>¶</a></h3><p>Returns the truth value of x OR y element-wise.</p><p>Elementwise logical OR of input1 and input2. Axis of size 1 will be
broadcast as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_right_shift-mlirtosalogicalrightshiftop><code>tosa.logical_right_shift</code> (mlir::tosa::LogicalRightShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_right_shift-mlirtosalogicalrightshiftop>¶</a></h3><p>Elementwise Logical Right Shift</p><p>Elementwise logical right shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosalogical_xor-mlirtosalogicalxorop><code>tosa.logical_xor</code> (mlir::tosa::LogicalXorOp)&nbsp;<a class=headline-hash href=#tosalogical_xor-mlirtosalogicalxorop>¶</a></h3><p>Returns the truth value of x XOR y element-wise.</p><p>Elementwise logical XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosamatmul-mlirtosamatmulop><code>tosa.matmul</code> (mlir::tosa::MatMulOp)&nbsp;<a class=headline-hash href=#tosamatmul-mlirtosamatmulop>¶</a></h3><p>Matrix multiplication with bias</p><p>Performs a two dimensional matrix multiplication. This allows both inputs to
be activations, rather than reserving weights as an attribute in the
FULLY_CONNECTED operator.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::MatMulOpQuantizationAttr</td><td>Attribute for MatMulOp quantization information.</td></tr></tbody></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr><tr><td style=text-align:center><code>b</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>c</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr></tbody></table><h3 id=tosamax_pool2d-mlirtosamaxpool2dop><code>tosa.max_pool2d</code> (mlir::tosa::MaxPool2dOp)&nbsp;<a class=headline-hash href=#tosamax_pool2d-mlirtosamaxpool2dop>¶</a></h3><p>Performs max pooling on the input.</p><p>This performs a max pooling over the given input tensor. A sliding window of
size given by <kernel size>is passed over the input tensor, with the
maximum value being placed in the
output tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>kernel</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr></tbody></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosamaximum-mlirtosamaximumop><code>tosa.maximum</code> (mlir::tosa::MaximumOp)&nbsp;<a class=headline-hash href=#tosamaximum-mlirtosamaximumop>¶</a></h3><p>Elementwise Maximum</p><p>Elementwise max of input1 and input2. Axis of size 1 will be broadcast, as
necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaminimum-mlirtosaminimumop><code>tosa.minimum</code> (mlir::tosa::MinimumOp)&nbsp;<a class=headline-hash href=#tosaminimum-mlirtosaminimumop>¶</a></h3><p>Elementwise Minimum</p><p>Elementwise minimum of input1 and input2. Axis of size 1
will be broadcast, as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosamul-mlirtosamulop><code>tosa.mul</code> (mlir::tosa::MulOp)&nbsp;<a class=headline-hash href=#tosamul-mlirtosamulop>¶</a></h3><p>Multiplication operator</p><p>Elementwise multiplication (Hadamard product) of input1 and input2.
Axis of size 1 will be broadcast, as necessary.</p><p>Traits: Commutative, ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>shift</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosanegate-mlirtosanegateop><code>tosa.negate</code> (mlir::tosa::NegateOp)&nbsp;<a class=headline-hash href=#tosanegate-mlirtosanegateop>¶</a></h3><p>Elementwise negate op</p><p>Elementwise negation operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::UnaryOpQuantizationAttr</td><td>Attribute for UnaryOp quantization information.</td></tr></tbody></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosapad-mlirtosapadop><code>tosa.pad</code> (mlir::tosa::PadOp)&nbsp;<a class=headline-hash href=#tosapad-mlirtosapadop>¶</a></h3><p>Pads a tensor with value specified.</p><p>Pads a tensor along borders of each dimension with pad_value.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::PadOpQuantizationAttr</td><td>Attribute for PadOp quantization information.</td></tr></tbody></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>ranked tensor of number values</td></tr><tr><td style=text-align:center><code>padding</code></td><td>tensor of 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>pad_const</code></td><td>0D tensor of number values</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of number values</td></tr></tbody></table><h3 id=tosapow-mlirtosapowop><code>tosa.pow</code> (mlir::tosa::PowOp)&nbsp;<a class=headline-hash href=#tosapow-mlirtosapowop>¶</a></h3><p>Computes the power of one value to another.</p><p>Elementwise input1 raised to the power of input2.
Axis of size 1 will be broadcast, as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>z</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosareciprocal-mlirtosareciprocalop><code>tosa.reciprocal</code> (mlir::tosa::ReciprocalOp)&nbsp;<a class=headline-hash href=#tosareciprocal-mlirtosareciprocalop>¶</a></h3><p>Elementwise reciprocal op</p><p>Elementwise reciprocal operation. For integer operation, a TABLE should be
used with the appropriate ranges.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosareduce_all-mlirtosareduceallop><code>tosa.reduce_all</code> (mlir::tosa::ReduceAllOp)&nbsp;<a class=headline-hash href=#tosareduce_all-mlirtosareduceallop>¶</a></h3><p>Reduce All operator</p><p>Reduce a tensor along the given axis with a logical AND operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_any-mlirtosareduceanyop><code>tosa.reduce_any</code> (mlir::tosa::ReduceAnyOp)&nbsp;<a class=headline-hash href=#tosareduce_any-mlirtosareduceanyop>¶</a></h3><p>Reduce Any operator</p><p>Reduce a tensor along the given axis with a logical OR operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_max-mlirtosareducemaxop><code>tosa.reduce_max</code> (mlir::tosa::ReduceMaxOp)&nbsp;<a class=headline-hash href=#tosareduce_max-mlirtosareducemaxop>¶</a></h3><p>Reduce Max operator</p><p>Reduce a tensor along the given axis with a maximum operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_min-mlirtosareduceminop><code>tosa.reduce_min</code> (mlir::tosa::ReduceMinOp)&nbsp;<a class=headline-hash href=#tosareduce_min-mlirtosareduceminop>¶</a></h3><p>Reduce Min operator</p><p>Reduce a tensor along the given axis with a minimum operation</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_prod-mlirtosareduceprodop><code>tosa.reduce_prod</code> (mlir::tosa::ReduceProdOp)&nbsp;<a class=headline-hash href=#tosareduce_prod-mlirtosareduceprodop>¶</a></h3><p>Reduce Prod operator</p><p>Reduce a tensor along the given axis by computing the product of the axis.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_sum-mlirtosareducesumop><code>tosa.reduce_sum</code> (mlir::tosa::ReduceSumOp)&nbsp;<a class=headline-hash href=#tosareduce_sum-mlirtosareducesumop>¶</a></h3><p>Reduce Sum operator</p><p>Reduce a tensor along the given axis by computing the sum of the axis.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosarelun-mlirtosarelunop><code>tosa.reluN</code> (mlir::tosa::ReluNOp)&nbsp;<a class=headline-hash href=#tosarelun-mlirtosarelunop>¶</a></h3><p>Computes rectified linear: <code>max(features, N)</code>.</p><p>ReLU with a scalar maximum value.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>max_int</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>max_fp</code></td><td style=text-align:center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr></tbody></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosarescale-mlirtosarescaleop><code>tosa.rescale</code> (mlir::tosa::RescaleOp)&nbsp;<a class=headline-hash href=#tosarescale-mlirtosarescaleop>¶</a></h3><p>Tosa rescale operator</p><p>Rescale quantized values into a new domain. Supported rescalings are:
Mode Input Output
signed 8 to 8 int8 int8
signed 8 to 16 int8 int16
signed 8 to 32 int8 int32
signed 16 to 8 int16 int8
signed 16 to 16 int16 int16
signed 16 to 32 int16 int32
signed 32 to 8 int32 int8
signed 32 to 16 int32 int16
signed 32 to 32 int32 int32
signed 48 to 8 int48 int8
signed 48 to 16 int48 int16
signed 48 to 32 int48 int32
unsigned 8 to signed 8 uint8 int8
signed 8 to unsigned 8 int8 uint8</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_zp</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>output_zp</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>multiplier</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td style=text-align:center><code>shift</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td style=text-align:center><code>scale32</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>double_round</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>per_channel</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosareshape-mlirtosareshapeop><code>tosa.reshape</code> (mlir::tosa::ReshapeOp)&nbsp;<a class=headline-hash href=#tosareshape-mlirtosareshapeop>¶</a></h3><p>Reshape operator</p><p>Returns a tensor with the same type/values as the input, with a new shape
specified by the shape argument. Reshape may operate on tensors of any rank.
No data conversion happens during a reshape operation.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>new_shape</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of number values</td></tr></tbody></table><h3 id=tosaresize-mlirtosaresizeop><code>tosa.resize</code> (mlir::tosa::ResizeOp)&nbsp;<a class=headline-hash href=#tosaresize-mlirtosaresizeop>¶</a></h3><p>Resize operation, supports various resize/upsample modes</p><p>Resizes a tensor. Resize is only allowed in the H and W dimensions. In
expected use, stride_y is approximately (IH&#171;shift)/OH and stride_x is
approximately (IW&#171;shift)/OW. OH and OW are also supplied as inputs since
there may be off by one errors if calculating OH and OW from the strides.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_size</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>offset</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>shift</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>stride_fp</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>32-bit float array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>offset_fp</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>32-bit float array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>mode</code></td><td style=text-align:center>::mlir::StringAttr</td><td>Supported resize/upsampling strategies</td></tr></tbody></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosareverse-mlirtosareverseop><code>tosa.reverse</code> (mlir::tosa::ReverseOp)&nbsp;<a class=headline-hash href=#tosareverse-mlirtosareverseop>¶</a></h3><p>Reverse operator</p><p>Returns a tensor with the same type/values as the input, with the data
reversed along the given axis. No data conversion happens during a reverse
operation.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>axis</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosarsqrt-mlirtosarsqrtop><code>tosa.rsqrt</code> (mlir::tosa::RsqrtOp)&nbsp;<a class=headline-hash href=#tosarsqrt-mlirtosarsqrtop>¶</a></h3><p>Elementwise 1/sqrt op</p><p>Elementwise reciprocal square root operation. For integer operation, a TABLE
should be used with the appropriate ranges.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosascatter-mlirtosascatterop><code>tosa.scatter</code> (mlir::tosa::ScatterOp)&nbsp;<a class=headline-hash href=#tosascatter-mlirtosascatterop>¶</a></h3><p>Scatter operation,</p><p>The values_out tensor is set to the values_in tensor with data modified as follows:
data from the input tensor is inserted at the positions specified by the indices tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values_in</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>2D tensor of 32-bit signless integer values</td></tr><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values_out</code></td><td>unranked.tensor of number values or 3D tensor of number values</td></tr></tbody></table><h3 id=tosaselect-mlirtosaselectop><code>tosa.select</code> (mlir::tosa::SelectOp)&nbsp;<a class=headline-hash href=#tosaselect-mlirtosaselectop>¶</a></h3><p>Elementwise select operator</p><p>Elementwise select of the output based on a condition.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pred</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>on_true</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>on_false</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosasigmoid-mlirtosasigmoidop><code>tosa.sigmoid</code> (mlir::tosa::SigmoidOp)&nbsp;<a class=headline-hash href=#tosasigmoid-mlirtosasigmoidop>¶</a></h3><p>Computes elementwise sigmoid of input.</p><p>Sigmoid function: output = 1 / (1 + exp(-input))
For quantized integer data types, the TABLE operator should be used instead
with the following definition. The sigmoid table has 513 entries each of
16-bit precision and covering the input range -16.0 to +16.0
in steps of 1/16.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosaslice-mlirtosasliceop><code>tosa.slice</code> (mlir::tosa::SliceOp)&nbsp;<a class=headline-hash href=#tosaslice-mlirtosasliceop>¶</a></h3><p>Slice operator</p><p>Extracts a slice of the input1 on the given axis, beginning at the
start coordinates, and extending for size elements in each direction. No
data conversion happens during a slice operation.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>start</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>size</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosasub-mlirtosasubop><code>tosa.sub</code> (mlir::tosa::SubOp)&nbsp;<a class=headline-hash href=#tosasub-mlirtosasubop>¶</a></h3><p>Elementwise subtraction operator</p><p>Elementwise subtraction of input1 and input2. Axis of size 1 will be
broadcast as necessary.</p><p>Traits: ResultsBroadcastableShape</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosatable-mlirtosatableop><code>tosa.table</code> (mlir::tosa::TableOp)&nbsp;<a class=headline-hash href=#tosatable-mlirtosatableop>¶</a></h3><p>Table lookup op</p><p>Interpolated table lookup operation. Input values are scaled to create a
fixed-point 9.7 value. The high 9 bits are used to index into the table.
The fractional bits are used to interpolate based on the looked up value and
the index+1 value in the table. The TABLE operator then returns a 16.7
interpolated value. Note that there must be 513 values to handle the full
range of inputs.</p><p>The TABLE operator is expected to be used as follows:</p><ul><li>A RESCALE node is expected before the TABLE operator to scale the input
to a full int16_t range for the table lookup</li><li>If an int16_t result is required then follow the TABLE operator with a
RESCALE with a right shift of 7</li><li>If an int8_t result is required then follow the TABLE operator with a
RESCALE with a right shift of 15</li></ul><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr><tr><td style=text-align:center><code>table</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosatanh-mlirtosatanhop><code>tosa.tanh</code> (mlir::tosa::TanhOp)&nbsp;<a class=headline-hash href=#tosatanh-mlirtosatanhop>¶</a></h3><p>Computes elementwise hyperbolic tangent of input</p><p>Parameterized hyperbolic tangent.
For quantized integer data types, the TABLE operator should be used instead
with the following definition. The tanh_table has 513 entries each of
16-bit precision and covering the input range -8.0 to +8.0 in steps of 1/32.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosatile-mlirtosatileop><code>tosa.tile</code> (mlir::tosa::TileOp)&nbsp;<a class=headline-hash href=#tosatile-mlirtosatileop>¶</a></h3><p>Tile operator</p><p>Replicates input 0 multiplies times along each dimension.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>multiples</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosatranspose_conv2d-mlirtosatransposeconv2dop><code>tosa.transpose_conv2d</code> (mlir::tosa::TransposeConv2DOp)&nbsp;<a class=headline-hash href=#tosatranspose_conv2d-mlirtosatransposeconv2dop>¶</a></h3><p>Transpose 2D Convolution operator.</p><p>Performs a 2D transposed convolution over the given tensor input, using the
weights tensor.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out_pad</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>stride</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>dilation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td style=text-align:center><code>out_shape</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with at least 4 elements</td></tr><tr><td style=text-align:center><code>quantization_info</code></td><td style=text-align:center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>filter</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr><tr><td style=text-align:center><code>bias</code></td><td>unranked.tensor of number values or 1D tensor of number values</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 4D tensor of number values</td></tr></tbody></table><h3 id=tosatranspose-mlirtosatransposeop><code>tosa.transpose</code> (mlir::tosa::TransposeOp)&nbsp;<a class=headline-hash href=#tosatranspose-mlirtosatransposeop>¶</a></h3><p>Transpose operator</p><p>Permutes the dimensions based on perm.</p><p>Interfaces: InferShapedTypeOpInterface, NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D/5D/6D tensor of number values</td></tr><tr><td style=text-align:center><code>perms</code></td><td>tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>unranked.tensor of number values or 1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosawhile_loop-mlirtosawhileop><code>tosa.while_loop</code> (mlir::tosa::WhileOp)&nbsp;<a class=headline-hash href=#tosawhile_loop-mlirtosawhileop>¶</a></h3><p>output = input; While (Cond(output)) {output = Body(output)}</p><p>Generates and evaluates a Bool condition and either executes a loop body or
exits to another control point. This action is performed repeatedly after
updating and re-evaluating the Boolean condition every iteration. This
implements the semantic foreach or while iterative loop structure.</p><p>Traits: RecursiveSideEffects, SingleBlockImplicitTerminator<yieldop></p><p>Interfaces: InferShapedTypeOpInterface, LoopLikeOpInterface, TosaOpInterface</p><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosayield-mlirtosayieldop><code>tosa.yield</code> (mlir::tosa::YieldOp)&nbsp;<a class=headline-hash href=#tosayield-mlirtosayieldop>¶</a></h3><p>yield operator</p><p>return operation within the conditional and body of
structured control flow. Operation takes variadic operands
but produces no results of its own.</p><p>Traits: Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), TosaOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Builtin/ title="Builtin Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Builtin Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Transform/ title="Transform Dialect">Next - Transform Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li class=active><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>