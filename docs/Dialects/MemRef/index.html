<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'memref' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/MemRef/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'memref' Dialect</h1><p>This dialect provides documentation for operations within the MemRef dialect.</p><p><strong>Please post an RFC on the
<a href=https://llvm.discourse.group/c/mlir/31>forum</a>
before adding or changing any operation in this dialect.</strong></p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#memrefassume_alignment-mlirmemrefassumealignmentop><code>memref.assume_alignment</code> (::mlir::memref::AssumeAlignmentOp)</a></li><li><a href=#memrefatomic_rmw-mlirmemrefatomicrmwop><code>memref.atomic_rmw</code> (::mlir::memref::AtomicRMWOp)</a></li><li><a href=#memrefatomic_yield-mlirmemrefatomicyieldop><code>memref.atomic_yield</code> (::mlir::memref::AtomicYieldOp)</a></li><li><a href=#memrefcopy-mlirmemrefcopyop><code>memref.copy</code> (::mlir::memref::CopyOp)</a></li><li><a href=#memrefgeneric_atomic_rmw-mlirmemrefgenericatomicrmwop><code>memref.generic_atomic_rmw</code> (::mlir::memref::GenericAtomicRMWOp)</a></li><li><a href=#memrefload-mlirmemrefloadop><code>memref.load</code> (::mlir::memref::LoadOp)</a></li><li><a href=#memrefalloc-mlirmemrefallocop><code>memref.alloc</code> (::mlir::memref::AllocOp)</a></li><li><a href=#memrefalloca-mlirmemrefallocaop><code>memref.alloca</code> (::mlir::memref::AllocaOp)</a></li><li><a href=#memrefalloca_scope-mlirmemrefallocascopeop><code>memref.alloca_scope</code> (::mlir::memref::AllocaScopeOp)</a></li><li><a href=#memrefalloca_scopereturn-mlirmemrefallocascopereturnop><code>memref.alloca_scope.return</code> (::mlir::memref::AllocaScopeReturnOp)</a></li><li><a href=#memrefcast-mlirmemrefcastop><code>memref.cast</code> (::mlir::memref::CastOp)</a></li><li><a href=#memrefcollapse_shape-mlirmemrefcollapseshapeop><code>memref.collapse_shape</code> (::mlir::memref::CollapseShapeOp)</a></li><li><a href=#memrefdealloc-mlirmemrefdeallocop><code>memref.dealloc</code> (::mlir::memref::DeallocOp)</a></li><li><a href=#memrefdim-mlirmemrefdimop><code>memref.dim</code> (::mlir::memref::DimOp)</a></li><li><a href=#memrefdma_start-mlirmemrefdmastartop><code>memref.dma_start</code> (::mlir::memref::DmaStartOp)</a></li><li><a href=#memrefdma_wait-mlirmemrefdmawaitop><code>memref.dma_wait</code> (::mlir::memref::DmaWaitOp)</a></li><li><a href=#memrefexpand_shape-mlirmemrefexpandshapeop><code>memref.expand_shape</code> (::mlir::memref::ExpandShapeOp)</a></li><li><a href=#memrefget_global-mlirmemrefgetglobalop><code>memref.get_global</code> (::mlir::memref::GetGlobalOp)</a></li><li><a href=#memrefglobal-mlirmemrefglobalop><code>memref.global</code> (::mlir::memref::GlobalOp)</a></li><li><a href=#memrefprefetch-mlirmemrefprefetchop><code>memref.prefetch</code> (::mlir::memref::PrefetchOp)</a></li><li><a href=#memrefrank-mlirmemrefrankop><code>memref.rank</code> (::mlir::memref::RankOp)</a></li><li><a href=#memrefreinterpret_cast-mlirmemrefreinterpretcastop><code>memref.reinterpret_cast</code> (::mlir::memref::ReinterpretCastOp)</a></li><li><a href=#memrefreshape-mlirmemrefreshapeop><code>memref.reshape</code> (::mlir::memref::ReshapeOp)</a></li><li><a href=#memrefstore-mlirmemrefstoreop><code>memref.store</code> (::mlir::memref::StoreOp)</a></li><li><a href=#memreftranspose-mlirmemreftransposeop><code>memref.transpose</code> (::mlir::memref::TransposeOp)</a></li><li><a href=#memrefview-mlirmemrefviewop><code>memref.view</code> (::mlir::memref::ViewOp)</a></li><li><a href=#memrefsubview-mlirmemrefsubviewop><code>memref.subview</code> (::mlir::memref::SubViewOp)</a></li><li><a href=#memreftensor_store-mlirmemreftensorstoreop><code>memref.tensor_store</code> (::mlir::memref::TensorStoreOp)</a></li><li><a href=#dma_start-operation>&lsquo;dma_start&rsquo; operation</a></li><li><a href=#dma_wait-operation>&lsquo;dma_wait&rsquo; operation</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p>The <code>memref</code> dialect is intended to hold core memref creation and
manipulation ops, which are not strongly associated with any particular
other dialect or domain abstraction.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#memrefassume_alignment-mlirmemrefassumealignmentop><code>memref.assume_alignment</code> (::mlir::memref::AssumeAlignmentOp)</a></li><li><a href=#memrefatomic_rmw-mlirmemrefatomicrmwop><code>memref.atomic_rmw</code> (::mlir::memref::AtomicRMWOp)</a></li><li><a href=#memrefatomic_yield-mlirmemrefatomicyieldop><code>memref.atomic_yield</code> (::mlir::memref::AtomicYieldOp)</a></li><li><a href=#memrefcopy-mlirmemrefcopyop><code>memref.copy</code> (::mlir::memref::CopyOp)</a></li><li><a href=#memrefgeneric_atomic_rmw-mlirmemrefgenericatomicrmwop><code>memref.generic_atomic_rmw</code> (::mlir::memref::GenericAtomicRMWOp)</a></li><li><a href=#memrefload-mlirmemrefloadop><code>memref.load</code> (::mlir::memref::LoadOp)</a></li><li><a href=#memrefalloc-mlirmemrefallocop><code>memref.alloc</code> (::mlir::memref::AllocOp)</a></li><li><a href=#memrefalloca-mlirmemrefallocaop><code>memref.alloca</code> (::mlir::memref::AllocaOp)</a></li><li><a href=#memrefalloca_scope-mlirmemrefallocascopeop><code>memref.alloca_scope</code> (::mlir::memref::AllocaScopeOp)</a></li><li><a href=#memrefalloca_scopereturn-mlirmemrefallocascopereturnop><code>memref.alloca_scope.return</code> (::mlir::memref::AllocaScopeReturnOp)</a></li><li><a href=#memrefcast-mlirmemrefcastop><code>memref.cast</code> (::mlir::memref::CastOp)</a></li><li><a href=#memrefcollapse_shape-mlirmemrefcollapseshapeop><code>memref.collapse_shape</code> (::mlir::memref::CollapseShapeOp)</a></li><li><a href=#memrefdealloc-mlirmemrefdeallocop><code>memref.dealloc</code> (::mlir::memref::DeallocOp)</a></li><li><a href=#memrefdim-mlirmemrefdimop><code>memref.dim</code> (::mlir::memref::DimOp)</a></li><li><a href=#memrefdma_start-mlirmemrefdmastartop><code>memref.dma_start</code> (::mlir::memref::DmaStartOp)</a></li><li><a href=#memrefdma_wait-mlirmemrefdmawaitop><code>memref.dma_wait</code> (::mlir::memref::DmaWaitOp)</a></li><li><a href=#memrefexpand_shape-mlirmemrefexpandshapeop><code>memref.expand_shape</code> (::mlir::memref::ExpandShapeOp)</a></li><li><a href=#memrefget_global-mlirmemrefgetglobalop><code>memref.get_global</code> (::mlir::memref::GetGlobalOp)</a></li><li><a href=#memrefglobal-mlirmemrefglobalop><code>memref.global</code> (::mlir::memref::GlobalOp)</a></li><li><a href=#memrefprefetch-mlirmemrefprefetchop><code>memref.prefetch</code> (::mlir::memref::PrefetchOp)</a></li><li><a href=#memrefrank-mlirmemrefrankop><code>memref.rank</code> (::mlir::memref::RankOp)</a></li><li><a href=#memrefreinterpret_cast-mlirmemrefreinterpretcastop><code>memref.reinterpret_cast</code> (::mlir::memref::ReinterpretCastOp)</a></li><li><a href=#memrefreshape-mlirmemrefreshapeop><code>memref.reshape</code> (::mlir::memref::ReshapeOp)</a></li><li><a href=#memrefstore-mlirmemrefstoreop><code>memref.store</code> (::mlir::memref::StoreOp)</a></li><li><a href=#memreftranspose-mlirmemreftransposeop><code>memref.transpose</code> (::mlir::memref::TransposeOp)</a></li><li><a href=#memrefview-mlirmemrefviewop><code>memref.view</code> (::mlir::memref::ViewOp)</a></li><li><a href=#memrefsubview-mlirmemrefsubviewop><code>memref.subview</code> (::mlir::memref::SubViewOp)</a></li><li><a href=#memreftensor_store-mlirmemreftensorstoreop><code>memref.tensor_store</code> (::mlir::memref::TensorStoreOp)</a></li><li><a href=#dma_start-operation>&lsquo;dma_start&rsquo; operation</a></li><li><a href=#dma_wait-operation>&lsquo;dma_wait&rsquo; operation</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=memrefassume_alignment-mlirmemrefassumealignmentop><code>memref.assume_alignment</code> (::mlir::memref::AssumeAlignmentOp)&nbsp;<a class=headline-hash href=#memrefassume_alignment-mlirmemrefassumealignmentop>¶</a></h3><p>assertion that gives alignment information to the input memref</p><p>Syntax:</p><pre><code>operation ::= `memref.assume_alignment` $memref `,` $alignment attr-dict `:` type($memref)
</code></pre><p>The <code>assume_alignment</code> operation takes a memref and an integer of alignment
value, and internally annotates the buffer with the given alignment. If
the buffer isn&rsquo;t aligned to the given alignment, the behavior is undefined.</p><p>This operation doesn&rsquo;t affect the semantics of a correct program. It&rsquo;s for
optimization only, and the optimization is best-effort.</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>alignment</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=memrefatomic_rmw-mlirmemrefatomicrmwop><code>memref.atomic_rmw</code> (::mlir::memref::AtomicRMWOp)&nbsp;<a class=headline-hash href=#memrefatomic_rmw-mlirmemrefatomicrmwop>¶</a></h3><p>atomic read-modify-write operation</p><p>Syntax:</p><pre><code>operation ::= `memref.atomic_rmw` $kind $value `,` $memref `[` $indices `]` attr-dict `:` `(` type($value) `,`
              type($memref) `)` `-&gt;` type($result)
</code></pre><p>The <code>memref.atomic_rmw</code> operation provides a way to perform a read-modify-write
sequence that is free from data races. The kind enumeration specifies the
modification to perform. The value operand represents the new value to be
applied during the modification. The memref operand represents the buffer
that the read and write will be performed against, as accessed by the
specified indices. The arity of the indices is the rank of the memref. The
result represents the latest value that was stored.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>atomic_rmw <span class=s>&#34;addf&#34;</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>kind</code></td><td style=text-align:center>::mlir::arith::AtomicRMWKindAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless integer or floating-point</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer or floating-point</td></tr></tbody></table><h3 id=memrefatomic_yield-mlirmemrefatomicyieldop><code>memref.atomic_yield</code> (::mlir::memref::AtomicYieldOp)&nbsp;<a class=headline-hash href=#memrefatomic_yield-mlirmemrefatomicyieldop>¶</a></h3><p>yield operation for GenericAtomicRMWOp</p><p>Syntax:</p><pre><code>operation ::= `memref.atomic_yield` $result attr-dict `:` type($result)
</code></pre><p>&ldquo;memref.atomic_yield&rdquo; yields an SSA value from a
GenericAtomicRMWOp region.</p><p>Traits: HasParent<genericatomicrmwop>, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=memrefcopy-mlirmemrefcopyop><code>memref.copy</code> (::mlir::memref::CopyOp)&nbsp;<a class=headline-hash href=#memrefcopy-mlirmemrefcopyop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `memref.copy` $source `,` $target attr-dict `:` type($source) `to` type($target)
</code></pre><p>Copies the data from the source to the destination memref.</p><p>Usage:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>copy <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Source and destination are expected to have the same element type and shape.
Otherwise, the result is undefined. They may have different layouts.</p><p>Traits: SameOperandsElementType, SameOperandsShape</p><p>Interfaces: CopyOpInterface</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr><tr><td style=text-align:center><code>target</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=memrefgeneric_atomic_rmw-mlirmemrefgenericatomicrmwop><code>memref.generic_atomic_rmw</code> (::mlir::memref::GenericAtomicRMWOp)&nbsp;<a class=headline-hash href=#memrefgeneric_atomic_rmw-mlirmemrefgenericatomicrmwop>¶</a></h3><p>atomic read-modify-write operation with a region</p><p>The <code>memref.generic_atomic_rmw</code> operation provides a way to perform a
read-modify-write sequence that is free from data races. The memref operand
represents the buffer that the read and write will be performed against, as
accessed by the specified indices. The arity of the indices is the rank of
the memref. The result represents the latest value that was stored. The
region contains the code for the modification itself. The entry block has
a single argument that represents the value stored in <code>memref[indices]</code>
before the write is performed. No side-effecting ops are allowed in the
body of <code>GenericAtomicRMWOp</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>generic_atomic_rmw <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%current_value</span> <span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
    <span class=nv>%c1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1.0</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=nv>%inc</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%current_value</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=kt>memref</span><span class=p>.</span>atomic_yield <span class=nv>%inc</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><p>Traits: SingleBlockImplicitTerminator<atomicyieldop></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer or floating-point</td></tr></tbody></table><h3 id=memrefload-mlirmemrefloadop><code>memref.load</code> (::mlir::memref::LoadOp)&nbsp;<a class=headline-hash href=#memrefload-mlirmemrefloadop>¶</a></h3><p>load operation</p><p>Syntax:</p><pre><code>operation ::= `memref.load` $memref `[` $indices `]` attr-dict `:` type($memref)
</code></pre><p>The <code>load</code> op reads an element from a memref specified by an index list. The
output of load is a new value with the same type as the elements of the
memref. The arity of indices is the rank of the memref (i.e., if the memref
loaded from is of rank 3, then 3 indices are required for the load following
the memref identifier).</p><p>In an <code>affine.if</code> or <code>affine.for</code> body, the indices of a load are restricted
to SSA values bound to surrounding loop induction variables,
<a href=/docs/Dialects/Affine/#dimensions-and-symbols>symbols</a>, results of a
constant operations, or the result of an
<code>affine.apply</code> operation that can in turn take as arguments all of the
aforementioned SSA values or the recursively result of such an
<code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>3</span><span class=p>*</span>d0<span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d1<span class=err>+</span><span class=m>1</span><span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=nv>%12</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>

<span class=c>// Example of an indirect load (treated as non-affine)
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>2</span><span class=p>*</span>d0 <span class=err>+</span> <span class=m>1</span><span class=p>)&gt;(</span><span class=nv>%12</span><span class=p>)</span>
<span class=nv>%13</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%A</span><span class=p>[</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to
fully resolve a reference to an element of a memref, and (in affine
<code>affine.if</code> and <code>affine.for</code> operations) the compiler can follow use-def
chains (e.g. through
<a href=/docs/Dialects/Affine/#affineapply-affineapplyop><code>affine.apply</code></a>
operations) to precisely analyze references at compile-time using polyhedral
techniques. This is possible because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><p>Traits: MemRefsNormalizable</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=memrefalloc-mlirmemrefallocop><code>memref.alloc</code> (::mlir::memref::AllocOp)&nbsp;<a class=headline-hash href=#memrefalloc-mlirmemrefallocop>¶</a></h3><p>memory allocation operation</p><p>Syntax:</p><pre><code>operation ::= `memref.alloc` `(`$dynamicSizes`)` (`` `[` $symbolOperands^ `]`)? attr-dict `:` type($memref)
</code></pre><p>The <code>alloc</code> operation allocates a region of memory, as specified by its
memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the ssa value &lsquo;%d&rsquo; is
bound to the second dimension of the memref (which is dynamic).</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>(</span><span class=nv>%d</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of symbol operands are bound to the symbols of the
memrefs affine map. In the example below, the ssa value &lsquo;%s&rsquo; is bound to
the symbol &lsquo;s0&rsquo; in the affine map specified in the allocs memref type.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span>
                          affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>((</span>d0 <span class=err>+</span> s0<span class=p>),</span> d1<span class=p>)&gt;,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>This operation returns a single ssa value of memref type, which can be used
by subsequent load and store operations.</p><p>The optional <code>alignment</code> attribute may be specified to ensure that the
region of memory that will be indexed is aligned at the specified byte
boundary.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>{</span><span class=nl>alignment =</span> <span class=m>8</span><span class=p>}</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>((</span>d0 <span class=err>+</span> s0<span class=p>),</span> d1<span class=p>)&gt;,</span> <span class=m>1</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>alignment</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dynamicSizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>symbolOperands</code></td><td>index</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=memrefalloca-mlirmemrefallocaop><code>memref.alloca</code> (::mlir::memref::AllocaOp)&nbsp;<a class=headline-hash href=#memrefalloca-mlirmemrefallocaop>¶</a></h3><p>stack memory allocation operation</p><p>Syntax:</p><pre><code>operation ::= `memref.alloca` `(`$dynamicSizes`)` (`` `[` $symbolOperands^ `]`)? attr-dict `:` type($memref)
</code></pre><p>The <code>alloca</code> operation allocates memory on the stack, to be automatically
released when control transfers back from the region of its closest
surrounding operation with an
<a href=/docs/Traits/#automaticallocationscope><code>AutomaticAllocationScope</code></a> trait.
The amount of memory allocated is specified by its memref and additional
operands. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloca<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the SSA value &lsquo;%d&rsquo; is
bound to the second dimension of the memref (which is dynamic).</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloca<span class=p>(</span><span class=nv>%d</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>The optional list of symbol operands are bound to the symbols of the
memref&rsquo;s affine map. In the example below, the SSA value &lsquo;%s&rsquo; is bound to
the symbol &lsquo;s0&rsquo; in the affine map specified in the allocs memref type.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloca<span class=p>()[</span><span class=nv>%s</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span>
                           affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>((</span>d0 <span class=err>+</span> s0<span class=p>),</span> d1<span class=p>)&gt;&gt;</span>
</code></pre></div><p>This operation returns a single SSA value of memref type, which can be used
by subsequent load and store operations. An optional alignment attribute, if
specified, guarantees alignment at least to that boundary. If not specified,
an alignment on any convenient boundary compatible with the type will be
chosen.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>alignment</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dynamicSizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>symbolOperands</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=memrefalloca_scope-mlirmemrefallocascopeop><code>memref.alloca_scope</code> (::mlir::memref::AllocaScopeOp)&nbsp;<a class=headline-hash href=#memrefalloca_scope-mlirmemrefallocascopeop>¶</a></h3><p>explicitly delimited scope for stack allocation</p><p>The <code>memref.alloca_scope</code> operation represents an explicitly-delimited
scope for the alloca allocations. Any <code>memref.alloca</code> operations that are
used within this scope are going to be cleaned up automatically once
the control-flow exits the nested region. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>alloca_scope <span class=p>{</span>
  <span class=nv>%myalloca</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloca<span class=p>():</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x3x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p>Here, <code>%myalloca</code> memref is valid within the explicitly delimited scope
and is automatically deallocated at the end of the given region. Conceptually,
<code>memref.alloca_scope</code> is a passthrough operation with
<code>AutomaticAllocationScope</code> that spans the body of the region within the operation.</p><p><code>memref.alloca_scope</code> may also return results that are defined in the nested
region. To return a value, one should use <code>memref.alloca_scope.return</code>
operation:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%result</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloca_scope <span class=p>{</span>
  <span class=p>...</span>
  <span class=kt>memref</span><span class=p>.</span>alloca_scope<span class=p>.</span><span class=kt>return</span> <span class=nv>%value</span>
<span class=p>}</span>
</code></pre></div><p>If <code>memref.alloca_scope</code> returns no value, the <code>memref.alloca_scope.return</code> can
be left out, and will be inserted implicitly.</p><p>Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects, SingleBlockImplicitTerminator<allocascopereturnop></p><p>Interfaces: RegionBranchOpInterface</p><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=memrefalloca_scopereturn-mlirmemrefallocascopereturnop><code>memref.alloca_scope.return</code> (::mlir::memref::AllocaScopeReturnOp)&nbsp;<a class=headline-hash href=#memrefalloca_scopereturn-mlirmemrefallocascopereturnop>¶</a></h3><p>terminator for alloca_scope operation</p><p>Syntax:</p><pre><code>operation ::= `memref.alloca_scope.return` attr-dict ($results^ `:` type($results))?
</code></pre><p><code>memref.alloca_scope.return</code> operation returns zero or more SSA values
from the region within <code>memref.alloca_scope</code>. If no values are returned,
the return operation may be omitted. Otherwise, it has to be present
to indicate which values are going to be returned. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>alloca_scope<span class=p>.</span><span class=kt>return</span> <span class=nv>%value</span>
</code></pre></div><p>Traits: HasParent<allocascopeop>, ReturnLike, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=memrefcast-mlirmemrefcastop><code>memref.cast</code> (::mlir::memref::CastOp)&nbsp;<a class=headline-hash href=#memrefcast-mlirmemrefcastop>¶</a></h3><p>memref cast operation</p><p>Syntax:</p><pre><code>operation ::= `memref.cast` $source attr-dict `:` type($source) `to` type($dest)
</code></pre><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `memref.cast` ssa-use `:` type `to` type
</code></pre><p>The <code>memref.cast</code> operation converts a memref from one type to an equivalent
type with a compatible shape. The source and destination types are
compatible if:</p><p>a. Both are ranked memref types with the same element type, address space,
and rank and:</p><ol><li>Both have the same layout or both have compatible strided layouts.</li><li>The individual sizes (resp. offset and strides in the case of strided
memrefs) may convert constant dimensions to dynamic dimensions and
vice-versa.</li></ol><p>If the cast converts any dimensions from an unknown to a known size, then it
acts as an assertion that fails at runtime if the dynamic dimensions
disagree with resultant destination size.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Assert that the input dynamic shape matches the destination static shape.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Erase static shape information, replacing it with dynamic information.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// The same holds true for offsets and strides.
</span><span class=c></span>
<span class=c>// Assert that the input dynamic shape matches the destination static stride.
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=err>?</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=err>?</span><span class=p>,</span> <span class=err>?</span><span class=p>]&gt;</span> to
                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=m>5</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]&gt;</span>
<span class=c>// Erase static offset and stride information, replacing it with
</span><span class=c>// dynamic information.
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=m>5</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]&gt;</span> to
                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x4x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span><span class=err>?</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=err>?</span><span class=p>,</span> <span class=err>?</span><span class=p>]&gt;</span>
</code></pre></div><p>b. Either or both memref types are unranked with the same element type, and
address space.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>Cast to concrete shape<span class=p>.</span>
    <span class=nv>%4</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>

Erase rank information<span class=p>.</span>
    <span class=nv>%5</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</code></pre></div><p>Traits: MemRefsNormalizable, SameOperandsAndResultShape</p><p>Interfaces: CastOpInterface, NoSideEffect (MemoryEffectOpInterface), ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=memrefcollapse_shape-mlirmemrefcollapseshapeop><code>memref.collapse_shape</code> (::mlir::memref::CollapseShapeOp)&nbsp;<a class=headline-hash href=#memrefcollapse_shape-mlirmemrefcollapseshapeop>¶</a></h3><p>operation to produce a memref with a smaller rank.</p><p>Syntax:</p><pre><code>operation ::= `memref.collapse_shape` $src $reassociation attr-dict `:` type($src) `into` type($result)
</code></pre><p>The <code>memref.collapse_shape</code> op produces a new view with a smaller rank
whose sizes are a reassociation of the original <code>view</code>. The operation is
limited to such reassociations, where subsequent, contiguous dimensions are
collapsed into a single dimension. Such reassociations never require
additional allocs or copies.</p><p>Collapsing non-contiguous dimensions is undefined behavior. When a group of
dimensions can be statically proven to be non-contiguous, collapses of such
groups are rejected in the verifier on a best-effort basis. In the general
case, collapses of dynamically-sized dims with dynamic strides cannot be
proven to be contiguous or non-contiguous due to limitations in the memref
type.</p><p>A reassociation is defined as a continuous grouping of dimensions and is
represented with an array of I64ArrayAttr attribute.</p><p>Note: Only the dimensions within a reassociation group must be contiguous.
The remaining dimensions may be non-contiguous.</p><p>The result memref type can be zero-ranked if the source memref type is
statically shaped with all dimensions being unit extent. In such a case, the
reassociation indices must be empty.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Dimension collapse (i, j) -&gt; i&#39; and k -&gt; k&#39;
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>collapse_shape <span class=nv>%0</span> <span class=p>[[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span><span class=p>]]</span> <span class=p>:</span>
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x</span><span class=k>f32</span><span class=p>,</span> stride_spec<span class=p>&gt;</span> into <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> stride_spec_2<span class=p>&gt;</span>
</code></pre></div><p>For simplicity, this op may not be used to cast dynamicity of dimension
sizes and/or strides. I.e., a result dimension must be dynamic if and only
if at least one dimension in the corresponding reassociation group is
dynamic. Similarly, the stride of a result dimension must be dynamic if and
only if the corresponding start dimension in the source type is dynamic.</p><p>Note: This op currently assumes that the inner strides are of the
source/result layout map are the faster-varying ones.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reassociation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Array of 64-bit integer array attributes</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>strided memref of any type values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>strided memref of any type values</td></tr></tbody></table><h3 id=memrefdealloc-mlirmemrefdeallocop><code>memref.dealloc</code> (::mlir::memref::DeallocOp)&nbsp;<a class=headline-hash href=#memrefdealloc-mlirmemrefdeallocop>¶</a></h3><p>memory deallocation operation</p><p>Syntax:</p><pre><code>operation ::= `memref.dealloc` $memref attr-dict `:` type($memref)
</code></pre><p>The <code>dealloc</code> operation frees the region of memory referenced by a memref
which was originally created by the <code>alloc</code> operation.
The <code>dealloc</code> operation should not be called on memrefs which alias an
alloc&rsquo;d memref (e.g. memrefs returned by <code>view</code> operations).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>),</span> <span class=m>1</span><span class=p>&gt;&gt;</span>
<span class=kt>memref</span><span class=p>.</span>dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span>  affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>),</span> <span class=m>1</span><span class=p>&gt;&gt;</span>
</code></pre></div><p>Traits: MemRefsNormalizable</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=memrefdim-mlirmemrefdimop><code>memref.dim</code> (::mlir::memref::DimOp)&nbsp;<a class=headline-hash href=#memrefdim-mlirmemrefdimop>¶</a></h3><p>dimension index operation</p><p>Syntax:</p><pre><code>operation ::= `memref.dim` attr-dict $source `,` $index `:` type($source)
</code></pre><p>The <code>dim</code> operation takes a memref and a dimension operand of type <code>index</code>.
It returns the size of the requested dimension of the given memref.
If the dimension index is out of bounds the behavior is undefined.</p><p>The specified memref type is that of the first operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Always returns 4, can be constant folded:
</span><span class=c></span><span class=nv>%c0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%x</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>dim <span class=nv>%A</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Returns the dynamic dimension of %A.
</span><span class=c></span><span class=nv>%c1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%y</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>dim <span class=nv>%A</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic form:
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;memref.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
<span class=nv>%y</span> <span class=p>=</span> <span class=s>&#34;memref.dim&#34;</span><span class=p>(</span><span class=nv>%A</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>index</span>
</code></pre></div><p>Traits: MemRefsNormalizable</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr><tr><td style=text-align:center><code>index</code></td><td>index</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=memrefdma_start-mlirmemrefdmastartop><code>memref.dma_start</code> (::mlir::memref::DmaStartOp)&nbsp;<a class=headline-hash href=#memrefdma_start-mlirmemrefdmastartop>¶</a></h3><p>non-blocking DMA operation that starts a transfer</p><p>DmaStartOp starts a non-blocking DMA operation that transfers data from a
source memref to a destination memref. The source and destination memref
need not be of the same dimensionality, but need to have the same elemental
type. The operands include the source and destination memref&rsquo;s each followed
by its indices, size of the data transfer in terms of the number of elements
(of the elemental type of the memref), a tag memref with its indices, and
optionally at the end, a stride and a number_of_elements_per_stride
arguments. The tag location is used by a DmaWaitOp to check for completion.
The indices of the source memref, destination memref, and the tag memref
have the same restrictions as any load/store. The optional stride arguments
should be of &lsquo;index&rsquo; type, and specify a stride for the slower memory space
(memory space with a lower memory space id), transferring chunks of
number_of_elements_per_stride every stride until %num_elements are
transferred. Either both or no stride arguments should be specified. If the
source and destination locations overlap the behavior of this operation is
not defined.</p><p>For example, a DmaStartOp operation that transfers 256 elements of a memref
&lsquo;%src&rsquo; in memory space 0 at indices [%i, %j] to memref &lsquo;%dst&rsquo; in memory
space 1 at indices [%k, %l], would be specified as follows:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%num_elements</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>256</span>
<span class=nv>%idx</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%tag</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>4</span><span class=p>&gt;</span>
dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%num_elements</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40 x</span> <span class=m>128 x</span> <span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>0</span><span class=p>&gt;,</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=m>1024 x</span> <span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>1</span><span class=p>&gt;,</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>2</span><span class=p>&gt;</span>
</code></pre></div><p>If %stride and %num_elt_per_stride are specified, the DMA is expected to
transfer %num_elt_per_stride elements every %stride elements apart from
memory space 0 until %num_elements are transferred.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%num_elements</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>],</span> <span class=nv>%stride</span><span class=p>,</span>
          <span class=nv>%num_elt_per_stride</span> <span class=p>:</span>
</code></pre></div><p>TODO: add additional operands to allow source and destination striding, and
multiple stride levels.
TODO: Consider replacing src/dst memref indices with view memrefs.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=memrefdma_wait-mlirmemrefdmawaitop><code>memref.dma_wait</code> (::mlir::memref::DmaWaitOp)&nbsp;<a class=headline-hash href=#memrefdma_wait-mlirmemrefdmawaitop>¶</a></h3><p>blocking DMA operation that waits for transfer completion</p><p>Syntax:</p><pre><code>operation ::= `memref.dma_wait` $tagMemRef `[` $tagIndices `]` `,` $numElements attr-dict `:`
              type($tagMemRef)
</code></pre><p>DmaWaitOp blocks until the completion of a DMA operation associated with the
tag element &lsquo;%tag[%index]&rsquo;. %tag is a memref, and %index has to be an index
with the same restrictions as any load/store index. %num_elements is the
number of elements associated with the DMA operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir> dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%num_elements</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%index</span><span class=p>]</span> <span class=p>:</span>
   <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048 x</span> <span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>0</span><span class=p>&gt;,</span>
   <span class=kt>memref</span><span class=p>&lt;</span><span class=m>256 x</span> <span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>1</span><span class=p>&gt;</span>
   <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>2</span><span class=p>&gt;</span>
 <span class=p>...</span>
 <span class=p>...</span>
 dma_wait <span class=nv>%tag</span><span class=p>[</span><span class=nv>%index</span><span class=p>],</span> <span class=nv>%num_elements</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>2</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tagMemRef</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>tagIndices</code></td><td>index</td></tr><tr><td style=text-align:center><code>numElements</code></td><td>index</td></tr></tbody></table><h3 id=memrefexpand_shape-mlirmemrefexpandshapeop><code>memref.expand_shape</code> (::mlir::memref::ExpandShapeOp)&nbsp;<a class=headline-hash href=#memrefexpand_shape-mlirmemrefexpandshapeop>¶</a></h3><p>operation to produce a memref with a higher rank.</p><p>Syntax:</p><pre><code>operation ::= `memref.expand_shape` $src $reassociation attr-dict `:` type($src) `into` type($result)
</code></pre><p>The <code>memref.expand_shape</code> op produces a new view with a higher rank whose
sizes are a reassociation of the original <code>view</code>. The operation is limited
to such reassociations, where a dimension is expanded into one or multiple
contiguous dimensions. Such reassociations never require additional allocs
or copies.</p><p>A reassociation is defined as a grouping of dimensions and is represented
with an array of I64ArrayAttr attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%r</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>expand_shape <span class=nv>%0</span> <span class=p>[[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span><span class=p>]]</span>
    <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> into <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x5x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>At most one dimension of a reassociation group (e.g., [0, 1] above) may be
dynamic in the result type. Otherwise, the op would be ambiguous, as it
would not be clear how the source dimension is extended.</p><p>If an op can be statically proven to be invalid (e.g, an expansion from
<code>memref&lt;10xf32></code> to <code>memref&lt;2x6xf32></code>), it is rejected by the verifier. If
it cannot statically be proven invalid (e.g., the full example above; it is
unclear whether the first source dimension is divisible by 5), the op is
accepted by the verifier. However, if the op is in fact invalid at runtime,
the behavior is undefined.</p><p>The source memref can be zero-ranked. In that case, the reassociation
indices must be empty and the result shape may only consist of unit
dimensions.</p><p>For simplicity, this op may not be used to cast dynamicity of dimension
sizes and/or strides. I.e., if and only if a source dimension is dynamic,
there must be a dynamic result dimension in the corresponding reassociation
group. Same for strides.</p><p>Note: This op currently assumes that the inner strides are of the
source/result layout map are the faster-varying ones.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reassociation</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Array of 64-bit integer array attributes</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>strided memref of any type values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>strided memref of any type values</td></tr></tbody></table><h3 id=memrefget_global-mlirmemrefgetglobalop><code>memref.get_global</code> (::mlir::memref::GetGlobalOp)&nbsp;<a class=headline-hash href=#memrefget_global-mlirmemrefgetglobalop>¶</a></h3><p>get the memref pointing to a global variable</p><p>Syntax:</p><pre><code>operation ::= `memref.get_global` $name `:` type($result) attr-dict
</code></pre><p>The <code>memref.get_global</code> operation retrieves the memref pointing to a
named global variable. If the global variable is marked constant, writing
to the result memref (such as through a <code>memref.store</code> operation) is
undefined.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>get_global <span class=nf>@foo</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), SymbolUserOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>statically shaped memref of any type values</td></tr></tbody></table><h3 id=memrefglobal-mlirmemrefglobalop><code>memref.global</code> (::mlir::memref::GlobalOp)&nbsp;<a class=headline-hash href=#memrefglobal-mlirmemrefglobalop>¶</a></h3><p>declare or define a global memref variable</p><p>Syntax:</p><pre><code>operation ::= `memref.global` ($sym_visibility^)?
              (`constant` $constant^)?
              $sym_name `:`
              custom&lt;GlobalMemrefOpTypeAndInitialValue&gt;($type, $initial_value)
              attr-dict
</code></pre><p>The <code>memref.global</code> operation declares or defines a named global memref
variable. The backing memory for the variable is allocated statically and is
described by the type of the variable (which should be a statically shaped
memref type). The operation is a declaration if no <code>initial_value</code> is
specified, else it is a definition. The <code>initial_value</code> can either be a unit
attribute to represent a definition of an uninitialized global variable, or
an elements attribute to represent the definition of a global variable with
an initial value. The global variable can also be marked constant using the
<code>constant</code> unit attribute. Writing to such constant global variables is
undefined.</p><p>The global variable can be accessed by using the <code>memref.get_global</code> to
retrieve the memref for the global variable. Note that the memref
for such global variable itself is immutable (i.e., memref.get_global for a
given global variable will always return the same memref descriptor).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Private variable with an initial value.
</span><span class=c></span><span class=kt>memref</span><span class=p>.</span>global <span class=s>&#34;private&#34;</span> <span class=nf>@x</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>=</span> dense<span class=p>&lt;</span><span class=m>0.0</span><span class=p>,</span><span class=m>2.0</span><span class=p>&gt;</span>

<span class=c>// Private variable with an initial value and an alignment (power of 2).
</span><span class=c></span><span class=kt>memref</span><span class=p>.</span>global <span class=s>&#34;private&#34;</span> <span class=nf>@x</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>=</span> dense<span class=p>&lt;</span><span class=m>0.0</span><span class=p>,</span><span class=m>2.0</span><span class=p>&gt;</span> <span class=p>{</span><span class=nl>alignment =</span> <span class=m>64</span><span class=p>}</span>

<span class=c>// Declaration of an external variable.
</span><span class=c></span><span class=kt>memref</span><span class=p>.</span>global <span class=s>&#34;private&#34;</span> <span class=nf>@y</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Uninitialized externally visible variable.
</span><span class=c></span><span class=kt>memref</span><span class=p>.</span>global <span class=nf>@z</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span> <span class=p>=</span> uninitialized

<span class=c>// Externally visible constant variable.
</span><span class=c></span><span class=kt>memref</span><span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>=</span> dense<span class=p>&lt;</span><span class=m>1</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: Symbol</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>sym_visibility</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>memref type attribute</td></tr><tr><td style=text-align:center><code>initial_value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr><tr><td style=text-align:center><code>constant</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>alignment</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=memrefprefetch-mlirmemrefprefetchop><code>memref.prefetch</code> (::mlir::memref::PrefetchOp)&nbsp;<a class=headline-hash href=#memrefprefetch-mlirmemrefprefetchop>¶</a></h3><p>prefetch operation</p><p>The &ldquo;prefetch&rdquo; op prefetches data from a memref location described with
subscript indices similar to memref.load, and with three attributes: a
read/write specifier, a locality hint, and a cache type specifier as shown
below:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>prefetch <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> read<span class=p>,</span> <span class=kt>loc</span>ality<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;,</span> data <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>400x400x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>The read/write specifier is either &lsquo;read&rsquo; or &lsquo;write&rsquo;, the locality hint
ranges from locality&lt;0> (no locality) to locality&lt;3> (extremely local keep
in cache). The cache type specifier is either &lsquo;data&rsquo; or &lsquo;instr&rsquo;
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>isWrite</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>localityHint</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 3</td></tr><tr><td style=text-align:center><code>isDataCache</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=memrefrank-mlirmemrefrankop><code>memref.rank</code> (::mlir::memref::RankOp)&nbsp;<a class=headline-hash href=#memrefrank-mlirmemrefrankop>¶</a></h3><p>rank operation</p><p>Syntax:</p><pre><code>operation ::= `memref.rank` $memref attr-dict `:` type($memref)
</code></pre><p>The <code>memref.rank</code> operation takes a memref operand and returns its rank.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>rank <span class=nv>%arg0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
<span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>rank <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=memrefreinterpret_cast-mlirmemrefreinterpretcastop><code>memref.reinterpret_cast</code> (::mlir::memref::ReinterpretCastOp)&nbsp;<a class=headline-hash href=#memrefreinterpret_cast-mlirmemrefreinterpretcastop>¶</a></h3><p>memref reinterpret cast operation</p><p>Syntax:</p><pre><code>operation ::= `memref.reinterpret_cast` $source `to` `offset` `` `:`
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($offsets, $static_offsets)
              `` `,` `sizes` `` `:`
              custom&lt;OperandsOrIntegersSizesList&gt;($sizes, $static_sizes) `` `,` `strides`
              `` `:`
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($strides, $static_strides)
              attr-dict `:` type($source) `to` type($result)
</code></pre><p>Modify offset, sizes and strides of an unranked/ranked memref.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>reinterpret_cast <span class=nv>%ranked</span> to
  offset<span class=p>:</span> <span class=p>[</span><span class=m>0</span><span class=p>],</span>
  sizes<span class=p>:</span> <span class=p>[</span><span class=nv>%size0</span><span class=p>,</span> <span class=m>10</span><span class=p>],</span>
  strides<span class=p>:</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=nv>%stride1</span><span class=p>]</span>
<span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x10x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span> <span class=m>0</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=err>?</span><span class=p>]&gt;</span>

<span class=kt>memref</span><span class=p>.</span>reinterpret_cast <span class=nv>%unranked</span> to
  offset<span class=p>:</span> <span class=p>[</span><span class=nv>%offset</span><span class=p>],</span>
  sizes<span class=p>:</span> <span class=p>[</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>],</span>
  strides<span class=p>:</span> <span class=p>[</span><span class=nv>%stride0</span><span class=p>,</span> <span class=nv>%stride1</span><span class=p>]</span>
<span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span> <span class=err>?</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=err>?</span><span class=p>,</span> <span class=err>?</span><span class=p>]&gt;</span>
</code></pre></div><p>Traits: AttrSizedOperandSegments, MemRefsNormalizable</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), OffsetSizeAndStrideOpInterface, ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>static_offsets</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_sizes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_strides</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>index</td></tr><tr><td style=text-align:center><code>sizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>strides</code></td><td>index</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=memrefreshape-mlirmemrefreshapeop><code>memref.reshape</code> (::mlir::memref::ReshapeOp)&nbsp;<a class=headline-hash href=#memrefreshape-mlirmemrefreshapeop>¶</a></h3><p>memref reshape operation</p><p>Syntax:</p><pre><code>operation ::= `memref.reshape` $source `(` $shape `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>The <code>reshape</code> operation converts a memref from one type to an
equivalent type with a provided shape. The data is never copied or
modified. The source and destination types are compatible if both have the
same element type, same number of elements, address space and identity
layout map. The following combinations are possible:</p><p>a. Source type is ranked or unranked. Shape argument has static size.
Result type is ranked.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Reshape statically-shaped memref.
</span><span class=c></span><span class=nv>%dst</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>reshape <span class=nv>%src</span><span class=p>(</span><span class=nv>%shape</span><span class=p>)</span>
         <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x1x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>&gt;)</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%dst0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>reshape <span class=nv>%src</span><span class=p>(</span><span class=nv>%shape0</span><span class=p>)</span>
         <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x1x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;)</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x2x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Flatten unranked memref.
</span><span class=c></span><span class=nv>%dst</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>reshape <span class=nv>%src</span><span class=p>(</span><span class=nv>%shape</span><span class=p>)</span>
         <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>&gt;)</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>b. Source type is ranked or unranked. Shape argument has dynamic size.
Result type is unranked.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Reshape dynamically-shaped 1D memref.
</span><span class=c></span><span class=nv>%dst</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>reshape <span class=nv>%src</span><span class=p>(</span><span class=nv>%shape</span><span class=p>)</span>
         <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;)</span> to <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
<span class=c>// Reshape unranked memref.
</span><span class=c></span><span class=nv>%dst</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>reshape <span class=nv>%src</span><span class=p>(</span><span class=nv>%shape</span><span class=p>)</span>
         <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;)</span> to <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>unranked.memref of any type values or memref of any type values</td></tr><tr><td style=text-align:center><code>shape</code></td><td>1D memref of signless integer or index values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=memrefstore-mlirmemrefstoreop><code>memref.store</code> (::mlir::memref::StoreOp)&nbsp;<a class=headline-hash href=#memrefstore-mlirmemrefstoreop>¶</a></h3><p>store operation</p><p>Syntax:</p><pre><code>operation ::= `memref.store` $value `,` $memref `[` $indices `]` attr-dict `:` type($memref)
</code></pre><p>Store a value to a memref location given by indices. The value stored should
have the same type as the elemental type of the memref. The number of
arguments provided within brackets need to match the rank of the memref.</p><p>In an affine context, the indices of a store are restricted to SSA values
bound to surrounding loop induction variables,
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>symbols</a>, results of a
<code>constant</code> operation, or the result of an
<a href=/docs/Dialects/Affine/#affineapply-affineapplyop><code>affine.apply</code></a> operation that can in
turn take as arguments all of the aforementioned SSA values or the
recursively result of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>store <span class=nv>%100</span><span class=p>,</span> <span class=nv>%A</span><span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=m>1023</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to
fully resolve a reference to an element of a memref, and (in polyhedral
<code>affine.if</code> and <code>affine.for</code> operations) the compiler can follow use-def
chains (e.g. through
<a href=/docs/Dialects/Affine/#affineapply-affineapplyop><code>affine.apply</code></a>
operations) to precisely analyze references at compile-time using polyhedral
techniques. This is possible because of the
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><p>Traits: MemRefsNormalizable</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=memreftranspose-mlirmemreftransposeop><code>memref.transpose</code> (::mlir::memref::TransposeOp)&nbsp;<a class=headline-hash href=#memreftranspose-mlirmemreftransposeop>¶</a></h3><p><code>transpose</code> produces a new strided memref (metadata-only)</p><p>The <code>transpose</code> op produces a strided memref whose sizes and strides
are a permutation of the original <code>in</code> memref. This is purely a metadata
transformation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>transpose <span class=nv>%0</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>j<span class=p>,</span> i<span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d1 <span class=p>*</span> s0 <span class=err>+</span> d0<span class=p>)&gt;&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>permutation</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>strided memref of any type values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>strided memref of any type values</td></tr></tbody></table><h3 id=memrefview-mlirmemrefviewop><code>memref.view</code> (::mlir::memref::ViewOp)&nbsp;<a class=headline-hash href=#memrefview-mlirmemrefviewop>¶</a></h3><p>memref view operation</p><p>Syntax:</p><pre><code>operation ::= `memref.view` $source `[` $byte_shift `]` `` `[` $sizes `]` attr-dict
              `:` type($source) `to` type(results)
</code></pre><p>The &ldquo;view&rdquo; operation extracts an N-D contiguous memref with empty layout map
with arbitrary element type from a 1-D contiguous memref with empty layout
map of i8 element type. The ViewOp supports the following arguments:</p><ul><li>A single dynamic byte-shift operand must be specified which represents a
a shift of the base 1-D memref pointer from which to create the resulting
contiguous memref view with identity layout.</li><li>A dynamic size operand that must be specified for each dynamic dimension
in the resulting view memref type.</li></ul><p>The &ldquo;view&rdquo; operation gives a structured indexing form to a flat 1-D buffer.
Unlike &ldquo;subview&rdquo; it can perform a type change. The type change behavior
requires the op to have special semantics because, e.g. a byte shift of 3
cannot be represented as an offset on f64.
For now, a &ldquo;view&rdquo; op:</p><ol><li>Only takes a contiguous source memref with 0 offset and empty layout.</li><li>Must specify a byte_shift operand (in the future, a special integer
attribute may be added to support the folded case).</li><li>Returns a contiguous memref with 0 offset and empty layout.</li></ol><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Allocate a flat 1D/i8 memref.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// ViewOp with dynamic offset and static sizes.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%offset_1024</span><span class=p>][]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// ViewOp with dynamic offset and two dynamic size.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%offset_1024</span><span class=p>][</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>]</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>1D memref of 8-bit signless integer values</td></tr><tr><td style=text-align:center><code>byte_shift</code></td><td>index</td></tr><tr><td style=text-align:center><code>sizes</code></td><td>index</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>memref of any type values</td></tr></tbody></table><h3 id=memrefsubview-mlirmemrefsubviewop><code>memref.subview</code> (::mlir::memref::SubViewOp)&nbsp;<a class=headline-hash href=#memrefsubview-mlirmemrefsubviewop>¶</a></h3><p>memref subview operation</p><p>Syntax:</p><pre><code>operation ::= `memref.subview` $source ``
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($offsets, $static_offsets)
              custom&lt;OperandsOrIntegersSizesList&gt;($sizes, $static_sizes)
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($strides, $static_strides)
              attr-dict `:` type($source) `to` type($result)
</code></pre><p>The &ldquo;subview&rdquo; operation converts a memref type to another memref type
which represents a reduced-size view of the original memref as specified by
the operation&rsquo;s offsets, sizes and strides arguments.</p><p>The SubView operation supports the following arguments:</p><ul><li>source: the &ldquo;base&rdquo; memref on which to create a &ldquo;view&rdquo; memref.</li><li>offsets: memref-rank number of offsets into the &ldquo;base&rdquo; memref at which to
create the &ldquo;view&rdquo; memref.</li><li>sizes: memref-rank number of sizes which specify the sizes of the result
&ldquo;view&rdquo; memref type.</li><li>strides: memref-rank number of strides that compose multiplicatively with
the base memref strides in each dimension.</li></ul><p>The representation based on offsets, sizes and strides support a
partially-static specification via attributes specified through the
<code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special
sentinel value ShapedType::kDynamicSize and
ShapedType::kDynamicStrideOrOffset encodes that the corresponding entry has
a dynamic value.</p><p>A subview operation may additionally reduce the rank of the resulting view
by removing dimensions that are statically known to be of size 1.</p><p>Example 1:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d1<span class=p>)&gt;&gt;</span>

<span class=c>// Create a sub-view of &#34;base&#34; memref &#39;%0&#39; with offset arguments &#39;%c0&#39;,
</span><span class=c>// dynamic sizes for each dimension, and stride arguments &#39;%c1&#39;.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>][</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>][</span><span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d1<span class=p>)&gt;&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=err>+</span> s0<span class=p>)&gt;&gt;</span>
</code></pre></div><p>Example 2:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)&gt;&gt;</span>

<span class=c>// Create a sub-view of &#34;base&#34; memref &#39;%0&#39; with dynamic offsets, sizes,
</span><span class=c>// and strides.
</span><span class=c>// Note that dynamic offsets are represented by the linearized dynamic
</span><span class=c>// offset symbol &#39;s0&#39; in the subview memref layout map, and that the
</span><span class=c>// dynamic strides operands, after being applied to the base memref
</span><span class=c>// strides in each dimension, are represented in the view memref layout
</span><span class=c>// map as symbols &#39;s1&#39;, &#39;s2&#39; and &#39;s3&#39;.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>,</span> <span class=nv>%k</span><span class=p>][</span><span class=nv>%size0</span><span class=p>,</span> <span class=nv>%size1</span><span class=p>,</span> <span class=nv>%size2</span><span class=p>][</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)&gt;&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x?x</span><span class=k>f32</span><span class=p>,</span>
      affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)[</span>s0<span class=p>,</span> s1<span class=p>,</span> s2<span class=p>,</span> s3<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=p>*</span> s2 <span class=err>+</span> d2 <span class=p>*</span> s3 <span class=err>+</span> s0<span class=p>)&gt;&gt;</span>
</code></pre></div><p>Example 3:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)&gt;&gt;</span>

<span class=c>// Subview with constant offsets, sizes and strides.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>0</span><span class=p>][</span><span class=m>4</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>4</span><span class=p>][</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2<span class=p>)&gt;&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> <span class=m>64</span> <span class=err>+</span> d1 <span class=p>*</span> <span class=m>4</span> <span class=err>+</span> d2 <span class=err>+</span> <span class=m>8</span><span class=p>)&gt;&gt;</span>
</code></pre></div><p>Example 4:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Subview with constant size, but dynamic offsets and
</span><span class=c>// strides. The resulting memref has a static shape, but if the
</span><span class=c>// base memref has an affine map to describe the layout, the result
</span><span class=c>// memref also uses an affine map to describe the layout. The
</span><span class=c>// strides of the result memref is computed as follows:
</span><span class=c>//
</span><span class=c>// Let #map1 represents the layout of the base memref, and #map2
</span><span class=c>// represents the layout of the result memref. A #mapsubview can be
</span><span class=c>// constructed to map an index from the result memref to the base
</span><span class=c>// memref (note that the description below uses more convenient
</span><span class=c>// naming for symbols, while in affine maps, symbols are
</span><span class=c>// represented as unsigned numbers that identify that symbol in the
</span><span class=c>// given affine map.
</span><span class=c>//
</span><span class=c>// #mapsubview = (d0, d1)[o0, o1, t0, t1] -&gt; (d0 * t0 + o0, d1 * t1 + o1)
</span><span class=c>//
</span><span class=c>// where, o0, o1, ... are offsets, and t0, t1, ... are strides. Then,
</span><span class=c>//
</span><span class=c>// #map2 = #map1.compose(#mapsubview)
</span><span class=c>//
</span><span class=c>// If the layout map is represented as
</span><span class=c>//
</span><span class=c>// #map1 = (d0, d1)[s0, s1, s2] -&gt; (d0 * s1 + d1 * s2 + s0)
</span><span class=c>//
</span><span class=c>// then,
</span><span class=c>//
</span><span class=c>// #map2 = (d0, d1)[s0, s1, s2, o0, o1, t0, t1] -&gt;
</span><span class=c>//              (d0 * s1 * t0 + d1 * s2 * t1 + o0 * s1 + o1 * s2 + s0)
</span><span class=c>//
</span><span class=c>// Representing this canonically
</span><span class=c>//
</span><span class=c>// #map2 = (d0, d1)[r0, r1, r2] -&gt; (d0 * r1 + d1 * r2 + r0)
</span><span class=c>//
</span><span class=c>// where, r0 = o0 * s1 + o1 * s2 + s0, r1 = s1 * t0, r2 = s2 * t1.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>][</span><span class=m>4</span><span class=p>,</span> <span class=m>4</span><span class=p>][</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>]</span> <span class=p>:</span>
  <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>,</span> s1<span class=p>,</span> s2<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> s1 <span class=err>+</span> d1 <span class=p>*</span> s2 <span class=err>+</span> s0<span class=p>)&gt;&gt;</span> to
    <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>r0<span class=p>,</span> r1<span class=p>,</span> r2<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=p>*</span> r1 <span class=err>+</span> d1 <span class=p>*</span> r2 <span class=err>+</span> r0<span class=p>)&gt;&gt;</span>

<span class=c>// Note that the subview op does not guarantee that the result
</span><span class=c>// memref is &#34;inbounds&#34; w.r.t to base memref. It is upto the client
</span><span class=c>// to ensure that the subview is accessed in a manner that is
</span><span class=c>// in-bounds.
</span></code></pre></div><p>Example 5:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Rank-reducing subview.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%0</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>][</span><span class=m>1</span><span class=p>,</span> <span class=m>16</span><span class=p>,</span> <span class=m>4</span><span class=p>][</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Original layout:
</span><span class=c>// (d0, d1, d2) -&gt; (64 * d0 + 16 * d1 + d2)
</span><span class=c>// Subviewed layout:
</span><span class=c>// (d0, d1, d2) -&gt; (64 * (d0 + 3) + 4 * (d1 + 4) + d2 + 2) = (64 * d0 + 4 * d1 + d2 + 210)
</span><span class=c>// After rank reducing:
</span><span class=c>// (d0, d1) -&gt; (4 * d0 + d1 + 210)
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>subview <span class=nv>%2</span><span class=p>[</span><span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>2</span><span class=p>][</span><span class=m>1</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>3</span><span class=p>][</span><span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x16x4x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>6x3x</span><span class=k>f32</span><span class=p>,</span> offset<span class=p>:</span> <span class=m>210</span><span class=p>,</span> strides<span class=p>:</span> <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>1</span><span class=p>]&gt;</span>
</code></pre></div><p>}</p><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), OffsetSizeAndStrideOpInterface, ViewLikeOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>static_offsets</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_sizes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_strides</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>index</td></tr><tr><td style=text-align:center><code>sizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>strides</code></td><td>index</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=memreftensor_store-mlirmemreftensorstoreop><code>memref.tensor_store</code> (::mlir::memref::TensorStoreOp)&nbsp;<a class=headline-hash href=#memreftensor_store-mlirmemreftensorstoreop>¶</a></h3><p>tensor store operation</p><p>Syntax:</p><pre><code>operation ::= `memref.tensor_store` $tensor `,` $memref attr-dict `:` type($memref)
</code></pre><p>Stores the contents of a tensor into a memref. The first operand is a value
of tensor type, the second operand is a value of memref type. The shapes and
element types of these must match, and are specified by the memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%9</span> <span class=p>=</span> dim <span class=nv>%8</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%10</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>(</span><span class=nv>%9</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>.</span><span class=kt>tensor</span>_store <span class=nv>%8</span><span class=p>,</span> <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#layout</span><span class=p>,</span> memspace0<span class=p>&gt;</span>
</code></pre></div><p>Traits: SameOperandsElementType, SameOperandsShape</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tensor</code></td><td>tensor of any type values</td></tr><tr><td style=text-align:center><code>memref</code></td><td>unranked.memref of any type values or memref of any type values</td></tr></tbody></table><h3 id=dma_start-operation>&lsquo;dma_start&rsquo; operation&nbsp;<a class=headline-hash href=#dma_start-operation>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `memref.dma_start` ssa-use`[`ssa-use-list`]` `,`
               ssa-use`[`ssa-use-list`]` `,` ssa-use `,`
               ssa-use`[`ssa-use-list`]` (`,` ssa-use `,` ssa-use)?
              `:` memref-type `,` memref-type `,` memref-type
</code></pre><p>Starts a non-blocking DMA operation that transfers data from a source memref to
a destination memref. The operands include the source and destination memref&rsquo;s
each followed by its indices, size of the data transfer in terms of the number
of elements (of the elemental type of the memref), a tag memref with its
indices, and optionally two additional arguments corresponding to the stride (in
terms of number of elements) and the number of elements to transfer per stride.
The tag location is used by a dma_wait operation to check for completion. The
indices of the source memref, destination memref, and the tag memref have the
same restrictions as any load/store operation in an affine context (whenever DMA
operations appear in an affine context). See
<a href=/docs/Dialects/Affine/#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in affine contexts. This allows powerful static analysis and transformations in
the presence of such DMAs including rescheduling, pipelining / overlap with
computation, and checking for matching start/end operations. The source and
destination memref need not be of the same dimensionality, but need to have the
same elemental type.</p><p>For example, a <code>memref.dma_start</code> operation that transfers 32 vector elements
from a memref <code>%src</code> at location <code>[%i, %j]</code> to memref <code>%dst</code> at <code>[%k, %l]</code> would
be specified as shown below.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%size</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>32</span> <span class=p>:</span> <span class=k>index</span>
<span class=nv>%tag</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>4</span><span class=p>&gt;</span>
<span class=nv>%idx</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
<span class=kt>memref</span><span class=p>.</span>dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%size</span><span class=p>,</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>]</span> <span class=p>:</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40 x</span> <span class=m>8 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)&gt;,</span> <span class=m>0</span><span class=p>&gt;,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)&gt;,</span> <span class=m>2</span><span class=p>&gt;,</span>
     <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>&gt;,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><h3 id=dma_wait-operation>&lsquo;dma_wait&rsquo; operation&nbsp;<a class=headline-hash href=#dma_wait-operation>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `memref.dma_wait` ssa-use`[`ssa-use-list`]` `,` ssa-use `:` memref-type
</code></pre><p>Blocks until the completion of a DMA operation associated with the tag element
specified with a tag memref and its indices. The operands include the tag memref
followed by its indices and the number of elements associated with the DMA being
waited on. The indices of the tag memref have the same restrictions as
load/store indices.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>.</span>dma_wait <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>],</span> <span class=nv>%size</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>)&gt;,</span> <span class=m>4</span><span class=p>&gt;</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/MathOps/ title="'math' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'math' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/MLProgramOps/ title="'ml_program' Dialect">Next - 'ml_program' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li class=active><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>