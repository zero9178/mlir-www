<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'omp' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'omp' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#attribute-constraint-definition>Attribute constraint definition</a><ul><li><a href=#cancellationconstructtype-clause>CancellationConstructType Clause</a></li><li><a href=#depend-clause>depend clause</a></li><li><a href=#memoryorderkind-clause>MemoryOrderKind Clause</a></li><li><a href=#orderkind-clause>OrderKind Clause</a></li><li><a href=#procbindkind-clause>ProcBindKind Clause</a></li><li><a href=#schedulekind-clause>ScheduleKind Clause</a></li><li><a href=#openmp-schedule-modifier>OpenMP Schedule Modifier</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#clausecancellationconstructtypeattr>ClauseCancellationConstructTypeAttr</a></li><li><a href=#clausedependattr>ClauseDependAttr</a></li><li><a href=#clausememoryorderkindattr>ClauseMemoryOrderKindAttr</a></li><li><a href=#clauseorderkindattr>ClauseOrderKindAttr</a></li><li><a href=#clauseprocbindkindattr>ClauseProcBindKindAttr</a></li><li><a href=#clauseschedulekindattr>ClauseScheduleKindAttr</a></li><li><a href=#schedulemodifierattr>ScheduleModifierAttr</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#ompatomiccapture-mlirompatomiccaptureop><code>omp.atomic.capture</code> (::mlir::omp::AtomicCaptureOp)</a></li><li><a href=#ompatomicread-mlirompatomicreadop><code>omp.atomic.read</code> (::mlir::omp::AtomicReadOp)</a></li><li><a href=#ompatomicupdate-mlirompatomicupdateop><code>omp.atomic.update</code> (::mlir::omp::AtomicUpdateOp)</a></li><li><a href=#ompatomicwrite-mlirompatomicwriteop><code>omp.atomic.write</code> (::mlir::omp::AtomicWriteOp)</a></li><li><a href=#ompbarrier-mlirompbarrierop><code>omp.barrier</code> (::mlir::omp::BarrierOp)</a></li><li><a href=#ompcancel-mlirompcancelop><code>omp.cancel</code> (::mlir::omp::CancelOp)</a></li><li><a href=#ompcancellationpoint-mlirompcancellationpointop><code>omp.cancellationpoint</code> (::mlir::omp::CancellationPointOp)</a></li><li><a href=#ompcriticaldeclare-mlirompcriticaldeclareop><code>omp.critical.declare</code> (::mlir::omp::CriticalDeclareOp)</a></li><li><a href=#ompcritical-mlirompcriticalop><code>omp.critical</code> (::mlir::omp::CriticalOp)</a></li><li><a href=#ompflush-mlirompflushop><code>omp.flush</code> (::mlir::omp::FlushOp)</a></li><li><a href=#ompmaster-mlirompmasterop><code>omp.master</code> (::mlir::omp::MasterOp)</a></li><li><a href=#ompordered-mliromporderedop><code>omp.ordered</code> (::mlir::omp::OrderedOp)</a></li><li><a href=#ompordered_region-mliromporderedregionop><code>omp.ordered_region</code> (::mlir::omp::OrderedRegionOp)</a></li><li><a href=#ompparallel-mlirompparallelop><code>omp.parallel</code> (::mlir::omp::ParallelOp)</a></li><li><a href=#ompreductiondeclare-mlirompreductiondeclareop><code>omp.reduction.declare</code> (::mlir::omp::ReductionDeclareOp)</a></li><li><a href=#ompreduction-mlirompreductionop><code>omp.reduction</code> (::mlir::omp::ReductionOp)</a></li><li><a href=#ompsection-mlirompsectionop><code>omp.section</code> (::mlir::omp::SectionOp)</a></li><li><a href=#ompsections-mlirompsectionsop><code>omp.sections</code> (::mlir::omp::SectionsOp)</a></li><li><a href=#ompsimdloop-mlirompsimdloopop><code>omp.simdloop</code> (::mlir::omp::SimdLoopOp)</a></li><li><a href=#ompsingle-mlirompsingleop><code>omp.single</code> (::mlir::omp::SingleOp)</a></li><li><a href=#omptarget-mliromptargetop><code>omp.target</code> (::mlir::omp::TargetOp)</a></li><li><a href=#omptask-mliromptaskop><code>omp.task</code> (::mlir::omp::TaskOp)</a></li><li><a href=#omptaskwait-mliromptaskwaitop><code>omp.taskwait</code> (::mlir::omp::TaskwaitOp)</a></li><li><a href=#omptaskyield-mliromptaskyieldop><code>omp.taskyield</code> (::mlir::omp::TaskyieldOp)</a></li><li><a href=#ompterminator-mlirompterminatorop><code>omp.terminator</code> (::mlir::omp::TerminatorOp)</a></li><li><a href=#ompthreadprivate-mlirompthreadprivateop><code>omp.threadprivate</code> (::mlir::omp::ThreadprivateOp)</a></li><li><a href=#ompwsloop-mlirompwsloopop><code>omp.wsloop</code> (::mlir::omp::WsLoopOp)</a></li><li><a href=#ompyield-mlirompyieldop><code>omp.yield</code> (::mlir::omp::YieldOp)</a></li></ul></li></ul></nav><h2 id=attribute-constraint-definition>Attribute constraint definition&nbsp;<a class=headline-hash href=#attribute-constraint-definition>¶</a></h2><h3 id=cancellationconstructtype-clause>CancellationConstructType Clause&nbsp;<a class=headline-hash href=#cancellationconstructtype-clause>¶</a></h3><h3 id=depend-clause>depend clause&nbsp;<a class=headline-hash href=#depend-clause>¶</a></h3><h3 id=memoryorderkind-clause>MemoryOrderKind Clause&nbsp;<a class=headline-hash href=#memoryorderkind-clause>¶</a></h3><h3 id=orderkind-clause>OrderKind Clause&nbsp;<a class=headline-hash href=#orderkind-clause>¶</a></h3><h3 id=procbindkind-clause>ProcBindKind Clause&nbsp;<a class=headline-hash href=#procbindkind-clause>¶</a></h3><h3 id=schedulekind-clause>ScheduleKind Clause&nbsp;<a class=headline-hash href=#schedulekind-clause>¶</a></h3><h3 id=openmp-schedule-modifier>OpenMP Schedule Modifier&nbsp;<a class=headline-hash href=#openmp-schedule-modifier>¶</a></h3><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=clausecancellationconstructtypeattr>ClauseCancellationConstructTypeAttr&nbsp;<a class=headline-hash href=#clausecancellationconstructtypeattr>¶</a></h3><p>CancellationConstructType Clause</p><p>Syntax:</p><pre><code>!omp.cancellationconstructtype&lt;
  ::mlir::omp::ClauseCancellationConstructType   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseCancellationConstructType</code></td><td>an enum of type ClauseCancellationConstructType</td></tr></tbody></table><h3 id=clausedependattr>ClauseDependAttr&nbsp;<a class=headline-hash href=#clausedependattr>¶</a></h3><p>depend clause</p><p>Syntax:</p><pre><code>!omp.clause_depend&lt;
  ::mlir::omp::ClauseDepend   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseDepend</code></td><td>an enum of type ClauseDepend</td></tr></tbody></table><h3 id=clausememoryorderkindattr>ClauseMemoryOrderKindAttr&nbsp;<a class=headline-hash href=#clausememoryorderkindattr>¶</a></h3><p>MemoryOrderKind Clause</p><p>Syntax:</p><pre><code>!omp.memoryorderkind&lt;
  ::mlir::omp::ClauseMemoryOrderKind   # value
&gt;
</code></pre><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseMemoryOrderKind</code></td><td>an enum of type ClauseMemoryOrderKind</td></tr></tbody></table><h3 id=clauseorderkindattr>ClauseOrderKindAttr&nbsp;<a class=headline-hash href=#clauseorderkindattr>¶</a></h3><p>OrderKind Clause</p><p>Syntax:</p><pre><code>!omp.orderkind&lt;
  ::mlir::omp::ClauseOrderKind   # value
&gt;
</code></pre><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseOrderKind</code></td><td>an enum of type ClauseOrderKind</td></tr></tbody></table><h3 id=clauseprocbindkindattr>ClauseProcBindKindAttr&nbsp;<a class=headline-hash href=#clauseprocbindkindattr>¶</a></h3><p>ProcBindKind Clause</p><p>Syntax:</p><pre><code>!omp.procbindkind&lt;
  ::mlir::omp::ClauseProcBindKind   # value
&gt;
</code></pre><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseProcBindKind</code></td><td>an enum of type ClauseProcBindKind</td></tr></tbody></table><h3 id=clauseschedulekindattr>ClauseScheduleKindAttr&nbsp;<a class=headline-hash href=#clauseschedulekindattr>¶</a></h3><p>ScheduleKind Clause</p><p>Syntax:</p><pre><code>!omp.schedulekind&lt;
  ::mlir::omp::ClauseScheduleKind   # value
&gt;
</code></pre><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ClauseScheduleKind</code></td><td>an enum of type ClauseScheduleKind</td></tr></tbody></table><h3 id=schedulemodifierattr>ScheduleModifierAttr&nbsp;<a class=headline-hash href=#schedulemodifierattr>¶</a></h3><p>OpenMP Schedule Modifier</p><p>Syntax:</p><pre><code>!omp.sched_mod&lt;
  ::mlir::omp::ScheduleModifier   # value
&gt;
</code></pre><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::omp::ScheduleModifier</code></td><td>an enum of type ScheduleModifier</td></tr></tbody></table><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=ompatomiccapture-mlirompatomiccaptureop><code>omp.atomic.capture</code> (::mlir::omp::AtomicCaptureOp)&nbsp;<a class=headline-hash href=#ompatomiccapture-mlirompatomiccaptureop>¶</a></h3><p>performs an atomic capture</p><p>Syntax:</p><pre><code>operation ::= `omp.atomic.capture` oilist(`memory_order` `(` custom&lt;ClauseAttr&gt;($memory_order_val) `)`
              |`hint` `(` custom&lt;SynchronizationHint&gt;($hint_val) `)`)
              $region attr-dict
</code></pre><p>This operation performs an atomic capture.</p><p><code>hint</code> is the value of hint (as used in the hint clause). It is a compile
time constant. As the name suggests, this is just a hint for optimization.</p><p><code>memory_order</code> indicates the memory ordering behavior of the construct. It
can be one of <code>seq_cst</code>, <code>acq_rel</code>, <code>release</code>, <code>acquire</code> or <code>relaxed</code>.</p><p>The region has the following allowed forms:</p><pre><code>  omp.atomic.capture {
    omp.atomic.update ...
    omp.atomic.read ...
    omp.terminator
  }

  omp.atomic.capture {
    omp.atomic.read ...
    omp.atomic.update ...
    omp.terminator
  }

  omp.atomic.capture {
    omp.atomic.read ...
    omp.atomic.write ...
    omp.terminator
  }
</code></pre><p>Traits: SingleBlockImplicitTerminator<terminatorop></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hint_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>memory_order_val</code></td><td style=text-align:center>::mlir::omp::ClauseMemoryOrderKindAttr</td><td>MemoryOrderKind Clause</td></tr></tbody></table><h3 id=ompatomicread-mlirompatomicreadop><code>omp.atomic.read</code> (::mlir::omp::AtomicReadOp)&nbsp;<a class=headline-hash href=#ompatomicread-mlirompatomicreadop>¶</a></h3><p>performs an atomic read</p><p>Syntax:</p><pre><code>operation ::= `omp.atomic.read` $v `=` $x
              oilist( `memory_order` `(` custom&lt;ClauseAttr&gt;($memory_order_val) `)`
              | `hint` `(` custom&lt;SynchronizationHint&gt;($hint_val) `)`)
              `:` type($x) attr-dict
</code></pre><p>This operation performs an atomic read.</p><p>The operand <code>x</code> is the address from where the value is atomically read.
The operand <code>v</code> is the address where the value is stored after reading.</p><p><code>hint</code> is the value of hint (as specified in the hint clause). It is a
compile time constant. As the name suggests, this is just a hint for
optimization.</p><p><code>memory_order</code> indicates the memory ordering behavior of the construct. It
can be one of <code>seq_cst</code>, <code>acquire</code> or <code>relaxed</code>.</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hint_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>memory_order_val</code></td><td style=text-align:center>::mlir::omp::ClauseMemoryOrderKindAttr</td><td>MemoryOrderKind Clause</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>OpenMP-compatible variable type</td></tr><tr><td style=text-align:center><code>v</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h3 id=ompatomicupdate-mlirompatomicupdateop><code>omp.atomic.update</code> (::mlir::omp::AtomicUpdateOp)&nbsp;<a class=headline-hash href=#ompatomicupdate-mlirompatomicupdateop>¶</a></h3><p>performs an atomic update</p><p>Syntax:</p><pre><code>operation ::= `omp.atomic.update` oilist( `memory_order` `(` custom&lt;ClauseAttr&gt;($memory_order_val) `)`
              | `hint` `(` custom&lt;SynchronizationHint&gt;($hint_val) `)`)
              $x `:` type($x) $region attr-dict
</code></pre><p>This operation performs an atomic update.</p><p>The operand <code>x</code> is exactly the same as the operand <code>x</code> in the OpenMP
Standard (OpenMP 5.0, section 2.17.7). It is the address of the variable
that is being updated. <code>x</code> is atomically read/written.</p><p><code>hint</code> is the value of hint (as used in the hint clause). It is a compile
time constant. As the name suggests, this is just a hint for optimization.</p><p><code>memory_order</code> indicates the memory ordering behavior of the construct. It
can be one of <code>seq_cst</code>, <code>release</code> or <code>relaxed</code>.</p><p>The region describes how to update the value of <code>x</code>. It takes the value at
<code>x</code> as an input and must yield the updated value. Only the update to <code>x</code> is
atomic. Generally the region must have only one instruction, but can
potentially have more than one instructions too. The update is sematically
similar to a compare-exchange loop based atomic update.</p><p>The syntax of atomic update operation is different from atomic read and
atomic write operations. This is because only the host dialect knows how to
appropriately update a value. For example, while generating LLVM IR, if
there are no special <code>atomicrmw</code> instructions for the operation-type
combination in atomic update, a compare-exchange loop is generated, where
the core update operation is directly translated like regular operations by
the host dialect. The front-end must handle semantic checks for allowed
operations.</p><p>Traits: SingleBlockImplicitTerminator<yieldop></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hint_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>memory_order_val</code></td><td style=text-align:center>::mlir::omp::ClauseMemoryOrderKindAttr</td><td>MemoryOrderKind Clause</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h3 id=ompatomicwrite-mlirompatomicwriteop><code>omp.atomic.write</code> (::mlir::omp::AtomicWriteOp)&nbsp;<a class=headline-hash href=#ompatomicwrite-mlirompatomicwriteop>¶</a></h3><p>performs an atomic write</p><p>Syntax:</p><pre><code>operation ::= `omp.atomic.write` $address `=` $value
              oilist( `hint` `(` custom&lt;SynchronizationHint&gt;($hint_val) `)`
              | `memory_order` `(` custom&lt;ClauseAttr&gt;($memory_order_val) `)`)
              `:` type($address) `,` type($value)
              attr-dict
</code></pre><p>This operation performs an atomic write.</p><p>The operand <code>address</code> is the address to where the <code>value</code> is atomically
written w.r.t. multiple threads. The evaluation of <code>value</code> need not be
atomic w.r.t. the write to address. In general, the type(address) must
dereference to type(value).</p><p><code>hint</code> is the value of hint (as specified in the hint clause). It is a
compile time constant. As the name suggests, this is just a hint for
optimization.</p><p><code>memory_order</code> indicates the memory ordering behavior of the construct. It
can be one of <code>seq_cst</code>, <code>release</code> or <code>relaxed</code>.</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hint_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>memory_order_val</code></td><td style=text-align:center>::mlir::omp::ClauseMemoryOrderKindAttr</td><td>MemoryOrderKind Clause</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>address</code></td><td>OpenMP-compatible variable type</td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=ompbarrier-mlirompbarrierop><code>omp.barrier</code> (::mlir::omp::BarrierOp)&nbsp;<a class=headline-hash href=#ompbarrier-mlirompbarrierop>¶</a></h3><p>barrier construct</p><p>Syntax:</p><pre><code>operation ::= `omp.barrier` attr-dict
</code></pre><p>The barrier construct specifies an explicit barrier at the point at which
the construct appears.</p><h3 id=ompcancel-mlirompcancelop><code>omp.cancel</code> (::mlir::omp::CancelOp)&nbsp;<a class=headline-hash href=#ompcancel-mlirompcancelop>¶</a></h3><p>cancel directive</p><p>Syntax:</p><pre><code>operation ::= `omp.cancel` `cancellation_construct_type` `(`
              custom&lt;ClauseAttr&gt;($cancellation_construct_type_val) `)`
              ( `if` `(` $if_expr^ `)` )? attr-dict
</code></pre><p>The cancel construct activates cancellation of the innermost enclosing
region of the type specified.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cancellation_construct_type_val</code></td><td style=text-align:center>::mlir::omp::ClauseCancellationConstructTypeAttr</td><td>CancellationConstructType Clause</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>if_expr</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=ompcancellationpoint-mlirompcancellationpointop><code>omp.cancellationpoint</code> (::mlir::omp::CancellationPointOp)&nbsp;<a class=headline-hash href=#ompcancellationpoint-mlirompcancellationpointop>¶</a></h3><p>cancellation point directive</p><p>Syntax:</p><pre><code>operation ::= `omp.cancellationpoint` `cancellation_construct_type` `(`
              custom&lt;ClauseAttr&gt;($cancellation_construct_type_val) `)`
              attr-dict
</code></pre><p>The cancellation point construct introduces a user-defined cancellation
point at which implicit or explicit tasks check if cancellation of the
innermost enclosing region of the type specified has been activated.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cancellation_construct_type_val</code></td><td style=text-align:center>::mlir::omp::ClauseCancellationConstructTypeAttr</td><td>CancellationConstructType Clause</td></tr></tbody></table><h3 id=ompcriticaldeclare-mlirompcriticaldeclareop><code>omp.critical.declare</code> (::mlir::omp::CriticalDeclareOp)&nbsp;<a class=headline-hash href=#ompcriticaldeclare-mlirompcriticaldeclareop>¶</a></h3><p>declares a named critical section.</p><p>Syntax:</p><pre><code>operation ::= `omp.critical.declare` $sym_name oilist(`hint` `(` custom&lt;SynchronizationHint&gt;($hint_val) `)`)
              attr-dict
</code></pre><p>Declares a named critical section.</p><p>The name can be used in critical constructs in the dialect.</p><p>Interfaces: Symbol</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>hint_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=ompcritical-mlirompcriticalop><code>omp.critical</code> (::mlir::omp::CriticalOp)&nbsp;<a class=headline-hash href=#ompcritical-mlirompcriticalop>¶</a></h3><p>critical construct</p><p>Syntax:</p><pre><code>operation ::= `omp.critical` (`(` $name^ `)`)? $region attr-dict
</code></pre><p>The critical construct imposes a restriction on the associated structured
block (region) to be executed by only a single thread at a time.</p><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h3 id=ompflush-mlirompflushop><code>omp.flush</code> (::mlir::omp::FlushOp)&nbsp;<a class=headline-hash href=#ompflush-mlirompflushop>¶</a></h3><p>flush construct</p><p>Syntax:</p><pre><code>operation ::= `omp.flush` ( `(` $varList^ `:` type($varList) `)` )? attr-dict
</code></pre><p>The flush construct executes the OpenMP flush operation. This operation
makes a thread’s temporary view of memory consistent with memory and
enforces an order on the memory operations of the variables explicitly
specified or implied.</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varList</code></td><td>any type</td></tr></tbody></table><h3 id=ompmaster-mlirompmasterop><code>omp.master</code> (::mlir::omp::MasterOp)&nbsp;<a class=headline-hash href=#ompmaster-mlirompmasterop>¶</a></h3><p>master construct</p><p>Syntax:</p><pre><code>operation ::= `omp.master` $region attr-dict
</code></pre><p>The master construct specifies a structured block that is executed by
the master thread of the team.</p><h3 id=ompordered-mliromporderedop><code>omp.ordered</code> (::mlir::omp::OrderedOp)&nbsp;<a class=headline-hash href=#ompordered-mliromporderedop>¶</a></h3><p>ordered construct without region</p><p>Syntax:</p><pre><code>operation ::= `omp.ordered` ( `depend_type` `` $depend_type_val^ )?
              ( `depend_vec` `(` $depend_vec_vars^ `:` type($depend_vec_vars) `)` )?
              attr-dict
</code></pre><p>The ordered construct without region is a stand-alone directive that
specifies cross-iteration dependences in a doacross loop nest.</p><p>The <code>depend_type_val</code> attribute refers to either the DEPEND(SOURCE) clause
or the DEPEND(SINK: vec) clause.</p><p>The <code>num_loops_val</code> attribute specifies the number of loops in the doacross
nest.</p><p>The <code>depend_vec_vars</code> is a variadic list of operands that specifies the index
of the loop iterator in the doacross nest for the DEPEND(SOURCE) clause or
the index of the element of &ldquo;vec&rdquo; for the DEPEND(SINK: vec) clause. It
contains the operands in multiple &ldquo;vec&rdquo; when multiple DEPEND(SINK: vec)
clauses exist in one ORDERED directive.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>depend_type_val</code></td><td style=text-align:center>::mlir::omp::ClauseDependAttr</td><td>depend clause</td></tr><tr><td style=text-align:center><code>num_loops_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>depend_vec_vars</code></td><td>any type</td></tr></tbody></table><h3 id=ompordered_region-mliromporderedregionop><code>omp.ordered_region</code> (::mlir::omp::OrderedRegionOp)&nbsp;<a class=headline-hash href=#ompordered_region-mliromporderedregionop>¶</a></h3><p>ordered construct with region</p><p>Syntax:</p><pre><code>operation ::= `omp.ordered_region` ( `simd` $simd^ )? $region attr-dict
</code></pre><p>The ordered construct with region specifies a structured block in a
worksharing-loop, SIMD, or worksharing-loop SIMD region that is executed in
the order of the loop iterations.</p><p>The <code>simd</code> attribute corresponds to the SIMD clause specified. If it is not
present, it behaves as if the THREADS clause is specified or no clause is
specified.</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>simd</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h3 id=ompparallel-mlirompparallelop><code>omp.parallel</code> (::mlir::omp::ParallelOp)&nbsp;<a class=headline-hash href=#ompparallel-mlirompparallelop>¶</a></h3><p>parallel construct</p><p>Syntax:</p><pre><code>operation ::= `omp.parallel` oilist( `reduction` `(`
              custom&lt;ReductionVarList&gt;(
              $reduction_vars, type($reduction_vars), $reductions
              ) `)`
              | `if` `(` $if_expr_var `:` type($if_expr_var) `)`
              | `num_threads` `(` $num_threads_var `:` type($num_threads_var) `)`
              | `allocate` `(`
              custom&lt;AllocateAndAllocator&gt;(
              $allocate_vars, type($allocate_vars),
              $allocators_vars, type($allocators_vars)
              ) `)`
              | `proc_bind` `(` custom&lt;ClauseAttr&gt;($proc_bind_val) `)`
              ) $region attr-dict
</code></pre><p>The parallel construct includes a region of code which is to be executed
by a team of threads.</p><p>The optional $if_expr_var parameter specifies a boolean result of a
conditional check. If this value is 1 or is not provided then the parallel
region runs as normal, if it is 0 then the parallel region is executed with
one thread.</p><p>The optional $num_threads_var parameter specifies the number of threads which
should be used to execute the parallel region.</p><p>The $allocators_vars and $allocate_vars parameters are a variadic list of values
that specify the memory allocator to be used to obtain storage for private values.</p><p>Reductions can be performed in a parallel construct by specifying reduction
accumulator variables in <code>reduction_vars</code> and symbols referring to reduction
declarations in the <code>reductions</code> attribute. Each reduction is identified
by the accumulator it uses and accumulators must not be repeated in the same
reduction. The <code>omp.reduction</code> operation accepts the accumulator and a
partial value which is considered to be produced by the thread for the
given reduction. If multiple values are produced for the same accumulator,
i.e. there are multiple <code>omp.reduction</code>s, the last value is taken. The
reduction declaration specifies how to combine the values from each thread
into the final value, which is available in the accumulator after all the
threads complete.</p><p>The optional $proc_bind_val attribute controls the thread affinity for the execution
of the parallel region.</p><p>Traits: AttrSizedOperandSegments, AutomaticAllocationScope, RecursiveSideEffects</p><p>Interfaces: OutlineableOpenMPOpInterface, ReductionClauseInterface</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reductions</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td style=text-align:center><code>proc_bind_val</code></td><td style=text-align:center>::mlir::omp::ClauseProcBindKindAttr</td><td>ProcBindKind Clause</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>if_expr_var</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>num_threads_var</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>allocate_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>allocators_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>reduction_vars</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h3 id=ompreductiondeclare-mlirompreductiondeclareop><code>omp.reduction.declare</code> (::mlir::omp::ReductionDeclareOp)&nbsp;<a class=headline-hash href=#ompreductiondeclare-mlirompreductiondeclareop>¶</a></h3><p>declares a reduction kind</p><p>Syntax:</p><pre><code>operation ::= `omp.reduction.declare` $sym_name `:` $type attr-dict-with-keyword `init` $initializerRegion `combiner` $reductionRegion custom&lt;AtomicReductionRegion&gt;($atomicReductionRegion)
</code></pre><p>Declares an OpenMP reduction kind. This requires two mandatory and one
optional region.</p><ol><li>The initializer region specifies how to initialize the thread-local
reduction value. This is usually the neutral element of the reduction.
For convenience, the region has an argument that contains the value
of the reduction accumulator at the start of the reduction. It is
expected to <code>omp.yield</code> the new value on all control flow paths.</li><li>The reduction region specifies how to combine two values into one, i.e.
the reduction operator. It accepts the two values as arguments and is
expected to <code>omp.yield</code> the combined value on all control flow paths.</li><li>The atomic reduction region is optional and specifies how two values
can be combined atomically given local accumulator variables. It is
expected to store the combined value in the first accumulator variable.</li></ol><p>Note that the MLIR type system does not allow for type-polymorphic
reductions. Separate reduction declarations should be created for different
element and accumulator types.</p><p>For initializer and reduction regions, the operand to <code>omp.yield</code> must
match the parent operation&rsquo;s results.</p><p>Interfaces: Symbol</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h3 id=ompreduction-mlirompreductionop><code>omp.reduction</code> (::mlir::omp::ReductionOp)&nbsp;<a class=headline-hash href=#ompreduction-mlirompreductionop>¶</a></h3><p>reduction construct</p><p>Syntax:</p><pre><code>operation ::= `omp.reduction` $operand `,` $accumulator attr-dict `:` type($accumulator)
</code></pre><p>Indicates the value that is produced by the current reduction-participating
entity for a reduction requested in some ancestor. The reduction is
identified by the accumulator, but the value of the accumulator may not be
updated immediately.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr><tr><td style=text-align:center><code>accumulator</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h3 id=ompsection-mlirompsectionop><code>omp.section</code> (::mlir::omp::SectionOp)&nbsp;<a class=headline-hash href=#ompsection-mlirompsectionop>¶</a></h3><p>section directive</p><p>Syntax:</p><pre><code>operation ::= `omp.section` $region attr-dict
</code></pre><p>A section operation encloses a region which represents one section in a
sections construct. A section op should always be surrounded by an
<code>omp.sections</code> operation.</p><p>Traits: HasParent<sectionsop></p><h3 id=ompsections-mlirompsectionsop><code>omp.sections</code> (::mlir::omp::SectionsOp)&nbsp;<a class=headline-hash href=#ompsections-mlirompsectionsop>¶</a></h3><p>sections construct</p><p>Syntax:</p><pre><code>operation ::= `omp.sections` oilist( `reduction` `(`
              custom&lt;ReductionVarList&gt;(
              $reduction_vars, type($reduction_vars), $reductions
              ) `)`
              | `allocate` `(`
              custom&lt;AllocateAndAllocator&gt;(
              $allocate_vars, type($allocate_vars),
              $allocators_vars, type($allocators_vars)
              ) `)`
              | `nowait` $nowait
              ) $region attr-dict
</code></pre><p>The sections construct is a non-iterative worksharing construct that
contains <code>omp.section</code> operations. The <code>omp.section</code> operations are to be
distributed among and executed by the threads in a team. Each <code>omp.section</code>
is executed once by one of the threads in the team in the context of its
implicit task.</p><p>Reductions can be performed in a sections construct by specifying reduction
accumulator variables in <code>reduction_vars</code> and symbols referring to reduction
declarations in the <code>reductions</code> attribute. Each reduction is identified
by the accumulator it uses and accumulators must not be repeated in the same
reduction. The <code>omp.reduction</code> operation accepts the accumulator and a
partial value which is considered to be produced by the section for the
given reduction. If multiple values are produced for the same accumulator,
i.e. there are multiple <code>omp.reduction</code>s, the last value is taken. The
reduction declaration specifies how to combine the values from each section
into the final value, which is available in the accumulator after all the
sections complete.</p><p>The $allocators_vars and $allocate_vars parameters are a variadic list of values
that specify the memory allocator to be used to obtain storage for private values.</p><p>The <code>nowait</code> attribute, when present, signifies that there should be no
implicit barrier at the end of the construct.</p><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: ReductionClauseInterface</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reductions</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td style=text-align:center><code>nowait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reduction_vars</code></td><td>OpenMP-compatible variable type</td></tr><tr><td style=text-align:center><code>allocate_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>allocators_vars</code></td><td>any type</td></tr></tbody></table><h3 id=ompsimdloop-mlirompsimdloopop><code>omp.simdloop</code> (::mlir::omp::SimdLoopOp)&nbsp;<a class=headline-hash href=#ompsimdloop-mlirompsimdloopop>¶</a></h3><p>simd loop construct</p><p>The simd construct can be applied to a loop to indicate that the loop can be
transformed into a SIMD loop (that is, multiple iterations of the loop can
be executed concurrently using SIMD instructions).. The lower and upper
bounds specify a half-open range: the range includes the lower bound but
does not include the upper bound.</p><p>The body region can contain any number of blocks. The region is terminated
by &ldquo;omp.yield&rdquo; instruction without operands.</p><pre><code>omp.simdloop (%i1, %i2) : index = (%c0, %c0) to (%c10, %c10) 
                                  step (%c1, %c1) {
  // block operations
  omp.yield
}
</code></pre><p>Traits: AttrSizedOperandSegments</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerBound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>upperBound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>step</code></td><td>integer or index</td></tr></tbody></table><h3 id=ompsingle-mlirompsingleop><code>omp.single</code> (::mlir::omp::SingleOp)&nbsp;<a class=headline-hash href=#ompsingle-mlirompsingleop>¶</a></h3><p>single directive</p><p>Syntax:</p><pre><code>operation ::= `omp.single` oilist(`allocate` `(`
              custom&lt;AllocateAndAllocator&gt;(
              $allocate_vars, type($allocate_vars),
              $allocators_vars, type($allocators_vars)
              ) `)`
              |`nowait` $nowait
              ) $region attr-dict
</code></pre><p>The single construct specifies that the associated structured block is
executed by only one of the threads in the team (not necessarily the
master thread), in the context of its implicit task. The other threads
in the team, which do not execute the block, wait at an implicit barrier
at the end of the single construct unless a nowait clause is specified.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nowait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>allocate_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>allocators_vars</code></td><td>any type</td></tr></tbody></table><h3 id=omptarget-mliromptargetop><code>omp.target</code> (::mlir::omp::TargetOp)&nbsp;<a class=headline-hash href=#omptarget-mliromptargetop>¶</a></h3><p>target construct</p><p>Syntax:</p><pre><code>operation ::= `omp.target` oilist( `if` `(` $if_expr `)`
              | `device` `(` $device `:` type($device) `)`
              | `thread_limit` `(` $thread_limit `:` type($thread_limit) `)`
              | `nowait` $nowait
              ) $region attr-dict
</code></pre><p>The target construct includes a region of code which is to be executed
on a device.</p><p>The optional $if_expr parameter specifies a boolean result of a
conditional check. If this value is 1 or is not provided then the target
region runs on a device, if it is 0 then the target region is executed on the
host device.</p><p>The optional $device parameter specifies the device number for the target region.</p><p>The optional $thread_limit specifies the limit on the number of threads</p><p>The optional $nowait elliminates the implicit barrier so the parent task can make progress
even if the target task is not yet completed.</p><p>TODO: map, is_device_ptr, depend, defaultmap, in_reduction</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nowait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>if_expr</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>device</code></td><td>integer</td></tr><tr><td style=text-align:center><code>thread_limit</code></td><td>integer</td></tr></tbody></table><h3 id=omptask-mliromptaskop><code>omp.task</code> (::mlir::omp::TaskOp)&nbsp;<a class=headline-hash href=#omptask-mliromptaskop>¶</a></h3><p>task construct</p><p>Syntax:</p><pre><code>operation ::= `omp.task` oilist(`if` `(` $if_expr `)`
              |`final` `(` $final_expr `)`
              |`untied` $untied
              |`mergeable` $mergeable
              |`in_reduction` `(`
              custom&lt;ReductionVarList&gt;(
              $in_reduction_vars, type($in_reduction_vars), $in_reductions
              ) `)`
              |`priority` `(` $priority `)`
              |`allocate` `(`
              custom&lt;AllocateAndAllocator&gt;(
              $allocate_vars, type($allocate_vars),
              $allocators_vars, type($allocators_vars)
              ) `)`
              ) $region attr-dict
</code></pre><p>The task construct defines an explicit task.</p><p>For definitions of &ldquo;undeferred task&rdquo;, &ldquo;included task&rdquo;, &ldquo;final task&rdquo; and
&ldquo;mergeable task&rdquo;, please check OpenMP Specification.</p><p>When an <code>if</code> clause is present on a task construct, and the value of
<code>if_expr</code> evaluates to <code>false</code>, an &ldquo;undeferred task&rdquo; is generated, and the
encountering thread must suspend the current task region, for which
execution cannot be resumed until execution of the structured block that is
associated with the generated task is completed.</p><p>When a <code>final</code> clause is present on a task construct and the <code>final_expr</code>
evaluates to <code>true</code>, the generated task will be a &ldquo;final task&rdquo;. All task
constructs encountered during execution of a final task will generate final
and included tasks.</p><p>If the <code>untied</code> clause is present on a task construct, any thread in the
team can resume the task region after a suspension. The <code>untied</code> clause is
ignored if a <code>final</code> clause is present on the same task construct and the
<code>final_expr</code> evaluates to <code>true</code>, or if a task is an included task.</p><p>When the <code>mergeable</code> clause is present on a task construct, the generated
task is a &ldquo;mergeable task&rdquo;.</p><p>The <code>in_reduction</code> clause specifies that this particular task (among all the
tasks in current taskgroup, if any) participates in a reduction.</p><p>The <code>priority</code> clause is a hint for the priority of the generated task.
The <code>priority</code> is a non-negative integer expression that provides a hint for
task execution order. Among all tasks ready to be executed, higher priority
tasks (those with a higher numerical value in the priority clause
expression) are recommended to execute before lower priority ones. The
default priority-value when no priority clause is specified should be
assumed to be zero (the lowest priority).</p><p>The <code>allocators_vars</code> and <code>allocate_vars</code> parameters are a variadic list of
values that specify the memory allocator to be used to obtain storage for
private values.</p><p>Traits: AttrSizedOperandSegments, AutomaticAllocationScope</p><p>Interfaces: OutlineableOpenMPOpInterface, ReductionClauseInterface</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>untied</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>mergeable</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>in_reductions</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>if_expr</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>final_expr</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>in_reduction_vars</code></td><td>OpenMP-compatible variable type</td></tr><tr><td style=text-align:center><code>priority</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>allocate_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>allocators_vars</code></td><td>any type</td></tr></tbody></table><h3 id=omptaskwait-mliromptaskwaitop><code>omp.taskwait</code> (::mlir::omp::TaskwaitOp)&nbsp;<a class=headline-hash href=#omptaskwait-mliromptaskwaitop>¶</a></h3><p>taskwait construct</p><p>Syntax:</p><pre><code>operation ::= `omp.taskwait` attr-dict
</code></pre><p>The taskwait construct specifies a wait on the completion of child tasks
of the current task.</p><h3 id=omptaskyield-mliromptaskyieldop><code>omp.taskyield</code> (::mlir::omp::TaskyieldOp)&nbsp;<a class=headline-hash href=#omptaskyield-mliromptaskyieldop>¶</a></h3><p>taskyield construct</p><p>Syntax:</p><pre><code>operation ::= `omp.taskyield` attr-dict
</code></pre><p>The taskyield construct specifies that the current task can be suspended
in favor of execution of a different task.</p><h3 id=ompterminator-mlirompterminatorop><code>omp.terminator</code> (::mlir::omp::TerminatorOp)&nbsp;<a class=headline-hash href=#ompterminator-mlirompterminatorop>¶</a></h3><p>terminator for OpenMP regions</p><p>Syntax:</p><pre><code>operation ::= `omp.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of OpenMP
operation. These regions are not expected to return any value so the
terminator takes no operands. The terminator op returns control to the
enclosing op.</p><p>Traits: Terminator</p><h3 id=ompthreadprivate-mlirompthreadprivateop><code>omp.threadprivate</code> (::mlir::omp::ThreadprivateOp)&nbsp;<a class=headline-hash href=#ompthreadprivate-mlirompthreadprivateop>¶</a></h3><p>threadprivate directive</p><p>Syntax:</p><pre><code>operation ::= `omp.threadprivate` $sym_addr `:` type($sym_addr) `-&gt;` type($tls_addr) attr-dict
</code></pre><p>The threadprivate directive specifies that variables are replicated, with
each thread having its own copy.</p><p>The current implementation uses the OpenMP runtime to provide thread-local
storage (TLS). Using the TLS feature of the LLVM IR will be supported in
future.</p><p>This operation takes in the address of a symbol that represents the original
variable and returns the address of its TLS. All occurrences of
threadprivate variables in a parallel region should use the TLS returned by
this operation.</p><p>The <code>sym_addr</code> refers to the address of the symbol, which is a pointer to
the original variable.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_addr</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tls_addr</code></td><td>OpenMP-compatible variable type</td></tr></tbody></table><h3 id=ompwsloop-mlirompwsloopop><code>omp.wsloop</code> (::mlir::omp::WsLoopOp)&nbsp;<a class=headline-hash href=#ompwsloop-mlirompwsloopop>¶</a></h3><p>worksharing-loop construct</p><p>Syntax:</p><pre><code>operation ::= `omp.wsloop` oilist(`linear` `(`
              custom&lt;LinearClause&gt;($linear_vars, type($linear_vars),
              $linear_step_vars) `)`
              |`schedule` `(`
              custom&lt;ScheduleClause&gt;(
              $schedule_val, $schedule_modifier, $simd_modifier,
              $schedule_chunk_var, type($schedule_chunk_var)) `)`
              |`collapse` `(` $collapse_val `)`
              |`nowait` $nowait
              |`ordered` `(` $ordered_val `)`
              |`order` `(` custom&lt;ClauseAttr&gt;($order_val) `)`
              |`reduction` `(`
              custom&lt;ReductionVarList&gt;(
              $reduction_vars, type($reduction_vars), $reductions
              ) `)`
              ) `for` custom&lt;WsLoopControl&gt;($region, $lowerBound, $upperBound, $step,
              type($step), $inclusive) attr-dict
</code></pre><p>The worksharing-loop construct specifies that the iterations of the loop(s)
will be executed in parallel by threads in the current context. These
iterations are spread across threads that already exist in the enclosing
parallel region. The lower and upper bounds specify a half-open range: the
range includes the lower bound but does not include the upper bound. If the
<code>inclusive</code> attribute is specified then the upper bound is also included.</p><p>The body region can contain any number of blocks. The region is terminated
by &ldquo;omp.yield&rdquo; instruction without operands.</p><pre><code>omp.wsloop &lt;clauses&gt;
for (%i1, %i2) : index = (%c0, %c0) to (%c10, %c10) step (%c1, %c1) {
  %a = load %arrA[%i1, %i2] : memref&lt;?x?xf32&gt;
  %b = load %arrB[%i1, %i2] : memref&lt;?x?xf32&gt;
  %sum = arith.addf %a, %b : f32
  store %sum, %arrC[%i1, %i2] : memref&lt;?x?xf32&gt;
  omp.yield
}
</code></pre><p>The <code>linear_step_vars</code> operand additionally specifies the step for each
associated linear operand. Note that the <code>linear_vars</code> and
<code>linear_step_vars</code> variadic lists should contain the same number of
elements.</p><p>Reductions can be performed in a workshare loop by specifying reduction
accumulator variables in <code>reduction_vars</code> and symbols referring to reduction
declarations in the <code>reductions</code> attribute. Each reduction is identified
by the accumulator it uses and accumulators must not be repeated in the same
reduction. The <code>omp.reduction</code> operation accepts the accumulator and a
partial value which is considered to be produced by the current loop
iteration for the given reduction. If multiple values are produced for the
same accumulator, i.e. there are multiple <code>omp.reduction</code>s, the last value
is taken. The reduction declaration specifies how to combine the values from
each iteration into the final value, which is available in the accumulator
after the loop completes.</p><p>The optional <code>schedule_val</code> attribute specifies the loop schedule for this
loop, determining how the loop is distributed across the parallel threads.
The optional <code>schedule_chunk_var</code> associated with this determines further
controls this distribution.</p><p>The optional <code>collapse_val</code> attribute specifies the number of loops which
are collapsed to form the worksharing loop.</p><p>The <code>nowait</code> attribute, when present, signifies that there should be no
implicit barrier at the end of the loop.</p><p>The optional <code>ordered_val</code> attribute specifies how many loops are associated
with the worksharing-loop construct. The value of zero refers to the ordered
clause specified without parameter.</p><p>The optional <code>order</code> attribute specifies which order the iterations of the
associate loops are executed in. Currently the only option for this
attribute is &ldquo;concurrent&rdquo;.</p><p>Traits: AttrSizedOperandSegments, RecursiveSideEffects</p><p>Interfaces: ReductionClauseInterface</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reductions</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td style=text-align:center><code>schedule_val</code></td><td style=text-align:center>::mlir::omp::ClauseScheduleKindAttr</td><td>ScheduleKind Clause</td></tr><tr><td style=text-align:center><code>schedule_modifier</code></td><td style=text-align:center>::mlir::omp::ScheduleModifierAttr</td><td>OpenMP Schedule Modifier</td></tr><tr><td style=text-align:center><code>simd_modifier</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>collapse_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr><tr><td style=text-align:center><code>nowait</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>ordered_val</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr><tr><td style=text-align:center><code>order_val</code></td><td style=text-align:center>::mlir::omp::ClauseOrderKindAttr</td><td>OrderKind Clause</td></tr><tr><td style=text-align:center><code>inclusive</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerBound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>upperBound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>step</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>linear_vars</code></td><td>any type</td></tr><tr><td style=text-align:center><code>linear_step_vars</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>reduction_vars</code></td><td>OpenMP-compatible variable type</td></tr><tr><td style=text-align:center><code>schedule_chunk_var</code></td><td>any type</td></tr></tbody></table><h3 id=ompyield-mlirompyieldop><code>omp.yield</code> (::mlir::omp::YieldOp)&nbsp;<a class=headline-hash href=#ompyield-mlirompyieldop>¶</a></h3><p>loop yield and termination operation</p><p>Syntax:</p><pre><code>operation ::= `omp.yield` ( `(` $results^ `:` type($results) `)` )? attr-dict
</code></pre><p>&ldquo;omp.yield&rdquo; yields SSA values from the OpenMP dialect op region and
terminates the region. The semantics of how the values are yielded is
defined by the parent operation.</p><p>Traits: HasParent&lt;WsLoopOp, ReductionDeclareOp, AtomicUpdateOp, SimdLoopOp>, ReturnLike, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/NVVMDialect/ title="'nvvm' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'nvvm' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/PDLOps/ title="'pdl' Dialect">Next - 'pdl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=active><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>