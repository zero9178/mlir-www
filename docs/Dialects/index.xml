<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dialects on MLIR</title><link>https://mlir.llvm.org/docs/Dialects/</link><description>Recent content in Dialects on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Dialects/index.xml" rel="self" type="application/rss+xml"/><item><title>'acc' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/OpenACCDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/OpenACCDialect/</guid><description>An OpenACC dialect for MLIR. This dialect models the construct from the OpenACC 3.1 directive language.
Attribute constraint definition DefaultValue Clause built-in reduction operations supported by OpenACC Attribute definition ClauseDefaultValueAttr ReductionOpAttr Operation definition acc.data (::mlir::acc::DataOp) acc.enter_data (::mlir::acc::EnterDataOp) acc.exit_data (::mlir::acc::ExitDataOp) acc.init (::mlir::acc::InitOp) acc.loop (::mlir::acc::LoopOp) acc.parallel (::mlir::acc::ParallelOp) acc.shutdown (::mlir::acc::ShutdownOp) acc.terminator (::mlir::acc::TerminatorOp) acc.update (::mlir::acc::UpdateOp) acc.wait (::mlir::acc::WaitOp) acc.yield (::mlir::acc::YieldOp) Attribute constraint definition DefaultValue Clause built-in reduction operations supported by OpenACC Attribute definition ClauseDefaultValueAttr DefaultValue Clause</description></item><item><title>'affine' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Affine/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Affine/</guid><description>This dialect provides a powerful abstraction for affine operations and analyses.
Polyhedral Structures Dimensions and Symbols Restrictions on Dimensions and Symbols Affine Expressions Affine Maps Semi-affine maps Integer Sets Operations affine.apply (mlir::AffineApplyOp) affine.for (mlir::AffineForOp) affine.if (mlir::AffineIfOp) affine.load (mlir::AffineLoadOp) affine.max (mlir::AffineMaxOp) affine.min (mlir::AffineMinOp) affine.parallel (mlir::AffineParallelOp) affine.prefetch (mlir::AffinePrefetchOp) affine.store (mlir::AffineStoreOp) affine.vector_load (mlir::AffineVectorLoadOp) affine.vector_store (mlir::AffineVectorStoreOp) affine.yield (mlir::AffineYieldOp) &amp;lsquo;affine.store&amp;rsquo; operation &amp;lsquo;affine.dma_start&amp;rsquo; operation &amp;lsquo;affine.dma_wait&amp;rsquo; operation Polyhedral Structures MLIR uses techniques from polyhedral compilation to make dependence analysis and loop transformations efficient and reliable.</description></item><item><title>'amx' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/AMX/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/AMX/</guid><description>The Intel Advanced Matrix Extensions (AMX) provide a tile matrix multiply unit (TMUL), a tile control register (TILECFG), and eight tile registers TMM0 through TMM7 (TILEDATA).
This AMX dialect provides a bridge between MLIR concepts such as vectors and memrefs and the lower level LLVM IR support of AMX. The dialect is split into user-facing AMX ops (AMX_Op) and backend-facing intrinsic ops (AMX_IntrOp).
Note that since configuration changes (implicit at dialect level) are costly, it is highly recommended to use the AMX dialect on same-shaped vectors, at least within a single method.</description></item><item><title>'arith' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ArithmeticOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ArithmeticOps/</guid><description>The arithmetic dialect is intended to hold basic integer and floating point mathematical operations. This includes unary, binary, and ternary arithmetic ops, bitwise and shift ops, cast ops, and compare ops. Operations in this dialect also accept vectors and tensors of integers or floats.
Operation definition arith.addf (::mlir::arith::AddFOp) arith.addi (::mlir::arith::AddIOp) arith.andi (::mlir::arith::AndIOp) arith.bitcast (::mlir::arith::BitcastOp) arith.ceildivsi (::mlir::arith::CeilDivSIOp) arith.ceildivui (::mlir::arith::CeilDivUIOp) arith.cmpf (::mlir::arith::CmpFOp) arith.cmpi (::mlir::arith::CmpIOp) arith.constant (::mlir::arith::ConstantOp) arith.divf (::mlir::arith::DivFOp) arith.divsi (::mlir::arith::DivSIOp) arith.</description></item><item><title>'arm_neon' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ArmNeon/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ArmNeon/</guid><description>Operation definition arm_neon.intr.smull (::mlir::arm_neon::SMullOp) arm_neon.2d.sdot (::mlir::arm_neon::Sdot2dOp) arm_neon.intr.sdot (::mlir::arm_neon::SdotOp) Type constraint definition LLVM dialect-compatible type Operation definition arm_neon.intr.smull (::mlir::arm_neon::SMullOp) smull roundscale op
Syntax:
operation ::= `arm_neon.intr.smull` $a `,` $b attr-dict `:` type($a) `to` type($res) Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;amp;FP register.</description></item><item><title>'arm_sve' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ArmSVE/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ArmSVE/</guid><description>Basic dialect to target Arm SVE architectures This dialect contains the definitions necessary to target specific Arm SVE scalable vector operations.
Operation definition arm_sve.intr.fadd (::mlir::arm_sve::ScalableMaskedAddFIntrOp) arm_sve.masked.addf (::mlir::arm_sve::ScalableMaskedAddFOp) arm_sve.intr.add (::mlir::arm_sve::ScalableMaskedAddIIntrOp) arm_sve.masked.addi (::mlir::arm_sve::ScalableMaskedAddIOp) arm_sve.intr.fdiv (::mlir::arm_sve::ScalableMaskedDivFIntrOp) arm_sve.masked.divf (::mlir::arm_sve::ScalableMaskedDivFOp) arm_sve.intr.fmul (::mlir::arm_sve::ScalableMaskedMulFIntrOp) arm_sve.masked.mulf (::mlir::arm_sve::ScalableMaskedMulFOp) arm_sve.intr.mul (::mlir::arm_sve::ScalableMaskedMulIIntrOp) arm_sve.masked.muli (::mlir::arm_sve::ScalableMaskedMulIOp) arm_sve.intr.sdiv (::mlir::arm_sve::ScalableMaskedSDivIIntrOp) arm_sve.masked.divi_signed (::mlir::arm_sve::ScalableMaskedSDivIOp) arm_sve.intr.fsub (::mlir::arm_sve::ScalableMaskedSubFIntrOp) arm_sve.masked.subf (::mlir::arm_sve::ScalableMaskedSubFOp) arm_sve.intr.sub (::mlir::arm_sve::ScalableMaskedSubIIntrOp) arm_sve.masked.subi (::mlir::arm_sve::ScalableMaskedSubIOp) arm_sve.intr.udiv (::mlir::arm_sve::ScalableMaskedUDivIIntrOp) arm_sve.masked.divi_unsigned (::mlir::arm_sve::ScalableMaskedUDivIOp) arm_sve.intr.sdot (::mlir::arm_sve::SdotIntrOp) arm_sve.sdot (::mlir::arm_sve::SdotOp) arm_sve.intr.smmla (::mlir::arm_sve::SmmlaIntrOp) arm_sve.smmla (::mlir::arm_sve::SmmlaOp) arm_sve.intr.udot (::mlir::arm_sve::UdotIntrOp) arm_sve.</description></item><item><title>'async' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/AsyncDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/AsyncDialect/</guid><description>Types and operations for async dialect This dialect contains operations for modeling asynchronous execution.
Type constraint definition coroutine handle switched-resume coroutine identifier saved coroutine state async group type async token type async value type Operation definition async.add_to_group (::mlir::async::AddToGroupOp) async.await_all (::mlir::async::AwaitAllOp) async.await (::mlir::async::AwaitOp) async.coro.begin (::mlir::async::CoroBeginOp) async.coro.end (::mlir::async::CoroEndOp) async.coro.free (::mlir::async::CoroFreeOp) async.coro.id (::mlir::async::CoroIdOp) async.coro.save (::mlir::async::CoroSaveOp) async.coro.suspend (::mlir::async::CoroSuspendOp) async.create_group (::mlir::async::CreateGroupOp) async.execute (::mlir::async::ExecuteOp) async.runtime.add_ref (::mlir::async::RuntimeAddRefOp) async.runtime.add_to_group (::mlir::async::RuntimeAddToGroupOp) async.runtime.await_and_resume (::mlir::async::RuntimeAwaitAndResumeOp) async.runtime.await (::mlir::async::RuntimeAwaitOp) async.</description></item><item><title>'bufferization' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/BufferizationOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/BufferizationOps/</guid><description>Bufferization in MLIR is the process of converting the tensor type to the memref type. The bufferization dialect is intended to collect operations/interfaces specific to the bufferization passes.
Overview of the bufferization infrastructure and important conceptual details related to using the MLIR dialect conversion infrastructure can be found in bufferization and buffer deallocation.
Operation definition bufferization.clone (::mlir::bufferization::CloneOp) bufferization.to_memref (::mlir::bufferization::ToMemrefOp) bufferization.to_tensor (::mlir::bufferization::ToTensorOp) Operation definition bufferization.clone (::mlir::bufferization::CloneOp) Syntax:</description></item><item><title>'cf' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/</guid><description>This dialect contains low-level, i.e. non-region based, control flow constructs. These constructs generally represent control flow directly on SSA blocks of a control flow graph.
Operation definition cf.assert (::mlir::cf::AssertOp) cf.br (::mlir::cf::BranchOp) cf.cond_br (::mlir::cf::CondBranchOp) cf.switch (::mlir::cf::SwitchOp) Operation definition cf.assert (::mlir::cf::AssertOp) Assert operation with message attribute
Syntax:
operation ::= `cf.assert` $arg `,` $msg attr-dict Assert operation with single boolean operand and an error message attribute. If the argument is true this operation has no effect.</description></item><item><title>'complex' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ComplexOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ComplexOps/</guid><description>The complex dialect is intended to hold complex numbers creation and arithmetic ops.
Operation definition complex.abs (::mlir::complex::AbsOp) complex.add (::mlir::complex::AddOp) complex.constant (::mlir::complex::ConstantOp) complex.cos (::mlir::complex::CosOp) complex.create (::mlir::complex::CreateOp) complex.div (::mlir::complex::DivOp) complex.eq (::mlir::complex::EqualOp) complex.exp (::mlir::complex::ExpOp) complex.im (::mlir::complex::ImOp) complex.log1p (::mlir::complex::Log1pOp) complex.log (::mlir::complex::LogOp) complex.mul (::mlir::complex::MulOp) complex.neg (::mlir::complex::NegOp) complex.neq (::mlir::complex::NotEqualOp) complex.re (::mlir::complex::ReOp) complex.sign (::mlir::complex::SignOp) complex.sin (::mlir::complex::SinOp) complex.sub (::mlir::complex::SubOp) Operation definition complex.abs (::mlir::complex::AbsOp) computes absolute value of a complex number
Syntax:
operation ::= `complex.</description></item><item><title>'dlti' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/DLTIDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/DLTIDialect/</guid><description>The Data Layout and Target Information (DLTI) dialect is intended to hold attributes and other components pertaining to descriptions of in-memory data layout and compilation targets.
Attribute constraint definition Target data layout entry Target data layout specification Attribute constraint definition Target data layout entry Target data layout specification</description></item><item><title>'emitc' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/EmitC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/EmitC/</guid><description>Dialect to generate C/C++ from MLIR. The EmitC dialect allows to convert operations from other MLIR dialects to EmitC ops. Those can be translated to C/C++ via the Cpp emitter.
The following convention is followed:
If template arguments are passed to an emitc.call operation, C++ is generated. If tensors are used, C++ is generated. If multiple return values are used within in a functions or an emitc.call operation, C++11 is required.</description></item><item><title>'func' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Func/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Func/</guid><description>This dialect provides documentation for operations within the Func dialect.
This dialect contains operations surrounding high order function abstractions, such as calls.
Please post an RFC on the forum before adding or changing any operation in this dialect.
Operations func.call_indirect (::mlir::func::CallIndirectOp) func.call (::mlir::func::CallOp) func.constant (::mlir::func::ConstantOp) func.func (::mlir::func::FuncOp) func.return (::mlir::func::ReturnOp) Operations func.call_indirect (::mlir::func::CallIndirectOp) indirect call operation
Syntax:
operation ::= `func.call_indirect` $callee `(` $callee_operands `)` attr-dict `:` type($callee) The func.</description></item><item><title>'gpu' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/GPU/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/GPU/</guid><description>Note: this dialect is more likely to change than others in the near future; use with caution.
This dialect provides middle-level abstractions for launching GPU kernels following a programming model similar to that of CUDA or OpenCL. It provides abstractions for kernel invocations (and may eventually provide those for device management) that are not present at the lower level (e.g., as LLVM IR intrinsics for GPUs). Its goal is to abstract away device- and driver-specific manipulations to launch a GPU kernel and provide a simple path towards GPU execution from MLIR.</description></item><item><title>'llvm' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVM/</guid><description>This dialect maps LLVM IR into MLIR by defining the corresponding operations and types. LLVM IR metadata is usually represented as MLIR attributes, which offer additional structure verification.
We use &amp;ldquo;LLVM IR&amp;rdquo; to designate the intermediate representation of LLVM and &amp;ldquo;LLVM dialect&amp;rdquo; or &amp;ldquo;LLVM IR dialect&amp;rdquo; to refer to this MLIR dialect.
Unless explicitly stated otherwise, the semantics of the LLVM dialect operations must correspond to the semantics of LLVM IR instructions and any divergence is considered a bug.</description></item><item><title>'math' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/MathOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/MathOps/</guid><description>The math dialect is intended to hold mathematical operations on integer and floating type beyond simple arithmetics.
Operation definition math.abs (::mlir::math::AbsOp) math.atan2 (::mlir::math::Atan2Op) math.atan (::mlir::math::AtanOp) math.ceil (::mlir::math::CeilOp) math.copysign (::mlir::math::CopySignOp) math.cos (::mlir::math::CosOp) math.ctlz (::mlir::math::CountLeadingZerosOp) math.cttz (::mlir::math::CountTrailingZerosOp) math.ctpop (::mlir::math::CtPopOp) math.erf (::mlir::math::ErfOp) math.exp2 (::mlir::math::Exp2Op) math.expm1 (::mlir::math::ExpM1Op) math.exp (::mlir::math::ExpOp) math.floor (::mlir::math::FloorOp) math.fma (::mlir::math::FmaOp) math.log10 (::mlir::math::Log10Op) math.log1p (::mlir::math::Log1pOp) math.log2 (::mlir::math::Log2Op) math.log (::mlir::math::LogOp) math.powf (::mlir::math::PowFOp) math.rsqrt (::mlir::math::RsqrtOp) math.sin (::mlir::math::SinOp) math.sqrt (::mlir::math::SqrtOp) math.tanh (::mlir::math::TanhOp) Operation definition math.</description></item><item><title>'memref' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/MemRef/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/MemRef/</guid><description>This dialect provides documentation for operations within the MemRef dialect.
Please post an RFC on the forum before adding or changing any operation in this dialect.
Operations Operation definition memref.assume_alignment (::mlir::memref::AssumeAlignmentOp) memref.atomic_rmw (::mlir::memref::AtomicRMWOp) memref.atomic_yield (::mlir::memref::AtomicYieldOp) memref.copy (::mlir::memref::CopyOp) memref.generic_atomic_rmw (::mlir::memref::GenericAtomicRMWOp) memref.load (::mlir::memref::LoadOp) memref.alloc (::mlir::memref::AllocOp) memref.alloca (::mlir::memref::AllocaOp) memref.alloca_scope (::mlir::memref::AllocaScopeOp) memref.alloca_scope.return (::mlir::memref::AllocaScopeReturnOp) memref.cast (::mlir::memref::CastOp) memref.collapse_shape (::mlir::memref::CollapseShapeOp) memref.dealloc (::mlir::memref::DeallocOp) memref.dim (::mlir::memref::DimOp) memref.dma_start (::mlir::memref::DmaStartOp) memref.dma_wait (::mlir::memref::DmaWaitOp) memref.expand_shape (::mlir::memref::ExpandShapeOp) memref.get_global (::mlir::memref::GetGlobalOp) memref.global (::mlir::memref::GlobalOp) memref.prefetch (::mlir::memref::PrefetchOp) memref.</description></item><item><title>'ml_program' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/MLProgramOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/MLProgramOps/</guid><description>The MLProgram dialect contains structural operations and types for defining a compiled Machine-Learning program, as created from common ML frameworks, such as TensorFlow, PyTorch, JAX, etc. It does not itself define computation ops common to such frameworks but establishes a common programming model for establishing modules, functions, globals and memory model components appropriate for such an abstract level of detail.
This dialect is under active development, and while stability is an eventual goal, it is not guaranteed at this juncture.</description></item><item><title>'nvgpu' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/NVGPU/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/NVGPU/</guid><description>This NVGPU dialect provides a bridge between the target agnostic GPU and Vector dialects and the lower level LLVM IR based NVVM dialect. This allow representing PTX specific operations while using MLIR high level concepts like memref and 2-D vector.
Operation definition nvgpu.ldmatrix (::mlir::nvgpu::LdMatrixOp) nvgpu.mma.sync (::mlir::nvgpu::MmaSyncOp) Operation definition nvgpu.ldmatrix (::mlir::nvgpu::LdMatrixOp) Syntax:
operation ::= `nvgpu.ldmatrix` $srcMemref`[` $indices `]` attr-dict `:` type($srcMemref) `-&amp;gt;` type($res) The nvgpu.ldmatrix op represents loading a matrix fragment from memory.</description></item><item><title>'nvvm' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/NVVMDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/NVVMDialect/</guid><description>Attribute constraint definition MMA binary operations NVVM MMA frag type MMA overflow options NVVM MMA layout NVVM MMA types NVVM shuffle kind Attribute definition MMAB1OpAttr MMAFragAttr MMAIntOverflowAttr MMALayoutAttr MMATypesAttr ShflKindAttr Operation definition nvvm.barrier0 (::mlir::NVVM::Barrier0Op) nvvm.read.ptx.sreg.ntid.x (::mlir::NVVM::BlockDimXOp) nvvm.read.ptx.sreg.ntid.y (::mlir::NVVM::BlockDimYOp) nvvm.read.ptx.sreg.ntid.z (::mlir::NVVM::BlockDimZOp) nvvm.read.ptx.sreg.ctaid.x (::mlir::NVVM::BlockIdXOp) nvvm.read.ptx.sreg.ctaid.y (::mlir::NVVM::BlockIdYOp) nvvm.read.ptx.sreg.ctaid.z (::mlir::NVVM::BlockIdZOp) nvvm.cp.async.commit.group (::mlir::NVVM::CpAsyncCommitGroupOp) nvvm.cp.async.shared.global (::mlir::NVVM::CpAsyncOp) nvvm.cp.async.wait.group (::mlir::NVVM::CpAsyncWaitGroupOp) nvvm.read.ptx.sreg.nctaid.x (::mlir::NVVM::GridDimXOp) nvvm.read.ptx.sreg.nctaid.y (::mlir::NVVM::GridDimYOp) nvvm.read.ptx.sreg.nctaid.z (::mlir::NVVM::GridDimZOp) nvvm.read.ptx.sreg.laneid (::mlir::NVVM::LaneIdOp) nvvm.ldmatrix (::mlir::NVVM::LdMatrixOp) nvvm.</description></item><item><title>'omp' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/OpenMPDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/OpenMPDialect/</guid><description>Attribute constraint definition CancellationConstructType Clause depend clause MemoryOrderKind Clause OrderKind Clause ProcBindKind Clause ScheduleKind Clause OpenMP Schedule Modifier Attribute definition ClauseCancellationConstructTypeAttr ClauseDependAttr ClauseMemoryOrderKindAttr ClauseOrderKindAttr ClauseProcBindKindAttr ClauseScheduleKindAttr ScheduleModifierAttr Operation definition omp.atomic.capture (::mlir::omp::AtomicCaptureOp) omp.atomic.read (::mlir::omp::AtomicReadOp) omp.atomic.update (::mlir::omp::AtomicUpdateOp) omp.atomic.write (::mlir::omp::AtomicWriteOp) omp.barrier (::mlir::omp::BarrierOp) omp.cancel (::mlir::omp::CancelOp) omp.cancellationpoint (::mlir::omp::CancellationPointOp) omp.critical.declare (::mlir::omp::CriticalDeclareOp) omp.critical (::mlir::omp::CriticalOp) omp.flush (::mlir::omp::FlushOp) omp.master (::mlir::omp::MasterOp) omp.ordered (::mlir::omp::OrderedOp) omp.ordered_region (::mlir::omp::OrderedRegionOp) omp.parallel (::mlir::omp::ParallelOp) omp.reduction.declare (::mlir::omp::ReductionDeclareOp) omp.reduction (::mlir::omp::ReductionOp) omp.section (::mlir::omp::SectionOp) omp.</description></item><item><title>'pdl' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/PDLOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/PDLOps/</guid><description>High level pattern definition dialect PDL presents a high level abstraction for the rewrite pattern infrastructure available in MLIR. This abstraction allows for representing patterns transforming MLIR, as MLIR. This allows for applying all of the benefits that the general MLIR infrastructure provides, to the infrastructure itself. This means that pattern matching can be more easily verified for correctness, targeted by frontends, and optimized.
PDL abstracts over various different aspects of patterns and core MLIR data structures.</description></item><item><title>'pdl_interp' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/PDLInterpOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/PDLInterpOps/</guid><description>Interpreted pattern execution dialect The PDL Interpreter dialect provides a lower level abstraction compared to the PDL dialect, and is targeted towards low level optimization and interpreter code generation. The dialect operations encapsulates low-level pattern match and rewrite &amp;ldquo;primitives&amp;rdquo;, such as navigating the IR (Operation::getOperand), creating new operations (OpBuilder::create), etc. Many of the operations within this dialect also fuse branching control flow with some form of a predicate comparison operation. This type of fusion reduces the amount of work that an interpreter must do when executing.</description></item><item><title>'quant' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/QuantDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/QuantDialect/</guid><description>Type constraint definition UniformQuantizedType Operation definition quant.const_fake_quant (::mlir::quant::ConstFakeQuant) quant.const_fake_quant_per_axis (::mlir::quant::ConstFakeQuantPerAxis) quant.coupled_ref (::mlir::quant::CoupledRefOp) quant.dcast (::mlir::quant::DequantizeCastOp) quant.qcast (::mlir::quant::QuantizeCastOp) quant.region (::mlir::quant::QuantizeRegionOp) quant.return (::mlir::quant::ReturnOp) quant.stats (::mlir::quant::StatisticsOp) quant.stats_ref (::mlir::quant::StatisticsRefOp) quant.scast (::mlir::quant::StorageCastOp) Type constraint definition UniformQuantizedType Operation definition quant.const_fake_quant (::mlir::quant::ConstFakeQuant) Simulates the effect of uniform quantization with const range. Given a const min, max, num_bits and narrow_range attribute, applies the same uniform quantization simulation as is done by the TensorFlow fake_quant_with_min_max_args op.</description></item><item><title>'rocdl' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ROCDLDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ROCDLDialect/</guid><description>Operation definition rocdl.barrier (::mlir::ROCDL::BarrierOp) rocdl.workgroup.dim.x (::mlir::ROCDL::BlockDimXOp) rocdl.workgroup.dim.y (::mlir::ROCDL::BlockDimYOp) rocdl.workgroup.dim.z (::mlir::ROCDL::BlockDimZOp) rocdl.workgroup.id.x (::mlir::ROCDL::BlockIdXOp) rocdl.workgroup.id.y (::mlir::ROCDL::BlockIdYOp) rocdl.workgroup.id.z (::mlir::ROCDL::BlockIdZOp) rocdl.grid.dim.x (::mlir::ROCDL::GridDimXOp) rocdl.grid.dim.y (::mlir::ROCDL::GridDimYOp) rocdl.grid.dim.z (::mlir::ROCDL::GridDimZOp) rocdl.buffer.load (::mlir::ROCDL::MubufLoadOp) rocdl.buffer.store (::mlir::ROCDL::MubufStoreOp) rocdl.workitem.id.x (::mlir::ROCDL::ThreadIdXOp) rocdl.workitem.id.y (::mlir::ROCDL::ThreadIdYOp) rocdl.workitem.id.z (::mlir::ROCDL::ThreadIdZOp) rocdl.mfma.f32.16x16x16f16 (::mlir::ROCDL::mfma_f32_16x16x16f16) rocdl.mfma.f32.16x16x1f32 (::mlir::ROCDL::mfma_f32_16x16x1f32) rocdl.mfma.f32.16x16x2bf16 (::mlir::ROCDL::mfma_f32_16x16x2bf16) rocdl.mfma.f32.16x16x4f16 (::mlir::ROCDL::mfma_f32_16x16x4f16) rocdl.mfma.f32.16x16x4f32 (::mlir::ROCDL::mfma_f32_16x16x4f32) rocdl.mfma.f32.16x16x8bf16 (::mlir::ROCDL::mfma_f32_16x16x8bf16) rocdl.mfma.f32.32x32x1f32 (::mlir::ROCDL::mfma_f32_32x32x1f32) rocdl.mfma.f32.32x32x2bf16 (::mlir::ROCDL::mfma_f32_32x32x2bf16) rocdl.mfma.f32.32x32x2f32 (::mlir::ROCDL::mfma_f32_32x32x2f32) rocdl.mfma.f32.32x32x4bf16 (::mlir::ROCDL::mfma_f32_32x32x4bf16) rocdl.mfma.f32.32x32x4f16 (::mlir::ROCDL::mfma_f32_32x32x4f16) rocdl.mfma.f32.32x32x8f16 (::mlir::ROCDL::mfma_f32_32x32x8f16) rocdl.mfma.f32.4x4x1f32 (::mlir::ROCDL::mfma_f32_4x4x1f32) rocdl.mfma.f32.4x4x2bf16 (::mlir::ROCDL::mfma_f32_4x4x2bf16) rocdl.mfma.f32.4x4x4f16 (::mlir::ROCDL::mfma_f32_4x4x4f16) rocdl.mfma.i32.16x16x16i8 (::mlir::ROCDL::mfma_i32_16x16x16i8) rocdl.mfma.i32.16x16x4i8 (::mlir::ROCDL::mfma_i32_16x16x4i8) rocdl.mfma.i32.32x32x4i8 (::mlir::ROCDL::mfma_i32_32x32x4i8) rocdl.</description></item><item><title>'scf' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SCFDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SCFDialect/</guid><description>Operation definition scf.condition (::mlir::scf::ConditionOp) scf.execute_region (::mlir::scf::ExecuteRegionOp) scf.for (::mlir::scf::ForOp) scf.if (::mlir::scf::IfOp) scf.parallel (::mlir::scf::ParallelOp) scf.reduce (::mlir::scf::ReduceOp) scf.reduce.return (::mlir::scf::ReduceReturnOp) scf.while (::mlir::scf::WhileOp) scf.yield (::mlir::scf::YieldOp) Operation definition scf.condition (::mlir::scf::ConditionOp) loop continuation condition
Syntax:
operation ::= `scf.condition` `(` $condition `)` attr-dict ($args^ `:` type($args))? This operation accepts the continuation (i.e., inverse of exit) condition of the scf.while construct. If its first argument is true, the &amp;ldquo;after&amp;rdquo; region of scf.while is executed, with the remaining arguments forwarded to the entry block of the region.</description></item><item><title>'shape' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ShapeDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ShapeDialect/</guid><description>Description of operations &amp;amp; types within the Shape dialect as well as their usage.
Types and operations for shape dialect This dialect contains operations for shape inference.
Note: Unless explicitly stated, all functions that return a shape and take shapes as input, return the invalid shape if one of its operands is an invalid shape. This avoids flagging multiple errors for one verification failure. The dialect itself does not specify how errors should be combined (there are multiple different options, from always choosing first operand, concatting etc.</description></item><item><title>'sparse_tensor' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SparseTensorOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SparseTensorOps/</guid><description>The SparseTensor dialect supports all the attributes, types, operations, and passes that are required to make sparse tensor types first class citizens within the MLIR compiler infrastructure. The dialect forms a bridge between high-level operations on sparse tensors types and lower-level operations on the actual sparse storage schemes consisting of pointers, indices, and values. Lower-level support may consist of fully generated code or may be provided by means of a small sparse runtime support library.</description></item><item><title>'spv' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SPIR-V/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SPIR-V/</guid><description>This document describes the design of the SPIR-V dialect in MLIR. It lists various design choices we made for modeling different SPIR-V mechanisms, and their rationale.
This document also explains in a high-level manner how different components are organized and implemented in the code and gives steps to follow for extending them.
This document assumes familiarity with SPIR-V. SPIR-V is the Khronos Group’s binary intermediate language for representing graphics shaders and compute kernels.</description></item><item><title>'tensor' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/TensorOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/TensorOps/</guid><description>The tensor dialect is intended to hold core tensor creation and manipulation ops, which are not strongly associated with any particular other dialect or domain abstraction. The primary smoke test of this is ops that make sense for any tensor element type.
We leave it to other dialects to hold the vast swath of possible computations one might want to do on a tensor.
The tensor type is (for better or for worse) used to represent all kinds of things, and supports an open-ended set of element types.</description></item><item><title>'vector' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Vector/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Vector/</guid><description>Positioning in the Codegen Infrastructure Components of a Generic Retargetable Vector-Level Dialect Short Description of the Existing Infrastructure LLVM level Hardware Vector Ops Virtual Vector Ops Virtual Vector Rewrite Patterns Virtual Vector to Hardware Vector Lowering Rationale Hardware as vector Machines of Minimum Granularity Transformations Problems Avoided The Big Out-Of-Scope Piece: Automatic Vectorization Bikeshed Naming Discussion DeeperDive Alternatives For Lowering an n-D Vector Type to LLVM Constraints Inherited from LLVM (see LangRef) Nested Aggregate Flattened 1-D Vector Type Discussion Relationship to LLVM matrix type proposal.</description></item><item><title>'x86vector' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/X86Vector/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/X86Vector/</guid><description>Operation definition x86vector.avx.intr.dp.ps.256 (::mlir::x86vector::DotIntrOp) x86vector.avx.intr.dot (::mlir::x86vector::DotOp) x86vector.avx512.intr.mask.compress (::mlir::x86vector::MaskCompressIntrOp) x86vector.avx512.mask.compress (::mlir::x86vector::MaskCompressOp) x86vector.avx512.mask.rndscale (::mlir::x86vector::MaskRndScaleOp) x86vector.avx512.intr.mask.rndscale.pd.512 (::mlir::x86vector::MaskRndScalePDIntrOp) x86vector.avx512.intr.mask.rndscale.ps.512 (::mlir::x86vector::MaskRndScalePSIntrOp) x86vector.avx512.mask.scalef (::mlir::x86vector::MaskScaleFOp) x86vector.avx512.intr.mask.scalef.pd.512 (::mlir::x86vector::MaskScaleFPDIntrOp) x86vector.avx512.intr.mask.scalef.ps.512 (::mlir::x86vector::MaskScaleFPSIntrOp) x86vector.avx.intr.rsqrt.ps.256 (::mlir::x86vector::RsqrtIntrOp) x86vector.avx.rsqrt (::mlir::x86vector::RsqrtOp) x86vector.avx512.intr.vp2intersect.d.512 (::mlir::x86vector::Vp2IntersectDIntrOp) x86vector.avx512.vp2intersect (::mlir::x86vector::Vp2IntersectOp) x86vector.avx512.intr.vp2intersect.q.512 (::mlir::x86vector::Vp2IntersectQIntrOp) Operation definition x86vector.avx.intr.dp.ps.256 (::mlir::x86vector::DotIntrOp) Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Operands: Operand Description a vector of 32-bit float values of length 8 b vector of 32-bit float values of length 8 c 8-bit signless integer Results: Result Description res vector of 32-bit float values of length 8 x86vector.</description></item><item><title>Builtin Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Builtin/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Builtin/</guid><description>The builtin dialect contains a core set of Attributes, Operations, and Types that have wide applicability across a very large number of domains and abstractions. Many of the components of this dialect are also instrumental in the implementation of the core IR. As such, this dialect is implicitly loaded in every MLIRContext, and available directly to all users of MLIR.
Given the far-reaching nature of this dialect and the fact that MLIR is extensible by design, any potential additions are heavily scrutinized.</description></item><item><title>Tensor Operator Set Architecture (TOSA) Dialect</title><link>https://mlir.llvm.org/docs/Dialects/TOSA/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/TOSA/</guid><description>Rationale TOSA and Tensor Level Expressiveness Complete Minimal Numerical Precision TOSA Operator Rationale COND_IF and WHILE_LOOP Using TOSA In A Compiler Quantization Parameters in Ops vs Tensors Operation definitions tosa.abs (mlir::tosa::AbsOp) tosa.add (mlir::tosa::AddOp) tosa.apply_scale (mlir::tosa::ApplyScaleOp) tosa.argmax (mlir::tosa::ArgMaxOp) tosa.arithmetic_right_shift (mlir::tosa::ArithmeticRightShiftOp) tosa.avg_pool2d (mlir::tosa::AvgPool2dOp) tosa.bitwise_and (mlir::tosa::BitwiseAndOp) tosa.bitwise_not (mlir::tosa::BitwiseNotOp) tosa.bitwise_or (mlir::tosa::BitwiseOrOp) tosa.bitwise_xor (mlir::tosa::BitwiseXorOp) tosa.cast (mlir::tosa::CastOp) tosa.ceil (mlir::tosa::CeilOp) tosa.clamp (mlir::tosa::ClampOp) tosa.clz (mlir::tosa::ClzOp) tosa.concat (mlir::tosa::ConcatOp) tosa.</description></item><item><title>Transform Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Transform/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Transform/</guid><description>Disclaimer Overview Dialect Extension Mechanism Side Effects Intended Use and Integrations Effects on the Infrastructure Operation definition transform.pdl_match (::mlir::transform::PDLMatchOp) transform.sequence (::mlir::transform::SequenceOp) transform.with_pdl_patterns (::mlir::transform::WithPDLPatternsOp) transform.yield (::mlir::transform::YieldOp) TransformOpInterface (TransformOpInterface) Methods: Fine-grain transformation control dialect
Disclaimer ** Proceed with care: not ready for general use. **
This dialect is evolving rapidly and may change on a very short notice. To decrease the maintenance burden and churn, only a few in-tree use cases are currently supported in the main tree:</description></item></channel></rss>