<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'affine' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/Affine/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'affine' Dialect</h1><p>This dialect provides a powerful abstraction for affine operations and analyses.</p><p><nav id=TableOfContents><ul><li><a href=#polyhedral-structures>Polyhedral Structures</a><ul><li><a href=#dimensions-and-symbols>Dimensions and Symbols</a></li><li><a href=#restrictions-on-dimensions-and-symbols>Restrictions on Dimensions and Symbols</a></li><li><a href=#affine-expressions>Affine Expressions</a></li><li><a href=#affine-maps>Affine Maps</a></li><li><a href=#semi-affine-maps>Semi-affine maps</a></li><li><a href=#integer-sets>Integer Sets</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#affineapply-mliraffineapplyop><code>affine.apply</code> (mlir::AffineApplyOp)</a></li><li><a href=#affinefor-mliraffineforop><code>affine.for</code> (mlir::AffineForOp)</a></li><li><a href=#affineif-mliraffineifop><code>affine.if</code> (mlir::AffineIfOp)</a></li><li><a href=#affineload-mliraffineloadop><code>affine.load</code> (mlir::AffineLoadOp)</a></li><li><a href=#affinemax-mliraffinemaxop><code>affine.max</code> (mlir::AffineMaxOp)</a></li><li><a href=#affinemin-mliraffineminop><code>affine.min</code> (mlir::AffineMinOp)</a></li><li><a href=#affineparallel-mliraffineparallelop><code>affine.parallel</code> (mlir::AffineParallelOp)</a></li><li><a href=#affineprefetch-mliraffineprefetchop><code>affine.prefetch</code> (mlir::AffinePrefetchOp)</a></li><li><a href=#affinestore-mliraffinestoreop><code>affine.store</code> (mlir::AffineStoreOp)</a></li><li><a href=#affinevector_load-mliraffinevectorloadop><code>affine.vector_load</code> (mlir::AffineVectorLoadOp)</a></li><li><a href=#affinevector_store-mliraffinevectorstoreop><code>affine.vector_store</code> (mlir::AffineVectorStoreOp)</a></li><li><a href=#affineyield-mliraffineyieldop><code>affine.yield</code> (mlir::AffineYieldOp)</a></li><li><a href=#affinestore-operation>&lsquo;affine.store&rsquo; operation</a></li><li><a href=#affinedma_start-operation>&lsquo;affine.dma_start&rsquo; operation</a></li><li><a href=#affinedma_wait-operation>&lsquo;affine.dma_wait&rsquo; operation</a></li></ul></li></ul></nav><h2 id=polyhedral-structures>Polyhedral Structures&nbsp;<a class=headline-hash href=#polyhedral-structures>¶</a></h2><p>MLIR uses techniques from polyhedral compilation to make dependence analysis and
loop transformations efficient and reliable. This section introduces some of the
core concepts that are used throughout the document.</p><h3 id=dimensions-and-symbols>Dimensions and Symbols&nbsp;<a class=headline-hash href=#dimensions-and-symbols>¶</a></h3><p>Dimensions and symbols are the two kinds of identifiers that can appear in the
polyhedral structures, and are always of
<a href=/docs/Dialects/Builtin/#indextype><code>index</code></a> type.
Dimensions are declared in parentheses and symbols are declared in square
brackets.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A 2d to 3d affine mapping.
</span><span class=c>// d0/d1 are dimensions, s0 is a symbol
</span><span class=c></span><span class=nv>#affine_map2to3</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1 <span class=err>+</span> s0<span class=p>,</span> d1 <span class=err>-</span> s0<span class=p>)&gt;</span>
</code></pre></div><p>Dimensional identifiers correspond to the dimensions of the underlying structure
being represented (a map, set, or more concretely a loop nest or a tensor); for
example, a three-dimensional loop nest has three dimensional identifiers. Symbol
identifiers represent an unknown quantity that can be treated as constant for a
region of interest.</p><p>Dimensions and symbols are bound to SSA values by various operations in MLIR and
use the same parenthesized vs square bracket list to distinguish the two.</p><p>Syntax:</p><pre><code>// Uses of SSA values that are passed to dimensional identifiers.
dim-use-list ::= `(` ssa-use-list? `)`

// Uses of SSA values that are used to bind symbols.
symbol-use-list ::= `[` ssa-use-list? `]`

// Most things that bind SSA values bind dimensions and symbols.
dim-and-symbol-use-list ::= dim-use-list symbol-use-list?
</code></pre><p>SSA values bound to dimensions and symbols must always have &lsquo;index&rsquo; type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#affine_map2to3</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1 <span class=err>+</span> s0<span class=p>,</span> d1 <span class=err>-</span> s0<span class=p>)&gt;</span>
<span class=c>// Binds %N to the s0 symbol in affine_map2to3.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()[</span><span class=nv>%N</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40x50x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#affine_map2to3</span><span class=p>&gt;</span>
</code></pre></div><h3 id=restrictions-on-dimensions-and-symbols>Restrictions on Dimensions and Symbols&nbsp;<a class=headline-hash href=#restrictions-on-dimensions-and-symbols>¶</a></h3><p>The affine dialect imposes certain restrictions on dimension and symbolic
identifiers to enable powerful analysis and transformation. An SSA value&rsquo;s use
can be bound to a symbolic identifier if that SSA value is either 1. a region
argument for an op with trait <code>AffineScope</code> (eg. <code>FuncOp</code>), 2. a value defined
at the top level of an <code>AffineScope</code> op (i.e., immediately enclosed by the
latter), 3. a value that dominates the <code>AffineScope</code> op enclosing the value&rsquo;s
use, 4. the result of a
constant operation, 5. the result of an
<a href=#affineapply-affineapplyop><code>affine.apply</code> operation</a> that recursively takes as
arguments any valid symbolic identifiers, or 6. the result of a
<a href=/docs/Dialects/MemRef/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> on either a memref that
is an argument to a <code>AffineScope</code> op or a memref where the corresponding
dimension is either static or a dynamic one in turn bound to a valid symbol.
<em>Note:</em> if the use of an SSA value is not contained in any op with the
<code>AffineScope</code> trait, only the rules 4-6 can be applied.</p><p>Note that as a result of rule (3) above, symbol validity is sensitive to the
location of the SSA use. Dimensions may be bound not only to anything that a
symbol is bound to, but also to induction variables of enclosing
<a href=#affinefor-affineforop><code>affine.for</code></a> and
<a href=#affineparallel-affineparallelop><code>affine.parallel</code></a> operations, and the result
of an
<a href=#affineapply-affineapplyop><code>affine.apply</code> operation</a> (which recursively
may use other dimensions and symbols).</p><h3 id=affine-expressions>Affine Expressions&nbsp;<a class=headline-hash href=#affine-expressions>¶</a></h3><p>Syntax:</p><pre><code>affine-expr ::= `(` affine-expr `)`
              | affine-expr `+` affine-expr
              | affine-expr `-` affine-expr
              | `-`? integer-literal `*` affine-expr
              | affine-expr `ceildiv` integer-literal
              | affine-expr `floordiv` integer-literal
              | affine-expr `mod` integer-literal
              | `-`affine-expr
              | bare-id
              | `-`? integer-literal

multi-dim-affine-expr ::= `(` `)`
                        | `(` affine-expr (`,` affine-expr)* `)`
</code></pre><p><code>ceildiv</code> is the ceiling function which maps the result of the division of its
first argument by its second argument to the smallest integer greater than or
equal to that result. <code>floordiv</code> is a function which maps the result of the
division of its first argument by its second argument to the largest integer
less than or equal to that result. <code>mod</code> is the modulo operation: since its
second argument is always positive, its results are always positive in our
usage. The <code>integer-literal</code> operand for ceildiv, floordiv, and mod is always
expected to be positive. <code>bare-id</code> is an identifier which must have type
<a href=/docs/Dialects/Builtin/#indextype>index</a>. The precedence of operations in an affine
expression are ordered from highest to lowest in the order: (1)
parenthesization, (2) negation, (3) modulo, multiplication, floordiv, and
ceildiv, and (4) addition and subtraction. All of these operators associate from
left to right.</p><p>A <em>multidimensional affine expression</em> is a comma separated list of
one-dimensional affine expressions, with the entire list enclosed in
parentheses.</p><p><strong>Context:</strong> An affine function, informally, is a linear function plus a
constant. More formally, a function f defined on a vector $\vec{v} \in
\mathbb{Z}^n$ is a multidimensional affine function of $\vec{v}$ if $f(\vec{v})$
can be expressed in the form $M \vec{v} + \vec{c}$ where $M$ is a constant
matrix from $\mathbb{Z}^{m \times n}$ and $\vec{c}$ is a constant vector from
$\mathbb{Z}$. $m$ is the dimensionality of such an affine function. MLIR further
extends the definition of an affine function to allow &lsquo;floordiv&rsquo;, &lsquo;ceildiv&rsquo;, and
&lsquo;mod&rsquo; with respect to positive integer constants. Such extensions to affine
functions have often been referred to as quasi-affine functions by the
polyhedral compiler community. MLIR uses the term &lsquo;affine map&rsquo; to refer to these
multidimensional quasi-affine functions. As examples, $(i+j+1, j)$, $(i \mod 2,
j+i)$, $(j, i/4, i \mod 4)$, $(2i+1, j)$ are two-dimensional affine functions of
$(i, j)$, but $(i \cdot j, i^2)$, $(i \mod j, i/j)$ are not affine functions of
$(i, j)$.</p><h3 id=affine-maps>Affine Maps&nbsp;<a class=headline-hash href=#affine-maps>¶</a></h3><p>Syntax:</p><pre><code>affine-map-inline
   ::= dim-and-symbol-id-lists `-&gt;` multi-dim-affine-expr
</code></pre><p>The identifiers in the dimensions and symbols lists must be unique. These are
the only identifiers that may appear in &lsquo;multi-dim-affine-expr&rsquo;. Affine maps
with one or more symbols in its specification are known as &ldquo;symbolic affine
maps&rdquo;, and those with no symbols as &ldquo;non-symbolic affine maps&rdquo;.</p><p><strong>Context:</strong> Affine maps are mathematical functions that transform a list of
dimension indices and symbols into a list of results, with affine expressions
combining the indices and symbols. Affine maps distinguish between
<a href=#dimensions-and-symbols>indices and symbols</a> because indices are inputs to the
affine map when the map is called (through an operation such as
<a href=#affineapply-affineapplyop>affine.apply</a>), whereas symbols are bound when the
map is established (e.g. when a memref is formed, establishing a memory
<a href=/docs/Dialects/Builtin/#layout-map>layout map</a>).</p><p>Affine maps are used for various core structures in MLIR. The restrictions we
impose on their form allows powerful analysis and transformation, while keeping
the representation closed with respect to several operations of interest.</p><h4 id=named-affine-mappings>Named affine mappings&nbsp;<a class=headline-hash href=#named-affine-mappings>¶</a></h4><p>Syntax:</p><pre><code>affine-map-id ::= `#` suffix-id

// Definitions of affine maps are at the top of the file.
affine-map-def    ::= affine-map-id `=` affine-map-inline
module-header-def ::= affine-map-def

// Uses of affine maps may use the inline form or the named form.
affine-map ::= affine-map-id | affine-map-inline
</code></pre><p>Affine mappings may be defined inline at the point of use, or may be hoisted to
the top of the file and given a name with an affine map definition, and used by
name.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Affine map out-of-line definition and usage example.
</span><span class=c></span><span class=nv>#affine_map42</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d0 <span class=err>+</span> d1 <span class=err>+</span> s0 floordiv <span class=m>2</span><span class=p>)&gt;</span>

<span class=c>// Use an affine mapping definition in an alloc operation, binding the
</span><span class=c>// SSA value %N to the symbol s0.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()[</span><span class=nv>%N</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#affine_map42</span><span class=p>&gt;</span>

<span class=c>// Same thing with an inline affine mapping definition.
</span><span class=c></span><span class=nv>%b</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()[</span><span class=nv>%N</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>,</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d0 <span class=err>+</span> d1 <span class=err>+</span> s0 floordiv <span class=m>2</span><span class=p>)&gt;&gt;</span>
</code></pre></div><h3 id=semi-affine-maps>Semi-affine maps&nbsp;<a class=headline-hash href=#semi-affine-maps>¶</a></h3><p>Semi-affine maps are extensions of affine maps to allow multiplication,
<code>floordiv</code>, <code>ceildiv</code>, and <code>mod</code> with respect to symbolic identifiers.
Semi-affine maps are thus a strict superset of affine maps.</p><p>Syntax of semi-affine expressions:</p><pre><code>semi-affine-expr ::= `(` semi-affine-expr `)`
                   | semi-affine-expr `+` semi-affine-expr
                   | semi-affine-expr `-` semi-affine-expr
                   | symbol-or-const `*` semi-affine-expr
                   | semi-affine-expr `ceildiv` symbol-or-const
                   | semi-affine-expr `floordiv` symbol-or-const
                   | semi-affine-expr `mod` symbol-or-const
                   | bare-id
                   | `-`? integer-literal

symbol-or-const ::= `-`? integer-literal | symbol-id

multi-dim-semi-affine-expr ::= `(` semi-affine-expr (`,` semi-affine-expr)* `)`
</code></pre><p>The precedence and associativity of operations in the syntax above is the same
as that for
<a href=#affine-expressions>affine expressions</a>.</p><p>Syntax of semi-affine maps:</p><pre><code>semi-affine-map-inline
   ::= dim-and-symbol-id-lists `-&gt;` multi-dim-semi-affine-expr
</code></pre><p>Semi-affine maps may be defined inline at the point of use, or may be hoisted to
the top of the file and given a name with a semi-affine map definition, and used
by name.</p><pre><code>semi-affine-map-id ::= `#` suffix-id

// Definitions of semi-affine maps are at the top of file.
semi-affine-map-def ::= semi-affine-map-id `=` semi-affine-map-inline
module-header-def ::= semi-affine-map-def

// Uses of semi-affine maps may use the inline form or the named form.
semi-affine-map ::= semi-affine-map-id | semi-affine-map-inline
</code></pre><h3 id=integer-sets>Integer Sets&nbsp;<a class=headline-hash href=#integer-sets>¶</a></h3><p>An integer set is a conjunction of affine constraints on a list of identifiers.
The identifiers associated with the integer set are separated out into two
classes: the set&rsquo;s dimension identifiers, and the set&rsquo;s symbolic identifiers.
The set is viewed as being parametric on its symbolic identifiers. In the
syntax, the list of set&rsquo;s dimension identifiers are enclosed in parentheses
while its symbols are enclosed in square brackets.</p><p>Syntax of affine constraints:</p><pre><code>affine-constraint ::= affine-expr `&gt;=` `0`
                    | affine-expr `==` `0`
affine-constraint-conjunction ::= affine-constraint (`,` affine-constraint)*
</code></pre><p>Integer sets may be defined inline at the point of use, or may be hoisted to the
top of the file and given a name with an integer set definition, and used by
name.</p><pre><code>integer-set-id ::= `#` suffix-id

integer-set-inline
   ::= dim-and-symbol-id-lists `:` '(' affine-constraint-conjunction? ')'

// Declarations of integer sets are at the top of the file.
integer-set-decl ::= integer-set-id `=` integer-set-inline

// Uses of integer sets may use the inline form or the named form.
integer-set ::= integer-set-id | integer-set-inline
</code></pre><p>The dimensionality of an integer set is the number of identifiers appearing in
dimension list of the set. The affine-constraint non-terminals appearing in the
syntax above are only allowed to contain identifiers from dims and symbols. A
set with no constraints is a set that is unbounded along all of the set&rsquo;s
dimensions.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A example two-dimensional integer set with two symbols.
</span><span class=c></span><span class=nv>#set42</span> <span class=p>=</span> affine_set<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>,</span> s1<span class=p>]</span>
   <span class=p>:</span> <span class=p>(</span>d0 <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> <span class=err>-</span>d0 <span class=err>+</span> s0 <span class=err>-</span> <span class=m>1</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> d1 <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> <span class=err>-</span>d1 <span class=err>+</span> s1 <span class=err>-</span> <span class=m>1</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)&gt;</span>

<span class=c>// Inside a Region
</span><span class=c></span>affine<span class=p>.</span>if <span class=nv>#set42</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)[</span><span class=nv>%M</span><span class=p>,</span> <span class=nv>%N</span><span class=p>]</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><p><code>d0</code> and <code>d1</code> correspond to dimensional identifiers of the set, while <code>s0</code> and
<code>s1</code> are symbol identifiers.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=affineapply-mliraffineapplyop><code>affine.apply</code> (mlir::AffineApplyOp)&nbsp;<a class=headline-hash href=#affineapply-mliraffineapplyop>¶</a></h3><p>affine apply operation</p><p>The affine.apply operation applies an
<a href=#affine-expressions>affine mapping</a>
to a list of SSA values, yielding a single SSA value. The number of
dimension and symbol arguments to <code>affine.apply</code> must be equal to the
respective number of dimensional and symbolic inputs to the affine mapping;
the affine mapping has to be one-dimensional, and so the <code>affine.apply</code>
operation always returns one value. The input operands and result must all
have ‘index’ type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#map10</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 floordiv <span class=m>8</span> <span class=err>+</span> d1 floordiv <span class=m>128</span><span class=p>)&gt;</span>
<span class=p>...</span>
<span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map10</span> <span class=p>(</span><span class=nv>%s</span><span class=p>,</span> <span class=nv>%t</span><span class=p>)</span>

<span class=c>// Inline example.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;(</span>i<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>i<span class=err>+</span>s0<span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%42</span><span class=p>)[</span><span class=nv>%n</span><span class=p>]</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>map</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mapOperands</code></td><td>index</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affinefor-mliraffineforop><code>affine.for</code> (mlir::AffineForOp)&nbsp;<a class=headline-hash href=#affinefor-mliraffineforop>¶</a></h3><p>for operation</p><p>Syntax:</p><pre><code>operation   ::= `affine.for` ssa-id `=` lower-bound `to` upper-bound
                (`step` integer-literal)? `{` op* `}`

lower-bound ::= `max`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
upper-bound ::= `min`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
shorthand-bound ::= ssa-id | `-`? integer-literal
</code></pre><p>The <code>affine.for</code> operation represents an affine loop nest. It has one region
containing its body. This region must contain one block that terminates with
<a href=#affineyield-affineyieldop><code>affine.yield</code></a>. <em>Note:</em> when
<code>affine.for</code> is printed in custom format, the terminator is omitted. The
block has one argument of
<a href=/docs/Dialects/Builtin/#indextype><code>index</code></a> type that
represents the induction variable of the loop.</p><p>The <code>affine.for</code> operation executes its body a number of times iterating
from a lower bound to an upper bound by a stride. The stride, represented by
<code>step</code>, is a positive constant integer which defaults to &ldquo;1&rdquo; if not present.
The lower and upper bounds specify a half-open range: the range includes the
lower bound but does not include the upper bound.</p><p>The lower and upper bounds of a <code>affine.for</code> operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The
<a href=#restrictions-on-dimensions-and-symbols>same restrictions</a> hold for
these SSA values as for all bindings of SSA values to dimensions and
symbols.</p><p>The affine mappings for the bounds may return multiple results, in which
case the <code>max</code>/<code>min</code> keywords are required (for the lower/upper bound
respectively), and the bound is the maximum/minimum of the returned values.
There is no semantic ambiguity, but MLIR syntax requires the use of these
keywords to make things more obvious to human readers.</p><p>Many upper and lower bounds are simple, so MLIR accepts two custom form
syntaxes: the form that accepts a single &lsquo;ssa-id&rsquo; (e.g. <code>%N</code>) is shorthand
for applying that SSA value to a function that maps a single symbol to
itself, e.g., <code>()[s]->(s)()[%N]</code>. The integer literal form (e.g. <code>-42</code>) is
shorthand for a nullary mapping function that returns the constant value
(e.g. <code>()->(-42)()</code>).</p><p>Example showing reverse iteration of the inner loop:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#map57</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>s0 <span class=err>-</span> d0 <span class=err>-</span> <span class=m>1</span><span class=p>)&gt;</span>

<span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@simple_example</span><span class=p>(</span><span class=nv>%A</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%B</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=nv>%N</span> <span class=p>=</span> dim <span class=nv>%A</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  affine<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%N</span> step <span class=m>1</span> <span class=p>{</span>
    affine<span class=p>.</span>for <span class=nv>%j</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%N</span> <span class=p>{</span>   <span class=c>// implicitly steps by 1
</span><span class=c></span>      <span class=nv>%0</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map57</span><span class=p>(</span><span class=nv>%j</span><span class=p>)[</span><span class=nv>%N</span><span class=p>]</span>
      <span class=nv>%tmp</span> <span class=p>=</span> call <span class=nf>@F1</span><span class=p>(</span><span class=nv>%A</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)-&gt;(</span><span class=k>f32</span><span class=p>)</span>
      call <span class=nf>@F2</span><span class=p>(</span><span class=nv>%tmp</span><span class=p>,</span> <span class=nv>%B</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)-&gt;()</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p><code>affine.for</code> can also operate on loop-carried variables (<code>iter_args</code>) and
return the final values after loop termination. The initial values of the
variables are passed as additional SSA operands to the <code>affine.for</code>
following the operands for the loop&rsquo;s lower and upper bounds. The
operation&rsquo;s region has equivalent arguments for each variable representing
the value of the variable at the current iteration.</p><p>The region must terminate with an <code>affine.yield</code> that passes all the current
iteration variables to the next iteration, or to the <code>affine.for</code>&rsquo;s results
if at the last iteration. For <code>affine.for</code>&rsquo;s that execute zero iterations, the
initial values of the loop-carried variables (corresponding to the SSA
operands) will be the op&rsquo;s results.</p><p>For example, to sum-reduce a memref:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@reduce</span><span class=p>(</span><span class=nv>%buffer</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
 <span class=c>// Initial sum set to 0.
</span><span class=c></span> <span class=nv>%sum_0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
 <span class=c>// iter_args binds initial values to the loop&#39;s region arguments.
</span><span class=c></span> <span class=nv>%sum</span> <span class=p>=</span> affine<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>10</span> step <span class=m>2</span>
     iter_args<span class=p>(</span><span class=nv>%sum_iter</span> <span class=p>=</span> <span class=nv>%sum_0</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
   <span class=nv>%t</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%buffer</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1024x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=nv>%sum_next</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%sum_iter</span><span class=p>,</span> <span class=nv>%t</span> <span class=p>:</span> <span class=k>f32</span>
   <span class=c>// Yield current iteration sum to next iteration %sum_iter or to %sum
</span><span class=c></span>   <span class=c>// if final iteration.
</span><span class=c></span>   affine<span class=p>.</span>yield <span class=nv>%sum_next</span> <span class=p>:</span> <span class=k>f32</span>
 <span class=p>}</span>
 <span class=kt>return</span> <span class=nv>%sum</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%res</span><span class=p>:</span><span class=nl>2 =</span> affine<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>128</span> iter_args<span class=p>(</span><span class=nv>%arg0</span> <span class=p>=</span> <span class=nv>%init0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>=</span> <span class=nv>%init1</span><span class=p>)</span>
           <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%y0</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%y1</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%c2</span> <span class=p>:</span> <span class=k>index</span>
  affine<span class=p>.</span>yield <span class=nv>%y0</span><span class=p>,</span> <span class=nv>%y1</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span>
<span class=p>}</span>
</code></pre></div><p>If the <code>affine.for</code> defines any values, a yield terminator must be
explicitly present. The number and types of the &ldquo;affine.for&rdquo; results must
match the initial values in the <code>iter_args</code> binding and the yield operands.</p><p>Traits: AutomaticAllocationScope, ImplicitAffineTerminator, RecursiveSideEffects</p><p>Interfaces: LoopLikeOpInterface, RegionBranchOpInterface</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=affineif-mliraffineifop><code>affine.if</code> (mlir::AffineIfOp)&nbsp;<a class=headline-hash href=#affineif-mliraffineifop>¶</a></h3><p>if-then-else operation</p><p>Syntax:</p><pre><code>operation  ::= `affine.if` if-op-cond `{` op* `}` (`else` `{` op* `}`)?
if-op-cond ::= integer-set-attr dim-and-symbol-use-list
</code></pre><p>The <code>affine.if</code> operation restricts execution to a subset of the loop
iteration space defined by an integer set (a conjunction of affine
constraints). A single <code>affine.if</code> may end with an optional <code>else</code> clause.</p><p>The condition of the <code>affine.if</code> is represented by an
<a href=#integer-sets>integer set</a> (a conjunction of affine constraints),
and the SSA values bound to the dimensions and symbols in the integer set.
The
<a href=#restrictions-on-dimensions-and-symbols>same restrictions</a> hold for
these SSA values as for all bindings of SSA values to dimensions and
symbols.</p><p>The <code>affine.if</code> operation contains two regions for the &ldquo;then&rdquo; and &ldquo;else&rdquo;
clauses. <code>affine.if</code> may return results that are defined in its regions.
The values defined are determined by which execution path is taken. Each
region of the <code>affine.if</code> must contain a single block with no arguments,
and be terminated by <code>affine.yield</code>. If <code>affine.if</code> defines no values,
the <code>affine.yield</code> can be left out, and will be inserted implicitly.
Otherwise, it must be explicit. If no values are defined, the else block
may be empty (i.e. contain no blocks).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#set</span> <span class=p>=</span> affine_set<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>]:</span> <span class=p>(</span>d0 <span class=err>-</span> <span class=m>10</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> s0 <span class=err>-</span> d0 <span class=err>-</span> <span class=m>9</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span>
                                 d1 <span class=err>-</span> <span class=m>10</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> s0 <span class=err>-</span> d1 <span class=err>-</span> <span class=m>9</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)&gt;</span>
<span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@reduced_domain_example</span><span class=p>(</span><span class=nv>%A</span><span class=p>,</span> <span class=nv>%X</span><span class=p>,</span> <span class=nv>%N</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%N</span> <span class=p>{</span>
     affine<span class=p>.</span>for <span class=nv>%j</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%N</span> <span class=p>{</span>
       <span class=nv>%0</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map42</span><span class=p>(</span><span class=nv>%j</span><span class=p>)</span>
       <span class=nv>%tmp</span> <span class=p>=</span> call <span class=nf>@S1</span><span class=p>(</span><span class=nv>%X</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span>
       affine<span class=p>.</span>if <span class=nv>#set</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)[</span><span class=nv>%N</span><span class=p>]</span> <span class=p>{</span>
          <span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map43</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
          call <span class=nf>@S2</span><span class=p>(</span><span class=nv>%tmp</span><span class=p>,</span> <span class=nv>%A</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
       <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Example with an explicit yield (initialization with edge padding):</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#interior</span> <span class=p>=</span> affine_set<span class=p>&lt;(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>:</span> <span class=p>(</span>i <span class=err>-</span> <span class=m>1</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> j <span class=err>-</span> <span class=m>1</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span>  <span class=m>10</span> <span class=err>-</span> i <span class=p>&gt;=</span> <span class=m>0</span><span class=p>,</span> <span class=m>10</span> <span class=err>-</span> j <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span>
<span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@pad_edges</span><span class=p>(</span><span class=nv>%I</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x12x</span><span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%O</span> <span class=p>=</span> alloc <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x12x</span><span class=k>f32</span><span class=p>&gt;</span>
  affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> to <span class=p>(</span><span class=m>12</span><span class=p>,</span> <span class=m>12</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>if <span class=nv>#interior</span> <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%2</span> <span class=p>=</span> load <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span> <span class=err>-</span> <span class=m>1</span><span class=p>,</span> <span class=nv>%j</span> <span class=err>-</span> <span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;</span>
      affine<span class=p>.</span>yield <span class=nv>%2</span>
    <span class=p>}</span> else <span class=p>{</span>
      <span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
      affine<span class=p>.</span>yield <span class=nv>%2</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=p>}</span>
    affine<span class=p>.</span>store <span class=nv>%1</span><span class=p>,</span> <span class=nv>%O</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>12x12x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%O</span>
<span class=p>}</span>
</code></pre></div><p>Traits: ImplicitAffineTerminator, NoRegionArguments, RecursiveSideEffects</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=affineload-mliraffineloadop><code>affine.load</code> (mlir::AffineLoadOp)&nbsp;<a class=headline-hash href=#affineload-mliraffineloadop>¶</a></h3><p>affine load operation</p><p>The &ldquo;affine.load&rdquo; op reads an element from a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The output of &lsquo;affine.load&rsquo; is a new value with the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
&lsquo;symbol&rsquo; can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%i1</span> <span class=err>+</span> <span class=m>7</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 2: Uses &lsquo;symbol&rsquo; keyword for symbols &lsquo;%n&rsquo; and &lsquo;%m&rsquo;.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%n</span><span class=p>),</span> <span class=nv>%i1</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%m</span><span class=p>)]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: MemRefsNormalizable</p><p>Interfaces: AffineMapAccessInterface, AffineReadOpInterface</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=affinemax-mliraffinemaxop><code>affine.max</code> (mlir::AffineMaxOp)&nbsp;<a class=headline-hash href=#affinemax-mliraffinemaxop>¶</a></h3><p>max operation</p><p>The &ldquo;max&rdquo; operation computes the maximum value result from a multi-result
affine map.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> affine<span class=p>.</span>max <span class=p>(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>1000</span><span class=p>,</span> d0 <span class=err>+</span> <span class=m>512</span><span class=p>)</span> <span class=p>(</span><span class=nv>%i0</span><span class=p>)</span> <span class=p>:</span> <span class=k>index</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>map</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affinemin-mliraffineminop><code>affine.min</code> (mlir::AffineMinOp)&nbsp;<a class=headline-hash href=#affinemin-mliraffineminop>¶</a></h3><p>min operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list
</code></pre><p>The <code>affine.min</code> operation applies an
<a href=#affine-expressions>affine mapping</a>
to a list of SSA values, and returns the minimum value of all result
expressions. The number of dimension and symbol arguments to <code>affine.min</code>
must be equal to the respective number of dimensional and symbolic inputs to
the affine mapping; the <code>affine.min</code> operation always returns one value. The
input operands and result must all have &lsquo;index&rsquo; type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> affine<span class=p>.</span>min affine_map<span class=p>&lt;(</span>d0<span class=p>)[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=m>1000</span><span class=p>,</span> d0 <span class=err>+</span> <span class=m>512</span><span class=p>,</span> s0<span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>)[</span><span class=nv>%arg1</span><span class=p>]</span>
</code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>map</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=affineparallel-mliraffineparallelop><code>affine.parallel</code> (mlir::AffineParallelOp)&nbsp;<a class=headline-hash href=#affineparallel-mliraffineparallelop>¶</a></h3><p>multi-index parallel band operation</p><p>The &ldquo;affine.parallel&rdquo; operation represents a hyper-rectangular affine
parallel band, defining zero or more SSA values for its induction variables.
It has one region capturing the parallel band body. The induction variables
are represented as arguments of this region. These SSA values always have
type index, which is the size of the machine word. The strides, represented
by steps, are positive constant integers which defaults to &ldquo;1&rdquo; if not
present. The lower and upper bounds specify a half-open range: the range
includes the lower bound but does not include the upper bound. The body
region must contain exactly one block that terminates with &ldquo;affine.yield&rdquo;.</p><p>The lower and upper bounds of a parallel operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The same restrictions hold for these SSA values as for all bindings of SSA
values to dimensions and symbols. The list of expressions in each map is
interpreted according to the respective bounds group attribute. If a single
expression belongs to the group, then the result of this expression is taken
as a lower(upper) bound of the corresponding loop induction variable. If
multiple expressions belong to the group, then the lower(upper) bound is the
max(min) of these values obtained from these expressions. The loop band has
as many loops as elements in the group bounds attributes.</p><p>Each value yielded by affine.yield will be accumulated/reduced via one of
the reduction methods defined in the AtomicRMWKind enum. The order of
reduction is unspecified, and lowering may produce any valid ordering.
Loops with a 0 trip count will produce as a result the identity value
associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf). Assign
reductions for loops with a trip count != 1 produces undefined results.</p><p>Note: Calling AffineParallelOp::build will create the required region and
block, and insert the required terminator if it is trivial (i.e. no values
are yielded). Parsing will also create the required region, block, and
terminator, even when they are missing from the textual representation.</p><p>Example (3x3 valid convolution):</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@conv_2d</span><span class=p>(</span><span class=nv>%D</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%K</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x3x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>98x98x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
  <span class=nv>%O</span> <span class=p>=</span> alloc <span class=kt>memref</span><span class=p>&lt;</span><span class=m>98x98x</span><span class=k>f32</span><span class=p>&gt;</span>
  affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> to <span class=p>(</span><span class=m>98</span><span class=p>,</span> <span class=m>98</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%0</span> <span class=p>=</span> affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%kx</span><span class=p>,</span> <span class=nv>%ky</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> to <span class=p>(</span><span class=m>2</span><span class=p>,</span> <span class=m>2</span><span class=p>)</span> reduce <span class=p>(</span><span class=s>&#34;addf&#34;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%D</span><span class=p>[</span><span class=nv>%x</span> <span class=err>+</span> <span class=nv>%kx</span><span class=p>,</span> <span class=nv>%y</span> <span class=err>+</span> <span class=nv>%ky</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>
      <span class=nv>%2</span> <span class=p>=</span> affine<span class=p>.</span>load <span class=nv>%K</span><span class=p>[</span><span class=nv>%kx</span><span class=p>,</span> <span class=nv>%ky</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>3x3x</span><span class=k>f32</span><span class=p>&gt;</span>
      <span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>f32</span>
      affine<span class=p>.</span>yield <span class=nv>%3</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=p>}</span>
    affine<span class=p>.</span>store <span class=nv>%0</span><span class=p>,</span> O<span class=p>[</span><span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>98x98x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%O</span>
<span class=p>}</span>
</code></pre></div><p>Example (tiling by potentially imperfectly dividing sizes):</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%ii</span><span class=p>,</span> <span class=nv>%jj</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> to <span class=p>(</span><span class=nv>%N</span><span class=p>,</span> <span class=nv>%M</span><span class=p>)</span> step <span class=p>(</span><span class=m>32</span><span class=p>,</span> <span class=m>32</span><span class=p>)</span> <span class=p>{</span>
  affine<span class=p>.</span>parallel <span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span> <span class=p>=</span> <span class=p>(</span><span class=nv>%ii</span><span class=p>,</span> <span class=nv>%jj</span><span class=p>)</span>
                          to <span class=p>(</span>min<span class=p>(</span><span class=nv>%ii</span> <span class=err>+</span> <span class=m>32</span><span class=p>,</span> <span class=nv>%N</span><span class=p>),</span> min<span class=p>(</span><span class=nv>%jj</span> <span class=err>+</span> <span class=m>32</span><span class=p>,</span> <span class=nv>%M</span><span class=p>))</span> <span class=p>{</span>
    call <span class=nf>@f</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Traits: AutomaticAllocationScope, ImplicitAffineTerminator, MemRefsNormalizable, RecursiveSideEffects</p><p>Interfaces: LoopLikeOpInterface</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reductions</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Reduction ops</td></tr><tr><td style=text-align:center><code>lowerBoundsMap</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr><tr><td style=text-align:center><code>lowerBoundsGroups</code></td><td style=text-align:center>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr><tr><td style=text-align:center><code>upperBoundsMap</code></td><td style=text-align:center>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr><tr><td style=text-align:center><code>upperBoundsGroups</code></td><td style=text-align:center>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr><tr><td style=text-align:center><code>steps</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mapOperands</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=affineprefetch-mliraffineprefetchop><code>affine.prefetch</code> (mlir::AffinePrefetchOp)&nbsp;<a class=headline-hash href=#affineprefetch-mliraffineprefetchop>¶</a></h3><p>affine prefetch operation</p><p>The &ldquo;affine.prefetch&rdquo; op prefetches data from a memref location described
with an affine subscript similar to affine.load, and has three attributes:
a read/write specifier, a locality hint, and a cache type specifier as shown
below:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span>prefetch <span class=nv>%0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span> <span class=err>+</span> <span class=m>5</span><span class=p>],</span> read<span class=p>,</span> <span class=kt>loc</span>ality<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;,</span> data <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>400x400x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>The read/write specifier is either &lsquo;read&rsquo; or &lsquo;write&rsquo;, the locality hint
specifier ranges from locality&lt;0> (no locality) to locality&lt;3> (extremely
local keep in cache). The cache type specifier is either &lsquo;data&rsquo; or &lsquo;instr&rsquo;
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p><p>Interfaces: AffineMapAccessInterface</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>isWrite</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>localityHint</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 3</td></tr><tr><td style=text-align:center><code>isDataCache</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=affinestore-mliraffinestoreop><code>affine.store</code> (mlir::AffineStoreOp)&nbsp;<a class=headline-hash href=#affinestore-mliraffinestoreop>¶</a></h3><p>affine store operation</p><p>The &ldquo;affine.store&rdquo; op writes an element to a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The &lsquo;affine.store&rsquo; op stores a new value which is the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
&lsquo;symbol&rsquo; can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span>store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%i1</span> <span class=err>+</span> <span class=m>7</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 2: Uses &lsquo;symbol&rsquo; keyword for symbols &lsquo;%n&rsquo; and &lsquo;%m&rsquo;.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span>store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%n</span><span class=p>),</span> <span class=nv>%i1</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%m</span><span class=p>)]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: MemRefsNormalizable</p><p>Interfaces: AffineMapAccessInterface, AffineWriteOpInterface</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=affinevector_load-mliraffinevectorloadop><code>affine.vector_load</code> (mlir::AffineVectorLoadOp)&nbsp;<a class=headline-hash href=#affinevector_load-mliraffinevectorloadop>¶</a></h3><p>affine vector load operation</p><p>The &ldquo;affine.vector_load&rdquo; is the vector counterpart of
<a href=#affineload-affineloadop>affine.load</a>. It reads a slice from a
<a href=/docs/Dialects/Builtin/#memreftype>MemRef</a>, supplied as its first operand,
into a
<a href=/docs/Dialects/Builtin/#vectortype>vector</a> of the same base elemental type.
The index for each memref dimension is an affine expression of loop induction
variables and symbols. These indices determine the start position of the read
within the memref. The shape of the return vector type determines the shape of
the slice read from the memref. This slice is contiguous along the respective
dimensions of the shape. Strided vector loads will be supported in the future.
An affine expression of loop IVs and symbols must be specified for each
dimension of the memref. The keyword &lsquo;symbol&rsquo; can be used to indicate SSA
identifiers which are symbolic.</p><p>Example 1: 8-wide f32 vector load.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span><span class=kt>vector</span>_load <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%i1</span> <span class=err>+</span> <span class=m>7</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 2: 4-wide f32 vector load. Uses &lsquo;symbol&rsquo; keyword for symbols &lsquo;%n&rsquo; and &lsquo;%m&rsquo;.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span><span class=kt>vector</span>_load <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%n</span><span class=p>),</span> <span class=nv>%i1</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%m</span><span class=p>)]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 3: 2-dim f32 vector load.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> affine<span class=p>.</span><span class=kt>vector</span>_load <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span><span class=p>,</span> <span class=nv>%i1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x8x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>TODOs:</p><ul><li>Add support for strided vector loads.</li><li>Consider adding a permutation map to permute the slice that is read from memory
(see
<a href=../Vector/#vectortransfer_read-vectortransferreadop>vector.transfer_read</a>).</li></ul><p>Traits: MemRefsNormalizable</p><p>Interfaces: AffineMapAccessInterface, AffineReadOpInterface</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of any type values</td></tr></tbody></table><h3 id=affinevector_store-mliraffinevectorstoreop><code>affine.vector_store</code> (mlir::AffineVectorStoreOp)&nbsp;<a class=headline-hash href=#affinevector_store-mliraffinevectorstoreop>¶</a></h3><p>affine vector store operation</p><p>The &ldquo;affine.vector_store&rdquo; is the vector counterpart of
<a href=#affinestore-affinestoreop>affine.store</a>. It writes a
<a href=/docs/Dialects/Builtin/#vectortype>vector</a>, supplied as its first operand,
into a slice within a
<a href=/docs/Dialects/Builtin/#memreftype>MemRef</a> of the same base
elemental type, supplied as its second operand.
The index for each memref dimension is an affine expression of loop
induction variables and symbols. These indices determine the start position
of the write within the memref. The shape of th input vector determines the
shape of the slice written to the memref. This slice is contiguous along the
respective dimensions of the shape. Strided vector stores will be supported
in the future.
An affine expression of loop IVs and symbols must be specified for each
dimension of the memref. The keyword &lsquo;symbol&rsquo; can be used to indicate SSA
identifiers which are symbolic.</p><p>Example 1: 8-wide f32 vector store.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span><span class=kt>vector</span>_store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%i1</span> <span class=err>+</span> <span class=m>7</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 2: 4-wide f32 vector store. Uses &lsquo;symbol&rsquo; keyword for symbols &lsquo;%n&rsquo; and &lsquo;%m&rsquo;.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span><span class=kt>vector</span>_store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%n</span><span class=p>),</span> <span class=nv>%i1</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%m</span><span class=p>)]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>Example 3: 2-dim f32 vector store.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span><span class=kt>vector</span>_store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span><span class=p>,</span> <span class=nv>%i1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x8x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><p>TODOs:</p><ul><li>Add support for strided vector stores.</li><li>Consider adding a permutation map to permute the slice that is written to memory
(see
<a href=../Vector/#vectortransfer_write-vectortransferwriteop>vector.transfer_write</a>).</li></ul><p>Traits: MemRefsNormalizable</p><p>Interfaces: AffineMapAccessInterface, AffineWriteOpInterface</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=affineyield-mliraffineyieldop><code>affine.yield</code> (mlir::AffineYieldOp)&nbsp;<a class=headline-hash href=#affineyield-mliraffineyieldop>¶</a></h3><p>Yield values to parent operation</p><p>Syntax:</p><pre><code>operation ::= `affine.yield` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>&ldquo;affine.yield&rdquo; yields zero or more SSA values from an affine op region and
terminates the region. The semantics of how the values yielded are used
is defined by the parent operation.
If &ldquo;affine.yield&rdquo; has any operands, the operands must match the parent
operation&rsquo;s results.
If the parent operation defines no values, then the &ldquo;affine.yield&rdquo; may be
left out in the custom syntax and the builders will insert one implicitly.
Otherwise, it has to be present in the syntax to indicate which values are
yielded.</p><pre><code>
Traits: MemRefsNormalizable, ReturnLike, Terminator

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | any type


### 'affine.load' operation

Syntax:

</code></pre><p>operation ::= ssa-id <code>=</code> <code>affine.load</code> ssa-use <code>[</code> multi-dim-affine-map-of-ssa-ids <code>]</code> <code>:</code> memref-type</p><pre><code>
The `affine.load` op reads an element from a memref, where the index for each
memref dimension is an affine expression of loop induction variables and
symbols. The output of 'affine.load' is a new value with the same type as the
elements of the memref. An affine expression of loop IVs and symbols must be
specified for each dimension of the memref. The keyword 'symbol' can be used to
indicate SSA identifiers which are symbolic.

Example:

```mlir

  Example 1:

    %1 = affine.load %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;

  Example 2: Uses 'symbol' keyword for symbols '%n' and '%m'.

    %1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)]
      : memref&lt;100x100xf32&gt;

</code></pre><h3 id=affinestore-operation>&lsquo;affine.store&rsquo; operation&nbsp;<a class=headline-hash href=#affinestore-operation>¶</a></h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type
</code></pre><p>The <code>affine.store</code> op writes an element to a memref, where the index for each
memref dimension is an affine expression of loop induction variables and
symbols. The &lsquo;affine.store&rsquo; op stores a new value which is the same type as the
elements of the memref. An affine expression of loop IVs and symbols must be
specified for each dimension of the memref. The keyword &lsquo;symbol&rsquo; can be used to
indicate SSA identifiers which are symbolic.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>
    Example <span class=m>1</span><span class=p>:</span>

      affine<span class=p>.</span>store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%i1</span> <span class=err>+</span> <span class=m>7</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>

    Example <span class=m>2</span><span class=p>:</span> Uses <span class=err>&#39;</span>symbol<span class=err>&#39;</span> keyword for symbols <span class=err>&#39;</span><span class=nv>%n</span><span class=err>&#39;</span> and <span class=err>&#39;</span><span class=nv>%m</span><span class=err>&#39;</span><span class=p>.</span>

      affine<span class=p>.</span>store <span class=nv>%v0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%i0</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%n</span><span class=p>),</span> <span class=nv>%i1</span> <span class=err>+</span> symbol<span class=p>(</span><span class=nv>%m</span><span class=p>)]</span>
        <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x100x</span><span class=k>f32</span><span class=p>&gt;</span>

</code></pre></div><h3 id=affinedma_start-operation>&lsquo;affine.dma_start&rsquo; operation&nbsp;<a class=headline-hash href=#affinedma_start-operation>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `affine.dma_Start` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]`, `[` multi-dim-affine-map-of-ssa-ids `]`, `[` multi-dim-affine-map-of-ssa-ids `]`, ssa-use `:` memref-type
</code></pre><p>The <code>affine.dma_start</code> op starts a non-blocking DMA operation that transfers
data from a source memref to a destination memref. The source and destination
memref need not be of the same dimensionality, but need to have the same
elemental type. The operands include the source and destination memref&rsquo;s each
followed by its indices, size of the data transfer in terms of the number of
elements (of the elemental type of the memref), a tag memref with its indices,
and optionally at the end, a stride and a number_of_elements_per_stride
arguments. The tag location is used by an AffineDmaWaitOp to check for
completion. The indices of the source memref, destination memref, and the tag
memref have the same restrictions as any affine.load/store. In particular, index
for each memref dimension must be an affine expression of loop induction
variables and symbols. The optional stride arguments should be of &lsquo;index&rsquo; type,
and specify a stride for the slower memory space (memory space with a lower
memory space id), transferring chunks of number_of_elements_per_stride every
stride until %num_elements are transferred. Either both or no stride arguments
should be specified. The value of &lsquo;num_elements&rsquo; must be a multiple of
&lsquo;number_of_elements_per_stride&rsquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>For example<span class=p>,</span> a DmaStartOp operation that transfers <span class=m>256</span> elements of a <span class=kt>memref</span>
<span class=err>&#39;</span><span class=nv>%src</span><span class=err>&#39;</span> in memory space <span class=m>0</span> at indices <span class=p>[</span><span class=nv>%i</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> to <span class=kt>memref</span> <span class=err>&#39;</span><span class=nv>%dst</span><span class=err>&#39;</span> in memory
space <span class=m>1</span> at indices <span class=p>[</span><span class=nv>%k</span> <span class=err>+</span> <span class=m>7</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> would be specified as follows<span class=p>:</span>

  <span class=nv>%num_elements</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>256</span>
  <span class=nv>%idx</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%tag</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;</span>
  affine<span class=p>.</span>dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span> <span class=err>+</span> <span class=m>3</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span> <span class=err>+</span> <span class=m>7</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>],</span>
    <span class=nv>%num_elements</span> <span class=p>:</span>
      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>40x128x</span><span class=k>f32</span><span class=p>,</span> <span class=m>0</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x1024x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span>

  If <span class=nv>%stride</span> and <span class=nv>%num_elt_per_stride</span> are specified<span class=p>,</span> the DMA is expected to
  transfer <span class=nv>%num_elt_per_stride</span> elements every <span class=nv>%stride</span> elements apart from
  memory space <span class=m>0</span> until <span class=nv>%num_elements</span> are transferred<span class=p>.</span>

  affine<span class=p>.</span>dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%idx</span><span class=p>],</span> <span class=nv>%num_elements</span><span class=p>,</span>
    <span class=nv>%stride</span><span class=p>,</span> <span class=nv>%num_elt_per_stride</span> <span class=p>:</span> <span class=p>...</span>
</code></pre></div><h3 id=affinedma_wait-operation>&lsquo;affine.dma_wait&rsquo; operation&nbsp;<a class=headline-hash href=#affinedma_wait-operation>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `affine.dma_Start` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]`, `[` multi-dim-affine-map-of-ssa-ids `]`, `[` multi-dim-affine-map-of-ssa-ids `]`, ssa-use `:` memref-type
</code></pre><p>The <code>affine.dma_start</code> op blocks until the completion of a DMA operation
associated with the tag element &lsquo;%tag[%index]&rsquo;. %tag is a memref, and %index has
to be an index with the same restrictions as any load/store index. In
particular, index for each memref dimension must be an affine expression of loop
induction variables and symbols. %num_elements is the number of elements
associated with the DMA operation. For example:</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>affine<span class=p>.</span>dma_start <span class=nv>%src</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>],</span> <span class=nv>%dst</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%l</span><span class=p>],</span> <span class=nv>%tag</span><span class=p>[</span><span class=nv>%index</span><span class=p>],</span> <span class=nv>%num_elements</span> <span class=p>:</span>
  <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2048x</span><span class=k>f32</span><span class=p>,</span> <span class=m>0</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>256x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span>
<span class=p>...</span>
<span class=p>...</span>
affine<span class=p>.</span>dma_wait <span class=nv>%tag</span><span class=p>[</span><span class=nv>%index</span><span class=p>],</span> <span class=nv>%num_elements</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>i32</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/OpenACCDialect/ title="'acc' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'acc' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/AMX/ title="'amx' Dialect">Next - 'amx' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li class=active><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>