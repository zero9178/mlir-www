<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'emitc' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/EmitC/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'emitc' Dialect</h1><p>Dialect to generate C/C++ from MLIR.
The EmitC dialect allows to convert operations from other MLIR dialects to EmitC
ops. Those can be translated to C/C++ via the Cpp emitter.</p><p>The following convention is followed:</p><ul><li>If template arguments are passed to an <code>emitc.call</code> operation, C++ is
generated.</li><li>If tensors are used, C++ is generated.</li><li>If multiple return values are used within in a functions or an <code>emitc.call</code>
operation, C++11 is required.</li><li>If floating-point type template arguments are passed to an <code>emitc.call</code>
operation, C++20 is required.</li><li>Else the generated code is compatible with C99.</li></ul><p>These restrictions are neither inherent to the EmitC dialect itself nor to the
Cpp emitter and therefore need to be considered while implementing conversions.</p><p>After the conversion, C/C++ code can be emitted with <code>mlir-translate</code>. The tool
supports translating MLIR to C/C++ by passing <code>-mlir-to-cpp</code>. Furthermore, code
with variables declared at top can be generated by passing the additional
argument <code>-declare-variables-at-top</code>.</p><p>Besides operations part of the EmitC dialect, the Cpp targets supports
translating the following operations:</p><ul><li>&lsquo;cf&rsquo; Dialect<ul><li><code>cf.br</code></li><li><code>cf.cond_br</code></li></ul></li><li>&lsquo;func&rsquo; Dialect<ul><li><code>func.call</code></li><li><code>func.constant</code></li><li><code>func.func</code></li><li><code>func.return</code></li></ul></li><li>&lsquo;scf&rsquo; Dialect<ul><li><code>scf.for</code></li><li><code>scf.if</code></li><li><code>scf.yield</code></li></ul></li><li>&lsquo;arith&rsquo; Dialect<ul><li><code>arith.constant</code></li></ul></li></ul><p><nav id=TableOfContents><ul><li><a href=#attribute-constraint-definition>Attribute constraint definition</a><ul><li><a href=#an-opaque-attribute>An opaque attribute</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#opaqueattr>OpaqueAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-opaque-type>An opaque type</a></li><li><a href=#emitc-pointer-type>EmitC pointer type</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#emitcapply-mliremitcapplyop><code>emitc.apply</code> (::mlir::emitc::ApplyOp)</a></li><li><a href=#emitccall-mliremitccallop><code>emitc.call</code> (::mlir::emitc::CallOp)</a></li><li><a href=#emitccast-mliremitccastop><code>emitc.cast</code> (::mlir::emitc::CastOp)</a></li><li><a href=#emitcconstant-mliremitcconstantop><code>emitc.constant</code> (::mlir::emitc::ConstantOp)</a></li><li><a href=#emitcinclude-mliremitcincludeop><code>emitc.include</code> (::mlir::emitc::IncludeOp)</a></li><li><a href=#emitcvariable-mliremitcvariableop><code>emitc.variable</code> (::mlir::emitc::VariableOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#opaquetype>OpaqueType</a></li><li><a href=#pointertype>PointerType</a></li></ul></li></ul></nav><h2 id=attribute-constraint-definition>Attribute constraint definition&nbsp;<a class=headline-hash href=#attribute-constraint-definition>¶</a></h2><h3 id=an-opaque-attribute>An opaque attribute&nbsp;<a class=headline-hash href=#an-opaque-attribute>¶</a></h3><p>An opaque attribute of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;&#34;</span><span class=p>&gt;</span>
<span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;NULL&#34;</span><span class=p>&gt;</span>
<span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;nullptr&#34;</span><span class=p>&gt;</span>
</code></pre></div><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=opaqueattr>OpaqueAttr&nbsp;<a class=headline-hash href=#opaqueattr>¶</a></h3><p>An opaque attribute</p><p>An opaque attribute of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;&#34;</span><span class=p>&gt;</span>
<span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;NULL&#34;</span><span class=p>&gt;</span>
<span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;nullptr&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>the opaque value</td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=an-opaque-type>An opaque type&nbsp;<a class=headline-hash href=#an-opaque-type>¶</a></h3><p>An opaque data type of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;</span>
<span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;mytype&#34;</span><span class=p>&gt;</span>
<span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::vector&lt;std::string&gt;&#34;</span><span class=p>&gt;</span>
</code></pre></div><h3 id=emitc-pointer-type>EmitC pointer type&nbsp;<a class=headline-hash href=#emitc-pointer-type>¶</a></h3><p>A pointer data type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Pointer emitted as `int32_t*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=c>// Pointer emitted as `float*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Pointer emitted as `int*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;&gt;</span>
</code></pre></div><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=emitcapply-mliremitcapplyop><code>emitc.apply</code> (::mlir::emitc::ApplyOp)&nbsp;<a class=headline-hash href=#emitcapply-mliremitcapplyop>¶</a></h3><p>Apply operation</p><p>Syntax:</p><pre><code>operation ::= `emitc.apply` $applicableOperator `(` $operand `)` attr-dict `:` functional-type($operand, results)
</code></pre><p>With the <code>apply</code> operation the operators & (address of) and * (contents of)
can be applied to a single operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of applying the &amp; operator.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int32_t*&#34;</span><span class=p>&gt;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.apply&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span><span class=nl>applicableOperator =</span> <span class=s>&#34;&amp;&#34;</span><span class=p>}</span>
    <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int32_t*&#34;</span><span class=p>&gt;</span>

</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>applicableOperator</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=emitccall-mliremitccallop><code>emitc.call</code> (::mlir::emitc::CallOp)&nbsp;<a class=headline-hash href=#emitccall-mliremitccallop>¶</a></h3><p>Call operation</p><p>Syntax:</p><pre><code>operation ::= `emitc.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>call</code> operation represents a C++ function call. The call allows
specifying order of operands and attributes in the call as follows:</p><ul><li>integer value of index type refers to an operand;</li><li>attribute which will get lowered to constant value in call;</li></ul><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form defining a call to `foo()`.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>call <span class=s>&#34;foo&#34;</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.call&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>callee =</span> <span class=s>&#34;foo&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>args</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>template_args</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=emitccast-mliremitccastop><code>emitc.cast</code> (::mlir::emitc::CastOp)&nbsp;<a class=headline-hash href=#emitccast-mliremitccastop>¶</a></h3><p>Cast operation</p><p>Syntax:</p><pre><code>operation ::= `emitc.cast` $source attr-dict `:` type($source) `to` type($dest)
</code></pre><p>The <code>cast</code> operation performs an explicit type conversion and is emitted
as a C-style cast expression. It can be applied to integer, float, index
and EmitC types.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Cast from `int32_t` to `float`
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>cast <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span> to <span class=k>f32</span>

<span class=c>// Cast from `void` to `int32_t` pointer
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>cast <span class=nv>%arg1</span> <span class=p>:</span>
    <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;void&#34;</span><span class=p>&gt;&gt;</span> to <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: SameOperandsAndResultShape</p><p>Interfaces: CastOpInterface</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any type</td></tr></tbody></table><h3 id=emitcconstant-mliremitcconstantop><code>emitc.constant</code> (::mlir::emitc::ConstantOp)&nbsp;<a class=headline-hash href=#emitcconstant-mliremitcconstantop>¶</a></h3><p>Constant operation</p><p>The <code>constant</code> operation produces an SSA value equal to some constant
specified by an attribute. This can be used to form simple integer and
floating point constants, as well as more exotic things like tensor
constants. The <code>constant</code> operation also supports the EmitC opaque
attribute and the EmitC opaque type. Since folding is supported,
it should not be used with pointers.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Constant emitted as `char = CHAR_MIN;`
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span>
    <span class=p>{</span><span class=nl>value =</span> <span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;CHAR_MIN&#34;</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;char&#34;</span><span class=p>&gt;}</span>
    <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;char&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Traits: ConstantLike</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=emitcinclude-mliremitcincludeop><code>emitc.include</code> (::mlir::emitc::IncludeOp)&nbsp;<a class=headline-hash href=#emitcinclude-mliremitcincludeop>¶</a></h3><p>Include operation</p><p>The <code>include</code> operation allows to define a source file inclusion via the
<code>#include</code> directive.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form defining the inclusion of `&lt;myheader&gt;`.
</span><span class=c></span>emitc<span class=p>.</span>include <span class=p>&lt;</span><span class=s>&#34;myheader.h&#34;</span><span class=p>&gt;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=s>&#34;emitc.include&#34;</span> <span class=p>(){</span><span class=nl>include =</span> <span class=s>&#34;myheader.h&#34;</span><span class=p>,</span> is_standard_include<span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>

<span class=c>// Custom form defining the inclusion of `&#34;myheader&#34;`.
</span><span class=c></span>emitc<span class=p>.</span>include <span class=s>&#34;myheader.h&#34;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=s>&#34;emitc.include&#34;</span> <span class=p>(){</span><span class=nl>include =</span> <span class=s>&#34;myheader.h&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><p>Traits: HasParent<moduleop></p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>include</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>is_standard_include</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h3 id=emitcvariable-mliremitcvariableop><code>emitc.variable</code> (::mlir::emitc::VariableOp)&nbsp;<a class=headline-hash href=#emitcvariable-mliremitcvariableop>¶</a></h3><p>Variable operation</p><p>The <code>variable</code> operation produces an SSA value equal to some value
specified by an attribute. This can be used to form simple integer and
floating point variables, as well as more exotic things like tensor
variables. The <code>variable</code> operation also supports the EmitC opaque
attribute and the EmitC opaque type. If further supports the EmitC
pointer type, whereas folding is not supported.
The <code>variable</code> is emitted as a C/C++ local variable.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer variable
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Variable emitted as `int32_t* = NULL;`
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span>
    <span class=p>{</span><span class=nl>value =</span> <span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;NULL&#34;</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int32_t*&#34;</span><span class=p>&gt;}</span>
    <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int32_t*&#34;</span><span class=p>&gt;</span>
</code></pre></div><p>Since folding is not supported, it can be used with pointers.
As an example, it is valid to create pointers to <code>variable</code> operations
by using <code>apply</code> operations and pass these to a <code>call</code> operation.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
<span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%3</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
emitc<span class=p>.</span>call <span class=s>&#34;write&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=opaquetype>OpaqueType&nbsp;<a class=headline-hash href=#opaquetype>¶</a></h3><p>An opaque type</p><p>An opaque data type of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;</span>
<span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;mytype&#34;</span><span class=p>&gt;</span>
<span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::vector&lt;std::string&gt;&#34;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>the opaque value</td></tr></tbody></table><h3 id=pointertype>PointerType&nbsp;<a class=headline-hash href=#pointertype>¶</a></h3><p>EmitC pointer type</p><p>Syntax:</p><pre><code>!emitc.ptr&lt;
  Type   # pointee
&gt;
</code></pre><p>A pointer data type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Pointer emitted as `int32_t*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=c>// Pointer emitted as `float*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=c>// Pointer emitted as `int*`
</span><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;&gt;</span>
</code></pre></div><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointee</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/DLTIDialect/ title="'dlti' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'dlti' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Func/ title="'func' Dialect">Next - 'func' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li class=active><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>