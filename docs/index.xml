<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on MLIR</title><link>https://mlir.llvm.org/docs/</link><description>Recent content in Code Documentation on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Buffer Deallocation - Internals</title><link>https://mlir.llvm.org/docs/BufferDeallocationInternals/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/BufferDeallocationInternals/</guid><description>This section covers the internal functionality of the BufferDeallocation transformation. The transformation consists of several passes. The main pass called BufferDeallocation can be applied via “-buffer-deallocation” on MLIR programs.
Requirements In order to use BufferDeallocation on an arbitrary dialect, several control-flow interfaces have to be implemented when using custom operations. This is particularly important to understand the implicit control-flow dependencies between different parts of the input program. Without implementing the following interfaces, control-flow relations cannot be discovered properly and the resulting program can become invalid:</description></item><item><title>Bufferization</title><link>https://mlir.llvm.org/docs/Bufferization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Bufferization/</guid><description>Overview What is One-Shot Bufferize? Goals of Bufferization Destination-Passing Style Using One-Shot Bufferize Buffer Deallocation Memory Layouts Extending One-Shot Bufferize Debugging Buffer Copies Understanding the SSA Use-Def Chain Analysis Migrating from Dialect Conversion-based Bufferization Bufferization Function Graphs Dialect Conversion-based Bufferization Bufferization&amp;rsquo;s place in a compilation pipeline General structure of the bufferization process Example How to write a partial bufferization pass Other partial bufferization examples How to write a finalizing bufferization pass Changes since the talk Overview Bufferization in MLIR is the process of converting ops with tensor semantics to ops with memref semantics.</description></item><item><title>Data Layout Modeling</title><link>https://mlir.llvm.org/docs/DataLayout/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DataLayout/</guid><description>Data layout information allows the compiler to answer questions related to how a value of a particular type is stored in memory. For example, the size of a value or its address alignment requirements. It enables, among others, the generation of various linear memory addressing schemes for containers of abstract types and deeper reasoning about vectors.
The data layout subsystem is designed to scale to MLIR&amp;rsquo;s open type and operation system.</description></item><item><title>Debug Actions</title><link>https://mlir.llvm.org/docs/DebugActions/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DebugActions/</guid><description>Debug Action Debug Action Manager Debug Action Handler Action Specific Handlers Generic Handlers Common Action Handlers This file documents the infrastructure for Debug Actions. This is a DEBUG only API that allows for external entities to control various aspects of compiler execution. This is conceptually similar to something like DebugCounters in LLVM, but at a lower level. This framework doesn&amp;rsquo;t make any assumptions about how the higher level driver is controlling the execution, it merely provides a framework for connecting the two together.</description></item><item><title>Defining Dialect Attributes and Types</title><link>https://mlir.llvm.org/docs/AttributesAndTypes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/AttributesAndTypes/</guid><description>This document describes how to define dialect attributes and types.
LangRef Refresher Attributes Types Attributes and Types Adding a new Attribute or Type definition Class Name Documentation Mnemonic Parameters Traits Interfaces Builders Parsing and Printing Verification Storage Classes Mutable attributes and types Extra declarations Registering with the Dialect LangRef Refresher Before diving into how to define these constructs, below is a quick refresher from the MLIR LangRef.</description></item><item><title>Defining Dialects</title><link>https://mlir.llvm.org/docs/DefiningDialects/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DefiningDialects/</guid><description>This document describes how to define Dialects.
LangRef Refresher Defining a Dialect Initialization Documentation Class Name C++ Namespace Dependent Dialects Extra declarations hasConstantMaterializer: Materializing Constants from Attributes hasNonDefaultDestructor: Providing a custom destructor Discardable Attribute Verification Operation Interface Fallback Default Attribute/Type Parsers and Printers Dialect-wide Canonicalization Patterns C++ Accessor Prefix LangRef Refresher Before diving into how to define these constructs, below is a quick refresher from the MLIR LangRef.</description></item><item><title>Diagnostic Infrastructure</title><link>https://mlir.llvm.org/docs/Diagnostics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Diagnostics/</guid><description>Source Locations Diagnostic Engine Constructing a Diagnostic Diagnostic Appending arguments Attaching notes InFlight Diagnostic Diagnostic Configuration Options Print Operation On Diagnostic Print StackTrace On Diagnostic Common Diagnostic Handlers Scoped Diagnostic Handler SourceMgr Diagnostic Handler SourceMgr Diagnostic Verifier Handler Parallel Diagnostic Handler This document presents an introduction to using and interfacing with MLIR&amp;rsquo;s diagnostics infrastructure.
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc.</description></item><item><title>Dialect Conversion</title><link>https://mlir.llvm.org/docs/DialectConversion/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DialectConversion/</guid><description>This document describes a framework in MLIR in which to perform operation conversions between, and within dialects. This framework allows for transforming illegal operations to those supported by a provided conversion target, via a set of pattern-based operation rewriting patterns.
Modes of Conversion Conversion Target Recursive Legality Rewrite Pattern Specification Conversion Patterns Type Conversion Type Converter Region Signature Conversion Debugging The dialect conversion framework consists of the following components:</description></item><item><title>Extensible dialects</title><link>https://mlir.llvm.org/docs/ExtensibleDialects/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/ExtensibleDialects/</guid><description>This file documents the design and API of the extensible dialects. Extensible dialects are dialects that can be extended with new operations and types defined at runtime. This allows for users to define dialects via with meta-programming, or from another language, without having to recompile C++ code.
Usage Defining an extensible dialect Defining an operation at runtime Using an operation defined at runtime Defining a type at runtime Parsing types defined at runtime in an extensible dialect Using a type defined at runtime Defining an attribute at runtime Parsing attributes defined at runtime in an extensible dialect Using an attribute defined at runtime Implementation details Extensible dialect Operation representation and registration Type representation and registration Usage Defining an extensible dialect Dialects defined in C++ can be extended with new operations, types, etc.</description></item><item><title>Interfaces</title><link>https://mlir.llvm.org/docs/Interfaces/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Interfaces/</guid><description>MLIR is a generic and extensible framework, representing different dialects with their own attributes, operations, types, and so on. MLIR Dialects can express operations with a wide variety of semantics and different levels of abstraction. The downside to this is that MLIR transformations and analyses need to be able to account for the semantics of every operation, or be overly conservative. Without care, this can result in code with special-cases for each supported operation type.</description></item><item><title>LLVM IR Target</title><link>https://mlir.llvm.org/docs/TargetLLVMIR/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/TargetLLVMIR/</guid><description>This document describes the mechanisms of producing LLVM IR from MLIR. The overall flow is two-stage:
conversion of the IR to a set of dialects translatable to LLVM IR, for example LLVM Dialect or one of the hardware-specific dialects derived from LLVM IR intrinsics such as AMX, X86Vector or ArmNeon; translation of MLIR dialects to LLVM IR. This flow allows the non-trivial transformation to be performed within MLIR using MLIR APIs and makes the translation between MLIR and LLVM IR simple and potentially bidirectional.</description></item><item><title>MLIR C API</title><link>https://mlir.llvm.org/docs/CAPI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/CAPI/</guid><description>Current status: Under development, API unstable, built by default.
Design Many languages can interoperate with C but have a harder time with C++ due to name mangling and memory model differences. Although the C API for MLIR can be used directly from C, it is primarily intended to be wrapped in higher-level language- or library-specific constructs. Therefore the API tends towards simplicity and feature minimalism.
Note: while the C API is expected to be more stable than C++ API, it currently offers no stability guarantees.</description></item><item><title>MLIR Language Reference</title><link>https://mlir.llvm.org/docs/LangRef/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/LangRef/</guid><description>MLIR (Multi-Level IR) is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL), but which introduces notions from polyhedral loop optimization as first-class concepts. This hybrid design is optimized to represent, analyze, and transform high level dataflow graphs as well as target-specific code generated for high performance data parallel systems. Beyond its representational capabilities, its single continuous design provides a framework to lower from dataflow graphs to high-performance target-specific code.</description></item><item><title>Operation Canonicalization</title><link>https://mlir.llvm.org/docs/Canonicalization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Canonicalization/</guid><description>Canonicalization is an important part of compiler IR design: it makes it easier to implement reliable compiler transformations and to reason about what is better or worse in the code, and it forces interesting discussions about the goals of a particular level of IR. Dan Gohman wrote an article exploring these issues; it is worth reading if you&amp;rsquo;re not familiar with these concepts.
Most compilers have canonicalization passes, and sometimes they have many different ones (e.</description></item><item><title>Operation Definition Specification (ODS)</title><link>https://mlir.llvm.org/docs/OpDefinitions/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/OpDefinitions/</guid><description>In addition to specializing the mlir::Op C++ template, MLIR also supports defining operations and data types in a table-driven manner. This is achieved via TableGen, which is both a generic language and its tooling to maintain records of domain-specific information. Facts regarding an operation are specified concisely into a TableGen record, which will be expanded into an equivalent mlir::Op C++ template specialization at compiler build time.
This manual explains in detail all the available mechanisms for defining operations in such a table-driven manner.</description></item><item><title>Pass Infrastructure</title><link>https://mlir.llvm.org/docs/PassManagement/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/PassManagement/</guid><description>Operation Pass OperationPass : Op-Specific OperationPass : Op-Agnostic Dependent Dialects Initialization Analysis Management Querying Analyses Preserving Analyses Pass Failure Pass Manager OpPassManager Dynamic Pass Pipelines Instance Specific Pass Options Pass Statistics Pass Registration Pass Pipeline Registration Textual Pass Pipeline Specification Declarative Pass Specification Tablegen Specification Pass Instrumentation Standard Instrumentations Crash and Failure Reproduction Local Reproducer Generation Passes represent the basic infrastructure for transformation and optimization.</description></item><item><title>Passes</title><link>https://mlir.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Passes/</guid><description>This document describes the available MLIR passes and their contracts.
General Transformation Passes -canonicalize: Canonicalize operations -control-flow-sink: Sink operations into conditional blocks -cse: Eliminate common sub-expressions -inline: Inline function calls -loop-invariant-code-motion: Hoist loop invariant instructions outside of the loop -print-op-stats: Print statistics of operations -sccp: Sparse Conditional Constant Propagation -snapshot-op-locations: Generate new locations from the current IR -strip-debuginfo: Strip debug info from all operations -symbol-dce: Eliminate dead symbols -symbol-privatize: Mark symbols private -view-op-graph: Print Graphviz visualization of an operation Bufferization Passes -buffer-deallocation: Adds all required dealloc operations for all allocations in the input program -buffer-hoisting: Optimizes placement of allocation operations by moving them into common dominators and out of nested regions -buffer-loop-hoisting: Optimizes placement of allocation operations by moving them out of loop nests -buffer-results-to-out-params: Converts memref-typed function results to out-params -finalizing-bufferize: Finalize a partial bufferization -one-shot-bufferize: One-Shot Bufferize -promote-buffers-to-stack: Promotes heap-based allocations to automatically managed stack-based allocations Conversion Passes -arm-neon-2d-to-intr: Convert Arm NEON structured ops to intrinsics -convert-affine-for-to-gpu: Convert top-level AffineFor Ops to GPU kernels -convert-arith-to-llvm: Convert Arithmetic dialect to LLVM dialect -convert-arith-to-spirv: Convert Arithmetic dialect to SPIR-V dialect -convert-async-to-llvm: Convert the operations from the async dialect into the LLVM dialect -convert-bufferization-to-memref: Convert operations from the Bufferization dialect to the MemRef dialect -convert-cf-to-llvm: Convert ControlFlow operations to the LLVM dialect -convert-cf-to-spirv: Convert ControlFlow dialect to SPIR-V dialect -convert-complex-to-llvm: Convert Complex dialect to LLVM dialect -convert-complex-to-standard: Convert Complex dialect to standard dialect -convert-func-to-llvm: Convert from the Func dialect to the LLVM dialect -convert-func-to-spirv: Convert Func dialect to SPIR-V dialect -convert-gpu-launch-to-vulkan-launch: Convert gpu.</description></item><item><title>Pattern Rewriting : Generic DAG-to-DAG Rewriting</title><link>https://mlir.llvm.org/docs/PatternRewriter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/PatternRewriter/</guid><description>Introduction Defining Patterns Benefit Root Operation Name (Optional) match and rewrite implementation Application Recursion Debug Names and Labels Initialization Construction Pattern Rewriter Pattern Application Common Pattern Drivers Dialect Conversion Driver Greedy Pattern Rewrite Driver Debugging Debugging Pattern Filtering Common Pass Utilities This document details the design and API of the pattern rewriting infrastructure present in MLIR, a general DAG-to-DAG transformation framework.</description></item><item><title>PDLL - PDL Language</title><link>https://mlir.llvm.org/docs/PDLL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/PDLL/</guid><description>This document details the PDL Language (PDLL), a custom frontend language for writing pattern rewrites targeting MLIR.
Note: This document assumes a familiarity with MLIR concepts; more specifically the concepts detailed within the MLIR Pattern Rewriting and Operation Definition Specification (ODS) documentation.
Introduction Rationale Why build a new language instead of improving TableGen DRR? Why not build a DSL in &amp;ldquo;X&amp;rdquo;? Language Specification Includes Patterns Variables Operation Expression Attribute Expression Type Expression Tuples Constraints Rewriters Introduction Pattern matching is an extremely important component within MLIR, as it encompasses many different facets of the compiler.</description></item><item><title>Quantization</title><link>https://mlir.llvm.org/docs/Quantization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Quantization/</guid><description>This document outlines the design of the MLIR quantization system. While the term &amp;ldquo;quantization&amp;rdquo; is highly overloaded, in this case, it refers to a fairly narrow scope of techniques in use to enable conversion of floating-point computations to corresponding and plausible variants expressed in integer math for inference, as has historically been supported by low-bit depth inference engines such as TFLite, various accelerator hardware, and many DSPs.
Much of this is inspired by the approach taken in this paper with many extensions and adaptations folded in.</description></item><item><title>Shape Inference</title><link>https://mlir.llvm.org/docs/ShapeInference/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/ShapeInference/</guid><description>Shape inference as discussed here is considered a specific instance of type inference for ShapedType. Type constraints are along (at least) three axis: 1) elemental type, 2) rank (including static or dynamic), 3) dimensions. While some operations have no compile time fixed shape (e.g., output shape is dictated by data) we could still have some knowledge of constraints/bounds in the system for that operation (e.g., the output of a tf.where is at most the size of the input data).</description></item><item><title>SPIR-V Dialect to LLVM Dialect conversion manual</title><link>https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/</guid><description>This manual describes the conversion from SPIR-V Dialect to LLVM Dialect. It assumes familiarity with both, and describes the design choices behind the modelling of SPIR-V concepts in LLVM Dialect. The conversion is an ongoing work, and is expected to grow as more features are implemented.
Conversion can be performed by invoking an appropriate conversion pass:
mlir-opt -convert-spirv-to-llvm &amp;lt;filename.mlir&amp;gt; This pass performs type and operation conversions for SPIR-V operations as described in this document.</description></item><item><title>Symbols and Symbol Tables</title><link>https://mlir.llvm.org/docs/SymbolsAndSymbolTables/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/SymbolsAndSymbolTables/</guid><description>Symbol Defining or declaring a Symbol Symbol Table Referencing a Symbol Manipulating a Symbol Symbol Visibility With Regions, the multi-level aspect of MLIR is structural in the IR. A lot of infrastructure within the compiler is built around this nesting structure; including the processing of operations within the pass manager. One advantage of the MLIR design is that it is able to process operations in parallel, utilizing multiple threads.</description></item><item><title>Table-driven Declarative Rewrite Rule (DRR)</title><link>https://mlir.llvm.org/docs/DeclarativeRewrites/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DeclarativeRewrites/</guid><description>In addition to subclassing the mlir::RewritePattern C++ class, MLIR also supports defining rewrite rules in a declarative manner. Similar to Op Definition Specification (ODS), this is achieved via TableGen, which is a language to maintain records of domain-specific information. The rewrite rules are specified concisely in a TableGen record, which will be expanded into an equivalent mlir::RewritePattern subclass at compiler build time.
This manual explains in detail all of the available mechanisms for defining rewrite rules in such a declarative manner.</description></item><item><title>Traits</title><link>https://mlir.llvm.org/docs/Traits/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Traits/</guid><description>Defining a Trait Parametric Traits Attaching a Trait Attaching Operation Traits in ODS Using a Trait Operation Traits List AffineScope AutomaticAllocationScope Broadcastable Commutative ElementwiseMappable HasParent IsolatedFromAbove MemRefsNormalizable Single Block Region Single Block with Implicit Terminator SymbolTable Terminator MLIR allows for a truly open ecosystem, as any dialect may define attributes, operations, and types that suit a specific level of abstraction.</description></item></channel></rss>