<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Defining Dialects - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/DefiningDialects/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Defining Dialects</h1><p>This document describes how to define
<a href=/docs/LangRef/#dialects>Dialects</a>.</p><p><nav id=TableOfContents><ul><li><a href=#langref-refresher>LangRef Refresher</a></li><li><a href=#defining-a-dialect>Defining a Dialect</a><ul><li><a href=#initialization>Initialization</a></li><li><a href=#documentation>Documentation</a></li><li><a href=#class-name>Class Name</a></li><li><a href=#c-namespace>C++ Namespace</a></li><li><a href=#dependent-dialects>Dependent Dialects</a></li><li><a href=#extra-declarations>Extra declarations</a></li><li><a href=#hasconstantmaterializer-materializing-constants-from-attributes><code>hasConstantMaterializer</code>: Materializing Constants from Attributes</a></li><li><a href=#hasnondefaultdestructor-providing-a-custom-destructor><code>hasNonDefaultDestructor</code>: Providing a custom destructor</a></li><li><a href=#discardable-attribute-verification>Discardable Attribute Verification</a></li><li><a href=#operation-interface-fallback>Operation Interface Fallback</a></li><li><a href=#default-attributetype-parsers-and-printers>Default Attribute/Type Parsers and Printers</a></li><li><a href=#dialect-wide-canonicalization-patterns>Dialect-wide Canonicalization Patterns</a></li><li><a href=#c-accessor-prefix>C++ Accessor Prefix</a></li></ul></li></ul></nav><h2 id=langref-refresher>LangRef Refresher&nbsp;<a class=headline-hash href=#langref-refresher>¶</a></h2><p>Before diving into how to define these constructs, below is a quick refresher
from the
<a href=/docs/LangRef/>MLIR LangRef</a>.</p><p>Dialects are the mechanism by which to engage with and extend the MLIR
ecosystem. They allow for defining new
<a href=/docs/LangRef/>attributes</a>,
<a href=/docs/LangRef/>operations</a>, and
<a href=/docs/LangRef/>types</a>.
Dialects are used to model a variety of different abstractions; from traditional
<a href=/docs/Dialects/ArithmeticOps/>arithmetic</a> to
<a href=/docs/Dialects/PDLOps/>pattern rewrites</a>; and is one of the most fundamental
aspects of MLIR.</p><h2 id=defining-a-dialect>Defining a Dialect&nbsp;<a class=headline-hash href=#defining-a-dialect>¶</a></h2><p>At the most fundamental level, defining a dialect in MLIR is as simple as
specializing the
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/Dialect.h>C++ <code>Dialect</code> class</a>.
That being said, MLIR provides a powerful declaratively specification mechanism via
<a href=https://llvm.org/docs/TableGen/index.html>TableGen</a>; a generic language with
tooling to maintain records of domain-specific information; that simplifies the
definition process by automatically generating all of the necessary boilerplate
C++ code, significantly reduces maintainence burden when changing aspects of dialect
definitions, and also provides additional tools on top (such as
documentation generation). Given the above, the declarative specification is the
expected mechanism for defining new dialects, and is the method detailed within
this document. Before continuing, it is highly recommended that users review the
<a href=https://llvm.org/docs/TableGen/ProgRef.html>TableGen Programmer&rsquo;s Reference</a>
for an introduction to its syntax and constructs.</p><p>Below showcases an example simple Dialect definition. We generally recommend defining
the Dialect class in a different <code>.td</code> file from the attributes, operations, types,
and other sub-components of the dialect to establish a proper layering between
the various different dialect components. It also prevents situations where you may
inadvertantly generate multiple definitions for some constructs. This recommendation
extends to all of the MLIR constructs, including
<a href=/docs/Interfaces/>Interfaces</a> for example.</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=c>// Include the definition of the necessary tablegen constructs for defining
</span><span class=c>// our dialect. 
</span><span class=c></span><span class=nv>include</span> <span class=s>&#34;mlir/IR/DialectBase.td&#34;</span>

<span class=c>// Here is a simple definition of a dialect.
</span><span class=c></span><span class=k>def</span> <span class=nv>MyDialect</span> <span class=p>:</span> <span class=nv>Dialect</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;A short one line description of my dialect.&#34;</span><span class=p>;</span>
  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>    My dialect is a very important dialect. This section contains a much more
</span><span class=s>    detailed description that documents all of the important pieces of information
</span><span class=s>    to know about the document.
</span><span class=s>  }]</span><span class=p>;</span>

  <span class=c>/// This is the namespace of the dialect. It is used to encapsulate the sub-components
</span><span class=c></span>  <span class=c>/// of the dialect, such as operations (&#34;my_dialect.foo&#34;).
</span><span class=c></span>  <span class=k>let</span> <span class=nv>name</span> <span class=p>=</span> <span class=s>&#34;my_dialect&#34;</span><span class=p>;</span>

  <span class=c>/// The C++ namespace that the dialect, and its sub-components, get placed in.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>cppNamespace</span> <span class=p>=</span> <span class=s>&#34;::my_dialect&#34;</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The above showcases a very simple description of a dialect, but dialects have lots
of other capabilities that you may or may not need to utilize.</p><h3 id=initialization>Initialization&nbsp;<a class=headline-hash href=#initialization>¶</a></h3><p>Every dialect must implement an initialization hook to add attributes, operations, types,
attach any desired interfaces, or perform any other necessary initialization for the
dialect that should happen on construction. This hook is declared for every dialect to
define, and has the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=n>MyDialect</span><span class=o>::</span><span class=n>initialize</span><span class=p>()</span> <span class=p>{</span>
  <span class=c1>// Dialect initialization logic should be defined in here.
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h3 id=documentation>Documentation&nbsp;<a class=headline-hash href=#documentation>¶</a></h3><p>The <code>summary</code> and <code>description</code> fields allow for providing user documentation
for the dialect. The <code>summary</code> field expects a simple single-line string, with the
<code>description</code> field used for long and extensive documentation. This documentation can be
used to generate markdown documentation for the dialect and is used by upstream
<a href=https://mlir.llvm.org/docs/Dialects/>MLIR dialects</a>.</p><h3 id=class-name>Class Name&nbsp;<a class=headline-hash href=#class-name>¶</a></h3><p>The name of the C++ class which gets generated is the same as the name of our TableGen
dialect definition, but with any <code>_</code> characters stripped out. This means that if you name
your dialect <code>Foo_Dialect</code>, the generated C++ class would be <code>FooDialect</code>. In the example
above, we would get a C++ dialect named <code>MyDialect</code>.</p><h3 id=c-namespace>C++ Namespace&nbsp;<a class=headline-hash href=#c-namespace>¶</a></h3><p>The namespace that the C++ class for our dialect, and all of its sub-components, is placed
under is specified by the <code>cppNamespace</code> field. By default, uses the name of the dialect as
the only namespace. To avoid placing in any namespace, use <code>""</code>. To specify nested namespaces,
use <code>"::"</code> as the delimiter between namespace, e.g., given <code>"A::B"</code>, C++ classes will be placed
within: <code>namespace A { namespace B { &lt;classes> } }</code>.</p><p>Note that this works in conjunction with the dialect&rsquo;s C++ code. Depending on how the generated files
are included, you may want to specify a full namespace path or a partial one. In general, it&rsquo;s best
to use full namespaces whenever you can. This makes it easier for dialects within different namespaces,
and projects, to interact with each other.</p><h3 id=dependent-dialects>Dependent Dialects&nbsp;<a class=headline-hash href=#dependent-dialects>¶</a></h3><p>MLIR has a very large ecosystem, and contains dialects that server many different purposes. It
is quite common, given the above, that dialects may want to reuse certain components from other
dialects. This may mean generating operations from those dialects during canonicalization, reusing
attributes or types, etc. When a dialect has a dependency on another, i.e. when it constructs and/or
generally relies on the components of another dialect, a dialect dependency should be explicitly
recorded. An explicitly dependency ensures that dependent dialects are loaded alongside the
dialect. Dialect dependencies can be recorded using the <code>dependentDialects</code> dialects field:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyDialect</span> <span class=p>:</span> <span class=nv>Dialect</span> <span class=p>{</span>
  <span class=c>// Here we register the Arithmetic and Func dialect as dependencies of our `MyDialect`.
</span><span class=c></span>  <span class=k>let</span> <span class=nv>dependentDialects</span> <span class=p>=</span> <span class=p>[</span>
    <span class=s>&#34;arith::ArithmeticDialect&#34;</span><span class=p>,</span>
    <span class=s>&#34;func::FuncDialect&#34;</span>
  <span class=p>];</span>
<span class=p>}</span>
</code></pre></div><h3 id=extra-declarations>Extra declarations&nbsp;<a class=headline-hash href=#extra-declarations>¶</a></h3><p>The declarative Dialect definitions try to auto-generate as much logic and methods
as possible. With that said, there will always be long-tail cases that won&rsquo;t be covered.
For such cases, <code>extraClassDeclaration</code> can be used. Code within the <code>extraClassDeclaration</code>
field will be copied literally to the generated C++ Dialect class.</p><p>Note that <code>extraClassDeclaration</code> is a mechanism intended for long-tail cases by
power users; for not-yet-implemented widely-applicable cases, improving the
infrastructure is preferable.</p><h3 id=hasconstantmaterializer-materializing-constants-from-attributes><code>hasConstantMaterializer</code>: Materializing Constants from Attributes&nbsp;<a class=headline-hash href=#hasconstantmaterializer-materializing-constants-from-attributes>¶</a></h3><p>This field is utilized to materialize a constant operation from an <code>Attribute</code> value and
a <code>Type</code>. This is generally used when an operation within this dialect has been folded,
and a constant operation should be generated. <code>hasConstantMaterializer</code> is used to enable
materialization, and the <code>materializeConstant</code> hook is declared on the dialect. This
hook takes in an <code>Attribute</code> value, generally returned by <code>fold</code>, and produces a
&ldquo;constant-like&rdquo; operation that materializes that value. See the
<a href=/docs/Canonicalization/>documentation for canonicalization</a> for a more in-depth
introduction to <code>folding</code> in MLIR.</p><p>Constant materialization logic can then be defined in the source file:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Hook to materialize a single constant operation from a given attribute value
</span><span class=c1>/// with the desired resultant type. This method should use the provided builder
</span><span class=c1>/// to create the operation without changing the insertion position. The
</span><span class=c1>/// generated operation is expected to be constant-like. On success, this hook
</span><span class=c1>/// should return the operation generated to represent the constant value.
</span><span class=c1>/// Otherwise, it should return nullptr on failure.
</span><span class=c1></span><span class=n>Operation</span> <span class=o>*</span><span class=n>MyDialect</span><span class=o>::</span><span class=n>materializeConstant</span><span class=p>(</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>builder</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>value</span><span class=p>,</span>
                                          <span class=n>Type</span> <span class=n>type</span><span class=p>,</span> <span class=n>Location</span> <span class=n>loc</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>...</span>
<span class=p>}</span>
</code></pre></div><h3 id=hasnondefaultdestructor-providing-a-custom-destructor><code>hasNonDefaultDestructor</code>: Providing a custom destructor&nbsp;<a class=headline-hash href=#hasnondefaultdestructor-providing-a-custom-destructor>¶</a></h3><p>This field should be used when the Dialect class has a custom destructor, i.e.
when the dialect has some special logic to be run in the <code>~MyDialect</code>. In this case,
only the declaration of the destructor is generated for the Dialect class.</p><h3 id=discardable-attribute-verification>Discardable Attribute Verification&nbsp;<a class=headline-hash href=#discardable-attribute-verification>¶</a></h3><p>As described by the
<a href=/docs/LangRef/>MLIR Language Reference</a>,
<em>discardable attribute</em> are a type of attribute that has its semantics defined
by the dialect whose name prefixes that of the attribute. For example, if an
operation has an attribute named <code>gpu.contained_module</code>, the <code>gpu</code> dialect
defines the semantics and invariants, such as when and where it is valid to use,
of that attribute. To hook into this verification for attributes that are prefixed
by our dialect, several hooks on the Dialect may be used:</p><h4 id=hasoperationattrverify><code>hasOperationAttrVerify</code>&nbsp;<a class=headline-hash href=#hasoperationattrverify>¶</a></h4><p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of an operation. This hook has the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Verify the use of the given attribute, whose name is prefixed by the namespace of this
</span><span class=c1>/// dialect, that was used in `op`s dictionary.
</span><span class=c1></span><span class=n>LogicalResult</span> <span class=n>MyDialect</span><span class=o>::</span><span class=n>verifyOperationAttribute</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>NamedAttribute</span> <span class=n>attribute</span><span class=p>);</span>
</code></pre></div><h4 id=hasregionargattrverify><code>hasRegionArgAttrVerify</code>&nbsp;<a class=headline-hash href=#hasregionargattrverify>¶</a></h4><p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of a region entry block argument. Note that
the block arguments of a region entry block do not themselves have attribute dictionaries,
but some operations may provide special dictionary attributes that correspond to the arguments
of a region. For example, operations that implement <code>FunctionOpInterface</code> may have attribute
dictionaries on the operation that correspond to the arguments of entry block of the function.
In these cases, those operations will invoke this hook on the dialect to ensure the attribute
is verified. The hook necessary for the dialect to implement has the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Verify the use of the given attribute, whose name is prefixed by the namespace of this
</span><span class=c1>/// dialect, that was used on the attribute dictionary of a region entry block argument.
</span><span class=c1>/// Note: As described above, when a region entry block has a dictionary is up to the individual
</span><span class=c1>/// operation to define. 
</span><span class=c1></span><span class=n>LogicalResult</span> <span class=n>MyDialect</span><span class=o>::</span><span class=n>verifyRegionArgAttribute</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>regionIndex</span><span class=p>,</span>
                                                  <span class=kt>unsigned</span> <span class=n>argIndex</span><span class=p>,</span> <span class=n>NamedAttribute</span> <span class=n>attribute</span><span class=p>);</span>
</code></pre></div><h4 id=hasregionresultattrverify><code>hasRegionResultAttrVerify</code>&nbsp;<a class=headline-hash href=#hasregionresultattrverify>¶</a></h4><p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of a region result. Note that the results of a
region do not themselves have attribute dictionaries, but some operations may provide special
dictionary attributes that correspond to the results of a region. For example, operations that
implement <code>FunctionOpInterface</code> may have attribute dictionaries on the operation that correspond
to the results of the function. In these cases, those operations will invoke this hook on the
dialect to ensure the attribute is verified. The hook necessary for the dialect to implement
has the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Generate verification for the given attribute, whose name is prefixed by the namespace
</span><span class=c1>/// of this dialect, that was used on the attribute dictionary of a region result.
</span><span class=c1>/// Note: As described above, when a region entry block has a dictionary is up to the individual
</span><span class=c1>/// operation to define. 
</span><span class=c1></span><span class=n>LogicalResult</span> <span class=n>MyDialect</span><span class=o>::</span><span class=n>verifyRegionResultAttribute</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>regionIndex</span><span class=p>,</span>
                                                     <span class=kt>unsigned</span> <span class=n>argIndex</span><span class=p>,</span> <span class=n>NamedAttribute</span> <span class=n>attribute</span><span class=p>);</span>
</code></pre></div><h3 id=operation-interface-fallback>Operation Interface Fallback&nbsp;<a class=headline-hash href=#operation-interface-fallback>¶</a></h3><p>Some dialects have an open ecosystem and don&rsquo;t register all of the possible operations. In such
cases it is still possible to provide support for implementing an <code>OpInterface</code> for these
operations. When an operation isn&rsquo;t registered or does not provide an implementation for an
interface, the query will fallback to the dialect itself. The <code>hasOperationInterfaceFallback</code>
field may be used to declare this fallback for operations:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Return an interface model for the interface with the given `typeId` for the operation
</span><span class=c1>/// with the given name.
</span><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>MyDialect</span><span class=o>::</span><span class=n>getRegisteredInterfaceForOp</span><span class=p>(</span><span class=n>TypeID</span> <span class=n>typeID</span><span class=p>,</span> <span class=n>StringAttr</span> <span class=n>opName</span><span class=p>);</span>
</code></pre></div><p>For a more detail description of the expected usages of this hook, view the detailed
<a href=/docs/Interfaces/>interface documentation</a>.</p><h3 id=default-attributetype-parsers-and-printers>Default Attribute/Type Parsers and Printers&nbsp;<a class=headline-hash href=#default-attributetype-parsers-and-printers>¶</a></h3><p>When a dialect registers an Attribute or Type, it must also override the respective
<code>Dialect::parseAttribute</code>/<code>Dialect::printAttribute</code> or
<code>Dialect::parseType</code>/<code>Dialect::printType</code> methods. In these cases, the dialect must
explicitly handle the parsing and printing of each individual attribute or type within
the dialect. If all of the attributes and types of the dialect provide a mnemonic,
however, these methods may be autogenerated by using the
<code>useDefaultAttributePrinterParser</code> and <code>useDefaultTypePrinterParser</code> fields. By default,
these fields are set to <code>1</code>(enabled), meaning that if a dialect needs to explicitly handle the
parser and printer of its Attributes and Types it should set these to <code>0</code> as necessary.</p><h3 id=dialect-wide-canonicalization-patterns>Dialect-wide Canonicalization Patterns&nbsp;<a class=headline-hash href=#dialect-wide-canonicalization-patterns>¶</a></h3><p>Generally,
<a href=/docs/Canonicalization/>canonicalization</a> patterns are specific to individual
operations within a dialect. There are some cases, however, that prompt canonicalization
patterns to be added to the dialect-level. For example, if a dialect defines a canonicalization
pattern that operates on an interface or trait, it can be beneficial to only add this pattern
once, instead of duplicating per-operation that implements that interface. To enable the
generation of this hook, the <code>hasCanonicalizer</code> field may be used. This will declare
the <code>getCanonicalizationPatterns</code> method on the dialect, which has the form:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Return the canonicalization patterns for this dialect:
</span><span class=c1></span><span class=kt>void</span> <span class=n>MyDialect</span><span class=o>::</span><span class=n>getCanonicalizationPatterns</span><span class=p>(</span><span class=n>RewritePatternSet</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</code></pre></div><p>See the documentation for
<a href=/docs/Canonicalization/>Canonicalization in MLIR</a> for a much more
detailed description about canonicalization patterns.</p><h3 id=c-accessor-prefix>C++ Accessor Prefix&nbsp;<a class=headline-hash href=#c-accessor-prefix>¶</a></h3><p>Historically, MLIR has generated accessors for operation components (such as attribute, operands,
results) using the tablegen definition name verbatim. This means that if an operation was defined
as:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=nv>MyDialect</span><span class=p>&lt;</span><span class=s>&#34;op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$value</span><span class=p>,</span> <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$other_value</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>It would have accessors generated for the <code>value</code> and <code>other_value</code> attributes as follows:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>StringAttr</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>value</span><span class=p>();</span>
<span class=kt>void</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>value</span><span class=p>(</span><span class=n>StringAttr</span> <span class=n>newValue</span><span class=p>);</span>

<span class=n>StringAttr</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>other_value</span><span class=p>();</span>
<span class=kt>void</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>other_value</span><span class=p>(</span><span class=n>StringAttr</span> <span class=n>newValue</span><span class=p>);</span>
</code></pre></div><p>Since then, we have decided to move accessors over to a style that matches the rest of the
code base. More specifically, this means that we prefix accessors with <code>get</code> and <code>set</code>
respectively, and transform <code>snake_style</code> names to camel case (<code>UpperCamel</code> when prefixed,
and <code>lowerCamel</code> for individual variable names). If we look at the same example as above, this
would produce:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>StringAttr</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>getValue</span><span class=p>();</span>
<span class=kt>void</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>setValue</span><span class=p>(</span><span class=n>StringAttr</span> <span class=n>newValue</span><span class=p>);</span>

<span class=n>StringAttr</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>getOtherValue</span><span class=p>();</span>
<span class=kt>void</span> <span class=n>MyOp</span><span class=o>::</span><span class=n>setOtherValue</span><span class=p>(</span><span class=n>StringAttr</span> <span class=n>newValue</span><span class=p>);</span>
</code></pre></div><p>The form in which accessors are generated is controlled by the <code>emitAccessorPrefix</code> field.
This field may any of the following values:</p><ul><li><p><code>kEmitAccessorPrefix_Raw</code></p><ul><li>Don&rsquo;t emit any <code>get</code>/<code>set</code> prefix.</li></ul></li><li><p><code>kEmitAccessorPrefix_Prefixed</code></p><ul><li>Only emit with <code>get</code>/<code>set</code> prefix.</li></ul></li><li><p><code>kEmitAccessorPrefix_Both</code></p><ul><li>Emit with <strong>and</strong> without prefix.</li></ul></li></ul><p>All new dialects are strongly encouraged to use the <code>kEmitAccessorPrefix_Prefixed</code> value, as
the <code>Raw</code> form is deprecated and in the process of being removed.</p><p>Note: Remove this section when all dialects have been switched to the new accessor form.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/AttributesAndTypes/ title="Defining Dialect Attributes and Types"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Defining Dialect Attributes and Types</a>
<a class="nav nav-next" href=/docs/Diagnostics/ title="Diagnostic Infrastructure">Next - Diagnostic Infrastructure <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li class=active><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>