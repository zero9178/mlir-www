<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Symbols and Symbol Tables - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Symbols and Symbol Tables</h1><p><nav id=TableOfContents><ul><li><a href=#symbol>Symbol</a><ul><li><a href=#defining-or-declaring-a-symbol>Defining or declaring a Symbol</a></li></ul></li><li><a href=#symbol-table>Symbol Table</a><ul><li><a href=#referencing-a-symbol>Referencing a Symbol</a></li><li><a href=#manipulating-a-symbol>Manipulating a Symbol</a></li></ul></li><li><a href=#symbol-visibility>Symbol Visibility</a></li></ul></nav><p>With
<a href=/docs/LangRef/#regions>Regions</a>, the multi-level aspect of MLIR is
structural in the IR. A lot of infrastructure within the compiler is built
around this nesting structure; including the processing of operations within the
<a href=/docs/PassManagement/#pass-manager>pass manager</a>. One advantage of the MLIR
design is that it is able to process operations in parallel, utilizing multiple
threads. This is possible due to a property of the IR known as
<a href=/docs/Traits/#isolatedfromabove><code>IsolatedFromAbove</code></a>.</p><p>Without this property, any operation could affect or mutate the use-list of
operations defined above. Making this thread-safe requires expensive locking in
some of the core IR data structures, which becomes quite inefficient. To enable
multi-threaded compilation without this locking, MLIR uses local pools for
constant values as well as <code>Symbol</code> accesses for global values and variables.
This document details the design of <code>Symbol</code>s, what they are and how they fit
into the system.</p><p>The <code>Symbol</code> infrastructure essentially provides a non-SSA mechanism in which to
refer to an operation symbolically with a name. This allows for referring to
operations defined above regions that were defined as <code>IsolatedFromAbove</code> in a
safe way. It also allows for symbolically referencing operations define below
other regions as well.</p><h2 id=symbol>Symbol&nbsp;<a class=headline-hash href=#symbol>¶</a></h2><p>A <code>Symbol</code> is a named operation that resides immediately within a region that
defines a
<a href=#symbol-table><code>SymbolTable</code></a>. The name of a symbol <em>must</em> be unique
within the parent <code>SymbolTable</code>. This name is semantically similarly to an SSA
result value, and may be referred to by other operations to provide a symbolic
link, or use, to the symbol. An example of a <code>Symbol</code> operation is
<a href=/docs/Dialects/Builtin/#func-mlirfuncop><code>func.func</code></a>. <code>func.func</code> defines a
symbol name, which is
<a href=#referencing-a-symbol>referred to</a> by operations like
<a href=/docs/Dialects/Func/#funccall-callop><code>func.call</code></a>.</p><h3 id=defining-or-declaring-a-symbol>Defining or declaring a Symbol&nbsp;<a class=headline-hash href=#defining-or-declaring-a-symbol>¶</a></h3><p>A <code>Symbol</code> operation should use the <code>SymbolOpInterface</code> interface to provide the
necessary verification and accessors; it also supports operations, such as
<code>builtin.module</code>, that conditionally define a symbol. <code>Symbol</code>s must have the
following properties:</p><ul><li>A <code>StringAttr</code> attribute named
&lsquo;SymbolTable::getSymbolAttrName()'(<code>sym_name</code>).<ul><li>This attribute defines the symbolic &lsquo;name&rsquo; of the operation.</li></ul></li><li>An optional <code>StringAttr</code> attribute named
&lsquo;SymbolTable::getVisibilityAttrName()'(<code>sym_visibility</code>)<ul><li>This attribute defines the
<a href=#symbol-visibility>visibility</a> of the
symbol, or more specifically in-which scopes it may be accessed.</li></ul></li><li>No SSA results<ul><li>Intermixing the different ways to <code>use</code> an operation quickly becomes
unwieldy and difficult to analyze.</li></ul></li><li>Whether this operation is a declaration or definition (<code>isDeclaration</code>)<ul><li>Declarations do not define a new symbol but reference a symbol defined
outside the visible IR.</li></ul></li></ul><h2 id=symbol-table>Symbol Table&nbsp;<a class=headline-hash href=#symbol-table>¶</a></h2><p>Described above are <code>Symbol</code>s, which reside within a region of an operation
defining a <code>SymbolTable</code>. A <code>SymbolTable</code> operation provides the container for
the
<a href=#symbol><code>Symbol</code></a> operations. It verifies that all <code>Symbol</code> operations
have a unique name, and provides facilities for looking up symbols by name.
Operations defining a <code>SymbolTable</code> must use the <code>OpTrait::SymbolTable</code> trait.</p><h3 id=referencing-a-symbol>Referencing a Symbol&nbsp;<a class=headline-hash href=#referencing-a-symbol>¶</a></h3><p><code>Symbol</code>s are referenced symbolically by name via the
<a href=/docs/Dialects/Builtin/#symbolrefattr><code>SymbolRefAttr</code></a> attribute. A symbol
reference attribute contains a named reference to an operation that is nested
within a symbol table. It may optionally contain a set of nested references that
further resolve to a symbol nested within a different symbol table. When
resolving a nested reference, each non-leaf reference must refer to a symbol
operation that is also a
<a href=#symbol-table>symbol table</a>.</p><p>Below is an example of how an operation can reference a symbol operation:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// This `func.func` operation defines a symbol named `symbol`.
</span><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@symbol</span><span class=p>()</span>

<span class=c>// Our `foo.user` operation contains a SymbolRefAttr with the name of the
</span><span class=c>// `symbol` func.
</span><span class=c></span><span class=s>&#34;foo.user&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>uses =</span> <span class=p>[</span><span class=nf>@symbol</span><span class=p>]}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>

<span class=c>// Symbol references resolve to the nearest parent operation that defines a
</span><span class=c>// symbol table, so we can have references with arbitrary nesting levels.
</span><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@other_symbol</span><span class=p>()</span> <span class=p>{</span>
  affine<span class=p>.</span>for <span class=nv>%i0</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>10</span> <span class=p>{</span>
    <span class=c>// Our `foo.user` operation resolves to the same `symbol` func as defined
</span><span class=c></span>    <span class=c>// above.
</span><span class=c></span>    <span class=s>&#34;foo.user&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>uses =</span> <span class=p>[</span><span class=nf>@symbol</span><span class=p>]}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=p>}</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=c>// Here we define a nested symbol table. References within this operation will
</span><span class=c>// not resolve to any symbols defined above.
</span><span class=c></span>module <span class=p>{</span>
  <span class=c>// Error. We resolve references with respect to the closest parent operation
</span><span class=c></span>  <span class=c>// that defines a symbol table, so this reference can&#39;t be resolved.
</span><span class=c></span>  <span class=s>&#34;foo.user&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>uses =</span> <span class=p>[</span><span class=nf>@symbol</span><span class=p>]}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=p>}</span>

<span class=c>// Here we define another nested symbol table, except this time it also defines
</span><span class=c>// a symbol.
</span><span class=c></span>module <span class=nf>@module_symbol</span> <span class=p>{</span>
  <span class=c>// This `func.func` operation defines a symbol named `nested_symbol`.
</span><span class=c></span>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@nested_symbol</span><span class=p>()</span>
<span class=p>}</span>

<span class=c>// Our `foo.user` operation may refer to the nested symbol, by resolving through
</span><span class=c>// the parent.
</span><span class=c></span><span class=s>&#34;foo.user&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>uses =</span> <span class=p>[</span><span class=nf>@module_symbol</span><span class=p>::</span><span class=nf>@nested_symbol</span><span class=p>]}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><p>Using an attribute, as opposed to an SSA value, has several benefits:</p><ul><li><p>References may appear in more places than the operand list; including
<a href=Dialects/Builtin.md/dictionaryattr>nested attribute dictionaries</a>,
<a href=/docs/Dialects/Builtin/#arrayattr>array attributes</a>, etc.</p></li><li><p>Handling of SSA dominance remains unchanged.</p><ul><li>If we were to use SSA values, we would need to create some mechanism in
which to opt-out of certain properties of it such as dominance.
Attributes allow for referencing the operations irregardless of the
order in which they were defined.</li><li>Attributes simplify referencing operations within nested symbol tables,
which are traditionally not visible outside of the parent region.</li></ul></li></ul><p>The impact of this choice to use attributes as opposed to SSA values is that we
now have two mechanisms with reference operations. This means that some dialects
must either support both <code>SymbolRefs</code> and SSA value references, or provide
operations that materialize SSA values from a symbol reference. Each has
different trade offs depending on the situation. A function call may directly
use a <code>SymbolRef</code> as the callee, whereas a reference to a global variable might
use a materialization operation so that the variable can be used in other
operations like <code>arith.addi</code>.
<a href=/docs/Dialects/LLVM/#llvmmliraddressof-mlirllvmaddressofop><code>llvm.mlir.addressof</code></a>
is one example of such an operation.</p><p>See the <code>LangRef</code> definition of the
<a href=/docs/Dialects/Builtin/#symbolrefattr><code>SymbolRefAttr</code></a> for more information about
the structure of this attribute.</p><p>Operations that reference a <code>Symbol</code> and want to perform verification and
general mutation of the symbol should implement the <code>SymbolUserOpInterface</code> to
ensure that symbol accesses are legal and efficient.</p><h3 id=manipulating-a-symbol>Manipulating a Symbol&nbsp;<a class=headline-hash href=#manipulating-a-symbol>¶</a></h3><p>As described above, <code>SymbolRefs</code> act as an auxiliary way of defining uses of
operations to the traditional SSA use-list. As such, it is imperative to provide
similar functionality to manipulate and inspect the list of uses and the users.
The following are a few of the utilities provided by the <code>SymbolTable</code>:</p><ul><li><p><code>SymbolTable::getSymbolUses</code></p><ul><li>Access an iterator range over all of the uses on and nested within a
particular operation.</li></ul></li><li><p><code>SymbolTable::symbolKnownUseEmpty</code></p><ul><li>Check if a particular symbol is known to be unused within a specific
section of the IR.</li></ul></li><li><p><code>SymbolTable::replaceAllSymbolUses</code></p><ul><li>Replace all of the uses of one symbol with a new one within a specific
section of the IR.</li></ul></li><li><p><code>SymbolTable::lookupNearestSymbolFrom</code></p><ul><li>Lookup the definition of a symbol in the nearest symbol table from some
anchor operation.</li></ul></li></ul><h2 id=symbol-visibility>Symbol Visibility&nbsp;<a class=headline-hash href=#symbol-visibility>¶</a></h2><p>Along with a name, a <code>Symbol</code> also has a <code>visibility</code> attached to it. The
<code>visibility</code> of a symbol defines its structural reachability within the IR. A
symbol has one of the following visibilities:</p><ul><li><p>Public (Default)</p><ul><li>The symbol may be referenced from outside of the visible IR. We cannot
assume that all of the uses of this symbol are observable. If the
operation declares a symbol (as opposed to defining it), public
visibility is not allowed because symbol declarations are not intended
to be used from outside the visible IR.</li></ul></li><li><p>Private</p><ul><li>The symbol may only be referenced from within the current symbol table.</li></ul></li><li><p>Nested</p><ul><li>The symbol may be referenced by operations outside of the current symbol
table, but not outside of the visible IR, as long as each symbol table
parent also defines a non-private symbol.</li></ul></li></ul><p>For Functions, the visibility is printed after the operation name without a
quote. A few examples of what this looks like in the IR are shown below:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module <span class=nf>@public_module</span> <span class=p>{</span>
  <span class=c>// This function can be accessed by &#39;live.user&#39;, but cannot be referenced
</span><span class=c></span>  <span class=c>// externally; all uses are known to reside within parent regions.
</span><span class=c></span>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> nested <span class=nf>@nested_function</span><span class=p>()</span>

  <span class=c>// This function cannot be accessed outside of &#39;public_module&#39;.
</span><span class=c></span>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> private <span class=nf>@private_function</span><span class=p>()</span>
<span class=p>}</span>

<span class=c>// This function can only be accessed from within the top-level module.
</span><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> private <span class=nf>@private_function</span><span class=p>()</span>

<span class=c>// This function may be referenced externally.
</span><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@public_function</span><span class=p>()</span>

<span class=s>&#34;live.user&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>uses =</span> <span class=p>[</span>
  <span class=nf>@public_module</span><span class=p>::</span><span class=nf>@nested_function</span><span class=p>,</span>
  <span class=nf>@private_function</span><span class=p>,</span>
  <span class=nf>@public_function</span>
<span class=p>]}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/SPIRVToLLVMDialectConversion/ title="SPIR-V Dialect to LLVM Dialect conversion manual"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - SPIR-V Dialect to LLVM Dialect conversion manual</a>
<a class="nav nav-next" href=/docs/DeclarativeRewrites/ title="Table-driven Declarative Rewrite Rule (DRR)">Next - Table-driven Declarative Rewrite Rule (DRR) <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li class=active><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>