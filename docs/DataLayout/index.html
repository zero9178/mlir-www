<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Data Layout Modeling - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/DataLayout/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Data Layout Modeling</h1><p>Data layout information allows the compiler to answer questions related to how a
value of a particular type is stored in memory. For example, the size of a value
or its address alignment requirements. It enables, among others, the generation
of various linear memory addressing schemes for containers of abstract types and
deeper reasoning about vectors.</p><p>The data layout subsystem is designed to scale to MLIR&rsquo;s open type and operation
system. At the top level, it consists of:</p><ul><li>attribute interfaces that can be implemented by concrete data layout
specifications;</li><li>type interfaces that should be implemented by types subject to data layout;</li><li>operation interfaces that must be implemented by operations that can serve
as data layout scopes (e.g., modules);</li><li>and dialect interfaces for data layout properties unrelated to specific
types.</li></ul><p>Built-in types are handled specially to decrease the overall query cost.
Similarly, built-in <code>ModuleOp</code> supports data layouts without going through the
interface.</p><h2 id=usage>Usage&nbsp;<a class=headline-hash href=#usage>¶</a></h2><h3 id=scoping>Scoping&nbsp;<a class=headline-hash href=#scoping>¶</a></h3><p>Following MLIR&rsquo;s nested structure, data layout properties are <em>scoped</em> to
regions belonging to either operations that implement the
<code>DataLayoutOpInterface</code> or <code>ModuleOp</code> operations. Such scoping operations
partially control the data layout properties and may have attributes that affect
them, typically organized in a data layout specification.</p><p>Types may have a different data layout in different scopes, including scopes
that are nested in other scopes such as modules contained in other modules. At
the same time, within the given scope excluding any nested scope, a given type
has fixed data layout properties. Types are also expected to have a default,
&ldquo;natural&rdquo; data layout in case they are used outside of any operation that
provides data layout scope for them. This ensures that data layout queries
always have a valid result.</p><h3 id=compatibility-and-transformations>Compatibility and Transformations&nbsp;<a class=headline-hash href=#compatibility-and-transformations>¶</a></h3><p>The information necessary to compute layout properties can be combined from
nested scopes. For example, an outer scope can define layout properties for a
subset of types while inner scopes define them for a disjoint subset, or scopes
can progressively relax alignment requirements on a type. This mechanism is
supported by the notion of data layout <em>compatibility</em>: the layout defined in a
nested scope is expected to be compatible with that of the outer scope. MLIR
does not prescribe what compatibility means for particular ops and types but
provides hooks for them to provide target- and type-specific checks. For
example, one may want to only allow relaxation of alignment constraints (i.e.,
smaller alignment) in nested modules or, alternatively, one may require nested
modules to fully redefine all constraints of the outer scope.</p><p>Data layout compatibility is also relevant during IR transformation. Any
transformation that affects the data layout scoping operation is expected to
maintain data layout compatibility. It is under responsibility of the
transformation to ensure it is indeed the case.</p><h3 id=queries>Queries&nbsp;<a class=headline-hash href=#queries>¶</a></h3><p>Data layout property queries can be performed on the special object &ndash;
<code>DataLayout</code> &ndash; which can be created for the given scoping operation. These
objects allow one to interface with the data layout infrastructure and query
properties of given types in the scope of the object. The signature of
<code>DataLayout</code> class is as follows.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>DataLayout</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=k>explicit</span> <span class=n>DataLayout</span><span class=p>(</span><span class=n>DataLayoutOpInterface</span> <span class=n>scope</span><span class=p>);</span>

  <span class=kt>unsigned</span> <span class=nf>getTypeSize</span><span class=p>(</span><span class=n>Type</span> <span class=n>type</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=nf>getTypeSizeInBits</span><span class=p>(</span><span class=n>Type</span> <span class=n>type</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=nf>getTypeABIAlignment</span><span class=p>(</span><span class=n>Type</span> <span class=n>type</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=nf>getTypePreferredAlignment</span><span class=p>(</span><span class=n>Type</span> <span class=n>type</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>The user can construct the <code>DataLayout</code> object for the scope of interest. Since
the data layout properties are fixed in the scope, they will be computed only
once upon first request and cached for further use. Therefore,
<code>DataLayout(op.getParentOfType&lt;DataLayoutOpInterface>()).getTypeSize(type)</code> is
considered an anti-pattern since it discards the cache after use. Because of
caching, a <code>DataLayout</code> object returns valid results as long as the data layout
properties of enclosing scopes remain the same, that is, as long as none of the
ancestor operations are modified in a way that affects data layout. After such a
modification, the user is expected to create a fresh <code>DataLayout</code> object. To aid
with this, <code>DataLayout</code> asserts that the scope remains identical if MLIR is
compiled with assertions enabled.</p><h2 id=custom-implementations>Custom Implementations&nbsp;<a class=headline-hash href=#custom-implementations>¶</a></h2><p>Extensibility of the data layout modeling is provided through a set of MLIR
<a href=/docs/Interfaces/>Interfaces</a>.</p><h3 id=data-layout-specifications>Data Layout Specifications&nbsp;<a class=headline-hash href=#data-layout-specifications>¶</a></h3><p>Data layout specification is an
<a href=/docs/LangRef/#attributes>attribute</a> that is
conceptually a collection of key-value pairs called data layout specification
<em>entries</em>. Data layout specification attributes implement the
<code>DataLayoutSpecInterface</code>, described below. Each entry is itself an attribute
that implements the <code>DataLayoutEntryInterface</code>. Entries have a key, either a
<code>Type</code> or a <code>StringAttr</code>, and a value. Keys are used to associate entries with
specific types or dialects: when handling a data layout properties request, a
type or a dialect can only see the specification entries relevant to them and
must go through the supplied <code>DataLayout</code> object for any recursive query. This
supports and enforces better composability because types cannot (and should not)
understand layout details of other types. Entry values are arbitrary attributes,
specific to the type.</p><p>For example, a data layout specification may be an actual list of pairs with
simple custom syntax resembling the following:</p><pre><code>#my_dialect.layout_spec&lt;
  #my_dialect.layout_entry&lt;!my_dialect.type, size=42&gt;,
  #my_dialect.layout_entry&lt;&quot;my_dialect.endianness&quot;, &quot;little&quot;&gt;,
  #my_dialect.layout_entry&lt;!my_dialect.vector, prefer_large_alignment&gt;&gt;
</code></pre><p>The exact details of the specification and entry attributes, as well as their
syntax, are up to implementations.</p><p>We use the notion of <em>type class</em> throughout the data layout subsystem. It
corresponds to the C++ class of the given type, e.g., <code>IntegerType</code> for built-in
integers. MLIR does not have a mechanism to represent type classes in the IR.
Instead, data layout entries contain specific <em>instances</em> of a type class, for
example, <code>IntegerType{signedness=signless, bitwidth=8}</code> (or <code>i8</code> in the IR) or
<code>IntegerType{signedness=unsigned, bitwidth=32}</code> (or <code>ui32</code> in the IR). When
handling a data layout property query, a type class will be supplied with <em>all</em>
entries with keys belonging to this type class. For example, <code>IntegerType</code> will
see the entries for <code>i8</code>, <code>si16</code> and <code>ui32</code>, but will <em>not</em> see those for <code>f32</code>
or <code>memref&lt;?xi32></code> (neither will <code>MemRefType</code> see the entry for <code>i32</code>). This
allows for type-specific &ldquo;interpolation&rdquo; behavior where a type class can compute
data layout properties of <em>any</em> specific type instance given properties of other
instances. Using integers as an example again, their alignment could be computed
by taking that of the closest from above integer type with power-of-two
bitwidth.</p><h2 id=datalayoutentryinterface-datalayoutentryinterface>DataLayoutEntryInterface (<code>DataLayoutEntryInterface</code>)&nbsp;<a class=headline-hash href=#datalayoutentryinterface-datalayoutentryinterface>¶</a></h2><p>Attribute interface describing an entry in a data layout specification.</p><p>A data layout specification entry is a key-value pair. Its key is either a
type, when the entry is related to a type or a class of types, or an
identifier, when it is not. <code>DataLayoutEntryKey</code> is an alias allowing one
to use both key types. Its value is an arbitrary attribute that is
interpreted either by the type for type keys or by the dialect containing
the identifier for identifier keys. The interface provides a hook that
can be used by specific implementations to delegate the verification of
attribute fitness for a particular key to the relevant type or dialect.</p><h3 id=methods>Methods:&nbsp;<a class=headline-hash href=#methods>¶</a></h3><h4 id=getkey><code>getKey</code>&nbsp;<a class=headline-hash href=#getkey>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryKey</span> <span class=n>getKey</span><span class=p>();</span>
</code></pre></div><p>Returns the key of the this layout entry.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getvalue><code>getValue</code>&nbsp;<a class=headline-hash href=#getvalue>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Attribute</span> <span class=n>getValue</span><span class=p>();</span>
</code></pre></div><p>Returns the value of this layout entry.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=verifyentry><code>verifyEntry</code>&nbsp;<a class=headline-hash href=#verifyentry>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span> <span class=n>verifyEntry</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Location</span> <span class=n>loc</span><span class=p>);</span>
</code></pre></div><p>Checks that the entry is well-formed, reports errors at the provided location.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=datalayoutspecinterface-datalayoutspecinterface>DataLayoutSpecInterface (<code>DataLayoutSpecInterface</code>)&nbsp;<a class=headline-hash href=#datalayoutspecinterface-datalayoutspecinterface>¶</a></h2><p>Attribute interface describing a data layout specification.</p><p>A data layout specification is seen as a sequence of entries, each of which
is an attribute implementing the data layout entry interface. It assumes
a contiguous underlying storage for entries. The interface provides a hook
for implementations to verify the well-formedness of the specification,
with a default implementation that verifies the absence of entries with
duplicate keys and the well-formedness of each individual entry before
dispatching to the type or dialect the entry is associated with.</p><p>Data layout specifications may need to be combined in case they appear on
nested operations subject to layout, or to ensure the validity of layout
modification. Concrete specification attributes must implement the
corresponding hook.</p><h3 id=methods-1>Methods:&nbsp;<a class=headline-hash href=#methods-1>¶</a></h3><h4 id=combinewith><code>combineWith</code>&nbsp;<a class=headline-hash href=#combinewith>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutSpecInterface</span> <span class=n>combineWith</span><span class=p>(</span><span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>ArrayRef</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutSpecInterface</span><span class=o>&gt;</span> <span class=n>specs</span><span class=p>);</span>
</code></pre></div><p>Combines the current layout with the given list of layouts, provided from the outermost (oldest) to the innermost (newest). Returns null on failure.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getentries><code>getEntries</code>&nbsp;<a class=headline-hash href=#getentries>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>getEntries</span><span class=p>();</span>
</code></pre></div><p>Returns the list of layout entries.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getspecfortype><code>getSpecForType</code>&nbsp;<a class=headline-hash href=#getspecfortype>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryList</span> <span class=n>getSpecForType</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>TypeID</span> <span class=n>type</span><span class=p>);</span>
</code></pre></div><p>Returns a copy of the entries related to a specific type class regardles of type parameters.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getspecforidentifier><code>getSpecForIdentifier</code>&nbsp;<a class=headline-hash href=#getspecforidentifier>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryInterface</span> <span class=n>getSpecForIdentifier</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>identifier</span><span class=p>);</span>
</code></pre></div><p>Returns the entry related to the given identifier, if present.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=verifyspec><code>verifySpec</code>&nbsp;<a class=headline-hash href=#verifyspec>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span> <span class=n>verifySpec</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Location</span> <span class=n>loc</span><span class=p>);</span>
</code></pre></div><p>Verifies the validity of the specification and reports any errors at the given location.
NOTE: This method <em>must</em> be implemented by the user.</p><h3 id=data-layout-scoping-operations>Data Layout Scoping Operations&nbsp;<a class=headline-hash href=#data-layout-scoping-operations>¶</a></h3><p>Operations that define a scope for data layout queries, and that can be used to
create a <code>DataLayout</code> object, are expected to implement the
<code>DataLayoutOpInterface</code>. Such ops must provide at least a way of obtaining the
data layout specification. The specification need not be necessarily attached to
the operation as an attribute and may be constructed on-the-fly; it is only
fetched once per <code>DataLayout</code> object and cached. Such ops may also provide
custom handlers for data layout queries that provide results without forwarding
the queries down to specific types or post-processing the results returned by
types in target- or scope-specific ways. These custom handlers make it possible
for scoping operations to (re)define data layout properties for types without
having to modify the types themselves, e.g., when types are defined in another
dialect.</p><h2 id=datalayoutopinterface-datalayoutopinterface>DataLayoutOpInterface (<code>DataLayoutOpInterface</code>)&nbsp;<a class=headline-hash href=#datalayoutopinterface-datalayoutopinterface>¶</a></h2><p>Interface for operations that can have a data layout specification attached.</p><p>The <code>DataLayout</code> object, which can be used for data layout queries, can be
constructed for such operations. The absence of a data layout specification
must be handled without failing.</p><p>Concrete operations must implement the hook returning the data layout
specification. They may optionally override the methods used in data layout
queries, default implementations of which provide predefined answers for
built-in types and dispatch to the type interface for all other types. These
methods must be idempotent, that is return the same result on repeated
queries with the same parameters. They are declared static and therefore
have no access to the operation or its attributes. Instead, they receive a
list of data layout entries relevant to the request. The entries are known
to have passed the spec and entry verifier.</p><h3 id=methods-2>Methods:&nbsp;<a class=headline-hash href=#methods-2>¶</a></h3><h4 id=getdatalayoutspec><code>getDataLayoutSpec</code>&nbsp;<a class=headline-hash href=#getdatalayoutspec>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutSpecInterface</span> <span class=n>getDataLayoutSpec</span><span class=p>();</span>
</code></pre></div><p>Returns the data layout specification for this op, or null if it does not exist.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypesize><code>getTypeSize</code>&nbsp;<a class=headline-hash href=#gettypesize>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getTypeSize</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the size of the given type computed using the relevant entries. The data layout object can be used for recursive queries.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypesizeinbits><code>getTypeSizeInBits</code>&nbsp;<a class=headline-hash href=#gettypesizeinbits>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getTypeSizeInBits</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the size of the given type in bits computed using the relevant entries. The data layout object can be used for recursive queries.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypeabialignment><code>getTypeABIAlignment</code>&nbsp;<a class=headline-hash href=#gettypeabialignment>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getTypeABIAlignment</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the alignment required by the ABI for the given type computed using the relevant entries. The data layout object can be used for recursive queries.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypepreferredalignment><code>getTypePreferredAlignment</code>&nbsp;<a class=headline-hash href=#gettypepreferredalignment>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=kt>unsigned</span> <span class=nf>getTypePreferredAlignment</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>type</span><span class=p>,</span> <span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the alignment preferred by the given type computed using the relevant entries. The data layoutobject can be used for recursive queries.
NOTE: This method <em>must</em> be implemented by the user.</p><h3 id=types-with-data-layout>Types with Data Layout&nbsp;<a class=headline-hash href=#types-with-data-layout>¶</a></h3><p>Type classes that intend to handle data layout queries themselves are expected
to implement the <code>DataLayoutTypeInterface</code>. This interface provides overridable
hooks for each data layout query. Each of these hooks is supplied with the type
instance, a <code>DataLayout</code> object suitable for recursive queries, and a list of
data layout queries relevant for the type class. It is expected to provide a
valid result even if the list of entries is empty. These hooks do not have
access to the operation in the scope of which the query is handled and should
use the supplied entries instead.</p><h2 id=datalayouttypeinterface-datalayouttypeinterface>DataLayoutTypeInterface (<code>DataLayoutTypeInterface</code>)&nbsp;<a class=headline-hash href=#datalayouttypeinterface-datalayouttypeinterface>¶</a></h2><p>Interface for types subject to data layout.</p><p>Types willing to be supported by the data layout subsystem should implement
this interface by providing implementations of functions querying their
size, required and preferred alignment. Each of these functions accepts as
arguments a data layout object that can be used to perform recursive queries
in the same scope, and a list of data layout entries relevant to this type.
Specifically, the entries are those that have as key <em>any instance</em> of the
same type class as the current type. For example, if IntegerType had
implemented this interface, it would have received the entries with keys i1,
i2, i8, etc. regardless of the bitwidth of this type. This mechanism allows
types to &ldquo;interpolate&rdquo; the results in a type-specific way instead of listing
all possible types in the specification.</p><p>The list of entries may be empty, in which case the type must provide a
reasonable default value. The entries in the list are known to have passed
the spec and the entry verifiers, as well as the type-specified verifier if
provided.</p><p>In case of nested layout specs or spec changes, the type can override a hook
indicating whether the outer (old) and the inner (new) spec are compatible.</p><h3 id=methods-3>Methods:&nbsp;<a class=headline-hash href=#methods-3>¶</a></h3><h4 id=gettypesize-1><code>getTypeSize</code>&nbsp;<a class=headline-hash href=#gettypesize-1>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>unsigned</span> <span class=nf>getTypeSize</span><span class=p>(</span><span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the size of this type in bytes.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypesizeinbits-1><code>getTypeSizeInBits</code>&nbsp;<a class=headline-hash href=#gettypesizeinbits-1>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>unsigned</span> <span class=nf>getTypeSizeInBits</span><span class=p>(</span><span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the size of this type in bits.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getabialignment><code>getABIAlignment</code>&nbsp;<a class=headline-hash href=#getabialignment>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>unsigned</span> <span class=nf>getABIAlignment</span><span class=p>(</span><span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the ABI-required alignment for this type, in bytes
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getpreferredalignment><code>getPreferredAlignment</code>&nbsp;<a class=headline-hash href=#getpreferredalignment>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>unsigned</span> <span class=nf>getPreferredAlignment</span><span class=p>(</span><span class=k>const</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayout</span> <span class=o>&amp;</span><span class=n>dataLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>params</span><span class=p>);</span>
</code></pre></div><p>Returns the preferred alignment for this type, in bytes.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=arecompatible><code>areCompatible</code>&nbsp;<a class=headline-hash href=#arecompatible>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>bool</span> <span class=nf>areCompatible</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>oldLayout</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>newLayout</span><span class=p>);</span>
</code></pre></div><p>Returns true if the two lists of entries are compatible, that is, that <code>newLayout</code> spec entries can be nested in an op with <code>oldLayout</code> spec entries.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=verifyentries><code>verifyEntries</code>&nbsp;<a class=headline-hash href=#verifyentries>¶</a></h4><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span> <span class=n>verifyEntries</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DataLayoutEntryListRef</span> <span class=n>entries</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Location</span> <span class=n>loc</span><span class=p>);</span>
</code></pre></div><p>Verifies that the given list of entries is valid for this type.
NOTE: This method <em>must</em> be implemented by the user.</p><h3 id=dialects-with-data-layout-identifiers>Dialects with Data Layout Identifiers&nbsp;<a class=headline-hash href=#dialects-with-data-layout-identifiers>¶</a></h3><p>For data layout entries that are not related to a particular type class, the key
of the entry is an Identifier that belongs to some dialect. In this case, the
dialect is expected to implement the <code>DataLayoutDialectInterface</code>. This dialect
provides hooks for verifying the validity of the entry value attributes and for
and the compatibility of nested entries.</p><h3 id=bits-and-bytes>Bits and Bytes&nbsp;<a class=headline-hash href=#bits-and-bytes>¶</a></h3><p>Two versions of hooks are provided for sizes: in bits and in bytes. The version
in bytes has a default implementation that derives the size in bytes by rounding
up the result of division of the size in bits by 8. Types exclusively targeting
architectures with different assumptions can override this. Operations can
redefine this for all types, providing scoped versions for cases of byte sizes
other than eight without having to modify types, including built-in types.</p><h3 id=query-dispatch>Query Dispatch&nbsp;<a class=headline-hash href=#query-dispatch>¶</a></h3><p>The overall flow of a data layout property query is as follows.</p><ol><li>The user constructs a <code>DataLayout</code> at the given scope. The constructor
fetches the data layout specification and combines it with those of
enclosing scopes (layouts are expected to be compatible).</li><li>The user calls <code>DataLayout::query(Type ty)</code>.</li><li>If <code>DataLayout</code> has a cached response, this response is returned
immediately.</li><li>Otherwise, the query is handed down by <code>DataLayout</code> to the closest layout
scoping operation. If it implements <code>DataLayoutOpInterface</code>, then the query
is forwarded to<code>DataLayoutOpInterface::query(ty, *this, relevantEntries)</code>
where the relevant entries are computed as described above. If it does not
implement <code>DataLayoutOpInterface</code>, it must be a <code>ModuleOp</code>, and the query is
forwarded to <code>DataLayoutTypeInterface::query(dataLayout, relevantEntries)</code>
after casting <code>ty</code> to the type interface.</li><li>Unless the <code>query</code> hook is reimplemented by the op interface, the query is
handled further down to <code>DataLayoutTypeInterface::query(dataLayout, relevantEntries)</code> after casting <code>ty</code> to the type interface. If the type does
not implement the interface, an unrecoverable fatal error is produced.</li><li>The type is expected to always provide the response, which is returned up
the call stack and cached by the <code>DataLayout.</code></li></ol><h2 id=default-implementation>Default Implementation&nbsp;<a class=headline-hash href=#default-implementation>¶</a></h2><p>The default implementation of the data layout interfaces directly handles
queries for a subset of built-in types.</p><h3 id=built-in-modules>Built-in Modules&nbsp;<a class=headline-hash href=#built-in-modules>¶</a></h3><p>Built-in <code>ModuleOp</code> allows at most one attribute that implements
<code>DataLayoutSpecInterface</code>. It does not implement the entire interface for
efficiency and layering reasons. Instead, <code>DataLayout</code> can be constructed for
<code>ModuleOp</code> and handles modules transparently alongside other operations that
implement the interface.</p><h3 id=built-in-types>Built-in Types&nbsp;<a class=headline-hash href=#built-in-types>¶</a></h3><p>The following describes the default properties of built-in types.</p><p>The size of built-in integers and floats in bytes is computed as
<code>ceildiv(bitwidth, 8)</code>. The ABI alignment of integer types with bitwidth below
64 and of the float types is the closest from above power-of-two number of
bytes. The ABI alignment of integer types with bitwidth 64 and above is 4 bytes
(32 bits).</p><p>The size of built-in vectors is computed by first rounding their number of
elements in the <em>innermost</em> dimension to the closest power-of-two from above,
then getting the total number of elements, and finally multiplying it with the
element size. For example, <code>vector&lt;3xi32></code> and <code>vector&lt;4xi32></code> have the same
size. So do <code>vector&lt;2x3xf32></code> and <code>vector&lt;2x4xf32></code>, but <code>vector&lt;3x4xf32></code> and
<code>vector&lt;4x4xf32></code> have different sizes. The ABI and preferred alignment of
vector types is computed by taking the innermost dimension of the vector,
rounding it up to the closest power-of-two, taking a product of that with
element size in bytes, and rounding the result up again to the closest
power-of-two.</p><p>Note: these values are selected for consistency with the
<a href=https://llvm.org/docs/LangRef.html#data-layout>default data layout in LLVM</a>,
which MLIR assumed until the introduction of proper data layout modeling, and
with the
<a href=https://mlir.llvm.org/docs/Dialects/Vector/#deeperdive>modeling of n-D vectors</a>.
They <strong>may change</strong> in the future.</p><h4 id=index-type><code>index</code> type&nbsp;<a class=headline-hash href=#index-type>¶</a></h4><p>Index type is an integer type used for target-specific size information in,
e.g., <code>memref</code> operations. Its data layout is parameterized by a single integer
data layout entry that specifies its bitwidth. For example,</p><pre><code>module attributes { dlti.dl_spec = #dlti.dl_spec&lt;
  #dlti.dl_entry&lt;index, 32&gt;
&gt;} {}
</code></pre><p>specifies that <code>index</code> has 32 bits. All other layout properties of <code>index</code> match
those of the integer type with the same bitwidth defined above.</p><p>In absence of the corresponding entry, <code>index</code> is assumed to be a 64-bit
integer.</p><h4 id=complex-type><code>complex</code> type&nbsp;<a class=headline-hash href=#complex-type>¶</a></h4><p>By default complex type is treated like a 2 element structure of its given
element type. This is to say that each of its elements are aligned to their
preferred alignment, the entire complex type is also aligned to this preference,
and the complex type size includes the possible padding between elements to enforce
alignment.</p><h3 id=byte-size>Byte Size&nbsp;<a class=headline-hash href=#byte-size>¶</a></h3><p>The default data layout assumes 8-bit bytes.</p><h3 id=dlti-dialect>DLTI Dialect&nbsp;<a class=headline-hash href=#dlti-dialect>¶</a></h3><p>The
<a href=Dialects/DLTI.md>DLTI</a> dialect provides the attributes implementing
<code>DataLayoutSpecInterface</code> and <code>DataLayoutEntryInterface</code>, as well as a dialect
attribute that can be used to attach the specification to a given operation. The
verifier of this attribute triggers those of the specification and checks the
compatibility of nested specifications.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Bufferization/ title=Bufferization><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Bufferization</a>
<a class="nav nav-next" href=/docs/DebugActions/ title="Debug Actions">Next - Debug Actions <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li class=active><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>