<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Shape Inference - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/ShapeInference/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Shape Inference</h1><p>Shape inference as discussed here is considered a specific instance of type
inference for
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/IR/BuiltinTypes.h>ShapedType</a>. Type constraints are along (at least)
three axis: 1) elemental type, 2) rank (including static or dynamic), 3)
dimensions. While some operations have no compile time fixed shape (e.g., output
shape is dictated by data) we could still have some knowledge of
constraints/bounds in the system for that operation (e.g., the output of a
<code>tf.where</code> is at most the size of the input data). That is, there are additional
valuable constraints that could be captured even without full knowledge of the
shape.</p><p>Type inference is currently modelled executionally for operation creation using the
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Interfaces/InferTypeOpInterface.td><code>InferTypeOpInterface</code></a>, while
<code>InferShapedTypeOpInterface</code> is used to implement the shape and element type
inference. The return type can often be deduced from the deduced return shape
and elemental type (queryable from <code>InferShapedTypeOpInterface</code>) and so type
inference for tensor types can be implemented with <code>InferShapedTypeOpInterface</code>.</p><h2 id=shape-functions>Shape functions&nbsp;<a class=headline-hash href=#shape-functions>¶</a></h2><p>The C++ interfaces are the base mechanism whereby shape inference is queried and
executed, but not the intended way to specify shape constraints in general.</p><p>Initially the shape inference will be declaratively specified using:</p><ul><li><p>Constraints on the operands of an operation directly. For example
constraining the input type to be tensor/vector elements or that the
elemental type be of a specific type (e.g., output of computing the size
of a value is of elemental type <code>i1</code>) or class (e.g., float-like).</p></li><li><p>Constraints across operands and results of an operation.</p><ul><li>For example, specifying equality constraints on type/constituents of a
type (shape and elemental type) between operands and results (e.g., the
output type of an add is the same as those of the input operands).</li></ul></li></ul><p>NOTE: The C++ shape functions are an intermediate step until the shape dialect
is more full-fledged, at which point the C++ functions should become the
exceptional case.</p><h2 id=testing>Testing&nbsp;<a class=headline-hash href=#testing>¶</a></h2><p>Shape inference is currently tested alongside type inference by
<code>TestReturnTypeDriver</code> in the test dialect. This driver performs two checks:</p><ol><li>Verification that the return types specified matches the inferred types. This
explicit check will be removed and made part of Op verification instead.</li><li>Test the creation of Ops without specifying the return type explicitly in
function <code>testCreateFunctions</code> by creating new binary Ops (Op classes
specified in <code>TestReturnTypeDriver</code>) using 1) all operands to
<code>testCreateFunctions</code> as both operands, and 2) using combinations of input
operands of the function.</li></ol><h2 id=shape-dialect>Shape dialect&nbsp;<a class=headline-hash href=#shape-dialect>¶</a></h2><p>This section details the shape type inference dialect (<code>shape</code>). The initial
focus will be on shape functions that describe shape functions could be used in
runtime and compiler (for constructions of ops/refinement of shapes, reification
of dynamic allocations for dialect including TF, TFLite, XLA & tensor compute
dialect under discussion).</p><p>This will focus on the shape functions (e.g., determine the rank and dimensions
of the output shape). As shown in the shaped container type, shape will be one
of 3 components, the others being elemental type and attribute (which is
currently left open with the intention of supporting extensions such as layouts
or bounded shapes at a later point). This allows for decoupling of these:</p><ul><li>Not all the information is needed for all analysis;</li><li>Not all shape functions need to provide all the information (e.g., one could
define a base class function that only populates element type but composes
with the others);</li><li>It allows reusing the constraints between, say, Tensor and Memref
representation of an operation;</li></ul><p>An argument could be made that these are metadata function instead of shape
functions, with some considering shape and elemental types different and some considering them both as
part of shape. But <code>shape function</code> is IMHO descriptive and metadata can span
too large a range of potential uses/values.</p><h3 id=requirements>Requirements&nbsp;<a class=headline-hash href=#requirements>¶</a></h3><p>The requirements for the shape inference functions are determined by the
requirements of shape inference, but we believe the requirements below still
allow freedom to consider different shape inference approaches and so we do not
impose a particular shape inference approach here.</p><h4 id=shape-inference-functions>Shape inference functions&nbsp;<a class=headline-hash href=#shape-inference-functions>¶</a></h4><ul><li><p><strong>Expressiveness</strong> shape functions need to support programs where tensors
have shapes that are not known statically (for example, <code>tensor&lt;16x?xf32></code>
or <code>tensor&lt;*xf32>*</code>);</p></li><li><p><strong>Shape error detection</strong> Many operations will have constraints on their
operands. If the constraints are not satisfied or cannot be determined if
satisfied statically, then a runtime check/assertion could be generated.</p><ul><li>This also aligns with the requirement that the shape function description
should be usable by both the compiler and runtime.</li><li>Shape error functions should be easy to understand, at least what
constraint of the operation is violated. This also requires that shape
function error messages should be configurable by the author of the
shape function (e.g., the author would be able to give the semantic
constraint invalidated rather the low-level check that failed).</li><li>The static analysis may be used to eliminate run-time checks that are
guaranteed to pass.<ul><li>Ideally all would eventually (see section
<a href=#inline>Inlining shape checking</a>) be elided.</li></ul></li><li>Only reporting errors which are guaranteed to occur at runtime. If an error is only
possible (rather than guaranteed) then we use a runtime assertion to fail and produce an error
message with the invariant violated.</li></ul></li><li><p>Shape functions usable by compiler and runtime.</p><ul><li>This does not mean the exact same C++ function, but rather the
description should be consumable by either.</li><li>Shape function description should not be constrained by either runtime
or compiler&rsquo;s type system to handle types only used for analysis. That
is, these two type systems differ and both should be supported, but the
intersection of the two should not be required. As a particular example,
if a compiler only wants to differentiate exact shapes vs dynamic
shapes, then it need not consider a more generic shape lattice even
though the shape description supports it.</li></ul></li><li><p>Declarative (e.g., analyzable at compile time, possible to generate
different versions for different use cases)</p><ul><li>This may not strictly be a requirement, but a way to handle the former:
a declarative specification could be reused by both while avoiding a
need to map to or from a 3rd representation given these two systems
have/and will have different types.</li></ul></li><li><p>Shape inference functions are expressible at runtime</p><ul><li><p>User can define a shape function for a new operation dynamically at runtime,
this allows for vendors to describe an operation and shape function
dynamically.</p><p>This requirement is on the wishlist.</p></li></ul></li><li><p>Doesn&rsquo;t require graph-wide shape information (e.g., only require local
information)</p><ul><li>Shape functions should be cheap to invoke on each kernel launch.</li><li>Shape function can be dictated by arguments (operands, attributes and regions)
only (e.g., same operands as the corresponding operation could be
constructed & invoked with).</li><li>Shape information that needs higher-level/graph information should use
richer types (e.g., <code>TensorList&lt;F32></code>);</li><li>The function should be invocable before/while constructing an op (e.g.,
can&rsquo;t rely on the op being constructed).</li></ul></li><li><p>Shape functions should be pure functions.</p></li><li><p>Should support functions whose type is only known dynamically (e.g.,
<code>read_from_file</code> op)</p><ul><li>Without needing to invoke the op (e.g., reading a file once for
determining the shape & then post to be able to actually consume the
output of the file).</li></ul></li><li><p>The shape function operation dialect should be interoperable with non-shape function dialect operations.</p><ul><li><p>There may be a common set of operations that satisfy most uses (e.g., merge,
equal_type, arithmetic expressions, slice, concat, pattern matching on
attributes such as padding etc.) that will be discovered and could cover
a large percentage of the use cases. Among these there will be some
which carry extra semantic info that could be used for symbolic
constraints (e.g., checking equality of two dimensions resulting in
setting an equality constraint) and higher-order interpretation for
constraint solving.</p><p>It is therefore beneficial (but not required) to reuse operations,
especially as for statically known shapes, arbitrary arithmetic
computations could still be performed. This means that the computations
performed statically may or may not be supported by an arbitrary solver,
but would still be allowed.</p></li></ul></li><li><p>The shape function should be expandable such that symbolic equality and
upper bound constraints (say) could be represented and may be propagated by
shape inference.</p><ul><li>E.g., the shape functions may contain more information that is only
useful when used from shape inference;</li></ul></li><li><p>Shape functions are allowed to fail and report an error. The error reporting
should report the location of the operation that failed with, where
possible, a user actionable error message.</p><ul><li>These failures could become inlined and become runtime failures with
runtime values and error messages.</li><li>Reporting errors should be optional. E.g., The same function
may be used as to query validity without reporting an error.</li></ul></li></ul><h4 id=non-goals>Non-goals&nbsp;<a class=headline-hash href=#non-goals>¶</a></h4><ol><li>The shape dialect is an IR representations and not a programming language;<ul><li>While the functions should be readable, it doesn&rsquo;t carry the
conveniences of a programming language. Deciding how people write these
things, e.g. a mini dsl, a C++ API that generates them, extracting them
programmatically from <code>SetShapeFn</code> calls, etc., is still TBD.</li></ul></li><li>Describe the shape inference approach that will use the shape functions;<ul><li>The goal is that the shape functions and the constraints one could
obtain from them are general enough that they would be useful for
various analysis. But whether we follow very simple (e.g., only fully
static information is used for shape output, unranked for everything
else) to very advance (e.g., expression trees of symbolic constants) can
be evaluated independently of this proposal and with concrete benefit
analysis.</li></ul></li><li>Describe the approach whereby error messages will be generated;<ul><li>While the shape functions will be able to emit errors optionally, it
will be possible to dictate when they emit an error. This enables
deciding whether or which error to emit: there have been proposals in
the literature that the iteration order for shape inference affect the
quality of the error message produced, and the shape functions do not
mandate that.</li></ul></li><li>Flow sensitive shape functions;<ul><li>To enable scalable/cheap shape inference, the shape functions do not
intend to provide flow sensitive information. This facility could
potentially be built as part of some higher order analysis that reuse
the shape functions/constraints due to the shape functions.</li></ul></li><li>All static functions are usable for dynamic/unknown shapes;<ul><li>More involved computations can be performed with statically known shapes
than what can be sensibly analyzed with unknown/symbolic variables.</li></ul></li></ol><h3 id=discussion>Discussion&nbsp;<a class=headline-hash href=#discussion>¶</a></h3><h4 id=inline>Inline shape inference checks&nbsp;<a class=headline-hash href=#inline>¶</a></h4><p>Shape functions should be lowerable to runtime checks for validity. E.g. verify
as much as possible statically, but enable generating instructions to compute the
shape dynamically and or falling back to runtime checks for attributes not
verifiable at compile time. These checks inserted should ideally only check that
which could not have been verified statically.</p><p>These inlined calls could interfere with optimization patterns/passes (e.g.,
shape inference should not insert constructs that interfere with optimization
patterns) and so could be delayed until later (with another round of
optimizations, constant folding, CSE, etc., that should remove redundant runtime
operations).</p><h3 id=possibly-asked-questions>Possibly Asked Questions&nbsp;<a class=headline-hash href=#possibly-asked-questions>¶</a></h3><h4 id=what-about-ods-specifications-of-operations>What about ODS specifications of operations?&nbsp;<a class=headline-hash href=#what-about-ods-specifications-of-operations>¶</a></h4><p>In ODS we have been recording the constraints for the operands & attributes of
an operation. Where these are sufficient to constrain the output shape (e.g.,
<code>SameOperandAndResultType</code> or broadcastable) we should generate the shape
function from those. Where not, an explicit shape function should be specified
(spelling TBD but currently considering using the MLIR textual form as
serialization approach).</p><h4 id=why-not-extract-the-shape-function-from-reference-implementation>Why not extract the shape function from reference implementation?&nbsp;<a class=headline-hash href=#why-not-extract-the-shape-function-from-reference-implementation>¶</a></h4><p>This could be done in future! The extracted shape function would use the shape
inference dialect, so we are starting there. Especially for operations described in a
structured way, one could autogenerate the shape function.</p><h4 id=howin-what-language-will-the-shape-functions-be-authored>How/in what language will the shape functions be authored?&nbsp;<a class=headline-hash href=#howin-what-language-will-the-shape-functions-be-authored>¶</a></h4><p>TBD. open to many approaches and suggestions, starting on the IR produced by
whatever language is the priority of this proposal.</p><h4 id=what-shape-inference-approach-is-being-suggested-here>What shape inference approach is being suggested here?&nbsp;<a class=headline-hash href=#what-shape-inference-approach-is-being-suggested-here>¶</a></h4><p>None. There are multiple different shape inference approaches that we could
layer on top of these. From the most basic (always return unranked), to more
useful (return fixed shape for constant inputs/arguments) to the more advanced
(create logical conjunctions of algebraic statements between symbolic named
values).</p><h3 id=open-points>Open points&nbsp;<a class=headline-hash href=#open-points>¶</a></h3><ol><li>Should shape functions that produce dynamic outputs given all statically
shaped inputs be marked specially? E.g., read from file.</li></ol><p>TODO: Add examples here.</p><h2 id=wipfuture-considerations>WIP/Future considerations&nbsp;<a class=headline-hash href=#wipfuture-considerations>¶</a></h2><p>Shape functions are determined by attributes and could be arbitrarily
complicated with a wide-range of specification possibilities. Equality
relationships are common (e.g., the elemental type of the output matches the
primitive type of the inputs, both inputs have exactly the same type [primitive
type and shape]) and so these should be easy to specify. Algebraic relationships
would also be common (e.g., a concat of <code>[n,m]</code> and <code>[n,m]</code> matrix along axis 0
is <code>[n+n, m]</code> matrix), while some ops only have defined shapes under certain
cases (e.g., matrix multiplication of <code>[a,b]</code> and <code>[c,d]</code> is only defined if <code>b == c</code>).</p><p>Instead of specifying an additional mechanism to specify a shape transfer
function, the reference implementation of the operation will be used to derive
the shape function. The reference implementation is general and can support the
arbitrary computations needed to specify output shapes.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Rationale/UsageOfConst/ title="Usage of 'const' in MLIR, for core IR types"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Usage of 'const' in MLIR, for core IR types</a>
<a class="nav nav-next" href=/docs/SPIRVToLLVMDialectConversion/ title="SPIR-V Dialect to LLVM Dialect conversion manual">Next - SPIR-V Dialect to LLVM Dialect conversion manual <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li class=active><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>