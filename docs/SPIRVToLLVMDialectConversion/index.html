<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>SPIR-V Dialect to LLVM Dialect conversion manual - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>SPIR-V Dialect to LLVM Dialect conversion manual</h1><p>This manual describes the conversion from
<a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a>
to
<a href=/docs/Dialects/LLVM/>LLVM Dialect</a>. It assumes familiarity with both, and
describes the design choices behind the modelling of SPIR-V concepts in LLVM
Dialect. The conversion is an ongoing work, and is expected to grow as more
features are implemented.</p><p>Conversion can be performed by invoking an appropriate conversion pass:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>mlir-opt -convert-spirv-to-llvm &lt;filename.mlir&gt;
</code></pre></div><p>This pass performs type and operation conversions for SPIR-V operations as
described in this document.</p><p><nav id=TableOfContents><ul><li><a href=#type-conversion>Type Conversion</a><ul><li><a href=#scalar-types>Scalar types</a></li><li><a href=#vector-types>Vector types</a></li><li><a href=#pointer-types>Pointer types</a></li><li><a href=#array-types>Array types</a></li><li><a href=#struct-types>Struct types</a></li><li><a href=#not-implemented-types>Not implemented types</a></li></ul></li><li><a href=#operation-conversion>Operation Conversion</a><ul><li><a href=#arithmetic-ops>Arithmetic ops</a></li><li><a href=#bitwise-ops>Bitwise ops</a></li><li><a href=#cast-ops>Cast ops</a></li><li><a href=#comparison-ops>Comparison ops</a></li><li><a href=#composite-ops>Composite ops</a></li><li><a href=#spventrypoint-and-spvexecutionmode><code>spv.EntryPoint</code> and <code>spv.ExecutionMode</code></a></li><li><a href=#logical-ops>Logical ops</a></li><li><a href=#memory-ops>Memory ops</a></li><li><a href=#miscellaneous-ops-with-direct-conversions>Miscellaneous ops with direct conversions</a></li><li><a href=#shift-ops>Shift ops</a></li><li><a href=#spvconstant><code>spv.Constant</code></a></li><li><a href=#not-implemented-ops>Not implemented ops</a></li></ul></li><li><a href=#control-flow-conversion>Control flow conversion</a><ul><li><a href=#branch-ops>Branch ops</a></li><li><a href=#spvfunctioncall><code>spv.FunctionCall</code></a></li><li><a href=#spvmlirselection-and-spvmlirloop><code>spv.mlir.selection</code> and <code>spv.mlir.loop</code></a></li></ul></li><li><a href=#decorations-conversion>Decorations conversion</a></li><li><a href=#glsl-extended-instruction-set>GLSL extended instruction set</a><ul><li><a href=#direct-conversions-1>Direct conversions</a></li><li><a href=#special-cases-1>Special cases</a></li></ul></li><li><a href=#function-conversion-and-related-ops>Function conversion and related ops</a><ul><li><a href=#spvfunc><code>spv.func</code></a></li><li><a href=#spvreturn-and-spvreturnvalue><code>spv.Return</code> and <code>spv.ReturnValue</code></a></li></ul></li><li><a href=#module-ops>Module ops</a></li><li><a href=#mlir-spirv-cpu-runner><code>mlir-spirv-cpu-runner</code></a><ul><li><a href=#pipeline>Pipeline</a></li><li><a href=#walk-through>Walk-through</a></li></ul></li></ul></nav><h2 id=type-conversion>Type Conversion&nbsp;<a class=headline-hash href=#type-conversion>¶</a></h2><p>This section describes how SPIR-V Dialect types are mapped to LLVM Dialect.</p><h3 id=scalar-types>Scalar types&nbsp;<a class=headline-hash href=#scalar-types>¶</a></h3><table><thead><tr><th style=text-align:center>SPIR-V Dialect</th><th style=text-align:center>LLVM Dialect</th></tr></thead><tbody><tr><td style=text-align:center><code>i&lt;bitwidth></code></td><td style=text-align:center><code>!llvm.i&lt;bitwidth></code></td></tr><tr><td style=text-align:center><code>si&lt;bitwidth></code></td><td style=text-align:center><code>!llvm.i&lt;bitwidth></code></td></tr><tr><td style=text-align:center><code>ui&lt;bitwidth></code></td><td style=text-align:center><code>!llvm.i&lt;bitwidth></code></td></tr><tr><td style=text-align:center><code>f16</code></td><td style=text-align:center><code>f16</code></td></tr><tr><td style=text-align:center><code>f32</code></td><td style=text-align:center><code>f32</code></td></tr><tr><td style=text-align:center><code>f64</code></td><td style=text-align:center><code>f64</code></td></tr></tbody></table><h3 id=vector-types>Vector types&nbsp;<a class=headline-hash href=#vector-types>¶</a></h3><table><thead><tr><th style=text-align:center>SPIR-V Dialect</th><th style=text-align:center>LLVM Dialect</th></tr></thead><tbody><tr><td style=text-align:center><code>vector&lt;&lt;count> x &lt;scalar-type>></code></td><td style=text-align:center><code>vector&lt;&lt;count> x &lt;scalar-type>></code></td></tr></tbody></table><h3 id=pointer-types>Pointer types&nbsp;<a class=headline-hash href=#pointer-types>¶</a></h3><p>A SPIR-V pointer also takes a Storage Class. At the moment, conversion does
<strong>not</strong> take it into account.</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect</th><th style=text-align:center>LLVM Dialect</th></tr></thead><tbody><tr><td style=text-align:center><code>!spv.ptr&lt; &lt;element-type>, &lt;storage-class> ></code></td><td style=text-align:center><code>!llvm.ptr&lt;&lt;element-type>></code></td></tr></tbody></table><h3 id=array-types>Array types&nbsp;<a class=headline-hash href=#array-types>¶</a></h3><p>SPIR-V distinguishes between array type and run-time array type, the length of
which is not known at compile time. In LLVM, it is possible to index beyond the
end of the array. Therefore, runtime array can be implemented as a zero length
array type.</p><p>Moreover, SPIR-V supports the notion of array stride. Currently only natural
strides (based on
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/LayoutUtils.h><code>VulkanLayoutUtils</code></a>) are supported. They
are also mapped to LLVM array.</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect</th><th style=text-align:center>LLVM Dialect</th></tr></thead><tbody><tr><td style=text-align:center><code>!spv.array&lt;&lt;count> x &lt;element-type>></code></td><td style=text-align:center><code>!llvm.array&lt;&lt;count> x &lt;element-type>></code></td></tr><tr><td style=text-align:center><code>!spv.rtarray&lt; &lt;element-type> ></code></td><td style=text-align:center><code>!llvm.array&lt;0 x &lt;element-type>></code></td></tr></tbody></table><h3 id=struct-types>Struct types&nbsp;<a class=headline-hash href=#struct-types>¶</a></h3><p>Members of SPIR-V struct types may have decorations and offset information.
Currently, there is <strong>no</strong> support of member decorations conversion for structs.
For more information see section on
<a href=#Decorations-conversion>Decorations</a>.</p><p>Usually we expect that each struct member has a natural size and alignment.
However, there are cases (<em>e.g.</em> in graphics) where one would place struct
members explicitly at particular offsets. This case is <strong>not</strong> supported at the
moment. Hence, we adhere to the following mapping:</p><ul><li><p>Structs with no offset are modelled as LLVM packed structures.</p></li><li><p>Structs with natural offset (<em>i.e.</em> offset that equals to cumulative size of
the previous struct elements or is a natural alignment) are mapped to
naturally padded structs.</p></li><li><p>Structs with unnatural offset (<em>i.e.</em> offset that is not equal to cumulative
size of the previous struct elements) are <strong>not</strong> supported. In this case,
offsets can be emulated with padding fields (<em>e.g.</em> integers). However, such
a design would require index recalculation in the conversion of ops that
involve memory addressing.</p></li></ul><p>Examples of SPIR-V struct conversion are: ```mlir !spv.struct&lt;i8, i32> =>
!llvm.struct&lt;packed (i8, i32)> !spv.struct&lt;i8 [0], i32 [4]> => !llvm.struct&lt;(i8,
i32)></p><p>// error !spv.struct&lt;i8 [0], i32 [8]> ```</p><h3 id=not-implemented-types>Not implemented types&nbsp;<a class=headline-hash href=#not-implemented-types>¶</a></h3><p>The rest of the types not mentioned explicitly above are not supported by the
conversion. This includes <code>ImageType</code> and <code>MatrixType</code>.</p><h2 id=operation-conversion>Operation Conversion&nbsp;<a class=headline-hash href=#operation-conversion>¶</a></h2><p>This section describes how SPIR-V Dialect operations are converted to LLVM
Dialect. It lists already working conversion patterns, as well as those that are
an ongoing work.</p><p>There are also multiple ops for which there is no clear mapping in LLVM.
Conversion for those have to be discussed within the community on the
case-by-case basis.</p><h3 id=arithmetic-ops>Arithmetic ops&nbsp;<a class=headline-hash href=#arithmetic-ops>¶</a></h3><p>SPIR-V arithmetic ops mostly have a direct equivalent in LLVM Dialect. Such
exceptions as <code>spv.SMod</code> and <code>spv.FMod</code> are rare.</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.FAdd</code></td><td style=text-align:center><code>llvm.fadd</code></td></tr><tr><td style=text-align:center><code>spv.FDiv</code></td><td style=text-align:center><code>llvm.fdiv</code></td></tr><tr><td style=text-align:center><code>spv.FNegate</code></td><td style=text-align:center><code>llvm.fneg</code></td></tr><tr><td style=text-align:center><code>spv.FMul</code></td><td style=text-align:center><code>llvm.fmul</code></td></tr><tr><td style=text-align:center><code>spv.FRem</code></td><td style=text-align:center><code>llvm.frem</code></td></tr><tr><td style=text-align:center><code>spv.FSub</code></td><td style=text-align:center><code>llvm.fsub</code></td></tr><tr><td style=text-align:center><code>spv.IAdd</code></td><td style=text-align:center><code>llvm.add</code></td></tr><tr><td style=text-align:center><code>spv.IMul</code></td><td style=text-align:center><code>llvm.mul</code></td></tr><tr><td style=text-align:center><code>spv.ISub</code></td><td style=text-align:center><code>llvm.sub</code></td></tr><tr><td style=text-align:center><code>spv.SDiv</code></td><td style=text-align:center><code>llvm.sdiv</code></td></tr><tr><td style=text-align:center><code>spv.SRem</code></td><td style=text-align:center><code>llvm.srem</code></td></tr><tr><td style=text-align:center><code>spv.UDiv</code></td><td style=text-align:center><code>llvm.udiv</code></td></tr><tr><td style=text-align:center><code>spv.UMod</code></td><td style=text-align:center><code>llvm.urem</code></td></tr></tbody></table><h3 id=bitwise-ops>Bitwise ops&nbsp;<a class=headline-hash href=#bitwise-ops>¶</a></h3><p>SPIR-V has a range of bit ops that are mapped to LLVM dialect ops, intrinsics or
may have a specific conversion pattern.</p><h4 id=direct-conversion>Direct conversion&nbsp;<a class=headline-hash href=#direct-conversion>¶</a></h4><p>As with arithmetic ops, most of bitwise ops have a semantically equivalent op in
LLVM:</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.BitwiseAnd</code></td><td style=text-align:center><code>llvm.and</code></td></tr><tr><td style=text-align:center><code>spv.BitwiseOr</code></td><td style=text-align:center><code>llvm.or</code></td></tr><tr><td style=text-align:center><code>spv.BitwiseXor</code></td><td style=text-align:center><code>llvm.xor</code></td></tr></tbody></table><p>Also, some of bitwise ops can be modelled with LLVM intrinsics:</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect intrinsic</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.BitCount</code></td><td style=text-align:center><code>llvm.intr.ctpop</code></td></tr><tr><td style=text-align:center><code>spv.BitReverse</code></td><td style=text-align:center><code>llvm.intr.bitreverse</code></td></tr></tbody></table><h4 id=spvnot><code>spv.Not</code>&nbsp;<a class=headline-hash href=#spvnot>¶</a></h4><p><code>spv.Not</code> is modelled with a <code>xor</code> operation with a mask with all bits set.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>                            <span class=nv>%mask</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>Not <span class=nv>%op</span> <span class=p>:</span> <span class=nl>i32  =</span><span class=p>&gt;</span>  <span class=nv>%0</span>  <span class=p>=</span> llvm<span class=p>.</span>xor <span class=nv>%op</span><span class=p>,</span> <span class=nv>%mask</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><h4 id=bitfield-ops>Bitfield ops&nbsp;<a class=headline-hash href=#bitfield-ops>¶</a></h4><p>SPIR-V dialect has three bitfield ops: <code>spv.BitFieldInsert</code>,
<code>spv.BitFieldSExtract</code> and <code>spv.BitFieldUExtract</code>. This section will first
outline the general design of conversion patterns for this ops, and then
describe each of them.</p><p>All of these ops take <code>base</code>, <code>offset</code> and <code>count</code> (<code>insert</code> for
<code>spv.BitFieldInsert</code>) as arguments. There are two important things to note:</p><ul><li><p><code>offset</code> and <code>count</code> are always scalar. This means that we can have the
following case:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>BitFieldSExtract <span class=nv>%base</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</code></pre></div><p>To be able to proceed with conversion algorithms described below, all
operands have to be of the same type and bitwidth. This requires
broadcasting of <code>offset</code> and <code>count</code> to vectors, for example for the case
above it gives:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Broadcasting offset
</span><span class=c></span><span class=nv>%offset0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%zero</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%offset1</span> <span class=p>=</span> llvm<span class=p>.</span>insertelement <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%offset0</span><span class=p>[</span><span class=nv>%zero</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%one</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%vec_offset</span> <span class=p>=</span> llvm<span class=p>.</span>insertelement  <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%offset1</span><span class=p>[</span><span class=nv>%one</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// Broadcasting count
</span><span class=c>// ...
</span></code></pre></div></li><li><p><code>offset</code> and <code>count</code> may have different bitwidths from <code>base</code>. In this case,
both of these operands have to be zero extended (since they are treated as
unsigned by the specification) or truncated. For the above example it would
be:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Zero extending offset after broadcasting
</span><span class=c></span><span class=nv>%res_offset</span> <span class=p>=</span> llvm<span class=p>.</span>zext <span class=nv>%vec_offset</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>Also, note that if the bitwidth of <code>offset</code> or <code>count</code> is greater than the
bitwidth of <code>base</code>, truncation is still permitted. This is because the ops
have a defined behaviour with <code>offset</code> and <code>count</code> being less than the size
of <code>base</code>. It creates a natural upper bound on what values <code>offset</code> and
<code>count</code> can take, which is 64. This can be expressed in less than 8 bits.</p></li></ul><p>Now, having these two cases in mind, we can proceed with conversion for the ops
and their operands.</p><h5 id=spvbitfieldinsert><code>spv.BitFieldInsert</code>&nbsp;<a class=headline-hash href=#spvbitfieldinsert>¶</a></h5><p>This operation is implemented as a series of LLVM Dialect operations. First step
would be to create a mask with bits set outside [<code>offset</code>, <code>offset</code> + <code>count</code> -
1]. Then, unchanged bits are extracted from <code>base</code> that are outside of
[<code>offset</code>, <code>offset</code> + <code>count</code> - 1]. The result is <code>or</code>ed with shifted <code>insert</code>.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create mask
</span><span class=c>// %minus_one = llvm.mlir.constant(-1 : i32) : i32
</span><span class=c>// %t0        = llvm.shl %minus_one, %count : i32
</span><span class=c>// %t1        = llvm.xor %t0, %minus_one : i32
</span><span class=c>// %t2        = llvm.shl %t1, %offset : i32
</span><span class=c>// %mask      = llvm.xor %t2, %minus_one : i32
</span><span class=c></span>
<span class=c>// Extract unchanged bits from the Base
</span><span class=c>// %new_base  = llvm.and %base, %mask : i32
</span><span class=c></span>
<span class=c>// Insert new bits
</span><span class=c>// %sh_insert = llvm.shl %insert, %offset : i32
</span><span class=c>// %res       = llvm.or %new_base, %sh_insert : i32
</span><span class=c></span><span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>BitFieldInsert <span class=nv>%base</span><span class=p>,</span> <span class=nv>%insert</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</code></pre></div><h5 id=spvbitfieldsextract><code>spv.BitFieldSExtract</code>&nbsp;<a class=headline-hash href=#spvbitfieldsextract>¶</a></h5><p>To implement <code>spv.BitFieldSExtract</code>, <code>base</code> is shifted left by [sizeof(<code>base</code>) -
(<code>count</code> + <code>offset</code>)], so that the bit at <code>offset</code> + <code>count</code> - 1 is the most
significant bit. After, the result is shifted right, filling the bits with the
sign bit.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Calculate the amount to shift left.
</span><span class=c>// %size    = llvm.mlir.constant(32 : i32) : i32
</span><span class=c>// %t0      = llvm.add %count, %offset : i32
</span><span class=c>// %t1      = llvm.sub %size, %t0 : i32
</span><span class=c></span>
<span class=c>// Shift left and then right to extract the bits
</span><span class=c>// %sh_left = llvm.shl %base, %t1 : i32
</span><span class=c>// %t2      = llvm.add %offset, %t1 : i32
</span><span class=c>// %res     = llvm.ashr %sh_left, %t2 : i32
</span><span class=c></span><span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>BitFieldSExtract <span class=nv>%base</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</code></pre></div><h5 id=spvbitfielduextract><code>spv.BitFieldUExtract</code>&nbsp;<a class=headline-hash href=#spvbitfielduextract>¶</a></h5><p>For this op a similar pattern as for <code>spv.BitFieldInsert</code> is used. First, a mask
with bits set at [0, <code>count</code> - 1] is created. Then <code>base</code> is shifted by <code>offset</code>
and the mask is applied.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create a mask
</span><span class=c>// %minus_one = llvm.mlir.constant(-1 : i32) : i32
</span><span class=c>// %t0        = llvm.shl %minus_one, %count : i32
</span><span class=c>// mask       = llvm.xor  %t0, %minus_one : i32
</span><span class=c></span>
<span class=c>// Shift Base and apply mask
</span><span class=c>// %sh_base   = llvm.lshr %base, %offset : i32
</span><span class=c>// %res       = llvm.and %sh_base, %mask : i32
</span><span class=c></span><span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>BitFieldUExtract <span class=nv>%base</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</code></pre></div><h3 id=cast-ops>Cast ops&nbsp;<a class=headline-hash href=#cast-ops>¶</a></h3><h4 id=direct-conversions>Direct conversions&nbsp;<a class=headline-hash href=#direct-conversions>¶</a></h4><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.ConvertFToS</code></td><td style=text-align:center><code>llvm.fptosi</code></td></tr><tr><td style=text-align:center><code>spv.ConvertFToU</code></td><td style=text-align:center><code>llvm.fptoui</code></td></tr><tr><td style=text-align:center><code>spv.ConvertSToF</code></td><td style=text-align:center><code>llvm.sitofp</code></td></tr><tr><td style=text-align:center><code>spv.ConvertUToF</code></td><td style=text-align:center><code>llvm.uitofp</code></td></tr></tbody></table><h4 id=spvbitcast>spv.Bitcast&nbsp;<a class=headline-hash href=#spvbitcast>¶</a></h4><p>This operation has a direct counterpart in LLVM: <code>llvm.bitcast</code>. It is treated
separately since it also supports pointer to pointer bit pattern-preserving type
conversion, apart from regular scalar or vector of numerical type.</p><h4 id=special-cases>Special cases&nbsp;<a class=headline-hash href=#special-cases>¶</a></h4><p>Special cases include <code>spv.FConvert</code>, <code>spv.SConvert</code> and <code>spv.UConvert</code>. These
operations are either a truncate or extend. Let&rsquo;s denote the operand component
width as A, and result component width as R. Then, the following mappings are
used:</p><h5 id=spvfconvert><code>spv.FConvert</code>&nbsp;<a class=headline-hash href=#spvfconvert>¶</a></h5><table><thead><tr><th style=text-align:center>Case</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center>A &lt; R</td><td style=text-align:center><code>llvm.fpext</code></td></tr><tr><td style=text-align:center>A > R</td><td style=text-align:center><code>llvm.fptrunc</code></td></tr></tbody></table><h5 id=spvsconvert><code>spv.SConvert</code>&nbsp;<a class=headline-hash href=#spvsconvert>¶</a></h5><table><thead><tr><th style=text-align:center>Case</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center>A &lt; R</td><td style=text-align:center><code>llvm.sext</code></td></tr><tr><td style=text-align:center>A > R</td><td style=text-align:center><code>llvm.trunc</code></td></tr></tbody></table><h5 id=spvuconvert><code>spv.UConvert</code>&nbsp;<a class=headline-hash href=#spvuconvert>¶</a></h5><table><thead><tr><th style=text-align:center>Case</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center>A &lt; R</td><td style=text-align:center><code>llvm.zext</code></td></tr><tr><td style=text-align:center>A > R</td><td style=text-align:center><code>llvm.trunc</code></td></tr></tbody></table><p>The case when A = R is not possible, based on SPIR-V Dialect specification:</p><blockquote><p>The component width cannot equal the component width in Result Type.</p></blockquote><h3 id=comparison-ops>Comparison ops&nbsp;<a class=headline-hash href=#comparison-ops>¶</a></h3><p>SPIR-V comparison ops are mapped to LLVM <code>icmp</code> and <code>fcmp</code> operations.</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.IEqual</code></td><td style=text-align:center><code>llvm.icmp "eq"</code></td></tr><tr><td style=text-align:center><code>spv.INotEqual</code></td><td style=text-align:center><code>llvm.icmp "ne"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdEqual</code></td><td style=text-align:center><code>llvm.fcmp "oeq"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdGreaterThan</code></td><td style=text-align:center><code>llvm.fcmp "ogt"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdGreaterThanEqual</code></td><td style=text-align:center><code>llvm.fcmp "oge"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdLessThan</code></td><td style=text-align:center><code>llvm.fcmp "olt"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdLessThanEqual</code></td><td style=text-align:center><code>llvm.fcmp "ole"</code></td></tr><tr><td style=text-align:center><code>spv.FOrdNotEqual</code></td><td style=text-align:center><code>llvm.fcmp "one"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordEqual</code></td><td style=text-align:center><code>llvm.fcmp "ueq"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordGreaterThan</code></td><td style=text-align:center><code>llvm.fcmp "ugt"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordGreaterThanEqual</code></td><td style=text-align:center><code>llvm.fcmp "uge"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordLessThan</code></td><td style=text-align:center><code>llvm.fcmp "ult"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordLessThanEqual</code></td><td style=text-align:center><code>llvm.fcmp "ule"</code></td></tr><tr><td style=text-align:center><code>spv.FUnordNotEqual</code></td><td style=text-align:center><code>llvm.fcmp "une"</code></td></tr><tr><td style=text-align:center><code>spv.SGreaterThan</code></td><td style=text-align:center><code>llvm.icmp "sgt"</code></td></tr><tr><td style=text-align:center><code>spv.SGreaterThanEqual</code></td><td style=text-align:center><code>llvm.icmp "sge"</code></td></tr><tr><td style=text-align:center><code>spv.SLessThan</code></td><td style=text-align:center><code>llvm.icmp "slt"</code></td></tr><tr><td style=text-align:center><code>spv.SLessThanEqual</code></td><td style=text-align:center><code>llvm.icmp "sle"</code></td></tr><tr><td style=text-align:center><code>spv.UGreaterThan</code></td><td style=text-align:center><code>llvm.icmp "ugt"</code></td></tr><tr><td style=text-align:center><code>spv.UGreaterThanEqual</code></td><td style=text-align:center><code>llvm.icmp "uge"</code></td></tr><tr><td style=text-align:center><code>spv.ULessThan</code></td><td style=text-align:center><code>llvm.icmp "ult"</code></td></tr><tr><td style=text-align:center><code>spv.ULessThanEqual</code></td><td style=text-align:center><code>llvm.icmp "ule"</code></td></tr></tbody></table><h3 id=composite-ops>Composite ops&nbsp;<a class=headline-hash href=#composite-ops>¶</a></h3><p>Currently, conversion supports rewrite patterns for <code>spv.CompositeExtract</code> and
<code>spv.CompositeInsert</code>. We distinguish two cases for these operations: when the
composite object is a vector, and when the composite object is of a non-vector
type (<em>i.e.</em> struct, array or runtime array).</p><table><thead><tr><th style=text-align:center>Composite type</th><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center>vector</td><td style=text-align:center><code>spv.CompositeExtract</code></td><td style=text-align:center><code>llvm.extractelement</code></td></tr><tr><td style=text-align:center>vector</td><td style=text-align:center><code>spv.CompositeInsert</code></td><td style=text-align:center><code>llvm.insertelement</code></td></tr><tr><td style=text-align:center>non-vector</td><td style=text-align:center><code>spv.CompositeExtract</code></td><td style=text-align:center><code>llvm.extractvalue</code></td></tr><tr><td style=text-align:center>non-vector</td><td style=text-align:center><code>spv.CompositeInsert</code></td><td style=text-align:center><code>llvm.insertvalue</code></td></tr></tbody></table><h3 id=spventrypoint-and-spvexecutionmode><code>spv.EntryPoint</code> and <code>spv.ExecutionMode</code>&nbsp;<a class=headline-hash href=#spventrypoint-and-spvexecutionmode>¶</a></h3><p>First of all, it is important to note that there is no direct representation of
entry points in LLVM. At the moment, we use the following approach:</p><ul><li><p><code>spv.EntryPoint</code> is simply removed.</p></li><li><p>In contrast, <code>spv.ExecutionMode</code> may contain important information about the
entry point. For example, <code>LocalSize</code> provides information about the
work-group size that can be reused.</p><p>In order to preserve this information, <code>spv.ExecutionMode</code> is converted to a
struct global variable that stores the execution mode id and any variables
associated with it. In C, the struct has the structure shown below.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// No values are associated      // There are values that are associated
</span><span class=c1>// with this entry point.        // with this entry point.
</span><span class=c1></span><span class=k>struct</span> <span class=p>{</span>                         <span class=k>struct</span> <span class=p>{</span>
  <span class=n>int32_t</span> <span class=n>executionMode</span><span class=p>;</span>             <span class=n>int32_t</span> <span class=n>executionMode</span><span class=p>;</span>
<span class=p>};</span>                                   <span class=n>int32_t</span> <span class=n>values</span><span class=p>[];</span>
                                 <span class=p>};</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// spv.ExecutionMode @empty &#34;ContractionOff&#34;
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global external <span class=kt>constant</span> <span class=err>@</span><span class=p>{{.*}}()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span>   <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;</span>
  <span class=nv>%1</span>   <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>31</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
  <span class=nv>%ret</span> <span class=p>=</span> llvm<span class=p>.</span>insertvalue <span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;</span>
  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%ret</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;</span>
<span class=p>}</span>
</code></pre></div></li></ul><h3 id=logical-ops>Logical ops&nbsp;<a class=headline-hash href=#logical-ops>¶</a></h3><p>Logical ops follow a similar pattern as bitwise ops, with the difference that
they operate on <code>i1</code> or vector of <code>i1</code> values. The following mapping is used to
emulate SPIR-V ops behaviour:</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.LogicalAnd</code></td><td style=text-align:center><code>llvm.and</code></td></tr><tr><td style=text-align:center><code>spv.LogicalOr</code></td><td style=text-align:center><code>llvm.or</code></td></tr><tr><td style=text-align:center><code>spv.LogicalEqual</code></td><td style=text-align:center><code>llvm.icmp "eq"</code></td></tr><tr><td style=text-align:center><code>spv.LogicalNotEqual</code></td><td style=text-align:center><code>llvm.icmp "ne"</code></td></tr></tbody></table><p><code>spv.LogicalNot</code> has the same conversion pattern as bitwise <code>spv.Not</code>. It is
modelled with <code>xor</code> operation with a mask with all bits set.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>                                  <span class=nv>%mask</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>-1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>LogicalNot <span class=nv>%op</span> <span class=p>:</span> <span class=nl>i1  =</span><span class=p>&gt;</span>  <span class=nv>%0</span>    <span class=p>=</span> llvm<span class=p>.</span>xor <span class=nv>%op</span><span class=p>,</span> <span class=nv>%mask</span> <span class=p>:</span> <span class=k>i1</span>
</code></pre></div><h3 id=memory-ops>Memory ops&nbsp;<a class=headline-hash href=#memory-ops>¶</a></h3><p>This section describes the conversion patterns for SPIR-V dialect operations
that concern memory.</p><h4 id=spvaccesschain><code>spv.AccessChain</code>&nbsp;<a class=headline-hash href=#spvaccesschain>¶</a></h4><p><code>spv.AccessChain</code> is mapped to <code>llvm.getelementptr</code> op. In order to create a
valid LLVM op, we also add a 0 index to the <code>spv.AccessChain</code>&rsquo;s indices list in
order to go through the pointer.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Access the 1st element of the array
</span><span class=c></span><span class=nv>%i</span>   <span class=p>=</span> spv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
<span class=nv>%var</span> <span class=p>=</span> spv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;!</span>spv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Function<span class=p>&gt;</span>
<span class=nv>%el</span>  <span class=p>=</span> spv<span class=p>.</span>AccessChain <span class=nv>%var</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;!</span>spv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Function<span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>

<span class=c>// Corresponding LLVM dialect code
</span><span class=c></span><span class=nv>%i</span>   <span class=p>=</span> <span class=p>...</span>
<span class=nv>%var</span> <span class=p>=</span> <span class=p>...</span>
<span class=nv>%0</span>   <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%el</span>  <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%var</span><span class=p>[</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span>struct<span class=p>&lt;</span>packed <span class=p>(</span><span class=k>f32</span><span class=p>,</span> array<span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;)&gt;&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</code></pre></div><h4 id=spvload-and-spvstore><code>spv.Load</code> and <code>spv.Store</code>&nbsp;<a class=headline-hash href=#spvload-and-spvstore>¶</a></h4><p>These ops are converted to their LLVM counterparts: <code>llvm.load</code> and
<code>llvm.store</code>. If the op has a memory access attribute, then there are the
following cases, based on the value of the attribute:</p><ul><li><p><strong>Aligned</strong>: alignment is passed on to LLVM op builder, for example: <code>mlir // llvm.store %ptr, %val {alignment = 4 : i64} : !llvm.ptr&lt;f32> spv.Store "Function" %ptr, %val ["Aligned", 4] : f32</code></p></li><li><p><strong>None</strong>: same case as if there is no memory access attribute.</p></li><li><p><strong>Nontemporal</strong>: set <code>nontemporal</code> flag, for example: <code>mlir // %res = llvm.load %ptr {nontemporal} : !llvm.ptr&lt;f32> %res = spv.Load "Function" %ptr ["Nontemporal"] : f32</code></p></li><li><p><strong>Volatile</strong>: mark the op as <code>volatile</code>, for example: <code>mlir // %res = llvm.load volatile %ptr : !llvm.ptr&lt;f32> %res = spv.Load "Function" %ptr ["Volatile"] : f32</code> Otherwise the conversion fails as other cases
(<code>MakePointerAvailable</code>, <code>MakePointerVisible</code>, <code>NonPrivatePointer</code>) are not
supported yet.</p></li></ul><h4 id=spvglobalvariable-and-spvmliraddressof><code>spv.GlobalVariable</code> and <code>spv.mlir.addressof</code>&nbsp;<a class=headline-hash href=#spvglobalvariable-and-spvmliraddressof>¶</a></h4><p><code>spv.GlobalVariable</code> is modelled with <code>llvm.mlir.global</code> op. However, there is a
difference that has to be pointed out.</p><p>In SPIR-V dialect, the global variable returns a pointer, whereas in LLVM
dialect the global holds an actual value. This difference is handled by
<code>spv.mlir.addressof</code> and <code>llvm.mlir.addressof</code> ops that both return a pointer
and are used to reference the global.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Original SPIR-V module
</span><span class=c></span>spv<span class=p>.</span>module Logical GLSL450 <span class=p>{</span>
  spv<span class=p>.</span>GlobalVariable <span class=nf>@struct</span> <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;!</span>spv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Private<span class=p>&gt;</span>
  spv<span class=p>.</span><span class=kt>func</span> <span class=nf>@func</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span>
    <span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@struct</span> <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;!</span>spv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Private<span class=p>&gt;</span>
    spv<span class=p>.</span>Return
  <span class=p>}</span>
<span class=p>}</span>

<span class=c>// Converted result
</span><span class=c></span>module <span class=p>{</span>
  llvm<span class=p>.</span>mlir<span class=p>.</span>global private <span class=nf>@struct</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span>packed <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=p>[</span><span class=m>10 x</span> <span class=k>f32</span><span class=p>])&gt;</span>
  llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@func</span><span class=p>()</span> <span class=p>{</span>
    <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@struct</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span>struct<span class=p>&lt;</span>packed <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=p>[</span><span class=m>10 x</span> <span class=k>f32</span><span class=p>])&gt;&gt;</span>
    llvm<span class=p>.</span><span class=kt>return</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The SPIR-V to LLVM conversion does not involve modelling of workgroups. Hence,
we say that only current invocation is in conversion&rsquo;s scope. This means that
global variables with pointers of <code>Input</code>, <code>Output</code>, and <code>Private</code> storage
classes are supported. Also, <code>StorageBuffer</code> storage class is allowed for
executing
<a href=#mlir-spirv-cpu-runner><code>mlir-spirv-cpu-runner</code></a>.</p><p>Moreover, <code>bind</code> that specifies the descriptor set and the binding number and
<code>built_in</code> that specifies SPIR-V <code>BuiltIn</code> decoration have no conversion into
LLVM dialect.</p><p>Currently <code>llvm.mlir.global</code>s are created with <code>private</code> linkage for <code>Private</code>
storage class and <code>External</code> for other storage classes, based on SPIR-V spec:</p><blockquote><p>By default, functions and global variables are private to a module and cannot
be accessed by other modules. However, a module may be written to export or
import functions and global (module scope) variables.</p></blockquote><p>If the global variable&rsquo;s pointer has <code>Input</code> storage class, then a <code>constant</code>
flag is added to LLVM op:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>spv<span class=p>.</span>GlobalVariable <span class=nf>@var</span> <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Input<span class=p>&gt;</span>    <span class=p>=&gt;</span>    llvm<span class=p>.</span>mlir<span class=p>.</span>global external <span class=kt>constant</span> <span class=nf>@var</span><span class=p>()</span> <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><h4 id=spvvariable><code>spv.Variable</code>&nbsp;<a class=headline-hash href=#spvvariable>¶</a></h4><p>Per SPIR-V dialect spec, <code>spv.Variable</code> allocates an object in memory, resulting
in a pointer to it, which can be used with <code>spv.Load</code> and <code>spv.Store</code>. It is
also a function-level variable.</p><p><code>spv.Variable</code> is modelled as <code>llvm.alloca</code> op. If initialized, an additional
store instruction is used. Note that there is no initialization for arrays and
structs since constants of these types are not supported in LLVM dialect (TODO).
Also, at the moment initialization is only possible via <code>spv.Constant</code>.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Conversion of VariableOp without initialization
</span><span class=c></span>                                                               <span class=nv>%size</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> Function<span class=p>&gt;</span>   <span class=p>=&gt;</span>   <span class=nv>%res</span>  <span class=p>=</span> llvm<span class=p>.</span>alloca  <span class=nv>%size</span> <span class=p>x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span>vec<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>f32</span><span class=p>&gt;&gt;</span>

<span class=c>// Conversion of VariableOp with initialization
</span><span class=c></span>                                                               <span class=nv>%c</span>    <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
<span class=nv>%c</span>   <span class=p>=</span> spv<span class=p>.</span>Constant <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span>                                    <span class=nv>%size</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%c</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i64</span><span class=p>,</span> Function<span class=p>&gt;</span>    <span class=p>=&gt;</span>   <span class=nv>%res</span>  <span class=p>=</span> llvm<span class=p>.</span>alloca <span class=err>%</span><span class=p>[[</span>SIZE<span class=p>]]</span> <span class=p>x</span> <span class=k>i64</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
                                                               llvm<span class=p>.</span>store <span class=nv>%c</span><span class=p>,</span> <span class=nv>%res</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><p>Note that simple conversion to <code>alloca</code> may not be sufficient if the code has
some scoping. For example, if converting ops executed in a loop into <code>alloca</code>s,
a stack overflow may occur. For this case, <code>stacksave</code>/<code>stackrestore</code> pair can
be used (TODO).</p><h3 id=miscellaneous-ops-with-direct-conversions>Miscellaneous ops with direct conversions&nbsp;<a class=headline-hash href=#miscellaneous-ops-with-direct-conversions>¶</a></h3><p>There are multiple SPIR-V ops that do not fit in a particular group but can be
converted directly to LLVM dialect. Their conversion is addressed in this
section.</p><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.Select</code></td><td style=text-align:center><code>llvm.select</code></td></tr><tr><td style=text-align:center><code>spv.Undef</code></td><td style=text-align:center><code>llvm.mlir.undef</code></td></tr></tbody></table><h3 id=shift-ops>Shift ops&nbsp;<a class=headline-hash href=#shift-ops>¶</a></h3><p>Shift operates on two operands: <code>shift</code> and <code>base</code>.</p><p>In SPIR-V dialect, <code>shift</code> and <code>base</code> may have different bit width. On the
contrary, in LLVM Dialect both <code>base</code> and <code>shift</code> have to be of the same
bitwidth. This leads to the following conversions:</p><ul><li><p>if <code>base</code> has the same bitwidth as <code>shift</code>, the conversion is
straightforward.</p></li><li><p>if <code>base</code> has a greater bit width than <code>shift</code>, shift is sign or zero
extended first. Then the extended value is passed to the shift.</p></li><li><p>otherwise, the conversion is considered to be illegal.</p></li></ul><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Shift without extension
</span><span class=c></span><span class=nv>%res0</span> <span class=p>=</span> spv<span class=p>.</span>ShiftRightArithmetic <span class=nv>%0</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>i32  =</span><span class=p>&gt;</span>  <span class=nv>%res0</span> <span class=p>=</span> llvm<span class=p>.</span>ashr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Shift with extension
</span><span class=c></span>                                                        <span class=nv>%ext</span>  <span class=p>=</span> llvm<span class=p>.</span>sext <span class=nv>%1</span> <span class=p>:</span> <span class=k>i16</span> to <span class=k>i32</span>
<span class=nv>%res1</span> <span class=p>=</span> spv<span class=p>.</span>ShiftRightArithmetic <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>i16  =</span><span class=p>&gt;</span>  <span class=nv>%res1</span> <span class=p>=</span> llvm<span class=p>.</span>ashr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%ext</span><span class=p>:</span> <span class=k>i32</span>
</code></pre></div><h3 id=spvconstant><code>spv.Constant</code>&nbsp;<a class=headline-hash href=#spvconstant>¶</a></h3><p>At the moment <code>spv.Constant</code> conversion supports scalar and vector constants
<strong>only</strong>.</p><h4 id=mapping>Mapping&nbsp;<a class=headline-hash href=#mapping>¶</a></h4><p><code>spv.Constant</code> is mapped to <code>llvm.mlir.constant</code>. This is a straightforward
conversion pattern with a special case when the argument is signed or unsigned.</p><h4 id=special-case>Special case&nbsp;<a class=headline-hash href=#special-case>¶</a></h4><p>SPIR-V constant can be a signed or unsigned integer. Since LLVM Dialect does not
have signedness semantics, this case should be handled separately.</p><p>The conversion casts constant value attribute to a signless integer or a vector
of signless integers. This is correct because in SPIR-V, like in LLVM, how to
interpret an integer number is also dictated by the opcode. However, in reality
hardware implementation might show unexpected behavior. Therefore, it is better
to handle it case-by-case, given that the purpose of the conversion is not to
cover all possible corner cases.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// %0 = llvm.mlir.constant(0 : i8) : i8
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>Constant  <span class=m>0</span> <span class=p>:</span> <span class=k>i8</span>

<span class=c>// %1 = llvm.mlir.constant(dense&lt;[2, 3, 4]&gt; : vector&lt;3xi32&gt;) : vector&lt;3xi32&gt;
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> spv<span class=p>.</span>Constant dense<span class=p>&lt;[</span><span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span>ui32<span class=p>&gt;</span>
</code></pre></div><h3 id=not-implemented-ops>Not implemented ops&nbsp;<a class=headline-hash href=#not-implemented-ops>¶</a></h3><p>There is no support of the following ops:</p><ul><li>All atomic ops</li><li>All group ops</li><li>All matrix ops</li><li>All OCL ops</li></ul><p>As well as:</p><ul><li>spv.CompositeConstruct</li><li>spv.ControlBarrier</li><li>spv.CopyMemory</li><li>spv.FMod</li><li>spv.GLSL.Acos</li><li>spv.GLSL.Asin</li><li>spv.GLSL.Atan</li><li>spv.GLSL.Cosh</li><li>spv.GLSL.FSign</li><li>spv.GLSL.SAbs</li><li>spv.GLSL.Sinh</li><li>spv.GLSL.SSign</li><li>spv.MemoryBarrier</li><li>spv.mlir.referenceof</li><li>spv.SMod</li><li>spv.SpecConstant</li><li>spv.Unreachable</li><li>spv.VectorExtractDynamic</li></ul><h2 id=control-flow-conversion>Control flow conversion&nbsp;<a class=headline-hash href=#control-flow-conversion>¶</a></h2><h3 id=branch-ops>Branch ops&nbsp;<a class=headline-hash href=#branch-ops>¶</a></h3><p><code>spv.Branch</code> and <code>spv.BranchConditional</code> are mapped to <code>llvm.br</code> and
<code>llvm.cond_br</code>. Branch weights for <code>spv.BranchConditional</code> are mapped to
corresponding <code>branch_weights</code> attribute of <code>llvm.cond_br</code>. When translated to
proper LLVM, <code>branch_weights</code> are converted into LLVM metadata associated with
the conditional branch.</p><h3 id=spvfunctioncall><code>spv.FunctionCall</code>&nbsp;<a class=headline-hash href=#spvfunctioncall>¶</a></h3><p><code>spv.FunctionCall</code> maps to <code>llvm.call</code>. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> spv<span class=p>.</span>FunctionCall <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=nl>i32    =</span><span class=p>&gt;</span>    <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>f32</span>
spv<span class=p>.</span>FunctionCall <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>     <span class=p>=&gt;</span>    llvm<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><h3 id=spvmlirselection-and-spvmlirloop><code>spv.mlir.selection</code> and <code>spv.mlir.loop</code>&nbsp;<a class=headline-hash href=#spvmlirselection-and-spvmlirloop>¶</a></h3><p>Control flow within <code>spv.mlir.selection</code> and <code>spv.mlir.loop</code> is lowered directly
to LLVM via branch ops. The conversion can only be applied to selection or loop
with all blocks being reachable. Moreover, selection and loop control attributes
(such as <code>Flatten</code> or <code>Unroll</code>) are not supported at the moment.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Conversion of selection
</span><span class=c></span><span class=nv>%cond</span> <span class=p>=</span> spv<span class=p>.</span>Constant true                               <span class=nv>%cond</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>true<span class=p>)</span> <span class=p>:</span> <span class=k>i1</span>
spv<span class=p>.</span>mlir<span class=p>.</span>selection <span class=p>{</span>
  spv<span class=p>.</span>BranchConditional <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^true</span><span class=p>,</span> <span class=nl>^false            </span>llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^true</span><span class=p>,</span> <span class=nl>^false
</span><span class=nl>
</span><span class=nl>^true</span><span class=p>:</span>                                                                                              <span class=nl>^true</span><span class=p>:</span>
  <span class=c>// True block code                                    // True block code
</span><span class=c></span>  spv<span class=p>.</span>Branch <span class=nl>^merge                             </span><span class=p>=&gt;</span>      llvm<span class=p>.</span>br <span class=nl>^merge
</span><span class=nl>
</span><span class=nl>^false</span><span class=p>:</span>                                               <span class=nl>^false</span><span class=p>:</span>
  <span class=c>// False block code                                   // False block code
</span><span class=c></span>  spv<span class=p>.</span>Branch <span class=nl>^merge                                     </span>llvm<span class=p>.</span>br <span class=nl>^merge
</span><span class=nl>
</span><span class=nl>^merge</span><span class=p>:</span>                                               <span class=nl>^merge</span><span class=p>:</span>
  spv<span class=p>.</span>mlir<span class=p>.</span>merge                                            llvm<span class=p>.</span>br <span class=nl>^continue
</span><span class=nl></span><span class=p>}</span>
<span class=c>// Remaining code                                                                           ^continue:
</span><span class=c></span>                                                        <span class=c>// Remaining code
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Conversion of loop
</span><span class=c></span><span class=nv>%cond</span> <span class=p>=</span> spv<span class=p>.</span>Constant true                               <span class=nv>%cond</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>true<span class=p>)</span> <span class=p>:</span> <span class=k>i1</span>
spv<span class=p>.</span>mlir<span class=p>.</span>loop <span class=p>{</span>
  spv<span class=p>.</span>Branch <span class=nl>^header                                    </span>llvm<span class=p>.</span>br <span class=nl>^header
</span><span class=nl>
</span><span class=nl>^header</span><span class=p>:</span>                                              <span class=nl>^header</span><span class=p>:</span>
  <span class=c>// Header code                                        // Header code
</span><span class=c></span>  spv<span class=p>.</span>BranchConditional <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^body</span><span class=p>,</span> <span class=nl>^merge    </span><span class=p>=&gt;</span>      llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^body</span><span class=p>,</span> <span class=nl>^merge
</span><span class=nl>
</span><span class=nl>^body</span><span class=p>:</span>                                                <span class=nl>^body</span><span class=p>:</span>
  <span class=c>// Body code                                          // Body code
</span><span class=c></span>  spv<span class=p>.</span>Branch <span class=nl>^continue                                  </span>llvm<span class=p>.</span>br <span class=nl>^continue
</span><span class=nl>
</span><span class=nl>^continue</span><span class=p>:</span>                                            <span class=nl>^continue</span><span class=p>:</span>
  <span class=c>// Continue code                                      // Continue code
</span><span class=c></span>  spv<span class=p>.</span>Branch <span class=nl>^header                                    </span>llvm<span class=p>.</span>br <span class=nl>^header
</span><span class=nl>
</span><span class=nl>^merge</span><span class=p>:</span>                                               <span class=nl>^merge</span><span class=p>:</span>
  spv<span class=p>.</span>mlir<span class=p>.</span>merge                                            llvm<span class=p>.</span>br <span class=nl>^remaining
</span><span class=nl></span><span class=p>}</span>
<span class=c>// Remaining code                                     ^remaining:
</span><span class=c></span>                                                        <span class=c>// Remaining code
</span></code></pre></div><h2 id=decorations-conversion>Decorations conversion&nbsp;<a class=headline-hash href=#decorations-conversion>¶</a></h2><p><strong>Note: these conversions have not been implemented yet</strong></p><h2 id=glsl-extended-instruction-set>GLSL extended instruction set&nbsp;<a class=headline-hash href=#glsl-extended-instruction-set>¶</a></h2><p>This section describes how SPIR-V ops from GLSL extended instructions set are
mapped to LLVM Dialect.</p><h3 id=direct-conversions-1>Direct conversions&nbsp;<a class=headline-hash href=#direct-conversions-1>¶</a></h3><table><thead><tr><th style=text-align:center>SPIR-V Dialect op</th><th style=text-align:center>LLVM Dialect op</th></tr></thead><tbody><tr><td style=text-align:center><code>spv.GLSL.Ceil</code></td><td style=text-align:center><code>llvm.intr.ceil</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Cos</code></td><td style=text-align:center><code>llvm.intr.cos</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Exp</code></td><td style=text-align:center><code>llvm.intr.exp</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.FAbs</code></td><td style=text-align:center><code>llvm.intr.fabs</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Floor</code></td><td style=text-align:center><code>llvm.intr.floor</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.FMax</code></td><td style=text-align:center><code>llvm.intr.maxnum</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.FMin</code></td><td style=text-align:center><code>llvm.intr.minnum</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Log</code></td><td style=text-align:center><code>llvm.intr.log</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Sin</code></td><td style=text-align:center><code>llvm.intr.sin</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.Sqrt</code></td><td style=text-align:center><code>llvm.intr.sqrt</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.SMax</code></td><td style=text-align:center><code>llvm.intr.smax</code></td></tr><tr><td style=text-align:center><code>spv.GLSL.SMin</code></td><td style=text-align:center><code>llvm.intr.smin</code></td></tr></tbody></table><h3 id=special-cases-1>Special cases&nbsp;<a class=headline-hash href=#special-cases-1>¶</a></h3><p><code>spv.InverseSqrt</code> is mapped to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>                                           <span class=nv>%one</span>  <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
<span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>InverseSqrt <span class=nv>%arg</span> <span class=p>:</span> <span class=nl>f32    =</span><span class=p>&gt;</span>    <span class=nv>%sqrt</span> <span class=p>=</span> <span class=s>&#34;llvm.intr.sqrt&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
                                           <span class=nv>%res</span>  <span class=p>=</span> fdiv <span class=nv>%one</span><span class=p>,</span> <span class=nv>%sqrt</span> <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><p><code>spv.Tan</code> is mapped to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>                                   <span class=nv>%sin</span> <span class=p>=</span> <span class=s>&#34;llvm.intr.sin&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
<span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>Tan <span class=nv>%arg</span> <span class=p>:</span> <span class=nl>f32    =</span><span class=p>&gt;</span>    <span class=nv>%cos</span> <span class=p>=</span> <span class=s>&#34;llvm.intr.cos&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
                                   <span class=nv>%res</span> <span class=p>=</span> fdiv <span class=nv>%sin</span><span class=p>,</span> <span class=nv>%cos</span> <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><p><code>spv.Tanh</code> is modelled using the equality <code>tanh(x) = {exp(2x) - 1}/{exp(2x) + 1}</code>:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>                                     <span class=nv>%two</span>   <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2.0</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
                                     <span class=nv>%2xArg</span> <span class=p>=</span> llvm<span class=p>.</span>fmul <span class=nv>%two</span><span class=p>,</span> <span class=nv>%arg</span> <span class=p>:</span> <span class=k>f32</span>
                                     <span class=nv>%exp</span>   <span class=p>=</span> <span class=s>&#34;llvm.intr.exp&#34;</span><span class=p>(</span><span class=nv>%2xArg</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
<span class=nv>%res</span> <span class=p>=</span> spv<span class=p>.</span>Tanh <span class=nv>%arg</span> <span class=p>:</span> <span class=nl>f32     =</span><span class=p>&gt;</span>    <span class=nv>%one</span>   <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
                                     <span class=nv>%num</span>   <span class=p>=</span> llvm<span class=p>.</span>fsub <span class=nv>%exp</span><span class=p>,</span> <span class=nv>%one</span> <span class=p>:</span> <span class=k>f32</span>
                                     <span class=nv>%den</span>   <span class=p>=</span> llvm<span class=p>.</span>fadd <span class=nv>%exp</span><span class=p>,</span> <span class=nv>%one</span> <span class=p>:</span> <span class=k>f32</span>
                                     <span class=nv>%res</span>   <span class=p>=</span> llvm<span class=p>.</span>fdiv <span class=nv>%num</span><span class=p>,</span> <span class=nv>%den</span> <span class=p>:</span> <span class=k>f32</span>
</code></pre></div><h2 id=function-conversion-and-related-ops>Function conversion and related ops&nbsp;<a class=headline-hash href=#function-conversion-and-related-ops>¶</a></h2><p>This section describes the conversion of function-related operations from SPIR-V
to LLVM dialect.</p><h3 id=spvfunc><code>spv.func</code>&nbsp;<a class=headline-hash href=#spvfunc>¶</a></h3><p>This op declares or defines a SPIR-V function and it is converted to
<code>llvm.func</code>. This conversion handles signature conversion, and function control
attributes remapping to LLVM dialect function
<a href=/docs/Dialects/LLVM/#attribute-pass-through><code>passthrough</code> attribute</a>.</p><p>The following mapping is used to map
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_function_control_a_function_control>SPIR-V function control</a> to
<a href=https://llvm.org/docs/LangRef.html#function-attributes>LLVM function attributes</a>:</p><table><thead><tr><th style=text-align:center>SPIR-V Function Control Attributes</th><th style=text-align:center>LLVM Function Attributes</th></tr></thead><tbody><tr><td style=text-align:center>None</td><td style=text-align:center>No function attributes passed</td></tr><tr><td style=text-align:center>Inline</td><td style=text-align:center><code>alwaysinline</code></td></tr><tr><td style=text-align:center>DontInline</td><td style=text-align:center><code>noinline</code></td></tr><tr><td style=text-align:center>Pure</td><td style=text-align:center><code>readonly</code></td></tr><tr><td style=text-align:center>Const</td><td style=text-align:center><code>readnone</code></td></tr></tbody></table><h3 id=spvreturn-and-spvreturnvalue><code>spv.Return</code> and <code>spv.ReturnValue</code>&nbsp;<a class=headline-hash href=#spvreturn-and-spvreturnvalue>¶</a></h3><p>In LLVM IR, functions may return either 1 or 0 value. Hence, we map both ops to
<code>llvm.return</code> with or without a return value.</p><h2 id=module-ops>Module ops&nbsp;<a class=headline-hash href=#module-ops>¶</a></h2><p>Module in SPIR-V has one region that contains one block. It is defined via
<code>spv.module</code> op that also takes a range of attributes:</p><ul><li>Addressing model</li><li>Memory model</li><li>Version-Capability-Extension attribute</li></ul><p><code>spv.module</code> is converted into <code>ModuleOp</code>. This plays a role of enclosing scope
to LLVM ops. At the moment, SPIR-V module attributes are ignored.</p><h2 id=mlir-spirv-cpu-runner><code>mlir-spirv-cpu-runner</code>&nbsp;<a class=headline-hash href=#mlir-spirv-cpu-runner>¶</a></h2><p><code>mlir-spirv-cpu-runner</code> allows to execute <code>gpu</code> dialect kernel on the CPU via
SPIR-V to LLVM dialect conversion. Currently, only single-threaded kernel is
supported.</p><p>To build the runner, add the following option to <code>cmake</code>: <code>bash -DMLIR_ENABLE_SPIRV_CPU_RUNNER=1</code></p><h3 id=pipeline>Pipeline&nbsp;<a class=headline-hash href=#pipeline>¶</a></h3><p>The <code>gpu</code> module with the kernel and the host code undergo the following
transformations:</p><ul><li><p>Convert the <code>gpu</code> module into SPIR-V dialect, lower ABI attributes and
update version, capability and extension.</p></li><li><p>Emulate the kernel call by converting the launching operation into a normal
function call. The data from the host side to the device is passed via
copying to global variables. These are created in both the host and the
kernel code and later linked when nested modules are folded.</p></li><li><p>Convert SPIR-V dialect kernel to LLVM dialect via the new conversion path.</p></li></ul><p>After these passes, the IR transforms into a nested LLVM module - a main module
representing the host code and a kernel module. These modules are linked and
executed using <code>ExecutionEngine</code>.</p><h3 id=walk-through>Walk-through&nbsp;<a class=headline-hash href=#walk-through>¶</a></h3><p>This section gives a detailed overview of the IR changes while running
<code>mlir-spirv-cpu-runner</code>. First, consider that we have the following IR. (For
simplicity some type annotations and function implementations have been
omitted).</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>gpu<span class=p>.</span>module <span class=nf>@foo</span> <span class=p>{</span>
  gpu<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>{</span>
    <span class=c>// Kernel code.
</span><span class=c></span>    gpu<span class=p>.</span><span class=kt>return</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
  <span class=c>// Fill the buffer with some data
</span><span class=c></span>  <span class=nv>%buffer</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=nv>%data</span> <span class=p>=</span> <span class=p>...</span>
  call fillBuffer<span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%data</span><span class=p>)</span>

  <span class=s>&#34;gpu.launch_func&#34;</span><span class=p>(</span><span class=err>/</span><span class=p>*</span>grid dimensions<span class=p>*</span><span class=err>/</span><span class=p>,</span> <span class=nv>%buffer</span><span class=p>)</span> <span class=p>{</span>
    <span class=nl>kernel =</span> <span class=nf>@foo</span><span class=p>::</span>bar
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Lowering <code>gpu</code> dialect to SPIR-V dialect results in</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>spv<span class=p>.</span>module <span class=nf>@__spv__foo</span> <span class=err>/</span><span class=p>*</span>VCE triple and other metadata here<span class=p>*</span><span class=err>/</span> <span class=p>{</span>
  spv<span class=p>.</span>GlobalVariable <span class=nf>@__spv__foo_arg</span> bind<span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>0</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
  spv<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=c>// Kernel code.
</span><span class=c></span>  <span class=p>}</span>
  spv<span class=p>.</span>EntryPoint <span class=nf>@bar</span><span class=p>,</span> <span class=p>...</span>
<span class=p>}</span>

<span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
  <span class=c>// Fill the buffer with some data.
</span><span class=c></span>  <span class=nv>%buffer</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=nv>%data</span> <span class=p>=</span> <span class=p>...</span>
  call fillBuffer<span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%data</span><span class=p>)</span>

  <span class=s>&#34;gpu.launch_func&#34;</span><span class=p>(</span><span class=err>/</span><span class=p>*</span>grid dimensions<span class=p>*</span><span class=err>/</span><span class=p>,</span> <span class=nv>%buffer</span><span class=p>)</span> <span class=p>{</span>
    <span class=nl>kernel =</span> <span class=nf>@foo</span><span class=p>::</span>bar
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Then, the lowering from standard dialect to LLVM dialect is applied to the host
code.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>spv<span class=p>.</span>module <span class=nf>@__spv__foo</span> <span class=err>/</span><span class=p>*</span>VCE triple and other metadata here<span class=p>*</span><span class=err>/</span> <span class=p>{</span>
  spv<span class=p>.</span>GlobalVariable <span class=nf>@__spv__foo_arg</span> bind<span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>0</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
  spv<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=c>// Kernel code.
</span><span class=c></span>  <span class=p>}</span>
  spv<span class=p>.</span>EntryPoint <span class=nf>@bar</span><span class=p>,</span> <span class=p>...</span>
<span class=p>}</span>

<span class=c>// Kernel function declaration.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@__spv__foo_bar</span><span class=p>()</span> <span class=p>:</span> <span class=p>...</span>

llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
  <span class=c>// Fill the buffer with some data.
</span><span class=c></span>  llvm<span class=p>.</span>call fillBuffer<span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%data</span><span class=p>)</span>

  <span class=c>// Copy data to the global variable, call kernel, and copy the data back.
</span><span class=c></span>  <span class=nv>%addr</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@__spv__foo_arg_descriptor_set0_binding0</span> <span class=p>:</span> <span class=p>...</span>
  <span class=s>&#34;llvm.intr.memcpy&#34;</span><span class=p>(</span><span class=nv>%addr</span><span class=p>,</span> <span class=nv>%buffer</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
  llvm<span class=p>.</span>call <span class=nf>@__spv__foo_bar</span><span class=p>()</span>
  <span class=s>&#34;llvm.intr.memcpy&#34;</span><span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%addr</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>

  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Finally, SPIR-V module is converted to LLVM and the symbol names are resolved
for the linkage.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module <span class=nf>@__spv__foo</span> <span class=p>{</span>
  llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@__spv__foo_arg_descriptor_set0_binding0</span> <span class=p>:</span> <span class=p>...</span>
  llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@__spv__foo_bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=c>// Kernel code.
</span><span class=c></span>  <span class=p>}</span>
<span class=p>}</span>

<span class=c>// Kernel function declaration.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@__spv__foo_bar</span><span class=p>()</span> <span class=p>:</span> <span class=p>...</span>

llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
  <span class=c>// Fill the buffer with some data.
</span><span class=c></span>  llvm<span class=p>.</span>call fillBuffer<span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%data</span><span class=p>)</span>

  <span class=c>// Copy data to the global variable, call kernel, and copy the data back.
</span><span class=c></span>  <span class=nv>%addr</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@__spv__foo_arg_descriptor_set0_binding0</span> <span class=p>:</span> <span class=p>...</span>
  <span class=s>&#34;llvm.intr.memcpy&#34;</span><span class=p>(</span><span class=nv>%addr</span><span class=p>,</span> <span class=nv>%buffer</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
  llvm<span class=p>.</span>call <span class=nf>@__spv__foo_bar</span><span class=p>()</span>
  <span class=s>&#34;llvm.intr.memcpy&#34;</span><span class=p>(</span><span class=nv>%buffer</span><span class=p>,</span> <span class=nv>%addr</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>

  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/ShapeInference/ title="Shape Inference"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Shape Inference</a>
<a class="nav nav-next" href=/docs/SymbolsAndSymbolTables/ title="Symbols and Symbol Tables">Next - Symbols and Symbol Tables <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li class=active><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>