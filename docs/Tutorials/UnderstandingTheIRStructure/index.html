<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Understanding the IR Structure - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Understanding the IR Structure</h1><p>The MLIR Language Reference describes the
<a href=/docs/LangRef/#high-level-structure>High Level Structure</a>, this document
illustrates this structure through examples, and introduces at the same time the
C++ APIs involved in manipulating it.</p><p>We will implement a
<a href=/docs/PassManagement/#operation-pass>pass</a> that traverses any
MLIR input and prints the entity inside the IR. A pass (or in general almost any
piece of IR) is always rooted with an operation. Most of the time the top-level
operation is a <code>ModuleOp</code>, the MLIR <code>PassManager</code> is actually limited to
operation on a top-level <code>ModuleOp</code>. As such a pass starts with an operation,
and so will our traversal:</p><pre><code>  void runOnOperation() override {
    Operation *op = getOperation();
    resetIndent();
    printOperation(op);
  }
</code></pre><h2 id=traversing-the-ir-nesting>Traversing the IR Nesting&nbsp;<a class=headline-hash href=#traversing-the-ir-nesting>¶</a></h2><p>The IR is recursively nested, an <code>Operation</code> can have one or multiple nested
<code>Region</code>s, each of which is actually a list of <code>Blocks</code>, each of which itself
wraps a list of <code>Operation</code>s. Our traversal will follow this structure with
three methods: <code>printOperation()</code>, <code>printRegion()</code>, and <code>printBlock()</code>.</p><p>The first method inspects the properties of an operation, before iterating on
the nested regions and print them individually:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=kt>void</span> <span class=nf>printOperation</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Print the operation itself and some of its properties
</span><span class=c1></span>    <span class=n>printIndent</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;visiting op: &#39;&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;&#39; with &#34;</span>
                  <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getNumOperands</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; operands and &#34;</span>
                  <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getNumResults</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; results</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=c1>// Print the operation attributes
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrs</span><span class=p>().</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>printIndent</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrs</span><span class=p>().</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; attributes:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
      <span class=k>for</span> <span class=p>(</span><span class=n>NamedAttribute</span> <span class=nl>attr</span> <span class=p>:</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrs</span><span class=p>())</span>
        <span class=n>printIndent</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; - &#39;&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>attr</span><span class=p>.</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;&#39; : &#39;&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>attr</span><span class=p>.</span><span class=n>second</span>
                      <span class=o>&lt;&lt;</span> <span class=s>&#34;&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Recurse into each of the regions attached to the operation.
</span><span class=c1></span>    <span class=n>printIndent</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getNumRegions</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; nested regions:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>auto</span> <span class=n>indent</span> <span class=o>=</span> <span class=n>pushIndent</span><span class=p>();</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>Region</span> <span class=o>&amp;</span><span class=nl>region</span> <span class=p>:</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getRegions</span><span class=p>())</span>
      <span class=n>printRegion</span><span class=p>(</span><span class=n>region</span><span class=p>);</span>
  <span class=p>}</span>
</code></pre></div><p>A <code>Region</code> does not hold anything other than a list of <code>Block</code>s:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=kt>void</span> <span class=nf>printRegion</span><span class=p>(</span><span class=n>Region</span> <span class=o>&amp;</span><span class=n>region</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// A region does not hold anything by itself other than a list of blocks.
</span><span class=c1></span>    <span class=n>printIndent</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Region with &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>region</span><span class=p>.</span><span class=n>getBlocks</span><span class=p>().</span><span class=n>size</span><span class=p>()</span>
                  <span class=o>&lt;&lt;</span> <span class=s>&#34; blocks:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=k>auto</span> <span class=n>indent</span> <span class=o>=</span> <span class=n>pushIndent</span><span class=p>();</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>Block</span> <span class=o>&amp;</span><span class=nl>block</span> <span class=p>:</span> <span class=n>region</span><span class=p>.</span><span class=n>getBlocks</span><span class=p>())</span>
      <span class=n>printBlock</span><span class=p>(</span><span class=n>block</span><span class=p>);</span>
  <span class=p>}</span>
</code></pre></div><p>Finally, a <code>Block</code> has a list of arguments, and holds a list of <code>Operation</code>s:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=kt>void</span> <span class=nf>printBlock</span><span class=p>(</span><span class=n>Block</span> <span class=o>&amp;</span><span class=n>block</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Print the block intrinsics properties (basically: argument list)
</span><span class=c1></span>    <span class=n>printIndent</span><span class=p>()</span>
        <span class=o>&lt;&lt;</span> <span class=s>&#34;Block with &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>block</span><span class=p>.</span><span class=n>getNumArguments</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; arguments, &#34;</span>
        <span class=o>&lt;&lt;</span> <span class=n>block</span><span class=p>.</span><span class=n>getNumSuccessors</span><span class=p>()</span>
        <span class=o>&lt;&lt;</span> <span class=s>&#34; successors, and &#34;</span>
        <span class=c1>// Note, this `.size()` is traversing a linked-list and is O(n).
</span><span class=c1></span>        <span class=o>&lt;&lt;</span> <span class=n>block</span><span class=p>.</span><span class=n>getOperations</span><span class=p>().</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; operations</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>

    <span class=c1>// A block main role is to hold a list of Operations: let&#39;s recurse into
</span><span class=c1></span>    <span class=c1>// printing each operation.
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>indent</span> <span class=o>=</span> <span class=n>pushIndent</span><span class=p>();</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>&amp;</span><span class=nl>op</span> <span class=p>:</span> <span class=n>block</span><span class=p>.</span><span class=n>getOperations</span><span class=p>())</span>
      <span class=n>printOperation</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>);</span>
  <span class=p>}</span>
</code></pre></div><p>The code for the pass is available
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/test/lib/IR/TestPrintNesting.cpp>here in the repo</a>
and can be exercised with <code>mlir-opt -test-print-nesting</code>.</p><h3 id=example>Example&nbsp;<a class=headline-hash href=#example>¶</a></h3><p>The Pass introduced in the previous section can be applied on the following IR
with <code>mlir-opt -test-print-nesting -allow-unregistered-dialect llvm-project/mlir/test/IR/print-ir-nesting.mlir</code>:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=s>&#34;builtin.module&#34;</span><span class=p>()</span> <span class=p>(</span> <span class=p>{</span>
  <span class=nv>%0</span><span class=p>:</span><span class=nl>4 =</span> <span class=s>&#34;dialect.op1&#34;</span><span class=p>()</span> <span class=p>{</span><span class=s>&#34;attribute name&#34;</span> <span class=p>=</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i16</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span>
  <span class=s>&#34;dialect.op2&#34;</span><span class=p>()</span> <span class=p>(</span> <span class=p>{</span>
    <span class=s>&#34;dialect.innerop1&#34;</span><span class=p>(</span><span class=nv>%0#0</span><span class=p>,</span> <span class=nv>%0#1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i16</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=p>},</span>  <span class=p>{</span>
    <span class=s>&#34;dialect.innerop2&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
    <span class=s>&#34;dialect.innerop3&#34;</span><span class=p>(</span><span class=nv>%0#0</span><span class=p>,</span> <span class=nv>%0#2</span><span class=p>,</span> <span class=nv>%0#3</span><span class=p>)[</span><span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>  <span class=c>// pred: ^bb0
</span><span class=c></span>    <span class=s>&#34;dialect.innerop4&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
    <span class=s>&#34;dialect.innerop5&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=k>i64</span><span class=p>):</span>  <span class=c>// pred: ^bb0
</span><span class=c></span>    <span class=s>&#34;dialect.innerop6&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
    <span class=s>&#34;dialect.innerop7&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
  <span class=p>})</span> <span class=p>{</span><span class=s>&#34;other attribute&#34;</span> <span class=p>=</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=p>})</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</code></pre></div><p>And will yield the following output:</p><pre><code>visiting op: 'builtin.module' with 0 operands and 0 results
 1 nested regions:
  Region with 1 blocks:
    Block with 0 arguments, 0 successors, and 3 operations
      visiting op: 'dialect.op1' with 0 operands and 4 results
      1 attributes:
       - 'attribute name' : '42 : i32'
       0 nested regions:
      visiting op: 'dialect.op2' with 0 operands and 0 results
       2 nested regions:
        Region with 1 blocks:
          Block with 0 arguments, 0 successors, and 1 operations
            visiting op: 'dialect.innerop1' with 2 operands and 0 results
             0 nested regions:
        Region with 3 blocks:
          Block with 0 arguments, 2 successors, and 2 operations
            visiting op: 'dialect.innerop2' with 0 operands and 0 results
             0 nested regions:
            visiting op: 'dialect.innerop3' with 3 operands and 0 results
             0 nested regions:
          Block with 1 arguments, 0 successors, and 2 operations
            visiting op: 'dialect.innerop4' with 0 operands and 0 results
             0 nested regions:
            visiting op: 'dialect.innerop5' with 0 operands and 0 results
             0 nested regions:
          Block with 1 arguments, 0 successors, and 2 operations
            visiting op: 'dialect.innerop6' with 0 operands and 0 results
             0 nested regions:
            visiting op: 'dialect.innerop7' with 0 operands and 0 results
             0 nested regions:
       0 nested regions:
</code></pre><h2 id=other-ir-traversal-methods>Other IR Traversal Methods.&nbsp;<a class=headline-hash href=#other-ir-traversal-methods>¶</a></h2><p>In many cases, unwrapping the recursive structure of the IR is cumbersome and
you may be interested in using other helpers.</p><h3 id=filtered-iterator-getopsopty>Filtered iterator: <code>getOps&lt;OpTy>()</code>&nbsp;<a class=headline-hash href=#filtered-iterator-getopsopty>¶</a></h3><p>For example the <code>Block</code> class exposes a convenient templated method
<code>getOps&lt;OpTy>()</code> that provided a filtered iterator. Here is an example:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=k>auto</span> <span class=n>varOps</span> <span class=o>=</span> <span class=n>entryBlock</span><span class=p>.</span><span class=n>getOps</span><span class=o>&lt;</span><span class=n>spirv</span><span class=o>::</span><span class=n>GlobalVariableOp</span><span class=o>&gt;</span><span class=p>();</span>
  <span class=k>for</span> <span class=p>(</span><span class=n>spirv</span><span class=o>::</span><span class=n>GlobalVariableOp</span> <span class=nl>gvOp</span> <span class=p>:</span> <span class=n>varOps</span><span class=p>)</span> <span class=p>{</span>
     <span class=c1>// process each GlobalVariable Operation in the block.
</span><span class=c1></span>     <span class=p>...</span>
  <span class=p>}</span>
</code></pre></div><p>Similarly, the <code>Region</code> class exposes the same <code>getOps</code> method that will iterate
on all the blocks in the region.</p><h3 id=walkers>Walkers&nbsp;<a class=headline-hash href=#walkers>¶</a></h3><p>The <code>getOps&lt;OpTy>()</code> is useful to iterate on some Operations immediately listed
inside a single block (or a single region), however it is frequently interesting
to traverse the IR in a nested fashion. To this end MLIR exposes the <code>walk()</code>
helper on <code>Operation</code>, <code>Block</code>, and <code>Region</code>. This helper takes a single
argument: a callback method that will be invoked for every operation recursively
nested under the provided entity.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// Recursively traverse all the regions and blocks nested inside the function
</span><span class=c1></span>  <span class=c1>// and apply the callback on every single operation in post-order.
</span><span class=c1></span>  <span class=n>getFunction</span><span class=p>().</span><span class=n>walk</span><span class=p>([</span><span class=o>&amp;</span><span class=p>](</span><span class=n>mlir</span><span class=o>::</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// process Operation `op`.
</span><span class=c1></span>  <span class=p>});</span>
</code></pre></div><p>The provided callback can be specialized to filter on a particular type of
Operation, for example the following will apply the callback only on <code>LinalgOp</code>
operations nested inside the function:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>getFunction</span><span class=p>().</span><span class=n>walk</span><span class=p>([](</span><span class=n>LinalgOp</span> <span class=n>linalgOp</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// process LinalgOp `linalgOp`.
</span><span class=c1></span>  <span class=p>});</span>
</code></pre></div><p>Finally, the callback can optionally stop the walk by returning a
<code>WalkResult::interrupt()</code> value. For example the following walk will find all
<code>AllocOp</code> nested inside the function and interrupt the traversal if one of them
does not satisfy a criteria:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>WalkResult</span> <span class=n>result</span> <span class=o>=</span> <span class=n>getFunction</span><span class=p>().</span><span class=n>walk</span><span class=p>([</span><span class=o>&amp;</span><span class=p>](</span><span class=n>AllocOp</span> <span class=n>allocOp</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>isValid</span><span class=p>(</span><span class=n>allocOp</span><span class=p>))</span>
      <span class=k>return</span> <span class=n>WalkResult</span><span class=o>::</span><span class=n>interrupt</span><span class=p>();</span>
    <span class=k>return</span> <span class=n>WalkResult</span><span class=o>::</span><span class=n>advance</span><span class=p>();</span>
  <span class=p>});</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>wasInterrupted</span><span class=p>())</span>
    <span class=c1>// One alloc wasn&#39;t matching.
</span><span class=c1></span>    <span class=p>...</span>
</code></pre></div><h2 id=traversing-the-def-use-chains>Traversing the def-use chains&nbsp;<a class=headline-hash href=#traversing-the-def-use-chains>¶</a></h2><p>Another relationship in the IR is the one that links a <code>Value</code> with its users.
As defined in the
<a href=/docs/LangRef/#high-level-structure>language reference</a>,
each Value is either a <code>BlockArgument</code> or the result of exactly one <code>Operation</code>
(an <code>Operation</code> can have multiple results, each of them is a separate <code>Value</code>).
The users of a <code>Value</code> are <code>Operation</code>s, through their arguments: each
<code>Operation</code> argument references a single <code>Value</code>.</p><p>Here is a code sample that inspects the operands of an <code>Operation</code> and prints
some information about them:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// Print information about the producer of each of the operands.
</span><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>Value</span> <span class=nl>operand</span> <span class=p>:</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getOperands</span><span class=p>())</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>producer</span> <span class=o>=</span> <span class=n>operand</span><span class=p>.</span><span class=n>getDefiningOp</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;  - Operand produced by operation &#39;&#34;</span>
                   <span class=o>&lt;&lt;</span> <span class=n>producer</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// If there is no defining op, the Value is necessarily a Block
</span><span class=c1></span>      <span class=c1>// argument.
</span><span class=c1></span>      <span class=k>auto</span> <span class=n>blockArg</span> <span class=o>=</span> <span class=n>operand</span><span class=p>.</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>BlockArgument</span><span class=o>&gt;</span><span class=p>();</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;  - Operand produced by Block argument, number &#34;</span>
                   <span class=o>&lt;&lt;</span> <span class=n>blockArg</span><span class=p>.</span><span class=n>getArgNumber</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
</code></pre></div><p>Similarly, the following code sample iterates through the result <code>Value</code>s
produced by an <code>Operation</code> and for each result will iterate the users of these
results and print informations about them:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=c1>// Print information about the user of each of the result.
</span><span class=c1></span>  <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Has &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getNumResults</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; results:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>indexedResult</span> <span class=p>:</span> <span class=n>llvm</span><span class=o>::</span><span class=n>enumerate</span><span class=p>(</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getResults</span><span class=p>()))</span> <span class=p>{</span>
    <span class=n>Value</span> <span class=n>result</span> <span class=o>=</span> <span class=n>indexedResult</span><span class=p>.</span><span class=n>value</span><span class=p>();</span>
    <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;  - Result &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>indexedResult</span><span class=p>.</span><span class=n>index</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>use_empty</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; has no uses</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
      <span class=k>continue</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>hasOneUse</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; has a single use: &#34;</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; has &#34;</span>
                   <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>distance</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>getUses</span><span class=p>().</span><span class=n>begin</span><span class=p>(),</span>
                                    <span class=n>result</span><span class=p>.</span><span class=n>getUses</span><span class=p>().</span><span class=n>end</span><span class=p>())</span>
                   <span class=o>&lt;&lt;</span> <span class=s>&#34; uses:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=nl>userOp</span> <span class=p>:</span> <span class=n>result</span><span class=p>.</span><span class=n>getUsers</span><span class=p>())</span> <span class=p>{</span>
      <span class=n>llvm</span><span class=o>::</span><span class=n>outs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;    - &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>userOp</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
</code></pre></div><p>The illustrating code for this pass is available
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/test/lib/IR/TestPrintDefUse.cpp>here in the repo</a>
and can be exercised with <code>mlir-opt -test-print-defuse</code>.</p><p>The chaining of <code>Value</code>s and their uses can be viewed as following:</p><p><img src=/includes/img/DefUseChains.svg alt="Index Map Example"></p><p>The uses of a <code>Value</code> (<code>OpOperand</code> or <code>BlockOperand</code>) are also chained in a
doubly linked-list, which is particularly useful when replacing all uses of a
<code>Value</code> with a new one (&ldquo;RAUW&rdquo;):</p><p><img src=/includes/img/Use-list.svg alt="Index Map Example"></p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Tutorials/Toy/Ch-7/ title="Chapter 7: Adding a Composite Type to Toy"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 7: Adding a Composite Type to Toy</a>
<a class="nav nav-next" href=/docs/Tutorials/DataFlowAnalysis/ title="Writing DataFlow Analyses in MLIR">Next - Writing DataFlow Analyses in MLIR <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/pubs/>MLIR Related Publications</a></li><li><a href=/talks/>Talks</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/DefiningDialects/>Defining Dialects</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArithmeticOps/>'arith' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=has-sub-menu><a href=/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=/docs/ExtensibleDialects/>Extensible dialects</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class="parent has-sub-menu"><a href=/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=active><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>